/*

 lodash <https://lodash.com/>
 Copyright jQuery Foundation and other contributors <https://jquery.org/>
 Released under MIT license <https://lodash.com/license>
 Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors

 Regula: An annotation-based form-validation framework in Javascript
 Version 1.3.4-SNAPSHOT

 Written By Vivin Paliath (http://vivin.net)
 License: BSD License
 Copyright (C) 2010-2013

 Other licenses:

 DOMUtils#getElementsByAttribute
 Author: Robert Nyman
 Copyright Robert Nyman, http://www.robertnyman.com
 Free to use if this text is included
 jquery.panzoom.js v@VERSION
 Updated: @DATE
 Add pan and zoom functionality to any element
 Copyright (c) 2014 timmy willison
 Released under the MIT license
 https://github.com/timmywil/jquery.panzoom/blob/master/MIT-License.txt
 MIT
*/
window.Modernizr = function(window, document, undefined) {
    var version = "2.8.3",
        Modernizr = {},
        enableClasses = true,
        docElement = document.documentElement,
        mod = "modernizr",
        modElem = document.createElement(mod),
        mStyle = modElem.style,
        inputElem = document.createElement("input"),
        smile = ":)",
        toString = {}.toString,
        omPrefixes = "Webkit Moz O ms",
        cssomPrefixes = omPrefixes.split(" "),
        domPrefixes = omPrefixes.toLowerCase().split(" "),
        tests = {},
        inputs = {},
        attrs = {},
        classes = [],
        slice = classes.slice,
        featureName, injectElementWithStyles = function(rule,
            callback, nodes, testnames) {
            var style, ret, node, docOverflow, div = document.createElement("div"),
                body = document.body,
                fakeBody = body || document.createElement("body");
            if (parseInt(nodes, 10))
                while (nodes--) {
                    node = document.createElement("div");
                    node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
                    div.appendChild(node)
                }
            style = ["&#173;", '<style id="s', mod, '">', rule, "</style>"].join("");
            div.id = mod;
            (body ? div : fakeBody).innerHTML += style;
            fakeBody.appendChild(div);
            if (!body) {
                fakeBody.style.background = "";
                fakeBody.style.overflow =
                    "hidden";
                docOverflow = docElement.style.overflow;
                docElement.style.overflow = "hidden";
                docElement.appendChild(fakeBody)
            }
            ret = callback(div, rule);
            if (!body) {
                fakeBody.parentNode.removeChild(fakeBody);
                docElement.style.overflow = docOverflow
            } else div.parentNode.removeChild(div);
            return !!ret
        },
        _hasOwnProperty = {}.hasOwnProperty,
        hasOwnProp;
    if (!is(_hasOwnProperty, "undefined") && !is(_hasOwnProperty.call, "undefined")) hasOwnProp = function(object, property) {
        return _hasOwnProperty.call(object, property)
    };
    else hasOwnProp = function(object,
        property) {
        return property in object && is(object.constructor.prototype[property], "undefined")
    };
    if (!Function.prototype.bind) Function.prototype.bind = function bind(that) {
        var target = this;
        if (typeof target != "function") throw new TypeError;
        var args = slice.call(arguments, 1),
            bound = function() {
                if (this instanceof bound) {
                    var F = function() {};
                    F.prototype = target.prototype;
                    var self = new F;
                    var result = target.apply(self, args.concat(slice.call(arguments)));
                    if (Object(result) === result) return result;
                    return self
                } else return target.apply(that,
                    args.concat(slice.call(arguments)))
            };
        return bound
    };

    function setCss(str) {
        mStyle.cssText = str
    }

    function setCssAll(str1, str2) {
        return setCss(prefixes.join(str1 + ";") + (str2 || ""))
    }

    function is(obj, type) {
        return typeof obj === type
    }

    function contains(str, substr) {
        return !!~("" + str).indexOf(substr)
    }

    function testProps(props, prefixed) {
        for (var i in props) {
            var prop = props[i];
            if (!contains(prop, "-") && mStyle[prop] !== undefined) return prefixed == "pfx" ? prop : true
        }
        return false
    }

    function testDOMProps(props, obj, elem) {
        for (var i in props) {
            var item =
                obj[props[i]];
            if (item !== undefined) {
                if (elem === false) return props[i];
                if (is(item, "function")) return item.bind(elem || obj);
                return item
            }
        }
        return false
    }

    function testPropsAll(prop, prefixed, elem) {
        var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),
            props = (prop + " " + cssomPrefixes.join(ucProp + " ") + ucProp).split(" ");
        if (is(prefixed, "string") || is(prefixed, "undefined")) return testProps(props, prefixed);
        else {
            props = (prop + " " + domPrefixes.join(ucProp + " ") + ucProp).split(" ");
            return testDOMProps(props, prefixed, elem)
        }
    }
    tests["flexbox"] = function() {
        return testPropsAll("flexWrap")
    };
    tests["history"] = function() {
        return !!(window.history && history.pushState)
    };
    tests["websockets"] = function() {
        return "WebSocket" in window || "MozWebSocket" in window
    };
    tests["csstransitions"] = function() {
        return testPropsAll("transition")
    };

    function webforms() {
        Modernizr["input"] = function(props) {
            for (var i = 0, len = props.length; i < len; i++) attrs[props[i]] = !!(props[i] in inputElem);
            if (attrs.list) attrs.list = !!(document.createElement("datalist") && window.HTMLDataListElement);
            return attrs
        }("autocomplete autofocus list placeholder max min multiple pattern required step".split(" "));
        Modernizr["inputtypes"] = function(props) {
            for (var i = 0, bool, inputElemType, defaultView, len = props.length; i < len; i++) {
                inputElem.setAttribute("type", inputElemType = props[i]);
                bool = inputElem.type !== "text";
                if (bool) {
                    inputElem.value = smile;
                    inputElem.style.cssText = "position:absolute;visibility:hidden;";
                    if (/^range$/.test(inputElemType) && inputElem.style.WebkitAppearance !== undefined) {
                        docElement.appendChild(inputElem);
                        defaultView = document.defaultView;
                        bool = defaultView.getComputedStyle && defaultView.getComputedStyle(inputElem, null).WebkitAppearance !== "textfield" && inputElem.offsetHeight !== 0;
                        docElement.removeChild(inputElem)
                    } else if (/^(search|tel)$/.test(inputElemType));
                    else if (/^(url|email)$/.test(inputElemType)) bool = inputElem.checkValidity && inputElem.checkValidity() === false;
                    else bool = inputElem.value != smile
                }
                inputs[props[i]] = !!bool
            }
            return inputs
        }("search tel url email datetime date month week time datetime-local number range color".split(" "))
    }
    for (var feature in tests)
        if (hasOwnProp(tests, feature)) {
            featureName = feature.toLowerCase();
            Modernizr[featureName] = tests[feature]();
            classes.push((Modernizr[featureName] ? "" : "no-") + featureName)
        }
    Modernizr.input || webforms();
    Modernizr.addTest = function(feature, test) {
        if (typeof feature == "object")
            for (var key in feature) {
                if (hasOwnProp(feature, key)) Modernizr.addTest(key, feature[key])
            } else {
                feature = feature.toLowerCase();
                if (Modernizr[feature] !== undefined) return Modernizr;
                test = typeof test == "function" ? test() : test;
                if (typeof enableClasses !==
                    "undefined" && enableClasses) docElement.className += " " + (test ? "" : "no-") + feature;
                Modernizr[feature] = test
            }
        return Modernizr
    };
    setCss("");
    modElem = inputElem = null;
    (function(window, document) {
        var version = "3.7.0";
        var options = window.html5 || {};
        var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;
        var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;
        var supportsHtml5Styles;
        var expando = "_html5shiv";
        var expanID = 0;
        var expandoData = {};
        var supportsUnknownElements;
        (function() {
            try {
                var a = document.createElement("a");
                a.innerHTML = "<xyz></xyz>";
                supportsHtml5Styles = "hidden" in a;
                supportsUnknownElements = a.childNodes.length == 1 || function() {
                    document.createElement("a");
                    var frag = document.createDocumentFragment();
                    return typeof frag.cloneNode == "undefined" || typeof frag.createDocumentFragment == "undefined" || typeof frag.createElement == "undefined"
                }()
            } catch (e) {
                supportsHtml5Styles = true;
                supportsUnknownElements = true
            }
        })();

        function addStyleSheet(ownerDocument,
            cssText) {
            var p = ownerDocument.createElement("p"),
                parent = ownerDocument.getElementsByTagName("head")[0] || ownerDocument.documentElement;
            p.innerHTML = "x<style>" + cssText + "</style>";
            return parent.insertBefore(p.lastChild, parent.firstChild)
        }

        function getElements() {
            var elements = html5.elements;
            return typeof elements == "string" ? elements.split(" ") : elements
        }

        function getExpandoData(ownerDocument) {
            var data = expandoData[ownerDocument[expando]];
            if (!data) {
                data = {};
                expanID++;
                ownerDocument[expando] = expanID;
                expandoData[expanID] =
                    data
            }
            return data
        }

        function createElement(nodeName, ownerDocument, data) {
            if (!ownerDocument) ownerDocument = document;
            if (supportsUnknownElements) return ownerDocument.createElement(nodeName);
            if (!data) data = getExpandoData(ownerDocument);
            var node;
            if (data.cache[nodeName]) node = data.cache[nodeName].cloneNode();
            else if (saveClones.test(nodeName)) node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
            else node = data.createElem(nodeName);
            return node.canHaveChildren && !reSkip.test(nodeName) && !node.tagUrn ? data.frag.appendChild(node) :
                node
        }

        function createDocumentFragment(ownerDocument, data) {
            if (!ownerDocument) ownerDocument = document;
            if (supportsUnknownElements) return ownerDocument.createDocumentFragment();
            data = data || getExpandoData(ownerDocument);
            var clone = data.frag.cloneNode(),
                i = 0,
                elems = getElements(),
                l = elems.length;
            for (; i < l; i++) clone.createElement(elems[i]);
            return clone
        }

        function shivMethods(ownerDocument, data) {
            if (!data.cache) {
                data.cache = {};
                data.createElem = ownerDocument.createElement;
                data.createFrag = ownerDocument.createDocumentFragment;
                data.frag = data.createFrag()
            }
            ownerDocument.createElement = function(nodeName) {
                if (!html5.shivMethods) return data.createElem(nodeName);
                return createElement(nodeName, ownerDocument, data)
            };
            ownerDocument.createDocumentFragment = Function("h,f", "return function(){" + "var n=f.cloneNode(),c=n.createElement;" + "h.shivMethods&&(" + getElements().join().replace(/[\w\-]+/g, function(nodeName) {
                data.createElem(nodeName);
                data.frag.createElement(nodeName);
                return 'c("' + nodeName + '")'
            }) + ");return n}")(html5, data.frag)
        }

        function shivDocument(ownerDocument) {
            if (!ownerDocument) ownerDocument =
                document;
            var data = getExpandoData(ownerDocument);
            if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) data.hasCSS = !!addStyleSheet(ownerDocument, "article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}" + "mark{background:#FF0;color:#000}" + "template{display:none}");
            if (!supportsUnknownElements) shivMethods(ownerDocument, data);
            return ownerDocument
        }
        var html5 = {
            "elements": options.elements || "abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video",
            "version": version,
            "shivCSS": options.shivCSS !== false,
            "supportsUnknownElements": supportsUnknownElements,
            "shivMethods": options.shivMethods !== false,
            "type": "default",
            "shivDocument": shivDocument,
            createElement: createElement,
            createDocumentFragment: createDocumentFragment
        };
        window.html5 = html5;
        shivDocument(document)
    })(this, document);
    Modernizr._version = version;
    Modernizr._domPrefixes = domPrefixes;
    Modernizr._cssomPrefixes = cssomPrefixes;
    Modernizr.testProp = function(prop) {
        return testProps([prop])
    };
    Modernizr.testAllProps =
        testPropsAll;
    Modernizr.testStyles = injectElementWithStyles;
    docElement.className = docElement.className.replace(/(^|\s)no-js(\s|$)/, "$1$2") + (enableClasses ? " js " + classes.join(" ") : "");
    return Modernizr
}(this, this.document);
window.Detectizr = function(window, navigator, document, undefined) {
    var Detectizr = {},
        Modernizr = window.Modernizr,
        deviceTypes = ["tv", "tablet", "mobile", "desktop"],
        options = {
            addAllFeaturesAsClass: false,
            detectDevice: true,
            detectDeviceModel: true,
            detectScreen: true,
            detectOS: true,
            detectBrowser: true,
            detectPlugins: true
        },
        plugins2detect = [{
            name: "adobereader",
            substrs: ["Adobe", "Acrobat"],
            progIds: ["AcroPDF.PDF", "PDF.PDFCtrl.5"]
        }, {
            name: "flash",
            substrs: ["Shockwave Flash"],
            progIds: ["ShockwaveFlash.ShockwaveFlash.1"]
        }, {
            name: "wmplayer",
            substrs: ["Windows Media"],
            progIds: ["wmplayer.ocx"]
        }, {
            name: "silverlight",
            substrs: ["Silverlight"],
            progIds: ["AgControl.AgControl"]
        }, {
            name: "quicktime",
            substrs: ["QuickTime"],
            progIds: ["QuickTime.QuickTime"]
        }],
        rclass = /[\t\r\n]/g,
        docElement = document.documentElement,
        resizeTimeoutId, oldOrientation;

    function extend(obj, extObj) {
        var a, b, i;
        if (arguments.length > 2)
            for (a = 1, b = arguments.length; a < b; a += 1) extend(obj, arguments[a]);
        else
            for (i in extObj)
                if (extObj.hasOwnProperty(i)) obj[i] = extObj[i]; return obj
    }

    function is(key) {
        return Detectizr.browser.userAgent.indexOf(key) >
            -1
    }

    function test(regex) {
        return regex.test(Detectizr.browser.userAgent)
    }

    function exec(regex) {
        return regex.exec(Detectizr.browser.userAgent)
    }

    function trim(value) {
        return value.replace(/^\s+|\s+$/g, "")
    }

    function toCamel(string) {
        if (string === null || string === undefined) return "";
        return String(string).replace(/((\s|\-|\.)+[a-z0-9])/g, function($1) {
            return $1.toUpperCase().replace(/(\s|\-|\.)/g, "")
        })
    }

    function removeClass(element, value) {
        var class2remove = value || "",
            cur = element.nodeType === 1 && (element.className ? (" " +
                element.className + " ").replace(rclass, " ") : "");
        if (cur) {
            while (cur.indexOf(" " + class2remove + " ") >= 0) cur = cur.replace(" " + class2remove + " ", " ");
            element.className = value ? trim(cur) : ""
        }
    }

    function addVersionTest(version, major, minor) {
        if (!!version) {
            version = toCamel(version);
            if (!!major) {
                major = toCamel(major);
                addConditionalTest(version + major, true);
                if (!!minor) addConditionalTest(version + major + "_" + minor, true)
            }
        }
    }

    function addConditionalTest(feature, test) {
        if (!!feature && !!Modernizr)
            if (options.addAllFeaturesAsClass) Modernizr.addTest(feature,
                test);
            else {
                test = typeof test === "function" ? test() : test;
                if (test) Modernizr.addTest(feature, true);
                else {
                    delete Modernizr[feature];
                    removeClass(docElement, feature)
                }
            }
    }

    function setVersion(versionType, versionFull) {
        versionType.version = versionFull;
        var versionArray = versionFull.split(".");
        if (versionArray.length > 0) {
            versionArray = versionArray.reverse();
            versionType.major = versionArray.pop();
            if (versionArray.length > 0) {
                versionType.minor = versionArray.pop();
                if (versionArray.length > 0) {
                    versionArray = versionArray.reverse();
                    versionType.patch =
                        versionArray.join(".")
                } else versionType.patch = "0"
            } else versionType.minor = "0"
        } else versionType.major = "0"
    }

    function checkOrientation() {
        window.clearTimeout(resizeTimeoutId);
        resizeTimeoutId = window.setTimeout(function() {
            oldOrientation = Detectizr.device.orientation;
            if (window.innerHeight > window.innerWidth) Detectizr.device.orientation = "portrait";
            else Detectizr.device.orientation = "landscape";
            addConditionalTest(Detectizr.device.orientation, true);
            if (oldOrientation !== Detectizr.device.orientation) addConditionalTest(oldOrientation,
                false)
        }, 10)
    }

    function detectPlugin(substrs) {
        var plugins = navigator.plugins,
            plugin, haystack, pluginFoundText, j, k;
        for (j = plugins.length - 1; j >= 0; j--) {
            plugin = plugins[j];
            haystack = plugin.name + plugin.description;
            pluginFoundText = 0;
            for (k = substrs.length; k >= 0; k--)
                if (haystack.indexOf(substrs[k]) !== -1) pluginFoundText += 1;
            if (pluginFoundText === substrs.length) return true
        }
        return false
    }

    function detectObject(progIds) {
        var j;
        for (j = progIds.length - 1; j >= 0; j--) try {
            new ActiveXObject(progIds[j])
        } catch (e) {}
        return false
    }

    function detect(opt) {
        var i,
            j, device, os, browser, plugin2detect, pluginFound;
        options = extend({}, options, opt || {});
        if (options.detectDevice) {
            Detectizr.device = {
                type: "",
                model: "",
                orientation: ""
            };
            device = Detectizr.device;
            if (test(/googletv|smarttv|smart-tv|internet.tv|netcast|nettv|appletv|boxee|kylo|roku|dlnadoc|roku|pov_tv|hbbtv|ce\-html/)) {
                device.type = deviceTypes[0];
                device.model = "smartTv"
            } else if (test(/xbox|playstation.3|wii/)) {
                device.type = deviceTypes[0];
                device.model = "gameConsole"
            } else if (test(/ip(a|ro)d/)) {
                device.type = deviceTypes[1];
                device.model = "ipad"
            } else if (test(/tablet/) && !test(/rx-34/) || test(/folio/)) {
                device.type = deviceTypes[1];
                device.model = String(exec(/playbook/) || "")
            } else if (test(/linux/) && test(/android/) && !test(/fennec|mobi|htc.magic|htcX06ht|nexus.one|sc-02b|fone.945/)) {
                device.type = deviceTypes[1];
                device.model = "android"
            } else if (test(/kindle/) || test(/mac.os/) && test(/silk/)) {
                device.type = deviceTypes[1];
                device.model = "kindle"
            } else if (test(/gt-p10|sc-01c|shw-m180s|sgh-t849|sch-i800|shw-m180l|sph-p100|sgh-i987|zt180|htc(.flyer|\_flyer)|sprint.atp51|viewpad7|pandigital(sprnova|nova)|ideos.s7|dell.streak.7|advent.vega|a101it|a70bht|mid7015|next2|nook/) ||
                test(/mb511/) && test(/rutem/)) {
                device.type = deviceTypes[1];
                device.model = "android"
            } else if (test(/bb10/)) {
                device.type = deviceTypes[1];
                device.model = "blackberry"
            } else {
                device.model = exec(/iphone|ipod|android|blackberry|opera mini|opera mobi|skyfire|maemo|windows phone|palm|iemobile|symbian|symbianos|fennec|j2me/);
                if (device.model !== null) {
                    device.type = deviceTypes[2];
                    device.model = String(device.model)
                } else {
                    device.model = "";
                    if (test(/bolt|fennec|iris|maemo|minimo|mobi|mowser|netfront|novarra|prism|rx-34|skyfire|tear|xv6875|xv6975|google.wireless.transcoder/)) device.type =
                        deviceTypes[2];
                    else if (test(/opera/) && test(/windows.nt.5/) && test(/htc|xda|mini|vario|samsung\-gt\-i8000|samsung\-sgh\-i9/)) device.type = deviceTypes[2];
                    else if (test(/windows.(nt|xp|me|9)/) && !test(/phone/) || test(/win(9|.9|nt)/) || test(/\(windows 8\)/)) device.type = deviceTypes[3];
                    else if (test(/macintosh|powerpc/) && !test(/silk/)) {
                        device.type = deviceTypes[3];
                        device.model = "mac"
                    } else if (test(/linux/) && test(/x11/)) device.type = deviceTypes[3];
                    else if (test(/solaris|sunos|bsd/)) device.type = deviceTypes[3];
                    else if (test(/cros/)) device.type =
                        deviceTypes[3];
                    else if (test(/bot|crawler|spider|yahoo|ia_archiver|covario-ids|findlinks|dataparksearch|larbin|mediapartners-google|ng-search|snappy|teoma|jeeves|tineye/) && !test(/mobile/)) {
                        device.type = deviceTypes[3];
                        device.model = "crawler"
                    } else device.type = deviceTypes[2]
                }
            }
            for (i = 0, j = deviceTypes.length; i < j; i += 1) addConditionalTest(deviceTypes[i], device.type === deviceTypes[i]);
            if (options.detectDeviceModel) addConditionalTest(toCamel(device.model), true)
        }
        if (options.detectScreen) {
            device.screen = {};
            if (!!Modernizr &&
                !!Modernizr.mq) {
                if (Modernizr.mq("only screen and (max-width: 240px)")) {
                    device.screen.size = "veryVerySmall";
                    addConditionalTest("veryVerySmallScreen", true)
                } else if (Modernizr.mq("only screen and (max-width: 320px)")) {
                    device.screen.size = "verySmall";
                    addConditionalTest("verySmallScreen", true)
                } else if (Modernizr.mq("only screen and (max-width: 480px)")) {
                    device.screen.size = "small";
                    addConditionalTest("smallScreen", true)
                }
                if (device.type === deviceTypes[1] || device.type === deviceTypes[2])
                    if (Modernizr.mq("only screen and (-moz-min-device-pixel-ratio: 1.3), only screen and (-o-min-device-pixel-ratio: 2.6/2), only screen and (-webkit-min-device-pixel-ratio: 1.3), only screen  and (min-device-pixel-ratio: 1.3), only screen and (min-resolution: 1.3dppx)")) {
                        device.screen.resolution =
                            "high";
                        addConditionalTest("highresolution", true)
                    }
            }
            if (device.type === deviceTypes[1] || device.type === deviceTypes[2]) {
                window.onresize = function(event) {
                    checkOrientation(event)
                };
                checkOrientation()
            } else {
                device.orientation = "landscape";
                addConditionalTest(device.orientation, true)
            }
        }
        if (options.detectOS) {
            Detectizr.os = {};
            os = Detectizr.os;
            if (device.model !== "")
                if (device.model === "ipad" || device.model === "iphone" || device.model === "ipod") {
                    os.name = "ios";
                    setVersion(os, (test(/os\s([\d_]+)/) ? RegExp.$1 : "").replace(/_/g, "."))
                } else if (device.model ===
                "android") {
                os.name = "android";
                setVersion(os, test(/android\s([\d\.]+)/) ? RegExp.$1 : "")
            } else if (device.model === "blackberry") {
                os.name = "blackberry";
                setVersion(os, test(/version\/([^\s]+)/) ? RegExp.$1 : "")
            } else if (device.model === "playbook") {
                os.name = "blackberry";
                setVersion(os, test(/os ([^\s]+)/) ? RegExp.$1.replace(";", "") : "")
            }
            if (!os.name)
                if (is("win") || is("16bit")) {
                    os.name = "windows";
                    if (is("windows nt 6.3")) setVersion(os, "8.1");
                    else if (is("windows nt 6.2") || test(/\(windows 8\)/)) setVersion(os, "8");
                    else if (is("windows nt 6.1")) setVersion(os,
                        "7");
                    else if (is("windows nt 6.0")) setVersion(os, "vista");
                    else if (is("windows nt 5.2") || is("windows nt 5.1") || is("windows xp")) setVersion(os, "xp");
                    else if (is("windows nt 5.0") || is("windows 2000")) setVersion(os, "2k");
                    else if (is("winnt") || is("windows nt")) setVersion(os, "nt");
                    else if (is("win98") || is("windows 98")) setVersion(os, "98");
                    else if (is("win95") || is("windows 95")) setVersion(os, "95")
                } else if (is("mac") || is("darwin")) {
                os.name = "mac os";
                if (is("68k") || is("68000")) setVersion(os, "68k");
                else if (is("ppc") ||
                    is("powerpc")) setVersion(os, "ppc");
                else if (is("os x")) setVersion(os, (test(/os\sx\s([\d_]+)/) ? RegExp.$1 : "os x").replace(/_/g, "."))
            } else if (is("webtv")) os.name = "webtv";
            else if (is("x11") || is("inux")) os.name = "linux";
            else if (is("sunos")) os.name = "sun";
            else if (is("irix")) os.name = "irix";
            else if (is("freebsd")) os.name = "freebsd";
            else if (is("bsd")) os.name = "bsd";
            if (!!os.name) {
                addConditionalTest(os.name, true);
                if (!!os.major) {
                    addVersionTest(os.name, os.major);
                    if (!!os.minor) addVersionTest(os.name, os.major, os.minor)
                }
            }
            if (test(/\sx64|\sx86|\swin64|\swow64|\samd64/)) os.addressRegisterSize =
                "64bit";
            else os.addressRegisterSize = "32bit";
            addConditionalTest(os.addressRegisterSize, true)
        }
        if (options.detectBrowser) {
            browser = Detectizr.browser;
            if (!test(/opera|webtv/) && (test(/msie\s([\d\w\.]+)/) || is("trident"))) {
                browser.engine = "trident";
                browser.name = "ie";
                if (!window.addEventListener && document.documentMode && document.documentMode === 7) setVersion(browser, "8.compat");
                else if (test(/trident.*rv[ :](\d+)\./)) setVersion(browser, RegExp.$1);
                else setVersion(browser, test(/trident\/4\.0/) ? "8" : RegExp.$1)
            } else if (is("firefox")) {
                browser.engine =
                    "gecko";
                browser.name = "firefox";
                setVersion(browser, test(/firefox\/([\d\w\.]+)/) ? RegExp.$1 : "")
            } else if (is("gecko/")) browser.engine = "gecko";
            else if (is("opera")) {
                browser.name = "opera";
                browser.engine = "presto";
                setVersion(browser, test(/version\/([\d\.]+)/) ? RegExp.$1 : test(/opera(\s|\/)([\d\.]+)/) ? RegExp.$2 : "")
            } else if (is("konqueror")) browser.name = "konqueror";
            else if (is("chrome")) {
                browser.engine = "webkit";
                browser.name = "chrome";
                setVersion(browser, test(/chrome\/([\d\.]+)/) ? RegExp.$1 : "")
            } else if (is("iron")) {
                browser.engine =
                    "webkit";
                browser.name = "iron"
            } else if (is("crios")) {
                browser.name = "chrome";
                browser.engine = "webkit";
                setVersion(browser, test(/crios\/([\d\.]+)/) ? RegExp.$1 : "")
            } else if (is("applewebkit/")) {
                browser.name = "safari";
                browser.engine = "webkit";
                setVersion(browser, test(/version\/([\d\.]+)/) ? RegExp.$1 : "")
            } else if (is("mozilla/")) browser.engine = "gecko";
            if (!!browser.name) {
                addConditionalTest(browser.name, true);
                if (!!browser.major) {
                    addVersionTest(browser.name, browser.major);
                    if (!!browser.minor) addVersionTest(browser.name,
                        browser.major, browser.minor)
                }
            }
            addConditionalTest(browser.engine, true);
            browser.language = navigator.userLanguage || navigator.language;
            addConditionalTest(browser.language, true)
        }
        if (options.detectPlugins) {
            browser.plugins = [];
            for (i = plugins2detect.length - 1; i >= 0; i--) {
                plugin2detect = plugins2detect[i];
                pluginFound = false;
                if (window.ActiveXObject) pluginFound = detectObject(plugin2detect.progIds);
                else if (navigator.plugins) pluginFound = detectPlugin(plugin2detect.substrs);
                if (pluginFound) {
                    browser.plugins.push(plugin2detect.name);
                    addConditionalTest(plugin2detect.name, true)
                }
            }
            if (navigator.javaEnabled()) {
                browser.plugins.push("java");
                addConditionalTest("java", true)
            }
        }
    }
    Detectizr.detect = function(settings) {
        return detect(settings)
    };
    Detectizr.init = function() {
        if (Detectizr !== undefined) {
            Detectizr.browser = {
                userAgent: (navigator.userAgent || navigator.vendor || window.opera).toLowerCase()
            };
            Detectizr.detect()
        }
    };
    Detectizr.init();
    return Detectizr
}(this, this.navigator, this.document);
window.browser = Detectizr.browser;
console.log("Detectizr:", Detectizr);
console.log("Browser:", browser);
(function() {
    var method;
    var noop = function() {};
    var methods = ["assert", "clear", "count", "debug", "dir", "dirxml", "error", "exception", "group", "groupCollapsed", "groupEnd", "info", "log", "markTimeline", "profile", "profileEnd", "table", "time", "timeEnd", "timeStamp", "trace", "warn"];
    var length = methods.length;
    var console = window.console = window.console || {};
    while (length--) {
        method = methods[length];
        if (!console[method]) console[method] = noop
    }
})();

function require(x) {}
(function(f) {
    if (typeof exports === "object" && typeof module !== "undefined") module.exports = f();
    else if (typeof define === "function" && define.amd) define([], f);
    else {
        var g;
        if (typeof window !== "undefined") g = window;
        else if (typeof global !== "undefined") g = global;
        else if (typeof self !== "undefined") g = self;
        else g = this;
        g.XRegExp = f()
    }
})(function() {
    var define, module, exports;
    return function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    var f =
                        new Error("Cannot find module '" + o + "'");
                    throw f.code = "MODULE_NOT_FOUND", f;
                }
                var l = n[o] = {
                    exports: {}
                };
                t[o][0].call(l.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e)
                }, l, l.exports, e, t, n, r)
            }
            return n[o].exports
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s
    }({
        1: [function(require, module, exports) {
            module.exports = function(XRegExp) {
                var REGEX_DATA = "xregexp",
                    subParts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*]/g,
                    parts = XRegExp.union([/\({{([\w$]+)}}\)|{{([\w$]+)}}/,
                        subParts
                    ], "g");

                function deanchor(pattern) {
                    var leadingAnchor = /^\^/,
                        trailingAnchor = /\$$/;
                    if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern.replace(/\\[\s\S]/g, ""))) return pattern.replace(leadingAnchor, "").replace(trailingAnchor, "");
                    return pattern
                }

                function asXRegExp(value) {
                    return XRegExp.isRegExp(value) ? value[REGEX_DATA] && value[REGEX_DATA].captureNames ? value : XRegExp(value.source) : XRegExp(value)
                }
                XRegExp.build = function(pattern, subs, flags) {
                    var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern),
                        data = {},
                        numCaps = 0,
                        numPriorCaps, numOuterCaps = 0,
                        outerCapsMap = [0],
                        outerCapNames, sub, p;
                    if (inlineFlags) {
                        flags = flags || "";
                        inlineFlags[1].replace(/./g, function(flag) {
                            flags += flags.indexOf(flag) > -1 ? "" : flag
                        })
                    }
                    for (p in subs)
                        if (subs.hasOwnProperty(p)) {
                            sub = asXRegExp(subs[p]);
                            data[p] = {
                                pattern: deanchor(sub.source),
                                names: sub[REGEX_DATA].captureNames || []
                            }
                        }
                    pattern = asXRegExp(pattern);
                    outerCapNames = pattern[REGEX_DATA].captureNames || [];
                    pattern = pattern.source.replace(parts, function($0, $1, $2, $3, $4) {
                        var subName = $1 || $2,
                            capName,
                            intro;
                        if (subName) {
                            if (!data.hasOwnProperty(subName)) throw new ReferenceError("Undefined property " + $0);
                            if ($1) {
                                capName = outerCapNames[numOuterCaps];
                                outerCapsMap[++numOuterCaps] = ++numCaps;
                                intro = "(?<" + (capName || subName) + ">"
                            } else intro = "(?:";
                            numPriorCaps = numCaps;
                            return intro + data[subName].pattern.replace(subParts, function(match, paren, backref) {
                                    if (paren) {
                                        capName = data[subName].names[numCaps - numPriorCaps];
                                        ++numCaps;
                                        if (capName) return "(?<" + capName + ">"
                                    } else if (backref) return "\\" + (+backref + numPriorCaps);
                                    return match
                                }) +
                                ")"
                        }
                        if ($3) {
                            capName = outerCapNames[numOuterCaps];
                            outerCapsMap[++numOuterCaps] = ++numCaps;
                            if (capName) return "(?<" + capName + ">"
                        } else if ($4) return "\\" + outerCapsMap[+$4];
                        return $0
                    });
                    return XRegExp(pattern, flags)
                }
            }
        }, {}],
        2: [function(require, module, exports) {
            module.exports = function(XRegExp) {
                function row(name, value, start, end) {
                    return {
                        name: name,
                        value: value,
                        start: start,
                        end: end
                    }
                }
                XRegExp.matchRecursive = function(str, left, right, flags, options) {
                    flags = flags || "";
                    options = options || {};
                    var global = flags.indexOf("g") > -1,
                        sticky =
                        flags.indexOf("y") > -1,
                        basicFlags = flags.replace(/y/g, ""),
                        escapeChar = options.escapeChar,
                        vN = options.valueNames,
                        output = [],
                        openTokens = 0,
                        delimStart = 0,
                        delimEnd = 0,
                        lastOuterEnd = 0,
                        outerStart, innerStart, leftMatch, rightMatch, esc;
                    left = XRegExp(left, basicFlags);
                    right = XRegExp(right, basicFlags);
                    if (escapeChar) {
                        if (escapeChar.length > 1) throw new Error("Cannot use more than one escape character");
                        escapeChar = XRegExp.escape(escapeChar);
                        esc = new RegExp("(?:" + escapeChar + "[\\S\\s]|(?:(?!" + XRegExp.union([left, right]).source +
                            ")[^" + escapeChar + "])+)+", flags.replace(/[^imu]+/g, ""))
                    }
                    while (true) {
                        if (escapeChar) delimEnd += (XRegExp.exec(str, esc, delimEnd, "sticky") || [""])[0].length;
                        leftMatch = XRegExp.exec(str, left, delimEnd);
                        rightMatch = XRegExp.exec(str, right, delimEnd);
                        if (leftMatch && rightMatch)
                            if (leftMatch.index <= rightMatch.index) rightMatch = null;
                            else leftMatch = null;
                        if (leftMatch || rightMatch) {
                            delimStart = (leftMatch || rightMatch).index;
                            delimEnd = delimStart + (leftMatch || rightMatch)[0].length
                        } else if (!openTokens) break;
                        if (sticky && !openTokens &&
                            delimStart > lastOuterEnd) break;
                        if (leftMatch) {
                            if (!openTokens) {
                                outerStart = delimStart;
                                innerStart = delimEnd
                            }++openTokens
                        } else if (rightMatch && openTokens) {
                            if (!--openTokens) {
                                if (vN) {
                                    if (vN[0] && outerStart > lastOuterEnd) output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                                    if (vN[1]) output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
                                    if (vN[2]) output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
                                    if (vN[3]) output.push(row(vN[3], str.slice(delimStart,
                                        delimEnd), delimStart, delimEnd))
                                } else output.push(str.slice(innerStart, delimStart));
                                lastOuterEnd = delimEnd;
                                if (!global) break
                            }
                        } else throw new Error("Unbalanced delimiter found in string");
                        if (delimStart === delimEnd) ++delimEnd
                    }
                    if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));
                    return output
                }
            }
        }, {}],
        3: [function(require, module, exports) {
            module.exports = function(XRegExp) {
                var unicode = {};

                function normalize(name) {
                    return name.replace(/[- _]+/g,
                        "").toLowerCase()
                }

                function pad4(str) {
                    while (str.length < 4) str = "0" + str;
                    return str
                }

                function dec(hex) {
                    return parseInt(hex, 16)
                }

                function hex(dec) {
                    return parseInt(dec, 10).toString(16)
                }

                function charCode(chr) {
                    var esc = /^\\[xu](.+)/.exec(chr);
                    return esc ? dec(esc[1]) : chr.charCodeAt(chr.charAt(0) === "\\" ? 1 : 0)
                }

                function invertBmp(range) {
                    var output = "",
                        lastEnd = -1,
                        start;
                    XRegExp.forEach(range, /(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/, function(m) {
                        start = charCode(m[1]);
                        if (start > lastEnd + 1) {
                            output += "\\u" + pad4(hex(lastEnd +
                                1));
                            if (start > lastEnd + 2) output += "-\\u" + pad4(hex(start - 1))
                        }
                        lastEnd = charCode(m[2] || m[1])
                    });
                    if (lastEnd < 65535) {
                        output += "\\u" + pad4(hex(lastEnd + 1));
                        if (lastEnd < 65534) output += "-\\uFFFF"
                    }
                    return output
                }

                function cacheInvertedBmp(slug) {
                    var prop = "b!";
                    return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp))
                }

                function buildAstral(slug, isNegated) {
                    var item = unicode[slug],
                        combined = "";
                    if (item.bmp && !item.isBmpLast) combined = "[" + item.bmp + "]" + (item.astral ? "|" : "");
                    if (item.astral) combined += item.astral;
                    if (item.isBmpLast && item.bmp) combined += (item.astral ? "|" : "") + "[" + item.bmp + "]";
                    return isNegated ? "(?:(?!" + combined + ")(?:[\ud800-\udbff][\udc00-\udfff]|[\x00-￿]))" : "(?:" + combined + ")"
                }

                function cacheAstral(slug, isNegated) {
                    var prop = isNegated ? "a!" : "a=";
                    return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated))
                }
                XRegExp.addToken(/\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/, function(match, scope, flags) {
                    var ERR_DOUBLE_NEG = "Invalid double negation ",
                        ERR_UNKNOWN_NAME = "Unknown Unicode token ",
                        ERR_UNKNOWN_REF =
                        "Unicode token missing data ",
                        ERR_ASTRAL_ONLY = "Astral mode required for Unicode token ",
                        ERR_ASTRAL_IN_CLASS = "Astral mode does not support Unicode tokens within character classes",
                        isNegated = match[1] === "P" || !!match[2],
                        isAstralMode = flags.indexOf("A") > -1,
                        slug = normalize(match[4] || match[3]),
                        item = unicode[slug];
                    if (match[1] === "P" && match[2]) throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);
                    if (!unicode.hasOwnProperty(slug)) throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);
                    if (item.inverseOf) {
                        slug = normalize(item.inverseOf);
                        if (!unicode.hasOwnProperty(slug)) throw new ReferenceError(ERR_UNKNOWN_REF + match[0] + " -> " + item.inverseOf);
                        item = unicode[slug];
                        isNegated = !isNegated
                    }
                    if (!(item.bmp || isAstralMode)) throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);
                    if (isAstralMode) {
                        if (scope === "class") throw new SyntaxError(ERR_ASTRAL_IN_CLASS);
                        return cacheAstral(slug, isNegated)
                    }
                    return scope === "class" ? isNegated ? cacheInvertedBmp(slug) : item.bmp : (isNegated ? "[^" : "[") + item.bmp + "]"
                }, {
                    scope: "all",
                    optionalFlags: "A",
                    leadChar: "\\"
                });
                XRegExp.addUnicodeData =
                    function(data) {
                        var ERR_NO_NAME = "Unicode token requires name",
                            ERR_NO_DATA = "Unicode token has no character data ",
                            item, i;
                        for (i = 0; i < data.length; ++i) {
                            item = data[i];
                            if (!item.name) throw new Error(ERR_NO_NAME);
                            if (!(item.inverseOf || item.bmp || item.astral)) throw new Error(ERR_NO_DATA + item.name);
                            unicode[normalize(item.name)] = item;
                            if (item.alias) unicode[normalize(item.alias)] = item
                        }
                        XRegExp.cache.flush("patterns")
                    }
            }
        }, {}],
        4: [function(require, module, exports) {
            module.exports = function(XRegExp) {
                if (!XRegExp.addUnicodeData) throw new ReferenceError("Unicode Base must be loaded before Unicode Blocks");
                XRegExp.addUnicodeData([{
                    name: "InAegean_Numbers",
                    astral: "\ud800[\udd00-\udd3f]"
                }, {
                    name: "InAhom",
                    astral: "\ud805[\udf00-\udf3f]"
                }, {
                    name: "InAlchemical_Symbols",
                    astral: "\ud83d[\udf00-\udf7f]"
                }, {
                    name: "InAlphabetic_Presentation_Forms",
                    bmp: "ﬀ-ﭏ"
                }, {
                    name: "InAnatolian_Hieroglyphs",
                    astral: "\ud811[\udc00-\ude7f]"
                }, {
                    name: "InAncient_Greek_Musical_Notation",
                    astral: "\ud834[\ude00-\ude4f]"
                }, {
                    name: "InAncient_Greek_Numbers",
                    astral: "\ud800[\udd40-\udd8f]"
                }, {
                    name: "InAncient_Symbols",
                    astral: "\ud800[\udd90-\uddcf]"
                }, {
                    name: "InArabic",
                    bmp: "؀-ۿ"
                }, {
                    name: "InArabic_Extended_A",
                    bmp: "ࢠ-ࣿ"
                }, {
                    name: "InArabic_Mathematical_Alphabetic_Symbols",
                    astral: "\ud83b[\ude00-\udeff]"
                }, {
                    name: "InArabic_Presentation_Forms_A",
                    bmp: "ﭐ-﷿"
                }, {
                    name: "InArabic_Presentation_Forms_B",
                    bmp: "ﹰ-﻿"
                }, {
                    name: "InArabic_Supplement",
                    bmp: "ݐ-ݿ"
                }, {
                    name: "InArmenian",
                    bmp: "԰-֏"
                }, {
                    name: "InArrows",
                    bmp: "←-⇿"
                }, {
                    name: "InAvestan",
                    astral: "\ud802[\udf00-\udf3f]"
                }, {
                    name: "InBalinese",
                    bmp: "ᬀ-᭿"
                }, {
                    name: "InBamum",
                    bmp: "ꚠ-꛿"
                }, {
                    name: "InBamum_Supplement",
                    astral: "\ud81a[\udc00-\ude3f]"
                }, {
                    name: "InBasic_Latin",
                    bmp: "\x00-"
                }, {
                    name: "InBassa_Vah",
                    astral: "\ud81a[\uded0-\udeff]"
                }, {
                    name: "InBatak",
                    bmp: "ᯀ-᯿"
                }, {
                    name: "InBengali",
                    bmp: "ঀ-৿"
                }, {
                    name: "InBlock_Elements",
                    bmp: "▀-▟"
                }, {
                    name: "InBopomofo",
                    bmp: "㄀-ㄯ"
                }, {
                    name: "InBopomofo_Extended",
                    bmp: "ㆠ-ㆿ"
                }, {
                    name: "InBox_Drawing",
                    bmp: "─-╿"
                }, {
                    name: "InBrahmi",
                    astral: "\ud804[\udc00-\udc7f]"
                }, {
                    name: "InBraille_Patterns",
                    bmp: "⠀-⣿"
                }, {
                    name: "InBuginese",
                    bmp: "ᨀ-᨟"
                }, {
                    name: "InBuhid",
                    bmp: "ᝀ-᝟"
                }, {
                    name: "InByzantine_Musical_Symbols",
                    astral: "\ud834[\udc00-\udcff]"
                }, {
                    name: "InCJK_Compatibility",
                    bmp: "㌀-㏿"
                }, {
                    name: "InCJK_Compatibility_Forms",
                    bmp: "︰-﹏"
                }, {
                    name: "InCJK_Compatibility_Ideographs",
                    bmp: "豈-﫿"
                }, {
                    name: "InCJK_Compatibility_Ideographs_Supplement",
                    astral: "\ud87e[\udc00-\ude1f]"
                }, {
                    name: "InCJK_Radicals_Supplement",
                    bmp: "⺀-⻿"
                }, {
                    name: "InCJK_Strokes",
                    bmp: "㇀-㇯"
                }, {
                    name: "InCJK_Symbols_and_Punctuation",
                    bmp: "　-〿"
                }, {
                    name: "InCJK_Unified_Ideographs",
                    bmp: "一-鿿"
                }, {
                    name: "InCJK_Unified_Ideographs_Extension_A",
                    bmp: "㐀-䶿"
                }, {
                    name: "InCJK_Unified_Ideographs_Extension_B",
                    astral: "[\ud840-\ud868][\udc00-\udfff]|\ud869[\udc00-\udedf]"
                }, {
                    name: "InCJK_Unified_Ideographs_Extension_C",
                    astral: "\ud86d[\udc00-\udf3f]|[\ud86a-\ud86c][\udc00-\udfff]|\ud869[\udf00-\udfff]"
                }, {
                    name: "InCJK_Unified_Ideographs_Extension_D",
                    astral: "\ud86d[\udf40-\udfff]|\ud86e[\udc00-\udc1f]"
                }, {
                    name: "InCJK_Unified_Ideographs_Extension_E",
                    astral: "[\ud86f-\ud872][\udc00-\udfff]|\ud873[\udc00-\udeaf]|\ud86e[\udc20-\udfff]"
                }, {
                    name: "InCarian",
                    astral: "\ud800[\udea0-\udedf]"
                }, {
                    name: "InCaucasian_Albanian",
                    astral: "\ud801[\udd30-\udd6f]"
                }, {
                    name: "InChakma",
                    astral: "\ud804[\udd00-\udd4f]"
                }, {
                    name: "InCham",
                    bmp: "ꨀ-꩟"
                }, {
                    name: "InCherokee",
                    bmp: "Ꭰ-᏿"
                }, {
                    name: "InCherokee_Supplement",
                    bmp: "ꭰ-ꮿ"
                }, {
                    name: "InCombining_Diacritical_Marks",
                    bmp: "̀-ͯ"
                }, {
                    name: "InCombining_Diacritical_Marks_Extended",
                    bmp: "᪰-᫿"
                }, {
                    name: "InCombining_Diacritical_Marks_Supplement",
                    bmp: "᷀-᷿"
                }, {
                    name: "InCombining_Diacritical_Marks_for_Symbols",
                    bmp: "⃐-⃿"
                }, {
                    name: "InCombining_Half_Marks",
                    bmp: "︠-︯"
                }, {
                    name: "InCommon_Indic_Number_Forms",
                    bmp: "꠰-꠿"
                }, {
                    name: "InControl_Pictures",
                    bmp: "␀-␿"
                }, {
                    name: "InCoptic",
                    bmp: "Ⲁ-⳿"
                }, {
                    name: "InCoptic_Epact_Numbers",
                    astral: "\ud800[\udee0-\udeff]"
                }, {
                    name: "InCounting_Rod_Numerals",
                    astral: "\ud834[\udf60-\udf7f]"
                }, {
                    name: "InCuneiform",
                    astral: "\ud808[\udc00-\udfff]"
                }, {
                    name: "InCuneiform_Numbers_and_Punctuation",
                    astral: "\ud809[\udc00-\udc7f]"
                }, {
                    name: "InCurrency_Symbols",
                    bmp: "₠-⃏"
                }, {
                    name: "InCypriot_Syllabary",
                    astral: "\ud802[\udc00-\udc3f]"
                }, {
                    name: "InCyrillic",
                    bmp: "Ѐ-ӿ"
                }, {
                    name: "InCyrillic_Extended_A",
                    bmp: "ⷠ-ⷿ"
                }, {
                    name: "InCyrillic_Extended_B",
                    bmp: "Ꙁ-ꚟ"
                }, {
                    name: "InCyrillic_Supplement",
                    bmp: "Ԁ-ԯ"
                }, {
                    name: "InDeseret",
                    astral: "\ud801[\udc00-\udc4f]"
                }, {
                    name: "InDevanagari",
                    bmp: "ऀ-ॿ"
                }, {
                    name: "InDevanagari_Extended",
                    bmp: "꣠-ꣿ"
                }, {
                    name: "InDingbats",
                    bmp: "✀-➿"
                }, {
                    name: "InDomino_Tiles",
                    astral: "\ud83c[\udc30-\udc9f]"
                }, {
                    name: "InDuployan",
                    astral: "\ud82f[\udc00-\udc9f]"
                }, {
                    name: "InEarly_Dynastic_Cuneiform",
                    astral: "\ud809[\udc80-\udd4f]"
                }, {
                    name: "InEgyptian_Hieroglyphs",
                    astral: "\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2f]"
                }, {
                    name: "InElbasan",
                    astral: "\ud801[\udd00-\udd2f]"
                }, {
                    name: "InEmoticons",
                    astral: "\ud83d[\ude00-\ude4f]"
                }, {
                    name: "InEnclosed_Alphanumeric_Supplement",
                    astral: "\ud83c[\udd00-\uddff]"
                }, {
                    name: "InEnclosed_Alphanumerics",
                    bmp: "①-⓿"
                }, {
                    name: "InEnclosed_CJK_Letters_and_Months",
                    bmp: "㈀-㋿"
                }, {
                    name: "InEnclosed_Ideographic_Supplement",
                    astral: "\ud83c[\ude00-\udeff]"
                }, {
                    name: "InEthiopic",
                    bmp: "ሀ-፿"
                }, {
                    name: "InEthiopic_Extended",
                    bmp: "ⶀ-⷟"
                }, {
                    name: "InEthiopic_Extended_A",
                    bmp: "꬀-꬯"
                }, {
                    name: "InEthiopic_Supplement",
                    bmp: "ᎀ-᎟"
                }, {
                    name: "InGeneral_Punctuation",
                    bmp: " -⁯"
                }, {
                    name: "InGeometric_Shapes",
                    bmp: "■-◿"
                }, {
                    name: "InGeometric_Shapes_Extended",
                    astral: "\ud83d[\udf80-\udfff]"
                }, {
                    name: "InGeorgian",
                    bmp: "Ⴀ-ჿ"
                }, {
                    name: "InGeorgian_Supplement",
                    bmp: "ⴀ-⴯"
                }, {
                    name: "InGlagolitic",
                    bmp: "Ⰰ-ⱟ"
                }, {
                    name: "InGothic",
                    astral: "\ud800[\udf30-\udf4f]"
                }, {
                    name: "InGrantha",
                    astral: "\ud804[\udf00-\udf7f]"
                }, {
                    name: "InGreek_Extended",
                    bmp: "ἀ-῿"
                }, {
                    name: "InGreek_and_Coptic",
                    bmp: "Ͱ-Ͽ"
                }, {
                    name: "InGujarati",
                    bmp: "઀-૿"
                }, {
                    name: "InGurmukhi",
                    bmp: "਀-੿"
                }, {
                    name: "InHalfwidth_and_Fullwidth_Forms",
                    bmp: "＀-￯"
                }, {
                    name: "InHangul_Compatibility_Jamo",
                    bmp: "㄰-㆏"
                }, {
                    name: "InHangul_Jamo",
                    bmp: "ᄀ-ᇿ"
                }, {
                    name: "InHangul_Jamo_Extended_A",
                    bmp: "ꥠ-꥿"
                }, {
                    name: "InHangul_Jamo_Extended_B",
                    bmp: "ힰ-퟿"
                }, {
                    name: "InHangul_Syllables",
                    bmp: "가-힯"
                }, {
                    name: "InHanunoo",
                    bmp: "ᜠ-᜿"
                }, {
                    name: "InHatran",
                    astral: "\ud802[\udce0-\udcff]"
                }, {
                    name: "InHebrew",
                    bmp: "֐-׿"
                }, {
                    name: "InHigh_Private_Use_Surrogates",
                    bmp: "\udb80-\udbff"
                }, {
                    name: "InHigh_Surrogates",
                    bmp: "\ud800-\udb7f"
                }, {
                    name: "InHiragana",
                    bmp: "぀-ゟ"
                }, {
                    name: "InIPA_Extensions",
                    bmp: "ɐ-ʯ"
                }, {
                    name: "InIdeographic_Description_Characters",
                    bmp: "⿰-⿿"
                }, {
                    name: "InImperial_Aramaic",
                    astral: "\ud802[\udc40-\udc5f]"
                }, {
                    name: "InInscriptional_Pahlavi",
                    astral: "\ud802[\udf60-\udf7f]"
                }, {
                    name: "InInscriptional_Parthian",
                    astral: "\ud802[\udf40-\udf5f]"
                }, {
                    name: "InJavanese",
                    bmp: "ꦀ-꧟"
                }, {
                    name: "InKaithi",
                    astral: "\ud804[\udc80-\udccf]"
                }, {
                    name: "InKana_Supplement",
                    astral: "\ud82c[\udc00-\udcff]"
                }, {
                    name: "InKanbun",
                    bmp: "㆐-㆟"
                }, {
                    name: "InKangxi_Radicals",
                    bmp: "⼀-⿟"
                }, {
                    name: "InKannada",
                    bmp: "ಀ-೿"
                }, {
                    name: "InKatakana",
                    bmp: "゠-ヿ"
                }, {
                    name: "InKatakana_Phonetic_Extensions",
                    bmp: "ㇰ-ㇿ"
                }, {
                    name: "InKayah_Li",
                    bmp: "꤀-꤯"
                }, {
                    name: "InKharoshthi",
                    astral: "\ud802[\ude00-\ude5f]"
                }, {
                    name: "InKhmer",
                    bmp: "ក-៿"
                }, {
                    name: "InKhmer_Symbols",
                    bmp: "᧠-᧿"
                }, {
                    name: "InKhojki",
                    astral: "\ud804[\ude00-\ude4f]"
                }, {
                    name: "InKhudawadi",
                    astral: "\ud804[\udeb0-\udeff]"
                }, {
                    name: "InLao",
                    bmp: "຀-໿"
                }, {
                    name: "InLatin_Extended_Additional",
                    bmp: "Ḁ-ỿ"
                }, {
                    name: "InLatin_Extended_A",
                    bmp: "Ā-ſ"
                }, {
                    name: "InLatin_Extended_B",
                    bmp: "ƀ-ɏ"
                }, {
                    name: "InLatin_Extended_C",
                    bmp: "Ⱡ-Ɀ"
                }, {
                    name: "InLatin_Extended_D",
                    bmp: "꜠-ꟿ"
                }, {
                    name: "InLatin_Extended_E",
                    bmp: "ꬰ-꭯"
                }, {
                    name: "InLatin_1_Supplement",
                    bmp: "-ÿ"
                }, {
                    name: "InLepcha",
                    bmp: "ᰀ-ᱏ"
                }, {
                    name: "InLetterlike_Symbols",
                    bmp: "℀-⅏"
                }, {
                    name: "InLimbu",
                    bmp: "ᤀ-᥏"
                }, {
                    name: "InLinear_A",
                    astral: "\ud801[\ude00-\udf7f]"
                }, {
                    name: "InLinear_B_Ideograms",
                    astral: "\ud800[\udc80-\udcff]"
                }, {
                    name: "InLinear_B_Syllabary",
                    astral: "\ud800[\udc00-\udc7f]"
                }, {
                    name: "InLisu",
                    bmp: "ꓐ-꓿"
                }, {
                    name: "InLow_Surrogates",
                    bmp: "\udc00-\udfff"
                }, {
                    name: "InLycian",
                    astral: "\ud800[\ude80-\ude9f]"
                }, {
                    name: "InLydian",
                    astral: "\ud802[\udd20-\udd3f]"
                }, {
                    name: "InMahajani",
                    astral: "\ud804[\udd50-\udd7f]"
                }, {
                    name: "InMahjong_Tiles",
                    astral: "\ud83c[\udc00-\udc2f]"
                }, {
                    name: "InMalayalam",
                    bmp: "ഀ-ൿ"
                }, {
                    name: "InMandaic",
                    bmp: "ࡀ-࡟"
                }, {
                    name: "InManichaean",
                    astral: "\ud802[\udec0-\udeff]"
                }, {
                    name: "InMathematical_Alphanumeric_Symbols",
                    astral: "\ud835[\udc00-\udfff]"
                }, {
                    name: "InMathematical_Operators",
                    bmp: "∀-⋿"
                }, {
                    name: "InMeetei_Mayek",
                    bmp: "ꯀ-꯿"
                }, {
                    name: "InMeetei_Mayek_Extensions",
                    bmp: "ꫠ-꫿"
                }, {
                    name: "InMende_Kikakui",
                    astral: "\ud83a[\udc00-\udcdf]"
                }, {
                    name: "InMeroitic_Cursive",
                    astral: "\ud802[\udda0-\uddff]"
                }, {
                    name: "InMeroitic_Hieroglyphs",
                    astral: "\ud802[\udd80-\udd9f]"
                }, {
                    name: "InMiao",
                    astral: "\ud81b[\udf00-\udf9f]"
                }, {
                    name: "InMiscellaneous_Mathematical_Symbols_A",
                    bmp: "⟀-⟯"
                }, {
                    name: "InMiscellaneous_Mathematical_Symbols_B",
                    bmp: "⦀-⧿"
                }, {
                    name: "InMiscellaneous_Symbols",
                    bmp: "☀-⛿"
                }, {
                    name: "InMiscellaneous_Symbols_and_Arrows",
                    bmp: "⬀-⯿"
                }, {
                    name: "InMiscellaneous_Symbols_and_Pictographs",
                    astral: "\ud83d[\udc00-\uddff]|\ud83c[\udf00-\udfff]"
                }, {
                    name: "InMiscellaneous_Technical",
                    bmp: "⌀-⏿"
                }, {
                    name: "InModi",
                    astral: "\ud805[\ude00-\ude5f]"
                }, {
                    name: "InModifier_Tone_Letters",
                    bmp: "꜀-ꜟ"
                }, {
                    name: "InMongolian",
                    bmp: "᠀-᢯"
                }, {
                    name: "InMro",
                    astral: "\ud81a[\ude40-\ude6f]"
                }, {
                    name: "InMultani",
                    astral: "\ud804[\ude80-\udeaf]"
                }, {
                    name: "InMusical_Symbols",
                    astral: "\ud834[\udd00-\uddff]"
                }, {
                    name: "InMyanmar",
                    bmp: "က-႟"
                }, {
                    name: "InMyanmar_Extended_A",
                    bmp: "ꩠ-ꩿ"
                }, {
                    name: "InMyanmar_Extended_B",
                    bmp: "ꧠ-꧿"
                }, {
                    name: "InNKo",
                    bmp: "߀-߿"
                }, {
                    name: "InNabataean",
                    astral: "\ud802[\udc80-\udcaf]"
                }, {
                    name: "InNew_Tai_Lue",
                    bmp: "ᦀ-᧟"
                }, {
                    name: "InNumber_Forms",
                    bmp: "⅐-↏"
                }, {
                    name: "InOgham",
                    bmp: " -᚟"
                }, {
                    name: "InOl_Chiki",
                    bmp: "᱐-᱿"
                }, {
                    name: "InOld_Hungarian",
                    astral: "\ud803[\udc80-\udcff]"
                }, {
                    name: "InOld_Italic",
                    astral: "\ud800[\udf00-\udf2f]"
                }, {
                    name: "InOld_North_Arabian",
                    astral: "\ud802[\ude80-\ude9f]"
                }, {
                    name: "InOld_Permic",
                    astral: "\ud800[\udf50-\udf7f]"
                }, {
                    name: "InOld_Persian",
                    astral: "\ud800[\udfa0-\udfdf]"
                }, {
                    name: "InOld_South_Arabian",
                    astral: "\ud802[\ude60-\ude7f]"
                }, {
                    name: "InOld_Turkic",
                    astral: "\ud803[\udc00-\udc4f]"
                }, {
                    name: "InOptical_Character_Recognition",
                    bmp: "⑀-⑟"
                }, {
                    name: "InOriya",
                    bmp: "଀-୿"
                }, {
                    name: "InOrnamental_Dingbats",
                    astral: "\ud83d[\ude50-\ude7f]"
                }, {
                    name: "InOsmanya",
                    astral: "\ud801[\udc80-\udcaf]"
                }, {
                    name: "InPahawh_Hmong",
                    astral: "\ud81a[\udf00-\udf8f]"
                }, {
                    name: "InPalmyrene",
                    astral: "\ud802[\udc60-\udc7f]"
                }, {
                    name: "InPau_Cin_Hau",
                    astral: "\ud806[\udec0-\udeff]"
                }, {
                    name: "InPhags_pa",
                    bmp: "ꡀ-꡿"
                }, {
                    name: "InPhaistos_Disc",
                    astral: "\ud800[\uddd0-\uddff]"
                }, {
                    name: "InPhoenician",
                    astral: "\ud802[\udd00-\udd1f]"
                }, {
                    name: "InPhonetic_Extensions",
                    bmp: "ᴀ-ᵿ"
                }, {
                    name: "InPhonetic_Extensions_Supplement",
                    bmp: "ᶀ-ᶿ"
                }, {
                    name: "InPlaying_Cards",
                    astral: "\ud83c[\udca0-\udcff]"
                }, {
                    name: "InPrivate_Use_Area",
                    bmp: "-"
                }, {
                    name: "InPsalter_Pahlavi",
                    astral: "\ud802[\udf80-\udfaf]"
                }, {
                    name: "InRejang",
                    bmp: "ꤰ-꥟"
                }, {
                    name: "InRumi_Numeral_Symbols",
                    astral: "\ud803[\ude60-\ude7f]"
                }, {
                    name: "InRunic",
                    bmp: "ᚠ-᛿"
                }, {
                    name: "InSamaritan",
                    bmp: "ࠀ-࠿"
                }, {
                    name: "InSaurashtra",
                    bmp: "ꢀ-꣟"
                }, {
                    name: "InSharada",
                    astral: "\ud804[\udd80-\udddf]"
                }, {
                    name: "InShavian",
                    astral: "\ud801[\udc50-\udc7f]"
                }, {
                    name: "InShorthand_Format_Controls",
                    astral: "\ud82f[\udca0-\udcaf]"
                }, {
                    name: "InSiddham",
                    astral: "\ud805[\udd80-\uddff]"
                }, {
                    name: "InSinhala",
                    bmp: "඀-෿"
                }, {
                    name: "InSinhala_Archaic_Numbers",
                    astral: "\ud804[\udde0-\uddff]"
                }, {
                    name: "InSmall_Form_Variants",
                    bmp: "﹐-﹯"
                }, {
                    name: "InSora_Sompeng",
                    astral: "\ud804[\udcd0-\udcff]"
                }, {
                    name: "InSpacing_Modifier_Letters",
                    bmp: "ʰ-˿"
                }, {
                    name: "InSpecials",
                    bmp: "￰-￿"
                }, {
                    name: "InSundanese",
                    bmp: "ᮀ-ᮿ"
                }, {
                    name: "InSundanese_Supplement",
                    bmp: "᳀-᳏"
                }, {
                    name: "InSuperscripts_and_Subscripts",
                    bmp: "⁰-₟"
                }, {
                    name: "InSupplemental_Arrows_A",
                    bmp: "⟰-⟿"
                }, {
                    name: "InSupplemental_Arrows_B",
                    bmp: "⤀-⥿"
                }, {
                    name: "InSupplemental_Arrows_C",
                    astral: "\ud83e[\udc00-\udcff]"
                }, {
                    name: "InSupplemental_Mathematical_Operators",
                    bmp: "⨀-⫿"
                }, {
                    name: "InSupplemental_Punctuation",
                    bmp: "⸀-⹿"
                }, {
                    name: "InSupplemental_Symbols_and_Pictographs",
                    astral: "\ud83e[\udd00-\uddff]"
                }, {
                    name: "InSupplementary_Private_Use_Area_A",
                    astral: "[\udb80-\udbbf][\udc00-\udfff]"
                }, {
                    name: "InSupplementary_Private_Use_Area_B",
                    astral: "[\udbc0-\udbff][\udc00-\udfff]"
                }, {
                    name: "InSutton_SignWriting",
                    astral: "\ud836[\udc00-\udeaf]"
                }, {
                    name: "InSyloti_Nagri",
                    bmp: "ꠀ-꠯"
                }, {
                    name: "InSyriac",
                    bmp: "܀-ݏ"
                }, {
                    name: "InTagalog",
                    bmp: "ᜀ-ᜟ"
                }, {
                    name: "InTagbanwa",
                    bmp: "ᝠ-᝿"
                }, {
                    name: "InTags",
                    astral: "\udb40[\udc00-\udc7f]"
                }, {
                    name: "InTai_Le",
                    bmp: "ᥐ-᥿"
                }, {
                    name: "InTai_Tham",
                    bmp: "ᨠ-᪯"
                }, {
                    name: "InTai_Viet",
                    bmp: "ꪀ-꫟"
                }, {
                    name: "InTai_Xuan_Jing_Symbols",
                    astral: "\ud834[\udf00-\udf5f]"
                }, {
                    name: "InTakri",
                    astral: "\ud805[\ude80-\udecf]"
                }, {
                    name: "InTamil",
                    bmp: "஀-௿"
                }, {
                    name: "InTelugu",
                    bmp: "ఀ-౿"
                }, {
                    name: "InThaana",
                    bmp: "ހ-޿"
                }, {
                    name: "InThai",
                    bmp: "฀-๿"
                }, {
                    name: "InTibetan",
                    bmp: "ༀ-࿿"
                }, {
                    name: "InTifinagh",
                    bmp: "ⴰ-⵿"
                }, {
                    name: "InTirhuta",
                    astral: "\ud805[\udc80-\udcdf]"
                }, {
                    name: "InTransport_and_Map_Symbols",
                    astral: "\ud83d[\ude80-\udeff]"
                }, {
                    name: "InUgaritic",
                    astral: "\ud800[\udf80-\udf9f]"
                }, {
                    name: "InUnified_Canadian_Aboriginal_Syllabics",
                    bmp: "᐀-ᙿ"
                }, {
                    name: "InUnified_Canadian_Aboriginal_Syllabics_Extended",
                    bmp: "ᢰ-᣿"
                }, {
                    name: "InVai",
                    bmp: "ꔀ-꘿"
                }, {
                    name: "InVariation_Selectors",
                    bmp: "︀-️"
                }, {
                    name: "InVariation_Selectors_Supplement",
                    astral: "\udb40[\udd00-\uddef]"
                }, {
                    name: "InVedic_Extensions",
                    bmp: "᳐-᳿"
                }, {
                    name: "InVertical_Forms",
                    bmp: "︐-︟"
                }, {
                    name: "InWarang_Citi",
                    astral: "\ud806[\udca0-\udcff]"
                }, {
                    name: "InYi_Radicals",
                    bmp: "꒐-꓏"
                }, {
                    name: "InYi_Syllables",
                    bmp: "ꀀ-꒏"
                }, {
                    name: "InYijing_Hexagram_Symbols",
                    bmp: "䷀-䷿"
                }])
            }
        }, {}],
        5: [function(require, module, exports) {
            module.exports = function(XRegExp) {
                if (!XRegExp.addUnicodeData) throw new ReferenceError("Unicode Base must be loaded before Unicode Categories");
                XRegExp.addUnicodeData([{
                    name: "C",
                    alias: "Other",
                    isBmpLast: true,
                    bmp: "\x00--­͸͹΀-΃΋΍΢԰՗՘ՠֈ֋֌֐׈-׏׫-ׯ׵-؅؜؝۝܎܏݋݌޲-޿߻-߿࠮࠯࠿࡜࡝࡟-࢟ࢵ-࣢঄঍঎঑঒঩঱঳-঵঺঻৅৆৉৊৏-৖৘-৛৞৤৥ৼ-਀਄਋-਎਑਒਩਱਴਷਺਻਽੃-੆੉੊੎-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺઻૆૊૎૏૑-૟૤૥૲-૸ૺ-଀଄଍଎଑଒଩଱଴଺଻୅୆୉୊୎-୕୘-୛୞୤୥୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉௎௏௑-௖௘-௥௻-௿ఄ఍఑఩఺-఼౅౉౎-౔౗౛-౟౤౥౰-౷ಀ಄಍಑಩಴಺಻೅೉೎-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉൏-ൖ൘-൞൤൥൶-൸඀ඁ඄඗-඙඲඼඾඿෇-෉෋-෎෕෗෠-෥෰෱෵-฀฻-฾๜-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇໎໏໚໛໠-໿཈཭-཰྘྽࿍࿛-࿿჆჈-჌჎჏቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛፜፽-፿᎚-᎟᏶᏷᏾᏿᚝-᚟᛹-᛿ᜍ᜕-ᜟ᜷-᜿᝔-᝟᝭᝱᝴-᝿៞៟៪-៯៺-៿᠎᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤼-᤿᥁-᥃᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧝᨜᨝᩟᩽᩾᪊-᪏᪚-᪟᪮᪯ᪿ-᫿ᭌ-᭏᭽-᭿᯴-᯻᰸-᰺᱊-᱌ᲀ-Ჿ᳈-᳏᳷ᳺ-᳿᷶-᷻἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵῅῔῕῜῰῱῵῿​-‏‪-‮⁠-⁯⁲⁳₏₝-₟₿-⃏⃱-⃿↌-↏⏻-⏿␧-␿⑋-⑟⭴⭵⮖⮗⮺-⮼⯉⯒-⯫⯰-⯿Ⱟⱟ⳴-⳸⴦⴨-⴬⴮⴯⵨-⵮⵱-⵾⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⹃-⹿⺚⻴-⻿⿖-⿯⿼-⿿぀゗゘㄀-㄄ㄮ-㄰㆏ㆻ-ㆿ㇤-㇯㈟㋿䶶-䶿鿖-鿿꒍-꒏꓇-꓏꘬-꘿꛸-꛿ꞮꞯꞸ-ꟶ꠬-꠯꠺-꠿꡸-꡿ꣅ-꣍꣚-꣟ꣾꣿ꥔-꥞꥽-꥿꧎꧚-꧝꧿꨷-꨿꩎꩏꩚꩛꫃-꫚꫷-꬀꬇꬈꬏꬐꬗-꬟꬧꬯ꭦ-꭯꯮꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬷﬽﬿﭂﭅﯂-﯒﵀-﵏﶐﶑﷈-﷯﷾﷿︚-︟﹓﹧﹬-﹯﹵﻽-＀﾿-￁￈￉￐￑￘￙￝-￟￧￯-￻￾￿",
                    astral: "\ud834[\udcf6-\udcff\udd27\udd28\udd73-\udd7a\udde9-\uddff\ude46-\udeff\udf57-\udf5f\udf72-\udfff]|\ud836[\ude8c-\ude9a\udea0\udeb0-\udfff]|\ud83c[\udc2c-\udc2f\udc94-\udc9f\udcaf\udcb0\udcc0\udcd0\udcf6-\udcff\udd0d-\udd0f\udd2f\udd6c-\udd6f\udd9b-\udde5\ude03-\ude0f\ude3b-\ude3f\ude49-\ude4f\ude52-\udeff]|\ud81a[\ude39-\ude3f\ude5f\ude6a-\ude6d\ude70-\udecf\udeee\udeef\udef6-\udeff\udf46-\udf4f\udf5a\udf62\udf78-\udf7c\udf90-\udfff]|\ud809[\udc6f\udc75-\udc7f\udd44-\udfff]|\ud81b[\udc00-\udeff\udf45-\udf4f\udf7f-\udf8e\udfa0-\udfff]|\ud86e[\udc1e\udc1f]|\ud83d[\udd7a\udda4\uded1-\udedf\udeed-\udeef\udef4-\udeff\udf74-\udf7f\udfd5-\udfff]|\ud801[\udc9e\udc9f\udcaa-\udcff\udd28-\udd2f\udd64-\udd6e\udd70-\uddff\udf37-\udf3f\udf56-\udf5f\udf68-\udfff]|\ud800[\udc0c\udc27\udc3b\udc3e\udc4e\udc4f\udc5e-\udc7f\udcfb-\udcff\udd03-\udd06\udd34-\udd36\udd8d-\udd8f\udd9c-\udd9f\udda1-\uddcf\uddfe-\ude7f\ude9d-\ude9f\uded1-\udedf\udefc-\udeff\udf24-\udf2f\udf4b-\udf4f\udf7b-\udf7f\udf9e\udfc4-\udfc7\udfd6-\udfff]|\ud869[\uded7-\udeff]|\ud83b[\udc00-\uddff\ude04\ude20\ude23\ude25\ude26\ude28\ude33\ude38\ude3a\ude3c-\ude41\ude43-\ude46\ude48\ude4a\ude4c\ude50\ude53\ude55\ude56\ude58\ude5a\ude5c\ude5e\ude60\ude63\ude65\ude66\ude6b\ude73\ude78\ude7d\ude7f\ude8a\ude9c-\udea0\udea4\udeaa\udebc-\udeef\udef2-\udfff]|\ud87e[\ude1e-\udfff]|\udb40[\udc00-\udcff\uddf0-\udfff]|\ud804[\udc4e-\udc51\udc70-\udc7e\udcbd\udcc2-\udccf\udce9-\udcef\udcfa-\udcff\udd35\udd44-\udd4f\udd77-\udd7f\uddce\uddcf\udde0\uddf5-\uddff\ude12\ude3e-\ude7f\ude87\ude89\ude8e\ude9e\udeaa-\udeaf\udeeb-\udeef\udefa-\udeff\udf04\udf0d\udf0e\udf11\udf12\udf29\udf31\udf34\udf3a\udf3b\udf45\udf46\udf49\udf4a\udf4e\udf4f\udf51-\udf56\udf58-\udf5c\udf64\udf65\udf6d-\udf6f\udf75-\udfff]|\ud83a[\udcc5\udcc6\udcd7-\udfff]|\ud80d[\udc2f-\udfff]|\ud86d[\udf35-\udf3f]|[\ud807\ud80a\ud80b\ud80e-\ud810\ud812-\ud819\ud81c-\ud82b\ud82d\ud82e\ud830-\ud833\ud837-\ud839\ud83f\ud874-\ud87d\ud87f-\udb3f\udb41-\udbff][\udc00-\udfff]|\ud806[\udc00-\udc9f\udcf3-\udcfe\udd00-\udebf\udef9-\udfff]|\ud803[\udc49-\udc7f\udcb3-\udcbf\udcf3-\udcf9\udd00-\ude5f\ude7f-\udfff]|\ud835[\udc55\udc9d\udca0\udca1\udca3\udca4\udca7\udca8\udcad\udcba\udcbc\udcc4\udd06\udd0b\udd0c\udd15\udd1d\udd3a\udd3f\udd45\udd47-\udd49\udd51\udea6\udea7\udfcc\udfcd]|\ud805[\udc00-\udc7f\udcc8-\udccf\udcda-\udd7f\uddb6\uddb7\uddde-\uddff\ude45-\ude4f\ude5a-\ude7f\udeb8-\udebf\udeca-\udeff\udf1a-\udf1c\udf2c-\udf2f\udf40-\udfff]|\ud802[\udc06\udc07\udc09\udc36\udc39-\udc3b\udc3d\udc3e\udc56\udc9f-\udca6\udcb0-\udcdf\udcf3\udcf6-\udcfa\udd1c-\udd1e\udd3a-\udd3e\udd40-\udd7f\uddb8-\uddbb\uddd0\uddd1\ude04\ude07-\ude0b\ude14\ude18\ude34-\ude37\ude3b-\ude3e\ude48-\ude4f\ude59-\ude5f\udea0-\udebf\udee7-\udeea\udef7-\udeff\udf36-\udf38\udf56\udf57\udf73-\udf77\udf92-\udf98\udf9d-\udfa8\udfb0-\udfff]|\ud808[\udf9a-\udfff]|\ud82f[\udc6b-\udc6f\udc7d-\udc7f\udc89-\udc8f\udc9a\udc9b\udca0-\udfff]|\ud82c[\udc02-\udfff]|\ud811[\ude47-\udfff]|\ud83e[\udc0c-\udc0f\udc48-\udc4f\udc5a-\udc5f\udc88-\udc8f\udcae-\udd0f\udd19-\udd7f\udd85-\uddbf\uddc1-\udfff]|\ud873[\udea2-\udfff]"
                }, {
                    name: "Cc",
                    alias: "Control",
                    bmp: "\x00--"
                }, {
                    name: "Cf",
                    alias: "Format",
                    bmp: "­؀-؅؜۝܏᠎​-‏‪-‮⁠-⁤⁦-⁯﻿￹-￻",
                    astral: "\udb40[\udc01\udc20-\udc7f]|\ud82f[\udca0-\udca3]|\ud834[\udd73-\udd7a]|\ud804\udcbd"
                }, {
                    name: "Cn",
                    alias: "Unassigned",
                    bmp: "͸͹΀-΃΋΍΢԰՗՘ՠֈ֋֌֐׈-׏׫-ׯ׵-׿؝܎݋݌޲-޿߻-߿࠮࠯࠿࡜࡝࡟-࢟ࢵ-࣢঄঍঎঑঒঩঱঳-঵঺঻৅৆৉৊৏-৖৘-৛৞৤৥ৼ-਀਄਋-਎਑਒਩਱਴਷਺਻਽੃-੆੉੊੎-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺઻૆૊૎૏૑-૟૤૥૲-૸ૺ-଀଄଍଎଑଒଩଱଴଺଻୅୆୉୊୎-୕୘-୛୞୤୥୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉௎௏௑-௖௘-௥௻-௿ఄ఍఑఩఺-఼౅౉౎-౔౗౛-౟౤౥౰-౷ಀ಄಍಑಩಴಺಻೅೉೎-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉൏-ൖ൘-൞൤൥൶-൸඀ඁ඄඗-඙඲඼඾඿෇-෉෋-෎෕෗෠-෥෰෱෵-฀฻-฾๜-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇໎໏໚໛໠-໿཈཭-཰྘྽࿍࿛-࿿჆჈-჌჎჏቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛፜፽-፿᎚-᎟᏶᏷᏾᏿᚝-᚟᛹-᛿ᜍ᜕-ᜟ᜷-᜿᝔-᝟᝭᝱᝴-᝿៞៟៪-៯៺-៿᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤼-᤿᥁-᥃᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧝᨜᨝᩟᩽᩾᪊-᪏᪚-᪟᪮᪯ᪿ-᫿ᭌ-᭏᭽-᭿᯴-᯻᰸-᰺᱊-᱌ᲀ-Ჿ᳈-᳏᳷ᳺ-᳿᷶-᷻἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵῅῔῕῜῰῱῵῿⁥⁲⁳₏₝-₟₿-⃏⃱-⃿↌-↏⏻-⏿␧-␿⑋-⑟⭴⭵⮖⮗⮺-⮼⯉⯒-⯫⯰-⯿Ⱟⱟ⳴-⳸⴦⴨-⴬⴮⴯⵨-⵮⵱-⵾⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⹃-⹿⺚⻴-⻿⿖-⿯⿼-⿿぀゗゘㄀-㄄ㄮ-㄰㆏ㆻ-ㆿ㇤-㇯㈟㋿䶶-䶿鿖-鿿꒍-꒏꓇-꓏꘬-꘿꛸-꛿ꞮꞯꞸ-ꟶ꠬-꠯꠺-꠿꡸-꡿ꣅ-꣍꣚-꣟ꣾꣿ꥔-꥞꥽-꥿꧎꧚-꧝꧿꨷-꨿꩎꩏꩚꩛꫃-꫚꫷-꬀꬇꬈꬏꬐꬗-꬟꬧꬯ꭦ-꭯꯮꯯꯺-꯿힤-힯퟇-퟊퟼-퟿﩮﩯﫚-﫿﬇-﬒﬘-﬜﬷﬽﬿﭂﭅﯂-﯒﵀-﵏﶐﶑﷈-﷯﷾﷿︚-︟﹓﹧﹬-﹯﹵﻽﻾＀﾿-￁￈￉￐￑￘￙￝-￟￧￯-￸￾￿",
                    astral: "\udb40[\udc00\udc02-\udc1f\udc80-\udcff\uddf0-\udfff]|\ud834[\udcf6-\udcff\udd27\udd28\udde9-\uddff\ude46-\udeff\udf57-\udf5f\udf72-\udfff]|\ud83c[\udc2c-\udc2f\udc94-\udc9f\udcaf\udcb0\udcc0\udcd0\udcf6-\udcff\udd0d-\udd0f\udd2f\udd6c-\udd6f\udd9b-\udde5\ude03-\ude0f\ude3b-\ude3f\ude49-\ude4f\ude52-\udeff]|\ud81a[\ude39-\ude3f\ude5f\ude6a-\ude6d\ude70-\udecf\udeee\udeef\udef6-\udeff\udf46-\udf4f\udf5a\udf62\udf78-\udf7c\udf90-\udfff]|\ud809[\udc6f\udc75-\udc7f\udd44-\udfff]|\ud81b[\udc00-\udeff\udf45-\udf4f\udf7f-\udf8e\udfa0-\udfff]|\ud86e[\udc1e\udc1f]|\ud83d[\udd7a\udda4\uded1-\udedf\udeed-\udeef\udef4-\udeff\udf74-\udf7f\udfd5-\udfff]|\ud801[\udc9e\udc9f\udcaa-\udcff\udd28-\udd2f\udd64-\udd6e\udd70-\uddff\udf37-\udf3f\udf56-\udf5f\udf68-\udfff]|\ud800[\udc0c\udc27\udc3b\udc3e\udc4e\udc4f\udc5e-\udc7f\udcfb-\udcff\udd03-\udd06\udd34-\udd36\udd8d-\udd8f\udd9c-\udd9f\udda1-\uddcf\uddfe-\ude7f\ude9d-\ude9f\uded1-\udedf\udefc-\udeff\udf24-\udf2f\udf4b-\udf4f\udf7b-\udf7f\udf9e\udfc4-\udfc7\udfd6-\udfff]|\ud869[\uded7-\udeff]|\ud83b[\udc00-\uddff\ude04\ude20\ude23\ude25\ude26\ude28\ude33\ude38\ude3a\ude3c-\ude41\ude43-\ude46\ude48\ude4a\ude4c\ude50\ude53\ude55\ude56\ude58\ude5a\ude5c\ude5e\ude60\ude63\ude65\ude66\ude6b\ude73\ude78\ude7d\ude7f\ude8a\ude9c-\udea0\udea4\udeaa\udebc-\udeef\udef2-\udfff]|[\udbbf\udbff][\udffe\udfff]|\ud87e[\ude1e-\udfff]|\ud82f[\udc6b-\udc6f\udc7d-\udc7f\udc89-\udc8f\udc9a\udc9b\udca4-\udfff]|\ud83a[\udcc5\udcc6\udcd7-\udfff]|\ud80d[\udc2f-\udfff]|\ud86d[\udf35-\udf3f]|[\ud807\ud80a\ud80b\ud80e-\ud810\ud812-\ud819\ud81c-\ud82b\ud82d\ud82e\ud830-\ud833\ud837-\ud839\ud83f\ud874-\ud87d\ud87f-\udb3f\udb41-\udb7f][\udc00-\udfff]|\ud806[\udc00-\udc9f\udcf3-\udcfe\udd00-\udebf\udef9-\udfff]|\ud803[\udc49-\udc7f\udcb3-\udcbf\udcf3-\udcf9\udd00-\ude5f\ude7f-\udfff]|\ud835[\udc55\udc9d\udca0\udca1\udca3\udca4\udca7\udca8\udcad\udcba\udcbc\udcc4\udd06\udd0b\udd0c\udd15\udd1d\udd3a\udd3f\udd45\udd47-\udd49\udd51\udea6\udea7\udfcc\udfcd]|\ud836[\ude8c-\ude9a\udea0\udeb0-\udfff]|\ud805[\udc00-\udc7f\udcc8-\udccf\udcda-\udd7f\uddb6\uddb7\uddde-\uddff\ude45-\ude4f\ude5a-\ude7f\udeb8-\udebf\udeca-\udeff\udf1a-\udf1c\udf2c-\udf2f\udf40-\udfff]|\ud802[\udc06\udc07\udc09\udc36\udc39-\udc3b\udc3d\udc3e\udc56\udc9f-\udca6\udcb0-\udcdf\udcf3\udcf6-\udcfa\udd1c-\udd1e\udd3a-\udd3e\udd40-\udd7f\uddb8-\uddbb\uddd0\uddd1\ude04\ude07-\ude0b\ude14\ude18\ude34-\ude37\ude3b-\ude3e\ude48-\ude4f\ude59-\ude5f\udea0-\udebf\udee7-\udeea\udef7-\udeff\udf36-\udf38\udf56\udf57\udf73-\udf77\udf92-\udf98\udf9d-\udfa8\udfb0-\udfff]|\ud808[\udf9a-\udfff]|\ud804[\udc4e-\udc51\udc70-\udc7e\udcc2-\udccf\udce9-\udcef\udcfa-\udcff\udd35\udd44-\udd4f\udd77-\udd7f\uddce\uddcf\udde0\uddf5-\uddff\ude12\ude3e-\ude7f\ude87\ude89\ude8e\ude9e\udeaa-\udeaf\udeeb-\udeef\udefa-\udeff\udf04\udf0d\udf0e\udf11\udf12\udf29\udf31\udf34\udf3a\udf3b\udf45\udf46\udf49\udf4a\udf4e\udf4f\udf51-\udf56\udf58-\udf5c\udf64\udf65\udf6d-\udf6f\udf75-\udfff]|\ud82c[\udc02-\udfff]|\ud811[\ude47-\udfff]|\ud83e[\udc0c-\udc0f\udc48-\udc4f\udc5a-\udc5f\udc88-\udc8f\udcae-\udd0f\udd19-\udd7f\udd85-\uddbf\uddc1-\udfff]|\ud873[\udea2-\udfff]"
                }, {
                    name: "Co",
                    alias: "Private_Use",
                    bmp: "-",
                    astral: "[\udb80-\udbbe\udbc0-\udbfe][\udc00-\udfff]|[\udbbf\udbff][\udc00-\udffd]"
                }, {
                    name: "Cs",
                    alias: "Surrogate",
                    bmp: "\ud800-\udfff"
                }, {
                    name: "L",
                    alias: "Letter",
                    bmp: "A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢴऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛱ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎↃↄⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々〆〱-〵〻〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿕ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛥꜗ-ꜟꜢ-ꞈꞋ-ꞭꞰ-ꞷꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭥꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
                    astral: "\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2]|\ud83a[\udc00-\udcc4]|\ud801[\udc00-\udc9d\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\ude80-\ude9c\udea0-\uded0\udf00-\udf1f\udf30-\udf40\udf42-\udf49\udf50-\udf75\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf]|\ud80d[\udc00-\udc2e]|\ud87e[\udc00-\ude1d]|\ud81b[\udf00-\udf44\udf50\udf93-\udf9f]|[\ud80c\ud840-\ud868\ud86a-\ud86c\ud86f-\ud872][\udc00-\udfff]|\ud805[\udc80-\udcaf\udcc4\udcc5\udcc7\udd80-\uddae\uddd8-\udddb\ude00-\ude2f\ude44\ude80-\udeaa\udf00-\udf19]|\ud81a[\udc00-\ude38\ude40-\ude5e\uded0-\udeed\udf00-\udf2f\udf40-\udf43\udf63-\udf77\udf7d-\udf8f]|\ud809[\udc80-\udd43]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe\uddbf\ude00\ude10-\ude13\ude15-\ude17\ude19-\ude33\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee4\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e\udc9f\udca2\udca5\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb]|\ud804[\udc03-\udc37\udc83-\udcaf\udcd0-\udce8\udd03-\udd26\udd50-\udd72\udd76\udd83-\uddb2\uddc1-\uddc4\uddda\udddc\ude00-\ude11\ude13-\ude2b\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udede\udf05-\udf0c\udf0f\udf10\udf13-\udf28\udf2a-\udf30\udf32\udf33\udf35-\udf39\udf3d\udf50\udf5d-\udf61]|\ud808[\udc00-\udf99]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud806[\udca0-\udcdf\udcff\udec0-\udef8]|\ud811[\udc00-\ude46]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99]|\ud82c[\udc00\udc01]|\ud873[\udc00-\udea1]"
                }, {
                    name: "Ll",
                    alias: "Lowercase_Letter",
                    bmp: "a-zµß-öø-ÿāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĳĵķĸĺļľŀłńņňŉŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷźżž-ƀƃƅƈƌƍƒƕƙ-ƛƞơƣƥƨƪƫƭưƴƶƹƺƽ-ƿǆǉǌǎǐǒǔǖǘǚǜǝǟǡǣǥǧǩǫǭǯǰǳǵǹǻǽǿȁȃȅȇȉȋȍȏȑȓȕȗșțȝȟȡȣȥȧȩȫȭȯȱȳ-ȹȼȿɀɂɇɉɋɍɏ-ʓʕ-ʯͱͳͷͻ-ͽΐά-ώϐϑϕ-ϗϙϛϝϟϡϣϥϧϩϫϭϯ-ϳϵϸϻϼа-џѡѣѥѧѩѫѭѯѱѳѵѷѹѻѽѿҁҋҍҏґғҕҗҙқҝҟҡңҥҧҩҫҭүұҳҵҷҹһҽҿӂӄӆӈӊӌӎӏӑӓӕӗәӛӝӟӡӣӥӧөӫӭӯӱӳӵӷӹӻӽӿԁԃԅԇԉԋԍԏԑԓԕԗԙԛԝԟԡԣԥԧԩԫԭԯա-ևᏸ-ᏽᴀ-ᴫᵫ-ᵷᵹ-ᶚḁḃḅḇḉḋḍḏḑḓḕḗḙḛḝḟḡḣḥḧḩḫḭḯḱḳḵḷḹḻḽḿṁṃṅṇṉṋṍṏṑṓṕṗṙṛṝṟṡṣṥṧṩṫṭṯṱṳṵṷṹṻṽṿẁẃẅẇẉẋẍẏẑẓẕ-ẝẟạảấầẩẫậắằẳẵặẹẻẽếềểễệỉịọỏốồổỗộớờởỡợụủứừửữựỳỵỷỹỻỽỿ-ἇἐ-ἕἠ-ἧἰ-ἷὀ-ὅὐ-ὗὠ-ὧὰ-ώᾀ-ᾇᾐ-ᾗᾠ-ᾧᾰ-ᾴᾶᾷιῂ-ῄῆῇῐ-ΐῖῗῠ-ῧῲ-ῴῶῷℊℎℏℓℯℴℹℼℽⅆ-ⅉⅎↄⰰ-ⱞⱡⱥⱦⱨⱪⱬⱱⱳⱴⱶ-ⱻⲁⲃⲅⲇⲉⲋⲍⲏⲑⲓⲕⲗⲙⲛⲝⲟⲡⲣⲥⲧⲩⲫⲭⲯⲱⲳⲵⲷⲹⲻⲽⲿⳁⳃⳅⳇⳉⳋⳍⳏⳑⳓⳕⳗⳙⳛⳝⳟⳡⳣⳤⳬⳮⳳⴀ-ⴥⴧⴭꙁꙃꙅꙇꙉꙋꙍꙏꙑꙓꙕꙗꙙꙛꙝꙟꙡꙣꙥꙧꙩꙫꙭꚁꚃꚅꚇꚉꚋꚍꚏꚑꚓꚕꚗꚙꚛꜣꜥꜧꜩꜫꜭꜯ-ꜱꜳꜵꜷꜹꜻꜽꜿꝁꝃꝅꝇꝉꝋꝍꝏꝑꝓꝕꝗꝙꝛꝝꝟꝡꝣꝥꝧꝩꝫꝭꝯꝱ-ꝸꝺꝼꝿꞁꞃꞅꞇꞌꞎꞑꞓ-ꞕꞗꞙꞛꞝꞟꞡꞣꞥꞧꞩꞵꞷꟺꬰ-ꭚꭠ-ꭥꭰ-ꮿﬀ-ﬆﬓ-ﬗａ-ｚ",
                    astral: "\ud803[\udcc0-\udcf2]|\ud835[\udc1a-\udc33\udc4e-\udc54\udc56-\udc67\udc82-\udc9b\udcb6-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udccf\udcea-\udd03\udd1e-\udd37\udd52-\udd6b\udd86-\udd9f\uddba-\uddd3\uddee-\ude07\ude22-\ude3b\ude56-\ude6f\ude8a-\udea5\udec2-\udeda\udedc-\udee1\udefc-\udf14\udf16-\udf1b\udf36-\udf4e\udf50-\udf55\udf70-\udf88\udf8a-\udf8f\udfaa-\udfc2\udfc4-\udfc9\udfcb]|\ud801[\udc28-\udc4f]|\ud806[\udcc0-\udcdf]"
                }, {
                    name: "Lm",
                    alias: "Modifier_Letter",
                    bmp: "ʰ-ˁˆ-ˑˠ-ˤˬˮʹͺՙـۥۦߴߵߺࠚࠤࠨॱๆໆჼៗᡃᪧᱸ-ᱽᴬ-ᵪᵸᶛ-ᶿⁱⁿₐ-ₜⱼⱽⵯⸯ々〱-〵〻ゝゞー-ヾꀕꓸ-ꓽꘌꙿꚜꚝꜗ-ꜟꝰꞈꟸꟹꧏꧦꩰꫝꫳꫴꭜ-ꭟｰﾞﾟ",
                    astral: "\ud81a[\udf40-\udf43]|\ud81b[\udf93-\udf9f]"
                }, {
                    name: "Lo",
                    alias: "Other_Letter",
                    bmp: "ªºƻǀ-ǃʔא-תװ-ײؠ-ؿف-يٮٯٱ-ۓەۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪࠀ-ࠕࡀ-ࡘࢠ-ࢴऄ-हऽॐक़-ॡॲ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๅກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎა-ჺჽ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛱ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៜᠠ-ᡂᡄ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱷᳩ-ᳬᳮ-ᳱᳵᳶℵ-ℸⴰ-ⵧⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ〆〼ぁ-ゖゟァ-ヺヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿕ꀀ-ꀔꀖ-ꒌꓐ-ꓷꔀ-ꘋꘐ-ꘟꘪꘫꙮꚠ-ꛥꞏꟷꟻ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧠ-ꧤꧧ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩯꩱ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛꫜꫠ-ꫪꫲꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎יִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼｦ-ｯｱ-ﾝﾠ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
                    astral: "\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud83a[\udc00-\udcc4]|\ud803[\udc00-\udc48]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\ude80-\ude9c\udea0-\uded0\udf00-\udf1f\udf30-\udf40\udf42-\udf49\udf50-\udf75\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf]|\ud80d[\udc00-\udc2e]|\ud87e[\udc00-\ude1d]|\ud81b[\udf00-\udf44\udf50]|[\ud80c\ud840-\ud868\ud86a-\ud86c\ud86f-\ud872][\udc00-\udfff]|\ud805[\udc80-\udcaf\udcc4\udcc5\udcc7\udd80-\uddae\uddd8-\udddb\ude00-\ude2f\ude44\ude80-\udeaa\udf00-\udf19]|\ud806[\udcff\udec0-\udef8]|\ud809[\udc80-\udd43]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe\uddbf\ude00\ude10-\ude13\ude15-\ude17\ude19-\ude33\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee4\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud804[\udc03-\udc37\udc83-\udcaf\udcd0-\udce8\udd03-\udd26\udd50-\udd72\udd76\udd83-\uddb2\uddc1-\uddc4\uddda\udddc\ude00-\ude11\ude13-\ude2b\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udede\udf05-\udf0c\udf0f\udf10\udf13-\udf28\udf2a-\udf30\udf32\udf33\udf35-\udf39\udf3d\udf50\udf5d-\udf61]|\ud808[\udc00-\udf99]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud81a[\udc00-\ude38\ude40-\ude5e\uded0-\udeed\udf00-\udf2f\udf63-\udf77\udf7d-\udf8f]|\ud801[\udc50-\udc9d\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud811[\udc00-\ude46]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99]|\ud82c[\udc00\udc01]|\ud873[\udc00-\udea1]"
                }, {
                    name: "Lt",
                    alias: "Titlecase_Letter",
                    bmp: "ǅǈǋǲᾈ-ᾏᾘ-ᾟᾨ-ᾯᾼῌῼ"
                }, {
                    name: "Lu",
                    alias: "Uppercase_Letter",
                    bmp: "A-ZÀ-ÖØ-ÞĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮİĲĴĶĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸŹŻŽƁƂƄƆƇƉ-ƋƎ-ƑƓƔƖ-ƘƜƝƟƠƢƤƦƧƩƬƮƯƱ-ƳƵƷƸƼǄǇǊǍǏǑǓǕǗǙǛǞǠǢǤǦǨǪǬǮǱǴǶ-ǸǺǼǾȀȂȄȆȈȊȌȎȐȒȔȖȘȚȜȞȠȢȤȦȨȪȬȮȰȲȺȻȽȾɁɃ-ɆɈɊɌɎͰͲͶͿΆΈ-ΊΌΎΏΑ-ΡΣ-ΫϏϒ-ϔϘϚϜϞϠϢϤϦϨϪϬϮϴϷϹϺϽ-ЯѠѢѤѦѨѪѬѮѰѲѴѶѸѺѼѾҀҊҌҎҐҒҔҖҘҚҜҞҠҢҤҦҨҪҬҮҰҲҴҶҸҺҼҾӀӁӃӅӇӉӋӍӐӒӔӖӘӚӜӞӠӢӤӦӨӪӬӮӰӲӴӶӸӺӼӾԀԂԄԆԈԊԌԎԐԒԔԖԘԚԜԞԠԢԤԦԨԪԬԮԱ-ՖႠ-ჅჇჍᎠ-ᏵḀḂḄḆḈḊḌḎḐḒḔḖḘḚḜḞḠḢḤḦḨḪḬḮḰḲḴḶḸḺḼḾṀṂṄṆṈṊṌṎṐṒṔṖṘṚṜṞṠṢṤṦṨṪṬṮṰṲṴṶṸṺṼṾẀẂẄẆẈẊẌẎẐẒẔẞẠẢẤẦẨẪẬẮẰẲẴẶẸẺẼẾỀỂỄỆỈỊỌỎỐỒỔỖỘỚỜỞỠỢỤỦỨỪỬỮỰỲỴỶỸỺỼỾἈ-ἏἘ-ἝἨ-ἯἸ-ἿὈ-ὍὙὛὝὟὨ-ὯᾸ-ΆῈ-ΉῘ-ΊῨ-ῬῸ-Ώℂℇℋ-ℍℐ-ℒℕℙ-ℝℤΩℨK-ℭℰ-ℳℾℿⅅↃⰀ-ⰮⱠⱢ-ⱤⱧⱩⱫⱭ-ⱰⱲⱵⱾ-ⲀⲂⲄⲆⲈⲊⲌⲎⲐⲒⲔⲖⲘⲚⲜⲞⲠⲢⲤⲦⲨⲪⲬⲮⲰⲲⲴⲶⲸⲺⲼⲾⳀⳂⳄⳆⳈⳊⳌⳎⳐⳒⳔⳖⳘⳚⳜⳞⳠⳢⳫⳭⳲꙀꙂꙄꙆꙈꙊꙌꙎꙐꙒꙔꙖꙘꙚꙜꙞꙠꙢꙤꙦꙨꙪꙬꚀꚂꚄꚆꚈꚊꚌꚎꚐꚒꚔꚖꚘꚚꜢꜤꜦꜨꜪꜬꜮꜲꜴꜶꜸꜺꜼꜾꝀꝂꝄꝆꝈꝊꝌꝎꝐꝒꝔꝖꝘꝚꝜꝞꝠꝢꝤꝦꝨꝪꝬꝮꝹꝻꝽꝾꞀꞂꞄꞆꞋꞍꞐꞒꞖꞘꞚꞜꞞꞠꞢꞤꞦꞨꞪ-ꞭꞰ-ꞴꞶＡ-Ｚ",
                    astral: "\ud806[\udca0-\udcbf]|\ud803[\udc80-\udcb2]|\ud801[\udc00-\udc27]|\ud835[\udc00-\udc19\udc34-\udc4d\udc68-\udc81\udc9c\udc9e\udc9f\udca2\udca5\udca6\udca9-\udcac\udcae-\udcb5\udcd0-\udce9\udd04\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd38\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd6c-\udd85\udda0-\uddb9\uddd4-\udded\ude08-\ude21\ude3c-\ude55\ude70-\ude89\udea8-\udec0\udee2-\udefa\udf1c-\udf34\udf56-\udf6e\udf90-\udfa8\udfca]"
                }, {
                    name: "M",
                    alias: "Mark",
                    bmp: "̀-ͯ҃-҉֑-ׇֽֿׁׂׅׄؐ-ًؚ-ٰٟۖ-ۜ۟-۪ۤۧۨ-ܑۭܰ-݊ަ-ް߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣣ-ःऺ-़ा-ॏ॑-ॗॢॣঁ-ঃ়া-ৄেৈো-্ৗৢৣਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑੰੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣஂா-ூெ-ைொ-்ௗఀ-ఃా-ౄె-ైొ-్ౕౖౢౣಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣංඃ්ා-ුූෘ-ෟෲෳัิ-ฺ็-๎ັິ-ູົຼ່-ໍ༹༘༙༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏႚ-ႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝᠋-᠍ᢩᤠ-ᤫᤰ-᤻ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼᪰-᪾ᬀ-ᬄ᬴-᭄᭫-᭳ᮀ-ᮂᮡ-ᮭ᯦-᯳ᰤ-᰷᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷼-᷿⃐-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꙯-꙲ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-꣄꣠-꣱ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀ꧥꨩ-ꨶꩃꩌꩍꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭ﬞ︀-️︠-︯",
                    astral: "\ud805[\udcb0-\udcc3\uddaf-\uddb5\uddb8-\uddc0\udddc\udddd\ude30-\ude40\udeab-\udeb7\udf1d-\udf2b]|\ud834[\udd65-\udd69\udd6d-\udd72\udd7b-\udd82\udd85-\udd8b\uddaa-\uddad\ude42-\ude44]|\ud804[\udc00-\udc02\udc38-\udc46\udc7f-\udc82\udcb0-\udcba\udd00-\udd02\udd27-\udd34\udd73\udd80-\udd82\uddb3-\uddc0\uddca-\uddcc\ude2c-\ude37\udedf-\udeea\udf00-\udf03\udf3c\udf3e-\udf44\udf47\udf48\udf4b-\udf4d\udf57\udf62\udf63\udf66-\udf6c\udf70-\udf74]|\ud81b[\udf51-\udf7e\udf8f-\udf92]|\ud81a[\udef0-\udef4\udf30-\udf36]|\ud82f[\udc9d\udc9e]|\ud800[\uddfd\udee0\udf76-\udf7a]|\ud836[\ude00-\ude36\ude3b-\ude6c\ude75\ude84\ude9b-\ude9f\udea1-\udeaf]|\ud802[\ude01-\ude03\ude05\ude06\ude0c-\ude0f\ude38-\ude3a\ude3f\udee5\udee6]|\ud83a[\udcd0-\udcd6]|\udb40[\udd00-\uddef]"
                }, {
                    name: "Mc",
                    alias: "Spacing_Mark",
                    bmp: "ःऻा-ीॉ-ौॎॏংঃা-ীেৈোৌৗਃਾ-ੀઃા-ીૉોૌଂଃାୀେୈୋୌୗாிுூெ-ைொ-ௌௗఁ-ఃు-ౄಂಃಾೀ-ೄೇೈೊೋೕೖംഃാ-ീെ-ൈൊ-ൌൗංඃා-ෑෘ-ෟෲෳ༾༿ཿါာေးျြၖၗၢ-ၤၧ-ၭႃႄႇ-ႌႏႚ-ႜាើ-ៅះៈᤣ-ᤦᤩ-ᤫᤰᤱᤳ-ᤸᨙᨚᩕᩗᩡᩣᩤᩭ-ᩲᬄᬵᬻᬽ-ᭁᭃ᭄ᮂᮡᮦᮧ᮪ᯧᯪ-ᯬᯮ᯲᯳ᰤ-ᰫᰴᰵ᳡ᳲᳳ〮〯ꠣꠤꠧꢀꢁꢴ-ꣃꥒ꥓ꦃꦴꦵꦺꦻꦽ-꧀ꨯꨰꨳꨴꩍꩻꩽꫫꫮꫯꫵꯣꯤꯦꯧꯩꯪ꯬",
                    astral: "\ud834[\udd65\udd66\udd6d-\udd72]|\ud804[\udc00\udc02\udc82\udcb0-\udcb2\udcb7\udcb8\udd2c\udd82\uddb3-\uddb5\uddbf\uddc0\ude2c-\ude2e\ude32\ude33\ude35\udee0-\udee2\udf02\udf03\udf3e\udf3f\udf41-\udf44\udf47\udf48\udf4b-\udf4d\udf57\udf62\udf63]|\ud805[\udcb0-\udcb2\udcb9\udcbb-\udcbe\udcc1\uddaf-\uddb1\uddb8-\uddbb\uddbe\ude30-\ude32\ude3b\ude3c\ude3e\udeac\udeae\udeaf\udeb6\udf20\udf21\udf26]|\ud81b[\udf51-\udf7e]"
                }, {
                    name: "Me",
                    alias: "Enclosing_Mark",
                    bmp: "҈҉᪾⃝-⃠⃢-⃤꙰-꙲"
                }, {
                    name: "Mn",
                    alias: "Nonspacing_Mark",
                    bmp: "̀-ͯ҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-ٰٟۖ-ۜ۟-۪ۤۧۨ-ܑۭܰ-݊ަ-ް߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣣ-ंऺ़ु-ै्॑-ॗॢॣঁ়ু-ৄ্ৢৣਁਂ਼ੁੂੇੈੋ-੍ੑੰੱੵઁં઼ુ-ૅેૈ્ૢૣଁ଼ିୁ-ୄ୍ୖୢୣஂீ்ఀా-ీె-ైొ-్ౕౖౢౣಁ಼ಿೆೌ್ೢೣഁു-ൄ്ൢൣ්ි-ුූัิ-ฺ็-๎ັິ-ູົຼ່-ໍཱ༹༘༙༵༷-ཾྀ-྄྆྇ྍ-ྗྙ-ྼ࿆ိ-ူဲ-့္်ွှၘၙၞ-ၠၱ-ၴႂႅႆႍႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴឵ិ-ួំ៉-៓៝᠋-᠍ᢩᤠ-ᤢᤧᤨᤲ᤹-᤻ᨘᨗᨛᩖᩘ-ᩞ᩠ᩢᩥ-ᩬᩳ-᩿᩼᪰-᪽ᬀ-ᬃ᬴ᬶ-ᬺᬼᭂ᭫-᭳ᮀᮁᮢ-ᮥᮨᮩ᮫-ᮭ᯦ᯨᯩᯭᯯ-ᯱᰬ-ᰳᰶ᰷᳐-᳔᳒-᳢᳠-᳨᳭᳴᳸᳹᷀-᷵᷼-᷿⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〭꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠥꠦ꣄꣠-꣱ꤦ-꤭ꥇ-ꥑꦀ-ꦂ꦳ꦶ-ꦹꦼꧥꨩ-ꨮꨱꨲꨵꨶꩃꩌꩼꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫬꫭ꫶ꯥꯨ꯭ﬞ︀-️︠-︯",
                    astral: "\ud805[\udcb3-\udcb8\udcba\udcbf\udcc0\udcc2\udcc3\uddb2-\uddb5\uddbc\uddbd\uddbf\uddc0\udddc\udddd\ude33-\ude3a\ude3d\ude3f\ude40\udeab\udead\udeb0-\udeb5\udeb7\udf1d-\udf1f\udf22-\udf25\udf27-\udf2b]|\ud834[\udd67-\udd69\udd7b-\udd82\udd85-\udd8b\uddaa-\uddad\ude42-\ude44]|\ud81a[\udef0-\udef4\udf30-\udf36]|\ud81b[\udf8f-\udf92]|\ud82f[\udc9d\udc9e]|\ud800[\uddfd\udee0\udf76-\udf7a]|\ud836[\ude00-\ude36\ude3b-\ude6c\ude75\ude84\ude9b-\ude9f\udea1-\udeaf]|\ud802[\ude01-\ude03\ude05\ude06\ude0c-\ude0f\ude38-\ude3a\ude3f\udee5\udee6]|\ud804[\udc01\udc38-\udc46\udc7f-\udc81\udcb3-\udcb6\udcb9\udcba\udd00-\udd02\udd27-\udd2b\udd2d-\udd34\udd73\udd80\udd81\uddb6-\uddbe\uddca-\uddcc\ude2f-\ude31\ude34\ude36\ude37\udedf\udee3-\udeea\udf00\udf01\udf3c\udf40\udf66-\udf6c\udf70-\udf74]|\ud83a[\udcd0-\udcd6]|\udb40[\udd00-\uddef]"
                }, {
                    name: "N",
                    alias: "Number",
                    bmp: "0-9²³¹¼-¾٠-٩۰-۹߀-߉०-९০-৯৴-৹੦-੯૦-૯୦-୯୲-୷௦-௲౦-౯౸-౾೦-೯൦-൵෦-෯๐-๙໐-໙༠-༳၀-၉႐-႙፩-፼ᛮ-ᛰ០-៩៰-៹᠐-᠙᥆-᥏᧐-᧚᪀-᪉᪐-᪙᭐-᭙᮰-᮹᱀-᱉᱐-᱙⁰⁴-⁹₀-₉⅐-ↂↅ-↉①-⒛⓪-⓿❶-➓⳽〇〡-〩〸-〺㆒-㆕㈠-㈩㉈-㉏㉑-㉟㊀-㊉㊱-㊿꘠-꘩ꛦ-ꛯ꠰-꠵꣐-꣙꤀-꤉꧐-꧙꧰-꧹꩐-꩙꯰-꯹０-９",
                    astral: "\ud800[\udd07-\udd33\udd40-\udd78\udd8a\udd8b\udee1-\udefb\udf20-\udf23\udf41\udf4a\udfd1-\udfd5]|\ud801[\udca0-\udca9]|\ud803[\udcfa-\udcff\ude60-\ude7e]|\ud835[\udfce-\udfff]|\ud83a[\udcc7-\udccf]|\ud81a[\ude60-\ude69\udf50-\udf59\udf5b-\udf61]|\ud806[\udce0-\udcf2]|\ud804[\udc52-\udc6f\udcf0-\udcf9\udd36-\udd3f\uddd0-\uddd9\udde1-\uddf4\udef0-\udef9]|\ud834[\udf60-\udf71]|\ud83c[\udd00-\udd0c]|\ud809[\udc00-\udc6e]|\ud802[\udc58-\udc5f\udc79-\udc7f\udca7-\udcaf\udcfb-\udcff\udd16-\udd1b\uddbc\uddbd\uddc0-\uddcf\uddd2-\uddff\ude40-\ude47\ude7d\ude7e\ude9d-\ude9f\udeeb-\udeef\udf58-\udf5f\udf78-\udf7f\udfa9-\udfaf]|\ud805[\udcd0-\udcd9\ude50-\ude59\udec0-\udec9\udf30-\udf3b]"
                }, {
                    name: "Nd",
                    alias: "Decimal_Number",
                    bmp: "0-9٠-٩۰-۹߀-߉०-९০-৯੦-੯૦-૯୦-୯௦-௯౦-౯೦-೯൦-൯෦-෯๐-๙໐-໙༠-༩၀-၉႐-႙០-៩᠐-᠙᥆-᥏᧐-᧙᪀-᪉᪐-᪙᭐-᭙᮰-᮹᱀-᱉᱐-᱙꘠-꘩꣐-꣙꤀-꤉꧐-꧙꧰-꧹꩐-꩙꯰-꯹０-９",
                    astral: "\ud801[\udca0-\udca9]|\ud835[\udfce-\udfff]|\ud805[\udcd0-\udcd9\ude50-\ude59\udec0-\udec9\udf30-\udf39]|\ud806[\udce0-\udce9]|\ud804[\udc66-\udc6f\udcf0-\udcf9\udd36-\udd3f\uddd0-\uddd9\udef0-\udef9]|\ud81a[\ude60-\ude69\udf50-\udf59]"
                }, {
                    name: "Nl",
                    alias: "Letter_Number",
                    bmp: "ᛮ-ᛰⅠ-ↂↅ-ↈ〇〡-〩〸-〺ꛦ-ꛯ",
                    astral: "\ud809[\udc00-\udc6e]|\ud800[\udd40-\udd74\udf41\udf4a\udfd1-\udfd5]"
                }, {
                    name: "No",
                    alias: "Other_Number",
                    bmp: "²³¹¼-¾৴-৹୲-୷௰-௲౸-౾൰-൵༪-༳፩-፼៰-៹᧚⁰⁴-⁹₀-₉⅐-⅟↉①-⒛⓪-⓿❶-➓⳽㆒-㆕㈠-㈩㉈-㉏㉑-㉟㊀-㊉㊱-㊿꠰-꠵",
                    astral: "\ud804[\udc52-\udc65\udde1-\uddf4]|\ud803[\udcfa-\udcff\ude60-\ude7e]|\ud83c[\udd00-\udd0c]|\ud806[\udcea-\udcf2]|\ud83a[\udcc7-\udccf]|\ud802[\udc58-\udc5f\udc79-\udc7f\udca7-\udcaf\udcfb-\udcff\udd16-\udd1b\uddbc\uddbd\uddc0-\uddcf\uddd2-\uddff\ude40-\ude47\ude7d\ude7e\ude9d-\ude9f\udeeb-\udeef\udf58-\udf5f\udf78-\udf7f\udfa9-\udfaf]|\ud805[\udf3a\udf3b]|\ud81a[\udf5b-\udf61]|\ud834[\udf60-\udf71]|\ud800[\udd07-\udd33\udd75-\udd78\udd8a\udd8b\udee1-\udefb\udf20-\udf23]"
                }, {
                    name: "P",
                    alias: "Punctuation",
                    bmp: "!-#%-\\x2A,-/:;\\x3F@\\x5B-\\x5D_\\x7B}¡§«¶·»¿;·՚-՟։֊־׀׃׆׳״؉؊،؍؛؞؟٪-٭۔܀-܍߷-߹࠰-࠾࡞।॥॰૰෴๏๚๛༄-༒༔༺-༽྅࿐-࿔࿙࿚၊-၏჻፠-፨᐀᙭᙮᚛᚜᛫-᛭᜵᜶។-៖៘-៚᠀-᠊᥄᥅᨞᨟᪠-᪦᪨-᪭᭚-᭠᯼-᯿᰻-᰿᱾᱿᳀-᳇᳓‐-‧‰-⁃⁅-⁑⁓-⁞⁽⁾₍₎⌈-⌋〈〉❨-❵⟅⟆⟦-⟯⦃-⦘⧘-⧛⧼⧽⳹-⳼⳾⳿⵰⸀-⸮⸰-⹂、-〃〈-】〔-〟〰〽゠・꓾꓿꘍-꘏꙳꙾꛲-꛷꡴-꡷꣎꣏꣸-꣺꣼꤮꤯꥟꧁-꧍꧞꧟꩜-꩟꫞꫟꫰꫱꯫﴾﴿︐-︙︰-﹒﹔-﹡﹣﹨﹪﹫！-＃％-＊，-／：；？＠［-］＿｛｝｟-･",
                    astral: "\ud802[\udc57\udd1f\udd3f\ude50-\ude58\ude7f\udef0-\udef6\udf39-\udf3f\udf99-\udf9c]|\ud809[\udc70-\udc74]|\ud805[\udcc6\uddc1-\uddd7\ude41-\ude43\udf3c-\udf3e]|\ud836[\ude87-\ude8b]|\ud801\udd6f|\ud82f\udc9f|\ud804[\udc47-\udc4d\udcbb\udcbc\udcbe-\udcc1\udd40-\udd43\udd74\udd75\uddc5-\uddc9\uddcd\udddb\udddd-\udddf\ude38-\ude3d\udea9]|\ud800[\udd00-\udd02\udf9f\udfd0]|\ud81a[\ude6e\ude6f\udef5\udf37-\udf3b\udf44]"
                }, {
                    name: "Pc",
                    alias: "Connector_Punctuation",
                    bmp: "_‿⁀⁔︳︴﹍-﹏＿"
                }, {
                    name: "Pd",
                    alias: "Dash_Punctuation",
                    bmp: "\\x2D֊־᐀᠆‐-―⸗⸚⸺⸻⹀〜〰゠︱︲﹘﹣－"
                }, {
                    name: "Pe",
                    alias: "Close_Punctuation",
                    bmp: "\\x29\\x5D}༻༽᚜⁆⁾₎⌉⌋〉❩❫❭❯❱❳❵⟆⟧⟩⟫⟭⟯⦄⦆⦈⦊⦌⦎⦐⦒⦔⦖⦘⧙⧛⧽⸣⸥⸧⸩〉》」』】〕〗〙〛〞〟﴾︘︶︸︺︼︾﹀﹂﹄﹈﹚﹜﹞）］｝｠｣"
                }, {
                    name: "Pf",
                    alias: "Final_Punctuation",
                    bmp: "»’”›⸃⸅⸊⸍⸝⸡"
                }, {
                    name: "Pi",
                    alias: "Initial_Punctuation",
                    bmp: "«‘‛“‟‹⸂⸄⸉⸌⸜⸠"
                }, {
                    name: "Po",
                    alias: "Other_Punctuation",
                    bmp: "!-#%-'\\x2A,\\x2E/:;\\x3F@\\x5C¡§¶·¿;·՚-՟։׀׃׆׳״؉؊،؍؛؞؟٪-٭۔܀-܍߷-߹࠰-࠾࡞।॥॰૰෴๏๚๛༄-༒༔྅࿐-࿔࿙࿚၊-၏჻፠-፨᙭᙮᛫-᛭᜵᜶។-៖៘-៚᠀-᠅᠇-᠊᥄᥅᨞᨟᪠-᪦᪨-᪭᭚-᭠᯼-᯿᰻-᰿᱾᱿᳀-᳇᳓‖‗†-‧‰-‸※-‾⁁-⁃⁇-⁑⁓⁕-⁞⳹-⳼⳾⳿⵰⸀⸁⸆-⸈⸋⸎-⸖⸘⸙⸛⸞⸟⸪-⸮⸰-⸹⸼-⸿⹁、-〃〽・꓾꓿꘍-꘏꙳꙾꛲-꛷꡴-꡷꣎꣏꣸-꣺꣼꤮꤯꥟꧁-꧍꧞꧟꩜-꩟꫞꫟꫰꫱꯫︐-︖︙︰﹅﹆﹉-﹌﹐-﹒﹔-﹗﹟-﹡﹨﹪﹫！-＃％-＇＊，．／：；？＠＼｡､･",
                    astral: "\ud802[\udc57\udd1f\udd3f\ude50-\ude58\ude7f\udef0-\udef6\udf39-\udf3f\udf99-\udf9c]|\ud809[\udc70-\udc74]|\ud805[\udcc6\uddc1-\uddd7\ude41-\ude43\udf3c-\udf3e]|\ud836[\ude87-\ude8b]|\ud801\udd6f|\ud82f\udc9f|\ud804[\udc47-\udc4d\udcbb\udcbc\udcbe-\udcc1\udd40-\udd43\udd74\udd75\uddc5-\uddc9\uddcd\udddb\udddd-\udddf\ude38-\ude3d\udea9]|\ud800[\udd00-\udd02\udf9f\udfd0]|\ud81a[\ude6e\ude6f\udef5\udf37-\udf3b\udf44]"
                }, {
                    name: "Ps",
                    alias: "Open_Punctuation",
                    bmp: "\\x28\\x5B\\x7B༺༼᚛‚„⁅⁽₍⌈⌊〈❨❪❬❮❰❲❴⟅⟦⟨⟪⟬⟮⦃⦅⦇⦉⦋⦍⦏⦑⦓⦕⦗⧘⧚⧼⸢⸤⸦⸨⹂〈《「『【〔〖〘〚〝﴿︗︵︷︹︻︽︿﹁﹃﹇﹙﹛﹝（［｛｟｢"
                }, {
                    name: "S",
                    alias: "Symbol",
                    bmp: "\\x24\\x2B<->\\x5E`\\x7C~¢-¦¨©¬®-±´¸×÷˂-˅˒-˟˥-˫˭˯-˿͵΄΅϶҂֍-֏؆-؈؋؎؏۞۩۽۾߶৲৳৺৻૱୰௳-௺౿൹฿༁-༃༓༕-༗༚-༟༴༶༸྾-࿅࿇-࿌࿎࿏࿕-࿘႞႟᎐-᎙៛᥀᧞-᧿᭡-᭪᭴-᭼᾽᾿-῁῍-῏῝-῟῭-`´῾⁄⁒⁺-⁼₊-₌₠-₾℀℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊↋←-⌇⌌-⌨⌫-⏺␀-␦⑀-⑊⒜-ⓩ─-❧➔-⟄⟇-⟥⟰-⦂⦙-⧗⧜-⧻⧾-⭳⭶-⮕⮘-⮹⮽-⯈⯊-⯑⯬-⯯⳥-⳪⺀-⺙⺛-⻳⼀-⿕⿰-⿻〄〒〓〠〶〷〾〿゛゜㆐㆑㆖-㆟㇀-㇣㈀-㈞㈪-㉇㉐㉠-㉿㊊-㊰㋀-㋾㌀-㏿䷀-䷿꒐-꓆꜀-꜖꜠꜡꞉꞊꠨-꠫꠶-꠹꩷-꩹꭛﬩﮲-﯁﷼﷽﹢﹤-﹦﹩＄＋＜-＞＾｀｜～￠-￦￨-￮￼�",
                    astral: "\ud83e[\udc00-\udc0b\udc10-\udc47\udc50-\udc59\udc60-\udc87\udc90-\udcad\udd10-\udd18\udd80-\udd84\uddc0]|\ud83c[\udc00-\udc2b\udc30-\udc93\udca0-\udcae\udcb1-\udcbf\udcc1-\udccf\udcd1-\udcf5\udd10-\udd2e\udd30-\udd6b\udd70-\udd9a\udde6-\ude02\ude10-\ude3a\ude40-\ude48\ude50\ude51\udf00-\udfff]|\ud83d[\udc00-\udd79\udd7b-\udda3\udda5-\uded0\udee0-\udeec\udef0-\udef3\udf00-\udf73\udf80-\udfd4]|\ud835[\udec1\udedb\udefb\udf15\udf35\udf4f\udf6f\udf89\udfa9\udfc3]|\ud800[\udd37-\udd3f\udd79-\udd89\udd8c\udd90-\udd9b\udda0\uddd0-\uddfc]|\ud82f\udc9c|\ud805\udf3f|\ud802[\udc77\udc78\udec8]|\ud81a[\udf3c-\udf3f\udf45]|\ud836[\udc00-\uddff\ude37-\ude3a\ude6d-\ude74\ude76-\ude83\ude85\ude86]|\ud834[\udc00-\udcf5\udd00-\udd26\udd29-\udd64\udd6a-\udd6c\udd83\udd84\udd8c-\udda9\uddae-\udde8\ude00-\ude41\ude45\udf00-\udf56]|\ud83b[\udef0\udef1]"
                }, {
                    name: "Sc",
                    alias: "Currency_Symbol",
                    bmp: "\\x24¢-¥֏؋৲৳৻૱௹฿៛₠-₾꠸﷼﹩＄￠￡￥￦"
                }, {
                    name: "Sk",
                    alias: "Modifier_Symbol",
                    bmp: "\\x5E`¨¯´¸˂-˅˒-˟˥-˫˭˯-˿͵΄΅᾽᾿-῁῍-῏῝-῟῭-`´῾゛゜꜀-꜖꜠꜡꞉꞊꭛﮲-﯁＾｀￣",
                    astral: "\ud83c[\udffb-\udfff]"
                }, {
                    name: "Sm",
                    alias: "Math_Symbol",
                    bmp: "\\x2B<->\\x7C~¬±×÷϶؆-؈⁄⁒⁺-⁼₊-₌℘⅀-⅄⅋←-↔↚↛↠↣↦↮⇎⇏⇒⇔⇴-⋿⌠⌡⍼⎛-⎳⏜-⏡▷◁◸-◿♯⟀-⟄⟇-⟥⟰-⟿⤀-⦂⦙-⧗⧜-⧻⧾-⫿⬰-⭄⭇-⭌﬩﹢﹤-﹦＋＜-＞｜～￢￩-￬",
                    astral: "\ud83b[\udef0\udef1]|\ud835[\udec1\udedb\udefb\udf15\udf35\udf4f\udf6f\udf89\udfa9\udfc3]"
                }, {
                    name: "So",
                    alias: "Other_Symbol",
                    bmp: "¦©®°҂֍֎؎؏۞۩۽۾߶৺୰௳-௸௺౿൹༁-༃༓༕-༗༚-༟༴༶༸྾-࿅࿇-࿌࿎࿏࿕-࿘႞႟᎐-᎙᥀᧞-᧿᭡-᭪᭴-᭼℀℁℃-℆℈℉℔№℗℞-℣℥℧℩℮℺℻⅊⅌⅍⅏↊↋↕-↙↜-↟↡↢↤↥↧-↭↯-⇍⇐⇑⇓⇕-⇳⌀-⌇⌌-⌟⌢-⌨⌫-⍻⍽-⎚⎴-⏛⏢-⏺␀-␦⑀-⑊⒜-ⓩ─-▶▸-◀◂-◷☀-♮♰-❧➔-➿⠀-⣿⬀-⬯⭅⭆⭍-⭳⭶-⮕⮘-⮹⮽-⯈⯊-⯑⯬-⯯⳥-⳪⺀-⺙⺛-⻳⼀-⿕⿰-⿻〄〒〓〠〶〷〾〿㆐㆑㆖-㆟㇀-㇣㈀-㈞㈪-㉇㉐㉠-㉿㊊-㊰㋀-㋾㌀-㏿䷀-䷿꒐-꓆꠨-꠫꠶꠷꠹꩷-꩹﷽￤￨￭￮￼�",
                    astral: "\ud83e[\udc00-\udc0b\udc10-\udc47\udc50-\udc59\udc60-\udc87\udc90-\udcad\udd10-\udd18\udd80-\udd84\uddc0]|\ud83d[\udc00-\udd79\udd7b-\udda3\udda5-\uded0\udee0-\udeec\udef0-\udef3\udf00-\udf73\udf80-\udfd4]|\ud83c[\udc00-\udc2b\udc30-\udc93\udca0-\udcae\udcb1-\udcbf\udcc1-\udccf\udcd1-\udcf5\udd10-\udd2e\udd30-\udd6b\udd70-\udd9a\udde6-\ude02\ude10-\ude3a\ude40-\ude48\ude50\ude51\udf00-\udffa]|\ud800[\udd37-\udd3f\udd79-\udd89\udd8c\udd90-\udd9b\udda0\uddd0-\uddfc]|\ud82f\udc9c|\ud805\udf3f|\ud802[\udc77\udc78\udec8]|\ud81a[\udf3c-\udf3f\udf45]|\ud836[\udc00-\uddff\ude37-\ude3a\ude6d-\ude74\ude76-\ude83\ude85\ude86]|\ud834[\udc00-\udcf5\udd00-\udd26\udd29-\udd64\udd6a-\udd6c\udd83\udd84\udd8c-\udda9\uddae-\udde8\ude00-\ude41\ude45\udf00-\udf56]"
                }, {
                    name: "Z",
                    alias: "Separator",
                    bmp: "    - \u2028\u2029  　"
                }, {
                    name: "Zl",
                    alias: "Line_Separator",
                    bmp: "\u2028"
                }, {
                    name: "Zp",
                    alias: "Paragraph_Separator",
                    bmp: "\u2029"
                }, {
                    name: "Zs",
                    alias: "Space_Separator",
                    bmp: "    -   　"
                }])
            }
        }, {}],
        6: [function(require, module, exports) {
            module.exports = function(XRegExp) {
                if (!XRegExp.addUnicodeData) throw new ReferenceError("Unicode Base must be loaded before Unicode Properties");
                var unicodeData = [{
                    name: "ASCII",
                    bmp: "\x00-"
                }, {
                    name: "Alphabetic",
                    bmp: "A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͅͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևְ-ׇֽֿׁׂׅׄא-תװ-ײؐ-ؚؠ-ٗٙ-ٟٮ-ۓە-ۜۡ-ۭۨ-ۯۺ-ۼۿܐ-ܿݍ-ޱߊ-ߪߴߵߺࠀ-ࠗࠚ-ࠬࡀ-ࡘࢠ-ࢴࣣ-ࣰࣩ-ऻऽ-ौॎ-ॐॕ-ॣॱ-ঃঅ-ঌএঐও-নপ-রলশ-হঽ-ৄেৈোৌৎৗড়ঢ়য়-ৣৰৱਁ-ਃਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਾ-ੂੇੈੋੌੑਖ਼-ੜਫ਼ੰ-ੵઁ-ઃઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽ-ૅે-ૉોૌૐૠ-ૣૹଁ-ଃଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽ-ୄେୈୋୌୖୗଡ଼ଢ଼ୟ-ୣୱஂஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹா-ூெ-ைொ-ௌௐௗఀ-ఃఅ-ఌఎ-ఐఒ-నప-హఽ-ౄె-ైొ-ౌౕౖౘ-ౚౠ-ౣಁ-ಃಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽ-ೄೆ-ೈೊ-ೌೕೖೞೠ-ೣೱೲഁ-ഃഅ-ഌഎ-ഐഒ-ഺഽ-ൄെ-ൈൊ-ൌൎൗൟ-ൣൺ-ൿංඃඅ-ඖක-නඳ-රලව-ෆා-ුූෘ-ෟෲෳก-ฺเ-ๆํກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ູົ-ຽເ-ໄໆໍໜ-ໟༀཀ-ཇཉ-ཬཱ-ཱྀྈ-ྗྙ-ྼက-ံးျ-ဿၐ-ၢၥ-ၨၮ-ႆႎႜႝႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚ፟ᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜓᜠ-ᜳᝀ-ᝓᝠ-ᝬᝮ-ᝰᝲᝳក-ឳា-ៈៗៜᠠ-ᡷᢀ-ᢪᢰ-ᣵᤀ-ᤞᤠ-ᤫᤰ-ᤸᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨛᨠ-ᩞᩡ-ᩴᪧᬀ-ᬳᬵ-ᭃᭅ-ᭋᮀ-ᮩᮬ-ᮯᮺ-ᯥᯧ-ᯱᰀ-ᰵᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳳᳵᳶᴀ-ᶿᷧ-ᷴḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⒶ-ⓩⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⷠ-ⷿⸯ々-〇〡-〩〱-〵〸-〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿕ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙴ-ꙻꙿ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞭꞰ-ꞷꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠧꡀ-ꡳꢀ-ꣃꣲ-ꣷꣻꣽꤊ-ꤪꤰ-ꥒꥠ-ꥼꦀ-ꦲꦴ-ꦿꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨶꩀ-ꩍꩠ-ꩶꩺꩾ-ꪾꫀꫂꫛ-ꫝꫠ-ꫯꫲ-ꫵꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭥꭰ-ꯪ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
                    astral: "\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud804[\udc00-\udc45\udc82-\udcb8\udcd0-\udce8\udd00-\udd32\udd50-\udd72\udd76\udd80-\uddbf\uddc1-\uddc4\uddda\udddc\ude00-\ude11\ude13-\ude34\ude37\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udee8\udf00-\udf03\udf05-\udf0c\udf0f\udf10\udf13-\udf28\udf2a-\udf30\udf32\udf33\udf35-\udf39\udf3d-\udf44\udf47\udf48\udf4b\udf4c\udf50\udf57\udf5d-\udf63]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2]|\ud83a[\udc00-\udcc4]|\ud81a[\udc00-\ude38\ude40-\ude5e\uded0-\udeed\udf00-\udf36\udf40-\udf43\udf63-\udf77\udf7d-\udf8f]|\ud801[\udc00-\udc9d\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud83c[\udd30-\udd49\udd50-\udd69\udd70-\udd89]|\ud80d[\udc00-\udc2e]|\ud87e[\udc00-\ude1d]|[\ud80c\ud840-\ud868\ud86a-\ud86c\ud86f-\ud872][\udc00-\udfff]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e\udc9f\udca2\udca5\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99\udc9e]|\ud808[\udc00-\udf99]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud805[\udc80-\udcc1\udcc4\udcc5\udcc7\udd80-\uddb5\uddb8-\uddbe\uddd8-\udddd\ude00-\ude3e\ude40\ude44\ude80-\udeb5\udf00-\udf19\udf1d-\udf2a]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud806[\udca0-\udcdf\udcff\udec0-\udef8]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\ude80-\ude9c\udea0-\uded0\udf00-\udf1f\udf30-\udf4a\udf50-\udf7a\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe\uddbf\ude00-\ude03\ude05\ude06\ude0c-\ude13\ude15-\ude17\ude19-\ude33\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee4\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud811[\udc00-\ude46]|\ud82c[\udc00\udc01]|\ud81b[\udf00-\udf44\udf50-\udf7e\udf93-\udf9f]|\ud873[\udc00-\udea1]"
                }, {
                    name: "Any",
                    isBmpLast: true,
                    bmp: "\x00-￿",
                    astral: "[\ud800-\udbff][\udc00-\udfff]"
                }, {
                    name: "Default_Ignorable_Code_Point",
                    bmp: "­͏؜ᅟᅠ឴឵᠋-᠎​-‏‪-‮⁠-⁯ㅤ︀-️﻿ﾠ￰-￸",
                    astral: "[\udb40-\udb43][\udc00-\udfff]|\ud834[\udd73-\udd7a]|\ud82f[\udca0-\udca3]"
                }, {
                    name: "Lowercase",
                    bmp: "a-zªµºß-öø-ÿāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĳĵķĸĺļľŀłńņňŉŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷźżž-ƀƃƅƈƌƍƒƕƙ-ƛƞơƣƥƨƪƫƭưƴƶƹƺƽ-ƿǆǉǌǎǐǒǔǖǘǚǜǝǟǡǣǥǧǩǫǭǯǰǳǵǹǻǽǿȁȃȅȇȉȋȍȏȑȓȕȗșțȝȟȡȣȥȧȩȫȭȯȱȳ-ȹȼȿɀɂɇɉɋɍɏ-ʓʕ-ʸˀˁˠ-ˤͅͱͳͷͺ-ͽΐά-ώϐϑϕ-ϗϙϛϝϟϡϣϥϧϩϫϭϯ-ϳϵϸϻϼа-џѡѣѥѧѩѫѭѯѱѳѵѷѹѻѽѿҁҋҍҏґғҕҗҙқҝҟҡңҥҧҩҫҭүұҳҵҷҹһҽҿӂӄӆӈӊӌӎӏӑӓӕӗәӛӝӟӡӣӥӧөӫӭӯӱӳӵӷӹӻӽӿԁԃԅԇԉԋԍԏԑԓԕԗԙԛԝԟԡԣԥԧԩԫԭԯա-ևᏸ-ᏽᴀ-ᶿḁḃḅḇḉḋḍḏḑḓḕḗḙḛḝḟḡḣḥḧḩḫḭḯḱḳḵḷḹḻḽḿṁṃṅṇṉṋṍṏṑṓṕṗṙṛṝṟṡṣṥṧṩṫṭṯṱṳṵṷṹṻṽṿẁẃẅẇẉẋẍẏẑẓẕ-ẝẟạảấầẩẫậắằẳẵặẹẻẽếềểễệỉịọỏốồổỗộớờởỡợụủứừửữựỳỵỷỹỻỽỿ-ἇἐ-ἕἠ-ἧἰ-ἷὀ-ὅὐ-ὗὠ-ὧὰ-ώᾀ-ᾇᾐ-ᾗᾠ-ᾧᾰ-ᾴᾶᾷιῂ-ῄῆῇῐ-ΐῖῗῠ-ῧῲ-ῴῶῷⁱⁿₐ-ₜℊℎℏℓℯℴℹℼℽⅆ-ⅉⅎⅰ-ⅿↄⓐ-ⓩⰰ-ⱞⱡⱥⱦⱨⱪⱬⱱⱳⱴⱶ-ⱽⲁⲃⲅⲇⲉⲋⲍⲏⲑⲓⲕⲗⲙⲛⲝⲟⲡⲣⲥⲧⲩⲫⲭⲯⲱⲳⲵⲷⲹⲻⲽⲿⳁⳃⳅⳇⳉⳋⳍⳏⳑⳓⳕⳗⳙⳛⳝⳟⳡⳣⳤⳬⳮⳳⴀ-ⴥⴧⴭꙁꙃꙅꙇꙉꙋꙍꙏꙑꙓꙕꙗꙙꙛꙝꙟꙡꙣꙥꙧꙩꙫꙭꚁꚃꚅꚇꚉꚋꚍꚏꚑꚓꚕꚗꚙꚛ-ꚝꜣꜥꜧꜩꜫꜭꜯ-ꜱꜳꜵꜷꜹꜻꜽꜿꝁꝃꝅꝇꝉꝋꝍꝏꝑꝓꝕꝗꝙꝛꝝꝟꝡꝣꝥꝧꝩꝫꝭꝯ-ꝸꝺꝼꝿꞁꞃꞅꞇꞌꞎꞑꞓ-ꞕꞗꞙꞛꞝꞟꞡꞣꞥꞧꞩꞵꞷꟸ-ꟺꬰ-ꭚꭜ-ꭥꭰ-ꮿﬀ-ﬆﬓ-ﬗａ-ｚ",
                    astral: "\ud803[\udcc0-\udcf2]|\ud835[\udc1a-\udc33\udc4e-\udc54\udc56-\udc67\udc82-\udc9b\udcb6-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udccf\udcea-\udd03\udd1e-\udd37\udd52-\udd6b\udd86-\udd9f\uddba-\uddd3\uddee-\ude07\ude22-\ude3b\ude56-\ude6f\ude8a-\udea5\udec2-\udeda\udedc-\udee1\udefc-\udf14\udf16-\udf1b\udf36-\udf4e\udf50-\udf55\udf70-\udf88\udf8a-\udf8f\udfaa-\udfc2\udfc4-\udfc9\udfcb]|\ud801[\udc28-\udc4f]|\ud806[\udcc0-\udcdf]"
                }, {
                    name: "Noncharacter_Code_Point",
                    bmp: "﷐-﷯￾￿",
                    astral: "[\udb3f\udb7f\udbbf\udbff\ud83f\ud87f\ud8bf\udaff\ud97f\ud9bf\ud9ff\uda3f\ud8ff\udabf\uda7f\ud93f][\udffe\udfff]"
                }, {
                    name: "Uppercase",
                    bmp: "A-ZÀ-ÖØ-ÞĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮİĲĴĶĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸŹŻŽƁƂƄƆƇƉ-ƋƎ-ƑƓƔƖ-ƘƜƝƟƠƢƤƦƧƩƬƮƯƱ-ƳƵƷƸƼǄǇǊǍǏǑǓǕǗǙǛǞǠǢǤǦǨǪǬǮǱǴǶ-ǸǺǼǾȀȂȄȆȈȊȌȎȐȒȔȖȘȚȜȞȠȢȤȦȨȪȬȮȰȲȺȻȽȾɁɃ-ɆɈɊɌɎͰͲͶͿΆΈ-ΊΌΎΏΑ-ΡΣ-ΫϏϒ-ϔϘϚϜϞϠϢϤϦϨϪϬϮϴϷϹϺϽ-ЯѠѢѤѦѨѪѬѮѰѲѴѶѸѺѼѾҀҊҌҎҐҒҔҖҘҚҜҞҠҢҤҦҨҪҬҮҰҲҴҶҸҺҼҾӀӁӃӅӇӉӋӍӐӒӔӖӘӚӜӞӠӢӤӦӨӪӬӮӰӲӴӶӸӺӼӾԀԂԄԆԈԊԌԎԐԒԔԖԘԚԜԞԠԢԤԦԨԪԬԮԱ-ՖႠ-ჅჇჍᎠ-ᏵḀḂḄḆḈḊḌḎḐḒḔḖḘḚḜḞḠḢḤḦḨḪḬḮḰḲḴḶḸḺḼḾṀṂṄṆṈṊṌṎṐṒṔṖṘṚṜṞṠṢṤṦṨṪṬṮṰṲṴṶṸṺṼṾẀẂẄẆẈẊẌẎẐẒẔẞẠẢẤẦẨẪẬẮẰẲẴẶẸẺẼẾỀỂỄỆỈỊỌỎỐỒỔỖỘỚỜỞỠỢỤỦỨỪỬỮỰỲỴỶỸỺỼỾἈ-ἏἘ-ἝἨ-ἯἸ-ἿὈ-ὍὙὛὝὟὨ-ὯᾸ-ΆῈ-ΉῘ-ΊῨ-ῬῸ-Ώℂℇℋ-ℍℐ-ℒℕℙ-ℝℤΩℨK-ℭℰ-ℳℾℿⅅⅠ-ⅯↃⒶ-ⓏⰀ-ⰮⱠⱢ-ⱤⱧⱩⱫⱭ-ⱰⱲⱵⱾ-ⲀⲂⲄⲆⲈⲊⲌⲎⲐⲒⲔⲖⲘⲚⲜⲞⲠⲢⲤⲦⲨⲪⲬⲮⲰⲲⲴⲶⲸⲺⲼⲾⳀⳂⳄⳆⳈⳊⳌⳎⳐⳒⳔⳖⳘⳚⳜⳞⳠⳢⳫⳭⳲꙀꙂꙄꙆꙈꙊꙌꙎꙐꙒꙔꙖꙘꙚꙜꙞꙠꙢꙤꙦꙨꙪꙬꚀꚂꚄꚆꚈꚊꚌꚎꚐꚒꚔꚖꚘꚚꜢꜤꜦꜨꜪꜬꜮꜲꜴꜶꜸꜺꜼꜾꝀꝂꝄꝆꝈꝊꝌꝎꝐꝒꝔꝖꝘꝚꝜꝞꝠꝢꝤꝦꝨꝪꝬꝮꝹꝻꝽꝾꞀꞂꞄꞆꞋꞍꞐꞒꞖꞘꞚꞜꞞꞠꞢꞤꞦꞨꞪ-ꞭꞰ-ꞴꞶＡ-Ｚ",
                    astral: "\ud806[\udca0-\udcbf]|\ud803[\udc80-\udcb2]|\ud835[\udc00-\udc19\udc34-\udc4d\udc68-\udc81\udc9c\udc9e\udc9f\udca2\udca5\udca6\udca9-\udcac\udcae-\udcb5\udcd0-\udce9\udd04\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd38\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd6c-\udd85\udda0-\uddb9\uddd4-\udded\ude08-\ude21\ude3c-\ude55\ude70-\ude89\udea8-\udec0\udee2-\udefa\udf1c-\udf34\udf56-\udf6e\udf90-\udfa8\udfca]|\ud801[\udc00-\udc27]|\ud83c[\udd30-\udd49\udd50-\udd69\udd70-\udd89]"
                }, {
                    name: "White_Space",
                    bmp: "\t-\r    - \u2028\u2029  　"
                }];
                unicodeData.push({
                    name: "Assigned",
                    inverseOf: "Cn"
                });
                XRegExp.addUnicodeData(unicodeData)
            }
        }, {}],
        7: [function(require, module, exports) {
            module.exports = function(XRegExp) {
                if (!XRegExp.addUnicodeData) throw new ReferenceError("Unicode Base must be loaded before Unicode Scripts");
                XRegExp.addUnicodeData([{
                    name: "Ahom",
                    astral: "\ud805[\udf00-\udf19\udf1d-\udf2b\udf30-\udf3f]"
                }, {
                    name: "Anatolian_Hieroglyphs",
                    astral: "\ud811[\udc00-\ude46]"
                }, {
                    name: "Arabic",
                    bmp: "؀-؄؆-؋؍-ؚ؞ؠ-ؿف-يٖ-ٯٱ-ۜ۞-ۿݐ-ݿࢠ-ࢴࣣ-ࣿﭐ-﯁ﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-﷽ﹰ-ﹴﹶ-ﻼ",
                    astral: "\ud803[\ude60-\ude7e]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb\udef0\udef1]"
                }, {
                    name: "Armenian",
                    bmp: "Ա-Ֆՙ-՟ա-և֊֍-֏ﬓ-ﬗ"
                }, {
                    name: "Avestan",
                    astral: "\ud802[\udf00-\udf35\udf39-\udf3f]"
                }, {
                    name: "Balinese",
                    bmp: "ᬀ-ᭋ᭐-᭼"
                }, {
                    name: "Bamum",
                    bmp: "ꚠ-꛷",
                    astral: "\ud81a[\udc00-\ude38]"
                }, {
                    name: "Bassa_Vah",
                    astral: "\ud81a[\uded0-\udeed\udef0-\udef5]"
                }, {
                    name: "Batak",
                    bmp: "ᯀ-᯳᯼-᯿"
                }, {
                    name: "Bengali",
                    bmp: "ঀ-ঃঅ-ঌএঐও-নপ-রলশ-হ়-ৄেৈো-ৎৗড়ঢ়য়-ৣ০-৻"
                }, {
                    name: "Bopomofo",
                    bmp: "˪˫ㄅ-ㄭㆠ-ㆺ"
                }, {
                    name: "Brahmi",
                    astral: "\ud804[\udc00-\udc4d\udc52-\udc6f\udc7f]"
                }, {
                    name: "Braille",
                    bmp: "⠀-⣿"
                }, {
                    name: "Buginese",
                    bmp: "ᨀ-ᨛ᨞᨟"
                }, {
                    name: "Buhid",
                    bmp: "ᝀ-ᝓ"
                }, {
                    name: "Canadian_Aboriginal",
                    bmp: "᐀-ᙿᢰ-ᣵ"
                }, {
                    name: "Carian",
                    astral: "\ud800[\udea0-\uded0]"
                }, {
                    name: "Caucasian_Albanian",
                    astral: "\ud801[\udd30-\udd63\udd6f]"
                }, {
                    name: "Chakma",
                    astral: "\ud804[\udd00-\udd34\udd36-\udd43]"
                }, {
                    name: "Cham",
                    bmp: "ꨀ-ꨶꩀ-ꩍ꩐-꩙꩜-꩟"
                }, {
                    name: "Cherokee",
                    bmp: "Ꭰ-Ᏽᏸ-ᏽꭰ-ꮿ"
                }, {
                    name: "Common",
                    bmp: "\x00-@\\x5B-`\\x7B-©«-¹»-¿×÷ʹ-˟˥-˩ˬ-˿ʹ;΅·։؅،؛؜؟ـ۝।॥฿࿕-࿘჻᛫-᛭᜵᜶᠂᠃᠅᳓᳡ᳩ-ᳬᳮ-ᳳᳵᳶ -​‎-⁤⁦-⁰⁴-⁾₀-₎₠-₾℀-℥℧-℩ℬ-ℱℳ-⅍⅏-⅟↉-↋←-⏺␀-␦⑀-⑊①-⟿⤀-⭳⭶-⮕⮘-⮹⮽-⯈⯊-⯑⯬-⯯⸀-⹂⿰-⿻　-〄〆〈-〠〰-〷〼-〿゛゜゠・ー㆐-㆟㇀-㇣㈠-㉟㉿-㋏㍘-㏿䷀-䷿꜀-꜡ꞈ-꞊꠰-꠹꤮ꧏ꭛﴾﴿︐-︙︰-﹒﹔-﹦﹨-﹫﻿！-＠［-｀｛-･ｰﾞﾟ￠-￦￨-￮￹-�",
                    astral: "\ud83e[\udc00-\udc0b\udc10-\udc47\udc50-\udc59\udc60-\udc87\udc90-\udcad\udd10-\udd18\udd80-\udd84\uddc0]|\ud82f[\udca0-\udca3]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e\udc9f\udca2\udca5\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udfcb\udfce-\udfff]|\udb40[\udc01\udc20-\udc7f]|\ud83d[\udc00-\udd79\udd7b-\udda3\udda5-\uded0\udee0-\udeec\udef0-\udef3\udf00-\udf73\udf80-\udfd4]|\ud800[\udd00-\udd02\udd07-\udd33\udd37-\udd3f\udd90-\udd9b\uddd0-\uddfc\udee1-\udefb]|\ud834[\udc00-\udcf5\udd00-\udd26\udd29-\udd66\udd6a-\udd7a\udd83\udd84\udd8c-\udda9\uddae-\udde8\udf00-\udf56\udf60-\udf71]|\ud83c[\udc00-\udc2b\udc30-\udc93\udca0-\udcae\udcb1-\udcbf\udcc1-\udccf\udcd1-\udcf5\udd00-\udd0c\udd10-\udd2e\udd30-\udd6b\udd70-\udd9a\udde6-\uddff\ude01\ude02\ude10-\ude3a\ude40-\ude48\ude50\ude51\udf00-\udfff]"
                }, {
                    name: "Coptic",
                    bmp: "Ϣ-ϯⲀ-ⳳ⳹-⳿"
                }, {
                    name: "Cuneiform",
                    astral: "\ud809[\udc00-\udc6e\udc70-\udc74\udc80-\udd43]|\ud808[\udc00-\udf99]"
                }, {
                    name: "Cypriot",
                    astral: "\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37\udc38\udc3c\udc3f]"
                }, {
                    name: "Cyrillic",
                    bmp: "Ѐ-҄҇-ԯᴫᵸⷠ-ⷿꙀ-ꚟ︮︯"
                }, {
                    name: "Deseret",
                    astral: "\ud801[\udc00-\udc4f]"
                }, {
                    name: "Devanagari",
                    bmp: "ऀ-ॐ॓-ॣ०-ॿ꣠-ꣽ"
                }, {
                    name: "Duployan",
                    astral: "\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99\udc9c-\udc9f]"
                }, {
                    name: "Egyptian_Hieroglyphs",
                    astral: "\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]"
                }, {
                    name: "Elbasan",
                    astral: "\ud801[\udd00-\udd27]"
                }, {
                    name: "Ethiopic",
                    bmp: "ሀ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚ፝-፼ᎀ-᎙ⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮ"
                }, {
                    name: "Georgian",
                    bmp: "Ⴀ-ჅჇჍა-ჺჼ-ჿⴀ-ⴥⴧⴭ"
                }, {
                    name: "Glagolitic",
                    bmp: "Ⰰ-Ⱞⰰ-ⱞ"
                }, {
                    name: "Gothic",
                    astral: "\ud800[\udf30-\udf4a]"
                }, {
                    name: "Grantha",
                    astral: "\ud804[\udf00-\udf03\udf05-\udf0c\udf0f\udf10\udf13-\udf28\udf2a-\udf30\udf32\udf33\udf35-\udf39\udf3c-\udf44\udf47\udf48\udf4b-\udf4d\udf50\udf57\udf5d-\udf63\udf66-\udf6c\udf70-\udf74]"
                }, {
                    name: "Greek",
                    bmp: "Ͱ-ͳ͵-ͷͺ-ͽͿ΄ΆΈ-ΊΌΎ-ΡΣ-ϡϰ-Ͽᴦ-ᴪᵝ-ᵡᵦ-ᵪᶿἀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ῄῆ-ΐῖ-Ί῝-`ῲ-ῴῶ-῾Ωꭥ",
                    astral: "\ud800[\udd40-\udd8c\udda0]|\ud834[\ude00-\ude45]"
                }, {
                    name: "Gujarati",
                    bmp: "ઁ-ઃઅ-ઍએ-ઑઓ-નપ-રલળવ-હ઼-ૅે-ૉો-્ૐૠ-ૣ૦-૱ૹ"
                }, {
                    name: "Gurmukhi",
                    bmp: "ਁ-ਃਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹ਼ਾ-ੂੇੈੋ-੍ੑਖ਼-ੜਫ਼੦-ੵ"
                }, {
                    name: "Han",
                    bmp: "⺀-⺙⺛-⻳⼀-⿕々〇〡-〩〸-〻㐀-䶵一-鿕豈-舘並-龎",
                    astral: "\ud86e[\udc00-\udc1d\udc20-\udfff]|[\ud840-\ud868\ud86a-\ud86c\ud86f-\ud872][\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud87e[\udc00-\ude1d]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud873[\udc00-\udea1]"
                }, {
                    name: "Hangul",
                    bmp: "ᄀ-ᇿ〮〯ㄱ-ㆎ㈀-㈞㉠-㉾ꥠ-ꥼ가-힣ힰ-ퟆퟋ-ퟻﾠ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ"
                }, {
                    name: "Hanunoo",
                    bmp: "ᜠ-᜴"
                }, {
                    name: "Hatran",
                    astral: "\ud802[\udce0-\udcf2\udcf4\udcf5\udcfb-\udcff]"
                }, {
                    name: "Hebrew",
                    bmp: "֑-ׇא-תװ-״יִ-זּטּ-לּמּנּסּףּפּצּ-ﭏ"
                }, {
                    name: "Hiragana",
                    bmp: "ぁ-ゖゝ-ゟ",
                    astral: "\ud82c\udc01|\ud83c\ude00"
                }, {
                    name: "Imperial_Aramaic",
                    astral: "\ud802[\udc40-\udc55\udc57-\udc5f]"
                }, {
                    name: "Inherited",
                    bmp: "̀-ًͯ҅҆-ٰٕ॒॑᪰-᪾᳐-᳔᳒-᳢᳠-᳨᳭᳴᳸᳹᷀-᷵᷼-᷿‌‍⃐-〪⃰-゙゚〭︀-️︠-︭",
                    astral: "\ud834[\udd67-\udd69\udd7b-\udd82\udd85-\udd8b\uddaa-\uddad]|\ud800[\uddfd\udee0]|\udb40[\udd00-\uddef]"
                }, {
                    name: "Inscriptional_Pahlavi",
                    astral: "\ud802[\udf60-\udf72\udf78-\udf7f]"
                }, {
                    name: "Inscriptional_Parthian",
                    astral: "\ud802[\udf40-\udf55\udf58-\udf5f]"
                }, {
                    name: "Javanese",
                    bmp: "ꦀ-꧍꧐-꧙꧞꧟"
                }, {
                    name: "Kaithi",
                    astral: "\ud804[\udc80-\udcc1]"
                }, {
                    name: "Kannada",
                    bmp: "ಁ-ಃಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹ಼-ೄೆ-ೈೊ-್ೕೖೞೠ-ೣ೦-೯ೱೲ"
                }, {
                    name: "Katakana",
                    bmp: "ァ-ヺヽ-ヿㇰ-ㇿ㋐-㋾㌀-㍗ｦ-ｯｱ-ﾝ",
                    astral: "\ud82c\udc00"
                }, {
                    name: "Kayah_Li",
                    bmp: "꤀-꤭꤯"
                }, {
                    name: "Kharoshthi",
                    astral: "\ud802[\ude00-\ude03\ude05\ude06\ude0c-\ude13\ude15-\ude17\ude19-\ude33\ude38-\ude3a\ude3f-\ude47\ude50-\ude58]"
                }, {
                    name: "Khmer",
                    bmp: "ក-៝០-៩៰-៹᧠-᧿"
                }, {
                    name: "Khojki",
                    astral: "\ud804[\ude00-\ude11\ude13-\ude3d]"
                }, {
                    name: "Khudawadi",
                    astral: "\ud804[\udeb0-\udeea\udef0-\udef9]"
                }, {
                    name: "Lao",
                    bmp: "ກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ູົ-ຽເ-ໄໆ່-ໍ໐-໙ໜ-ໟ"
                }, {
                    name: "Latin",
                    bmp: "A-Za-zªºÀ-ÖØ-öø-ʸˠ-ˤᴀ-ᴥᴬ-ᵜᵢ-ᵥᵫ-ᵷᵹ-ᶾḀ-ỿⁱⁿₐ-ₜKÅℲⅎⅠ-ↈⱠ-ⱿꜢ-ꞇꞋ-ꞭꞰ-ꞷꟷ-ꟿꬰ-ꭚꭜ-ꭤﬀ-ﬆＡ-Ｚａ-ｚ"
                }, {
                    name: "Lepcha",
                    bmp: "ᰀ-᰷᰻-᱉ᱍ-ᱏ"
                }, {
                    name: "Limbu",
                    bmp: "ᤀ-ᤞᤠ-ᤫᤰ-᤻᥀᥄-᥏"
                }, {
                    name: "Linear_A",
                    astral: "\ud801[\ude00-\udf36\udf40-\udf55\udf60-\udf67]"
                }, {
                    name: "Linear_B",
                    astral: "\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa]"
                }, {
                    name: "Lisu",
                    bmp: "ꓐ-꓿"
                }, {
                    name: "Lycian",
                    astral: "\ud800[\ude80-\ude9c]"
                }, {
                    name: "Lydian",
                    astral: "\ud802[\udd20-\udd39\udd3f]"
                }, {
                    name: "Mahajani",
                    astral: "\ud804[\udd50-\udd76]"
                }, {
                    name: "Malayalam",
                    bmp: "ഁ-ഃഅ-ഌഎ-ഐഒ-ഺഽ-ൄെ-ൈൊ-ൎൗൟ-ൣ൦-൵൹-ൿ"
                }, {
                    name: "Mandaic",
                    bmp: "ࡀ-࡛࡞"
                }, {
                    name: "Manichaean",
                    astral: "\ud802[\udec0-\udee6\udeeb-\udef6]"
                }, {
                    name: "Meetei_Mayek",
                    bmp: "ꫠ-꫶ꯀ-꯭꯰-꯹"
                }, {
                    name: "Mende_Kikakui",
                    astral: "\ud83a[\udc00-\udcc4\udcc7-\udcd6]"
                }, {
                    name: "Meroitic_Cursive",
                    astral: "\ud802[\udda0-\uddb7\uddbc-\uddcf\uddd2-\uddff]"
                }, {
                    name: "Meroitic_Hieroglyphs",
                    astral: "\ud802[\udd80-\udd9f]"
                }, {
                    name: "Miao",
                    astral: "\ud81b[\udf00-\udf44\udf50-\udf7e\udf8f-\udf9f]"
                }, {
                    name: "Modi",
                    astral: "\ud805[\ude00-\ude44\ude50-\ude59]"
                }, {
                    name: "Mongolian",
                    bmp: "᠀᠁᠄᠆-᠎᠐-᠙ᠠ-ᡷᢀ-ᢪ"
                }, {
                    name: "Mro",
                    astral: "\ud81a[\ude40-\ude5e\ude60-\ude69\ude6e\ude6f]"
                }, {
                    name: "Multani",
                    astral: "\ud804[\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea9]"
                }, {
                    name: "Myanmar",
                    bmp: "က-႟ꧠ-ꧾꩠ-ꩿ"
                }, {
                    name: "Nabataean",
                    astral: "\ud802[\udc80-\udc9e\udca7-\udcaf]"
                }, {
                    name: "New_Tai_Lue",
                    bmp: "ᦀ-ᦫᦰ-ᧉ᧐-᧚᧞᧟"
                }, {
                    name: "Nko",
                    bmp: "߀-ߺ"
                }, {
                    name: "Ogham",
                    bmp: " -᚜"
                }, {
                    name: "Ol_Chiki",
                    bmp: "᱐-᱿"
                }, {
                    name: "Old_Hungarian",
                    astral: "\ud803[\udc80-\udcb2\udcc0-\udcf2\udcfa-\udcff]"
                }, {
                    name: "Old_Italic",
                    astral: "\ud800[\udf00-\udf23]"
                }, {
                    name: "Old_North_Arabian",
                    astral: "\ud802[\ude80-\ude9f]"
                }, {
                    name: "Old_Permic",
                    astral: "\ud800[\udf50-\udf7a]"
                }, {
                    name: "Old_Persian",
                    astral: "\ud800[\udfa0-\udfc3\udfc8-\udfd5]"
                }, {
                    name: "Old_South_Arabian",
                    astral: "\ud802[\ude60-\ude7f]"
                }, {
                    name: "Old_Turkic",
                    astral: "\ud803[\udc00-\udc48]"
                }, {
                    name: "Oriya",
                    bmp: "ଁ-ଃଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହ଼-ୄେୈୋ-୍ୖୗଡ଼ଢ଼ୟ-ୣ୦-୷"
                }, {
                    name: "Osmanya",
                    astral: "\ud801[\udc80-\udc9d\udca0-\udca9]"
                }, {
                    name: "Pahawh_Hmong",
                    astral: "\ud81a[\udf00-\udf45\udf50-\udf59\udf5b-\udf61\udf63-\udf77\udf7d-\udf8f]"
                }, {
                    name: "Palmyrene",
                    astral: "\ud802[\udc60-\udc7f]"
                }, {
                    name: "Pau_Cin_Hau",
                    astral: "\ud806[\udec0-\udef8]"
                }, {
                    name: "Phags_Pa",
                    bmp: "ꡀ-꡷"
                }, {
                    name: "Phoenician",
                    astral: "\ud802[\udd00-\udd1b\udd1f]"
                }, {
                    name: "Psalter_Pahlavi",
                    astral: "\ud802[\udf80-\udf91\udf99-\udf9c\udfa9-\udfaf]"
                }, {
                    name: "Rejang",
                    bmp: "ꤰ-꥓꥟"
                }, {
                    name: "Runic",
                    bmp: "ᚠ-ᛪᛮ-ᛸ"
                }, {
                    name: "Samaritan",
                    bmp: "ࠀ-࠭࠰-࠾"
                }, {
                    name: "Saurashtra",
                    bmp: "ꢀ-꣄꣎-꣙"
                }, {
                    name: "Sharada",
                    astral: "\ud804[\udd80-\uddcd\uddd0-\udddf]"
                }, {
                    name: "Shavian",
                    astral: "\ud801[\udc50-\udc7f]"
                }, {
                    name: "Siddham",
                    astral: "\ud805[\udd80-\uddb5\uddb8-\udddd]"
                }, {
                    name: "SignWriting",
                    astral: "\ud836[\udc00-\ude8b\ude9b-\ude9f\udea1-\udeaf]"
                }, {
                    name: "Sinhala",
                    bmp: "ංඃඅ-ඖක-නඳ-රලව-ෆ්ා-ුූෘ-ෟ෦-෯ෲ-෴",
                    astral: "\ud804[\udde1-\uddf4]"
                }, {
                    name: "Sora_Sompeng",
                    astral: "\ud804[\udcd0-\udce8\udcf0-\udcf9]"
                }, {
                    name: "Sundanese",
                    bmp: "ᮀ-ᮿ᳀-᳇"
                }, {
                    name: "Syloti_Nagri",
                    bmp: "ꠀ-꠫"
                }, {
                    name: "Syriac",
                    bmp: "܀-܍܏-݊ݍ-ݏ"
                }, {
                    name: "Tagalog",
                    bmp: "ᜀ-ᜌᜎ-᜔"
                }, {
                    name: "Tagbanwa",
                    bmp: "ᝠ-ᝬᝮ-ᝰᝲᝳ"
                }, {
                    name: "Tai_Le",
                    bmp: "ᥐ-ᥭᥰ-ᥴ"
                }, {
                    name: "Tai_Tham",
                    bmp: "ᨠ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪠-᪭"
                }, {
                    name: "Tai_Viet",
                    bmp: "ꪀ-ꫂꫛ-꫟"
                }, {
                    name: "Takri",
                    astral: "\ud805[\ude80-\udeb7\udec0-\udec9]"
                }, {
                    name: "Tamil",
                    bmp: "ஂஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹா-ூெ-ைொ-்ௐௗ௦-௺"
                }, {
                    name: "Telugu",
                    bmp: "ఀ-ఃఅ-ఌఎ-ఐఒ-నప-హఽ-ౄె-ైొ-్ౕౖౘ-ౚౠ-ౣ౦-౯౸-౿"
                }, {
                    name: "Thaana",
                    bmp: "ހ-ޱ"
                }, {
                    name: "Thai",
                    bmp: "ก-ฺเ-๛"
                }, {
                    name: "Tibetan",
                    bmp: "ༀ-ཇཉ-ཬཱ-ྗྙ-ྼ྾-࿌࿎-࿔࿙࿚"
                }, {
                    name: "Tifinagh",
                    bmp: "ⴰ-ⵧⵯ⵰⵿"
                }, {
                    name: "Tirhuta",
                    astral: "\ud805[\udc80-\udcc7\udcd0-\udcd9]"
                }, {
                    name: "Ugaritic",
                    astral: "\ud800[\udf80-\udf9d\udf9f]"
                }, {
                    name: "Vai",
                    bmp: "ꔀ-ꘫ"
                }, {
                    name: "Warang_Citi",
                    astral: "\ud806[\udca0-\udcf2\udcff]"
                }, {
                    name: "Yi",
                    bmp: "ꀀ-ꒌ꒐-꓆"
                }])
            }
        }, {}],
        8: [function(require, module, exports) {
            var XRegExp = require("./xregexp");
            require("./addons/build")(XRegExp);
            require("./addons/matchrecursive")(XRegExp);
            require("./addons/unicode-base")(XRegExp);
            require("./addons/unicode-blocks")(XRegExp);
            require("./addons/unicode-categories")(XRegExp);
            require("./addons/unicode-properties")(XRegExp);
            require("./addons/unicode-scripts")(XRegExp);
            module.exports = XRegExp
        }, {
            "./addons/build": 1,
            "./addons/matchrecursive": 2,
            "./addons/unicode-base": 3,
            "./addons/unicode-blocks": 4,
            "./addons/unicode-categories": 5,
            "./addons/unicode-properties": 6,
            "./addons/unicode-scripts": 7,
            "./xregexp": 9
        }],
        9: [function(require, module, exports) {
            var REGEX_DATA = "xregexp";
            var features = {
                astral: false,
                natives: false
            };
            var nativ = {
                exec: RegExp.prototype.exec,
                test: RegExp.prototype.test,
                match: String.prototype.match,
                replace: String.prototype.replace,
                split: String.prototype.split
            };
            var fixed = {};
            var regexCache = {};
            var patternCache = {};
            var tokens = [];
            var defaultScope = "default";
            var classScope = "class";
            var nativeTokens = {
                "default": /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/,
                "class": /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/
            };
            var replacementToken = /\$(?:{([\w$]+)}|(\d\d?|[\s\S]))/g;
            var correctExecNpcg = nativ.exec.call(/()??/, "")[1] === undefined;
            var hasNativeU = function() {
                var isSupported = true;
                try {
                    new RegExp("", "u")
                } catch (exception) {
                    isSupported = false
                }
                return isSupported
            }();
            var hasNativeY = function() {
                var isSupported = true;
                try {
                    new RegExp("", "y")
                } catch (exception) {
                    isSupported = false
                }
                return isSupported
            }();
            var hasFlagsProp = /a/.flags !== undefined;
            var registeredFlags = {
                g: true,
                i: true,
                m: true,
                u: hasNativeU,
                y: hasNativeY
            };
            var toString = {}.toString;

            function augment(regex, captureNames, xSource, xFlags, isInternalOnly) {
                var p;
                regex[REGEX_DATA] = {
                    captureNames: captureNames
                };
                if (isInternalOnly) return regex;
                if (regex.__proto__) regex.__proto__ = XRegExp.prototype;
                else
                    for (p in XRegExp.prototype) regex[p] = XRegExp.prototype[p];
                regex[REGEX_DATA].source = xSource;
                regex[REGEX_DATA].flags = xFlags ? xFlags.split("").sort().join("") : xFlags;
                return regex
            }

            function clipDuplicates(str) {
                return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, "")
            }

            function copyRegex(regex, options) {
                if (!XRegExp.isRegExp(regex)) throw new TypeError("Type RegExp expected");
                var xData = regex[REGEX_DATA] || {},
                    flags = getNativeFlags(regex),
                    flagsToAdd = "",
                    flagsToRemove = "",
                    xregexpSource = null,
                    xregexpFlags = null;
                options = options || {};
                if (options.removeG) flagsToRemove += "g";
                if (options.removeY) flagsToRemove += "y";
                if (flagsToRemove) flags = nativ.replace.call(flags, new RegExp("[" + flagsToRemove + "]+", "g"), "");
                if (options.addG) flagsToAdd += "g";
                if (options.addY) flagsToAdd += "y";
                if (flagsToAdd) flags = clipDuplicates(flags + flagsToAdd);
                if (!options.isInternalOnly) {
                    if (xData.source !== undefined) xregexpSource =
                        xData.source;
                    if (xData.flags != null) xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags
                }
                regex = augment(new RegExp(regex.source, flags), hasNamedCapture(regex) ? xData.captureNames.slice(0) : null, xregexpSource, xregexpFlags, options.isInternalOnly);
                return regex
            }

            function dec(hex) {
                return parseInt(hex, 16)
            }

            function getNativeFlags(regex) {
                return hasFlagsProp ? regex.flags : nativ.exec.call(/\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1]
            }

            function hasNamedCapture(regex) {
                return !!(regex[REGEX_DATA] &&
                    regex[REGEX_DATA].captureNames)
            }

            function hex(dec) {
                return parseInt(dec, 10).toString(16)
            }

            function indexOf(array, value) {
                var len = array.length,
                    i;
                for (i = 0; i < len; ++i)
                    if (array[i] === value) return i;
                return -1
            }

            function isType(value, type) {
                return toString.call(value) === "[object " + type + "]"
            }

            function isQuantifierNext(pattern, pos, flags) {
                return nativ.test.call(flags.indexOf("x") > -1 ? /^(?:\s+|#.*|\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/ : /^(?:\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/, pattern.slice(pos))
            }

            function pad4(str) {
                while (str.length <
                    4) str = "0" + str;
                return str
            }

            function prepareFlags(pattern, flags) {
                var i;
                if (clipDuplicates(flags) !== flags) throw new SyntaxError("Invalid duplicate regex flag " + flags);
                pattern = nativ.replace.call(pattern, /^\(\?([\w$]+)\)/, function($0, $1) {
                    if (nativ.test.call(/[gy]/, $1)) throw new SyntaxError("Cannot use flag g or y in mode modifier " + $0);
                    flags = clipDuplicates(flags + $1);
                    return ""
                });
                for (i = 0; i < flags.length; ++i)
                    if (!registeredFlags[flags.charAt(i)]) throw new SyntaxError("Unknown regex flag " + flags.charAt(i));
                return {
                    pattern: pattern,
                    flags: flags
                }
            }

            function prepareOptions(value) {
                var options = {};
                if (isType(value, "String")) {
                    XRegExp.forEach(value, /[^\s,]+/, function(match) {
                        options[match] = true
                    });
                    return options
                }
                return value
            }

            function registerFlag(flag) {
                if (!/^[\w$]$/.test(flag)) throw new Error("Flag must be a single character A-Za-z0-9_$");
                registeredFlags[flag] = true
            }

            function runTokens(pattern, flags, pos, scope, context) {
                var i = tokens.length,
                    leadChar = pattern.charAt(pos),
                    result = null,
                    match, t;
                while (i--) {
                    t = tokens[i];
                    if (t.leadChar && t.leadChar !== leadChar ||
                        t.scope !== scope && t.scope !== "all" || t.flag && flags.indexOf(t.flag) === -1) continue;
                    match = XRegExp.exec(pattern, t.regex, pos, "sticky");
                    if (match) {
                        result = {
                            matchLength: match[0].length,
                            output: t.handler.call(context, match, scope, flags),
                            reparse: t.reparse
                        };
                        break
                    }
                }
                return result
            }

            function setAstral(on) {
                features.astral = on
            }

            function setNatives(on) {
                RegExp.prototype.exec = (on ? fixed : nativ).exec;
                RegExp.prototype.test = (on ? fixed : nativ).test;
                String.prototype.match = (on ? fixed : nativ).match;
                String.prototype.replace = (on ? fixed : nativ).replace;
                String.prototype.split = (on ? fixed : nativ).split;
                features.natives = on
            }

            function toObject(value) {
                if (value == null) throw new TypeError("Cannot convert null or undefined to object");
                return value
            }

            function XRegExp(pattern, flags) {
                var context = {
                        hasNamedCapture: false,
                        captureNames: []
                    },
                    scope = defaultScope,
                    output = "",
                    pos = 0,
                    result, token, generated, appliedPattern, appliedFlags;
                if (XRegExp.isRegExp(pattern)) {
                    if (flags !== undefined) throw new TypeError("Cannot supply flags when copying a RegExp");
                    return copyRegex(pattern)
                }
                pattern =
                    pattern === undefined ? "" : String(pattern);
                flags = flags === undefined ? "" : String(flags);
                if (XRegExp.isInstalled("astral") && flags.indexOf("A") === -1) flags += "A";
                if (!patternCache[pattern]) patternCache[pattern] = {};
                if (!patternCache[pattern][flags]) {
                    result = prepareFlags(pattern, flags);
                    appliedPattern = result.pattern;
                    appliedFlags = result.flags;
                    while (pos < appliedPattern.length) {
                        do {
                            result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
                            if (result && result.reparse) appliedPattern = appliedPattern.slice(0, pos) + result.output +
                                appliedPattern.slice(pos + result.matchLength)
                        } while (result && result.reparse);
                        if (result) {
                            output += result.output;
                            pos += result.matchLength || 1
                        } else {
                            token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, "sticky")[0];
                            output += token;
                            pos += token.length;
                            if (token === "[" && scope === defaultScope) scope = classScope;
                            else if (token === "]" && scope === classScope) scope = defaultScope
                        }
                    }
                    patternCache[pattern][flags] = {
                        pattern: nativ.replace.call(output, /\(\?:\)(?:[*+?]|\{\d+(?:,\d*)?})?\??(?=\(\?:\))|^\(\?:\)(?:[*+?]|\{\d+(?:,\d*)?})?\??|\(\?:\)(?:[*+?]|\{\d+(?:,\d*)?})?\??$/g,
                            ""),
                        flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ""),
                        captures: context.hasNamedCapture ? context.captureNames : null
                    }
                }
                generated = patternCache[pattern][flags];
                return augment(new RegExp(generated.pattern, generated.flags), generated.captures, pattern, flags)
            }
            XRegExp.prototype = new RegExp;
            XRegExp.version = "3.1.0-dev";
            XRegExp.addToken = function(regex, handler, options) {
                options = options || {};
                var optionalFlags = options.optionalFlags,
                    i;
                if (options.flag) registerFlag(options.flag);
                if (optionalFlags) {
                    optionalFlags = nativ.split.call(optionalFlags,
                        "");
                    for (i = 0; i < optionalFlags.length; ++i) registerFlag(optionalFlags[i])
                }
                tokens.push({
                    regex: copyRegex(regex, {
                        addG: true,
                        addY: hasNativeY,
                        isInternalOnly: true
                    }),
                    handler: handler,
                    scope: options.scope || defaultScope,
                    flag: options.flag,
                    reparse: options.reparse,
                    leadChar: options.leadChar
                });
                XRegExp.cache.flush("patterns")
            };
            XRegExp.cache = function(pattern, flags) {
                if (!regexCache[pattern]) regexCache[pattern] = {};
                return regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags))
            };
            XRegExp.cache.flush = function(cacheName) {
                if (cacheName ===
                    "patterns") patternCache = {};
                else regexCache = {}
            };
            XRegExp.escape = function(str) {
                return nativ.replace.call(toObject(str), /[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")
            };
            XRegExp.exec = function(str, regex, pos, sticky) {
                var cacheKey = "g",
                    addY = false,
                    match, r2;
                addY = hasNativeY && !!(sticky || regex.sticky && sticky !== false);
                if (addY) cacheKey += "y";
                regex[REGEX_DATA] = regex[REGEX_DATA] || {};
                r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
                    addG: true,
                    addY: addY,
                    removeY: sticky === false,
                    isInternalOnly: true
                }));
                r2.lastIndex =
                    pos = pos || 0;
                match = fixed.exec.call(r2, str);
                if (sticky && match && match.index !== pos) match = null;
                if (regex.global) regex.lastIndex = match ? r2.lastIndex : 0;
                return match
            };
            XRegExp.forEach = function(str, regex, callback) {
                var pos = 0,
                    i = -1,
                    match;
                while (match = XRegExp.exec(str, regex, pos)) {
                    callback(match, ++i, str, regex);
                    pos = match.index + (match[0].length || 1)
                }
            };
            XRegExp.globalize = function(regex) {
                return copyRegex(regex, {
                    addG: true
                })
            };
            XRegExp.install = function(options) {
                options = prepareOptions(options);
                if (!features.astral && options.astral) setAstral(true);
                if (!features.natives && options.natives) setNatives(true)
            };
            XRegExp.isInstalled = function(feature) {
                return !!features[feature]
            };
            XRegExp.isRegExp = function(value) {
                return toString.call(value) === "[object RegExp]"
            };
            XRegExp.match = function(str, regex, scope) {
                var global = regex.global && scope !== "one" || scope === "all",
                    cacheKey = (global ? "g" : "") + (regex.sticky ? "y" : "") || "noGY",
                    result, r2;
                regex[REGEX_DATA] = regex[REGEX_DATA] || {};
                r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
                    addG: !!global,
                    addY: !!regex.sticky,
                    removeG: scope === "one",
                    isInternalOnly: true
                }));
                result = nativ.match.call(toObject(str), r2);
                if (regex.global) regex.lastIndex = scope === "one" && result ? result.index + result[0].length : 0;
                return global ? result || [] : result && result[0]
            };
            XRegExp.matchChain = function(str, chain) {
                return function recurseChain(values, level) {
                    var item = chain[level].regex ? chain[level] : {
                            regex: chain[level]
                        },
                        matches = [],
                        addMatch = function(match) {
                            if (item.backref) {
                                if (!(match.hasOwnProperty(item.backref) || +item.backref < match.length)) throw new ReferenceError("Backreference to undefined group: " +
                                    item.backref);
                                matches.push(match[item.backref] || "")
                            } else matches.push(match[0])
                        },
                        i;
                    for (i = 0; i < values.length; ++i) XRegExp.forEach(values[i], item.regex, addMatch);
                    return level === chain.length - 1 || !matches.length ? matches : recurseChain(matches, level + 1)
                }([str], 0)
            };
            XRegExp.replace = function(str, search, replacement, scope) {
                var isRegex = XRegExp.isRegExp(search),
                    global = search.global && scope !== "one" || scope === "all",
                    cacheKey = (global ? "g" : "") + (search.sticky ? "y" : "") || "noGY",
                    s2 = search,
                    result;
                if (isRegex) {
                    search[REGEX_DATA] =
                        search[REGEX_DATA] || {};
                    s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {
                        addG: !!global,
                        addY: !!search.sticky,
                        removeG: scope === "one",
                        isInternalOnly: true
                    }))
                } else if (global) s2 = new RegExp(XRegExp.escape(String(search)), "g");
                result = fixed.replace.call(toObject(str), s2, replacement);
                if (isRegex && search.global) search.lastIndex = 0;
                return result
            };
            XRegExp.replaceEach = function(str, replacements) {
                var i, r;
                for (i = 0; i < replacements.length; ++i) {
                    r = replacements[i];
                    str = XRegExp.replace(str, r[0],
                        r[1], r[2])
                }
                return str
            };
            XRegExp.split = function(str, separator, limit) {
                return fixed.split.call(toObject(str), separator, limit)
            };
            XRegExp.test = function(str, regex, pos, sticky) {
                return !!XRegExp.exec(str, regex, pos, sticky)
            };
            XRegExp.uninstall = function(options) {
                options = prepareOptions(options);
                if (features.astral && options.astral) setAstral(false);
                if (features.natives && options.natives) setNatives(false)
            };
            XRegExp.union = function(patterns, flags) {
                var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*]/g,
                    output = [],
                    numCaptures = 0,
                    numPriorCaptures, captureNames, pattern, rewrite = function(match, paren, backref) {
                        var name = captureNames[numCaptures - numPriorCaptures];
                        if (paren) {
                            ++numCaptures;
                            if (name) return "(?<" + name + ">"
                        } else if (backref) return "\\" + (+backref + numPriorCaptures);
                        return match
                    },
                    i;
                if (!(isType(patterns, "Array") && patterns.length)) throw new TypeError("Must provide a nonempty array of patterns to merge");
                for (i = 0; i < patterns.length; ++i) {
                    pattern = patterns[i];
                    if (XRegExp.isRegExp(pattern)) {
                        numPriorCaptures = numCaptures;
                        captureNames = pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames || [];
                        output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite))
                    } else output.push(XRegExp.escape(pattern))
                }
                return XRegExp(output.join("|"), flags)
            };
            fixed.exec = function(str) {
                var origLastIndex = this.lastIndex,
                    match = nativ.exec.apply(this, arguments),
                    name, r2, i;
                if (match) {
                    if (!correctExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
                        r2 = copyRegex(this, {
                            removeG: true,
                            isInternalOnly: true
                        });
                        nativ.replace.call(String(str).slice(match.index),
                            r2,
                            function() {
                                var len = arguments.length,
                                    i;
                                for (i = 1; i < len - 2; ++i)
                                    if (arguments[i] === undefined) match[i] = undefined
                            })
                    }
                    if (this[REGEX_DATA] && this[REGEX_DATA].captureNames)
                        for (i = 1; i < match.length; ++i) {
                            name = this[REGEX_DATA].captureNames[i - 1];
                            if (name) match[name] = match[i]
                        }
                    if (this.global && !match[0].length && this.lastIndex > match.index) this.lastIndex = match.index
                }
                if (!this.global) this.lastIndex = origLastIndex;
                return match
            };
            fixed.test = function(str) {
                return !!fixed.exec.call(this, str)
            };
            fixed.match = function(regex) {
                var result;
                if (!XRegExp.isRegExp(regex)) regex = new RegExp(regex);
                else if (regex.global) {
                    result = nativ.match.apply(this, arguments);
                    regex.lastIndex = 0;
                    return result
                }
                return fixed.exec.call(regex, toObject(this))
            };
            fixed.replace = function(search, replacement) {
                var isRegex = XRegExp.isRegExp(search),
                    origLastIndex, captureNames, result;
                if (isRegex) {
                    if (search[REGEX_DATA]) captureNames = search[REGEX_DATA].captureNames;
                    origLastIndex = search.lastIndex
                } else search += "";
                if (isType(replacement, "Function")) result = nativ.replace.call(String(this),
                    search,
                    function() {
                        var args = arguments,
                            i;
                        if (captureNames) {
                            args[0] = new String(args[0]);
                            for (i = 0; i < captureNames.length; ++i)
                                if (captureNames[i]) args[0][captureNames[i]] = args[i + 1]
                        }
                        if (isRegex && search.global) search.lastIndex = args[args.length - 2] + args[0].length;
                        return replacement.apply(undefined, args)
                    });
                else result = nativ.replace.call(this == null ? this : String(this), search, function() {
                    var args = arguments;
                    return nativ.replace.call(String(replacement), replacementToken, function($0, $1, $2) {
                        var n;
                        if ($1) {
                            n = +$1;
                            if (n <= args.length -
                                3) return args[n] || "";
                            n = captureNames ? indexOf(captureNames, $1) : -1;
                            if (n < 0) throw new SyntaxError("Backreference to undefined group " + $0);
                            return args[n + 1] || ""
                        }
                        if ($2 === "$") return "$";
                        if ($2 === "&" || +$2 === 0) return args[0];
                        if ($2 === "`") return args[args.length - 1].slice(0, args[args.length - 2]);
                        if ($2 === "'") return args[args.length - 1].slice(args[args.length - 2] + args[0].length);
                        $2 = +$2;
                        if (!isNaN($2)) {
                            if ($2 > args.length - 3) throw new SyntaxError("Backreference to undefined group " + $0);
                            return args[$2] || ""
                        }
                        throw new SyntaxError("Invalid token " +
                            $0);
                    })
                });
                if (isRegex)
                    if (search.global) search.lastIndex = 0;
                    else search.lastIndex = origLastIndex;
                return result
            };
            fixed.split = function(separator, limit) {
                if (!XRegExp.isRegExp(separator)) return nativ.split.apply(this, arguments);
                var str = String(this),
                    output = [],
                    origLastIndex = separator.lastIndex,
                    lastLastIndex = 0,
                    lastLength;
                limit = (limit === undefined ? -1 : limit) >>> 0;
                XRegExp.forEach(str, separator, function(match) {
                    if (match.index + match[0].length > lastLastIndex) {
                        output.push(str.slice(lastLastIndex, match.index));
                        if (match.length >
                            1 && match.index < str.length) Array.prototype.push.apply(output, match.slice(1));
                        lastLength = match[0].length;
                        lastLastIndex = match.index + lastLength
                    }
                });
                if (lastLastIndex === str.length) {
                    if (!nativ.test.call(separator, "") || lastLength) output.push("")
                } else output.push(str.slice(lastLastIndex));
                separator.lastIndex = origLastIndex;
                return output.length > limit ? output.slice(0, limit) : output
            };
            XRegExp.addToken(/\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/, function(match, scope) {
                if (match[1] ===
                    "B" && scope === defaultScope) return match[0];
                throw new SyntaxError("Invalid escape " + match[0]);
            }, {
                scope: "all",
                leadChar: "\\"
            });
            XRegExp.addToken(/\\u{([\dA-Fa-f]+)}/, function(match, scope, flags) {
                var code = dec(match[1]);
                if (code > 1114111) throw new SyntaxError("Invalid Unicode code point " + match[0]);
                if (code <= 65535) return "\\u" + pad4(hex(code));
                if (hasNativeU && flags.indexOf("u") > -1) return match[0];
                throw new SyntaxError("Cannot use Unicode code point above \\u{FFFF} without flag u");
            }, {
                scope: "all",
                leadChar: "\\"
            });
            XRegExp.addToken(/\[(\^?)]/, function(match) {
                return match[1] ? "[\\s\\S]" : "\\b\\B"
            }, {
                leadChar: "["
            });
            XRegExp.addToken(/\(\?#[^)]*\)/, function(match, scope, flags) {
                return isQuantifierNext(match.input, match.index + match[0].length, flags) ? "" : "(?:)"
            }, {
                leadChar: "("
            });
            XRegExp.addToken(/\s+|#.*/, function(match, scope, flags) {
                return isQuantifierNext(match.input, match.index + match[0].length, flags) ? "" : "(?:)"
            }, {
                flag: "x"
            });
            XRegExp.addToken(/\./, function() {
                return "[\\s\\S]"
            }, {
                flag: "s",
                leadChar: "."
            });
            XRegExp.addToken(/\\k<([\w$]+)>/,
                function(match) {
                    var index = isNaN(match[1]) ? indexOf(this.captureNames, match[1]) + 1 : +match[1],
                        endIndex = match.index + match[0].length;
                    if (!index || index > this.captureNames.length) throw new SyntaxError("Backreference to undefined group " + match[0]);
                    return "\\" + index + (endIndex === match.input.length || isNaN(match.input.charAt(endIndex)) ? "" : "(?:)")
                }, {
                    leadChar: "\\"
                });
            XRegExp.addToken(/\\(\d+)/, function(match, scope) {
                if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !==
                    "0") throw new SyntaxError("Cannot use octal escape or backreference to undefined group " + match[0]);
                return match[0]
            }, {
                scope: "all",
                leadChar: "\\"
            });
            XRegExp.addToken(/\(\?P?<([\w$]+)>/, function(match) {
                if (!isNaN(match[1])) throw new SyntaxError("Cannot use integer as capture name " + match[0]);
                if (match[1] === "length" || match[1] === "__proto__") throw new SyntaxError("Cannot use reserved word as capture name " + match[0]);
                if (indexOf(this.captureNames, match[1]) > -1) throw new SyntaxError("Cannot use same name for multiple groups " +
                    match[0]);
                this.captureNames.push(match[1]);
                this.hasNamedCapture = true;
                return "("
            }, {
                leadChar: "("
            });
            XRegExp.addToken(/\((?!\?)/, function(match, scope, flags) {
                if (flags.indexOf("n") > -1) return "(?:";
                this.captureNames.push(null);
                return "("
            }, {
                optionalFlags: "n",
                leadChar: "("
            });
            module.exports = XRegExp
        }, {}]
    }, {}, [8])(8)
});
if (!String.prototype.startsWith)(function() {
    var defineProperty = function() {
        try {
            var object = {};
            var $defineProperty = Object.defineProperty;
            var result = $defineProperty(object, object, object) && $defineProperty
        } catch (error) {}
        return result
    }();
    var toString = {}.toString;
    var startsWith = function(search) {
        if (this == null) throw TypeError();
        var string = String(this);
        if (search && toString.call(search) == "[object RegExp]") throw TypeError();
        var stringLength = string.length;
        var searchString = String(search);
        var searchLength = searchString.length;
        var position = arguments.length > 1 ? arguments[1] : undefined;
        var pos = position ? Number(position) : 0;
        if (pos != pos) pos = 0;
        var start = Math.min(Math.max(pos, 0), stringLength);
        if (searchLength + start > stringLength) return false;
        var index = -1;
        while (++index < searchLength)
            if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) return false;
        return true
    };
    if (defineProperty) defineProperty(String.prototype, "startsWith", {
        "value": startsWith,
        "configurable": true,
        "writable": true
    });
    else String.prototype.startsWith = startsWith
})();
if (!String.prototype.endsWith) String.prototype.endsWith = function(searchString, position) {
    var subjectString = this.toString();
    if (typeof position !== "number" || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) position = subjectString.length;
    position -= searchString.length;
    var lastIndex = subjectString.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position
};
(function() {
    if (!Array.prototype.indexOf) Array.prototype.indexOf = function(elt) {
        var l = this.length >>> 0;
        var from = Number(arguments[1]) || 0;
        from = from < 0 ? Math.ceil(from) : Math.floor(from);
        if (from < 0) from += l;
        for (; from < l; from++)
            if (from in this && this[from] === elt) return from;
        return -1
    }
})();
(function() {
    if (!("classList" in document.documentElement)) {
        function addClassList(e) {
            Object.defineProperty(e.prototype, "classList", {
                get: function() {
                    var self = this,
                        cls = self.className.split(/\s+/g);

                    function _update(type) {
                        return function(value) {
                            var index = cls.indexOf(value),
                                isToggle = type == "toggle";
                            if (isToggle) type = ~index ? "remove" : "add";
                            if (type == "add") ~index || cls.push(value);
                            else if (type == "remove") ~index && cls.splice(index, 1);
                            self.className = cls.join(" ");
                            if (isToggle) return !~index
                        }
                    }
                    cls.add = _update("add");
                    cls.remove =
                        _update("remove");
                    cls.toggle = _update("toggle");
                    cls.contains = function(value) {
                        return !!~cls.indexOf(value)
                    };
                    cls.item = function(i) {
                        return cls[i] || null
                    };
                    return cls
                }
            })
        }
        if (window.HTMLElement) addClassList(HTMLElement);
        else {
            var doms = ["HTMLAnchorElement", "HTMLAreaElement", "HTMLBRElement", "HTMLBaseElement", "HTMLBodyElement", "HTMLButtonElement", "HTMLDListElement", "HTMLDivElement", "HTMLDocument", "HTMLEmbedElement", "HTMLFieldSetElement", "HTMLFontElement", "HTMLFormElement", "HTMLFrameElement", "HTMLFrameSetElement",
                "HTMLHRElement", "HTMLHeadElement", "HTMLHeadingElement", "HTMLHtmlElement", "HTMLIFrameElement", "HTMLImageElement", "HTMLInputElement", "HTMLLIElement", "HTMLLabelElement", "HTMLLegendElement", "HTMLLinkElement", "HTMLMapElement", "HTMLMarqueeElement", "HTMLMetaElement", "HTMLOListElement", "HTMLObjectElement", "HTMLOptionElement", "HTMLParagraphElement", "HTMLParamElement", "HTMLScriptElement", "HTMLSelectElement", "HTMLSpanElement", "HTMLStyleElement", "HTMLTableCaptionElement", "HTMLTableCellElement", "HTMLTableColElement",
                "HTMLTableElement", "HTMLTableRowElement", "HTMLTableSectionElement", "HTMLTextAreaElement", "HTMLTitleElement", "HTMLUListElement", "HTMLUnknownElement"
            ];
            for (var i = 0; i < doms.length; i++) window[doms[i]] && addClassList(window[doms[i]])
        }
    }
})();
(function(d, window) {
    var nativeSupport = false,
        cmKey = nativeSupport ? "contextMenu" : "_contextMenu",
        menuNodeName = "CMENU",
        lastX, lastY, mousedown_timeout, overlay, menustack, preview, timeout, t, preview_show_timer, holding = false,
        doneEvents = [],
        toAppend = [],
        old_contextmenu = window.contextmenu;

    function nextTick(callback) {
        setTimeout(callback, 0)
    }

    function offset(obj) {
        var curleft = 0,
            curtop = 0;
        if (obj.getClientRects) return obj.getClientRects()[0];
        do {
            curleft += obj.offsetLeft;
            curtop += obj.offsetTop;
            obj = obj.offsetParent
        } while (obj);
        return {
            left: curleft,
            top: curtop
        }
    }

    function html(n) {
        if (n.get) return n.get(0);
        return n
    }

    function hideMenu(menu, fade) {
        if (fade) throw "no need to fade";
        menu.style.display = "none";
        var launcher = menu.launcher;
        if (launcher) launcher.removeAttribute("open")
    }

    function popmenu() {
        var top = menustack.pop();
        hideMenu(top);
        return top
    }

    function mouseend() {
        overlay.style.opacity = "0.0";
        mousedown_timeout = setTimeout(function() {
                while (menustack.length) popmenu(false);
                overlay.style.display = "none";
                overlay.style.opacity = "1.0";
                triggerDoneEvents()
            },
            timeout)
    }

    function showMenu(menu) {
        menu.style.display = "inline-block"
    }

    function menuoncontextmenu(e) {
        e.stopPropagation();
        e.preventDefault()
    }

    function ancestor(name, node) {
        if (node.nodeName === name) return node;
        return ancestor(name, node.parentNode || {
            nodeName: name
        })
    }

    function onmouseover(e) {
        var menu = ancestor(menuNodeName, e.target),
            msl, a, i;
        if (preview) {
            if (preview === menu) {
                menustack.push(menu);
                preview = undefined;
                return
            }
            console.error("SHOULD NOT BE A PREVIEW")
        }
        msl = menustack.length;
        a = menustack.indexOf(menu);
        for (i = msl -
            1; i > a; i--) popmenu()
    }

    function onmousedown(e) {
        if (e.target.nodeName === menuNodeName)
            if (e.offsetX === 0) return;
        e.stopPropagation();
        e.preventDefault();
        return false
    }

    function onsubcontextmenuout(e) {
        preview_show_timer = clearTimeout(preview_show_timer);
        var menu = ancestor(menuNodeName, e.toElement);
        if (menu === preview) return false;
        if (preview) {
            hideMenu(preview);
            preview = undefined
        }
    }

    function onsubcontextmenu(e) {
        preview_show_timer = clearTimeout(preview_show_timer);
        preview_show_timer = setTimeout(function() {
            var menuitem = e.target,
                menu = menuitem[cmKey],
                pos;
            menu.launcher = menuitem;
            menuitem.setAttribute("open", true);
            if (preview && preview !== menu) hideMenu(preview);
            preview = menu;
            pos = offset(menuitem);
            menu.style.top = Math.max(pos.top - 5, 0) + "px";
            menu.style.left = pos.left + pos.width - 1 + "px";
            showMenu(menu)
        }, 200)
    }

    function appendToOverlay(menu) {
        if (overlay) overlay.appendChild(menu);
        else toAppend.push(menu)
    }

    function prepareMenu(menu) {
        var p = menu.parentNode,
            clone;
        menu.addEventListener("mouseover", onmouseover, false);
        menu.addEventListener("mousedown",
            onmousedown);
        menu.addEventListener("contextmenu", menuoncontextmenu);
        if (p.nodeName === menuNodeName) {
            clone = d.createElement("menuitem");
            menu.classList.add("submenu");
            clone.className = menu.className;
            clone.setAttribute("label", menu.getAttribute("label"));
            clone[cmKey] = menu;
            clone.addEventListener("mouseover", onsubcontextmenu);
            clone.addEventListener("mouseout", onsubcontextmenuout);
            p.replaceChild(clone, menu);
            appendToOverlay(menu)
        } else {
            p.removeChild(menu);
            appendToOverlay(menu)
        }
    }

    function initContextMenu(menu,
        x, y) {
        t = new Date;
        menustack.push(menu);
        menu.style.top = Math.max(y - 5, 0) + "px";
        menu.style.left = x + "px";
        showMenu(menu);
        overlay.style.display = "block";
        holding = false;
        var right = x + menu.offsetWidth;
        var bottom = y + menu.offsetHeight;
        var bodyHeight = document.body.offsetHeight;
        var bodyWidth = document.body.offsetWidth;
        if (bottom > bodyHeight) menu.style.top = y - (bottom - bodyHeight) + "px";
        if (right > bodyWidth) menu.style.left = x - (right - bodyWidth) + "px"
    }

    function oncontextsheet(e, menu, button) {
        var pos;
        if (button === undefined) button = e.target;
        pos = offset(button);
        if (menu === undefined) menu = contextMenufor(button);
        initContextMenu(menu, pos.left, pos.top + 28);
        if (e) {
            e.preventDefault();
            e.stopPropagation()
        }
        holding = true;
        return false
    }

    function oncontextsheetbtnup(e) {
        oncontextsheet(e);
        holding = false
    }

    function contextMenufor(node) {
        if (!node || !node.hasAttribute) return;
        if (node[cmKey]) return node[cmKey];
        if (node.hasAttribute("contextmenu")) {
            var node = d.getElementById(node.getAttribute("contextmenu"));
            node[cmKey] = node;
            return node
        }
        return contextMenufor(node.parentNode)
    }

    function simulateClickEvent(elm, e) {
        var evt;
        if (document.createEvent) evt = document.createEvent("MouseEvents");
        if (elm && elm.dispatchEvent && evt && evt.initMouseEvent) {
            evt.initMouseEvent("click", true, true, document.defaultView, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);
            elm.dispatchEvent(evt)
        }
    }

    function oncontextmenu(e) {
        var menu = contextMenufor(e.target),
            x = e.clientX,
            y = e.clientY;
        initContextMenu(menu, e.clientX, e.clientY);
        holding = true;
        lastX = x;
        lastY = y;
        e.preventDefault();
        e.stopPropagation();
        return false
    }

    function triggerDoneEvents() {
        doneEvents.forEach(function(f) {
            try {
                f()
            } catch (ex) {
                setTimeout(function() {
                    throw ex;
                }, 0)
            }
        });
        doneEvents = []
    }

    function inititalize() {
        menustack = [];
        overlay = d.createElement("div");
        var os_code = "osx10_7",
            mouseup_wait_for_me = 0;
        if (/Mac/.test(navigator.userAgent)) os_code = "osx10_7";
        else if (/Win/.test(navigator.userAgent)) os_code = "win7";
        d.body.classList.add(os_code);
        overlay.className = "_contextmenu_screen_";
        timeout = 150;
        t = 0;
        d.body.appendChild(overlay);
        overlay.addEventListener("mousedown",
            function(e) {
                mouseend(e)
            });
        overlay.addEventListener("mouseup", function(e) {
            if (mouseup_wait_for_me) return;
            var menuitem = e.target;
            if (menuitem.nodeName === "MENUITEM") {
                if (menuitem[cmKey]) return false;
                if (holding) simulateClickEvent(menuitem, e)
            }
            if (new Date - t < 300) {
                holding = false;
                return
            }
            if (menuitem.nodeName === "MENUITEM") setTimeout(function() {
                menuitem.style.background = "white";
                setTimeout(function() {
                    menuitem.style.background = "";
                    setTimeout(function() {
                        mouseend(e)
                    }, 30)
                }, 80)
            }, 10)
        });
        overlay.addEventListener("mousewheel",
            function(e) {
                e.preventDefault();
                e.stopPropagation();
                return false
            }, true);
        overlay.addEventListener("contextmenu", function(e) {
            overlay.style.display = "none";
            var node = d.elementFromPoint(e.clientX, e.clientY),
                menu = contextMenufor(node),
                x, y, dx, dy;
            if (menu) {
                overlay.style.display = "block";
                clearTimeout(mousedown_timeout);
                e.preventDefault();
                if (menustack[0] === menu) {
                    x = e.clientX;
                    y = e.clientY;
                    dx = x - lastX;
                    dy = y - lastY;
                    lastX = x;
                    lastY = y;
                    if (dx * dx + dy * dy < 50) {
                        overlay.style.opacity = "1.0";
                        overlay.style.display = "block";
                        clearTimeout(mousedown_timeout);
                        nextTick(mouseend);
                        return
                    }
                }
                mouseup_wait_for_me++;
                setTimeout(function() {
                    while (menustack.length) {
                        var m = menustack.pop();
                        hideMenu(m)
                    }
                    overlay.style.display = "none";
                    overlay.style.opacity = "1.0";
                    overlay.style.display = "block";
                    nextTick(function() {
                        mouseup_wait_for_me--;
                        initContextMenu(menu, e.clientX, e.clientY)
                    })
                }, timeout);
                return false
            }
            overlay.style.opacity = "1.0";
            overlay.style.display = "block";
            clearTimeout(mousedown_timeout);
            nextTick(mouseend)
        });
        overlay.addEventListener("mouseover", function(e) {
            if (e.target !== overlay) return;
            preview_show_timer = clearTimeout(preview_show_timer);
            if (preview) {
                hideMenu(preview);
                preview = undefined
            }
        })
    }

    function attachEventsToAllMenus() {
        var menus_dom = d.getElementsByTagName(menuNodeName),
            i, l, menus = [];
        for (i = 0, l = menus_dom.length; i < l; i++) menus[i] = menus_dom[i];
        for (i = 0, l = menus.length; i < l; i++) prepareMenu(menus[i])
    }

    function hookUpContextMenus() {
        var linkers = d.querySelectorAll("[contextmenu]"),
            element, i, l;
        for (i = 0, l = linkers.length; i < l; i++) {
            element = linkers[i];
            element[cmKey] = d.getElementById(element.getAttribute("contextmenu"));
            if (element.nodeName === "INPUT") {
                element.addEventListener("mouseup", oncontextsheetbtnup);
                element.addEventListener("contextmenu", oncontextsheet)
            } else element.addEventListener("contextmenu", oncontextmenu)
        }
    }

    function buildMenu(x) {
        var menu = d.createElement(menuNodeName),
            i, l, xi, submenu, menuitem;
        menu.setAttribute("type", "context");
        for (i = 0, l = x.length; i < l; i++) {
            xi = x[i];
            if (xi.children) {
                submenu = buildMenu(xi.children);
                submenu.setAttribute("label", xi.label);
                menu.appendChild(submenu)
            } else {
                if (xi.hr) menuitem = d.createElement("hr");
                else {
                    menuitem = d.createElement("menuitem");
                    menuitem.setAttribute("label", xi.label);
                    if (xi.onclick) menuitem.onclick = xi.onclick;
                    if (xi.icon) menuitem.icon = xi.icon;
                    if (xi.checked) menuitem.setAttribute("checked", xi.checked ? "checked" : "");
                    var key;
                    for (key in xi)
                        if (xi.hasOwnProperty(key))
                            if (["label", "icon", "hr", "onclick", "checked"].indexOf(key) === -1) menuitem.dataset[key] = xi[key]
                }
                menu.appendChild(menuitem)
            }
        }
        return menu
    }

    function contextmenu(x) {
        var menu = buildMenu(x),
            submenus, menus, i, l;
        d.body.appendChild(menu);
        if (nativeSupport) return menu;
        submenus = menu.getElementsByTagName(menuNodeName);
        menus = [menu];
        for (i = 0, l = submenus.length; i < l; i++) menus.push(submenus[i]);
        for (i = 0, l = menus.length; i < l; i++) prepareMenu(menus[i]);
        return menu
    }
    contextmenu.show = function(menu, x, y) {
        if (nativeSupport) throw "Not supported!";
        if (typeof menu === "string") menu = d.getElementById(menu);
        else menu = html(menu);
        if (typeof x === "number") initContextMenu(menu, x, y);
        else {
            oncontextsheet(null, menu, html(x));
            holding = false
        }
        return this
    };
    contextmenu.then = function(f) {
        if (nativeSupport) {
            f();
            return
        }
        doneEvents.push(f)
    };
    contextmenu.attach = function(element, menu) {
        element = html(element);
        menu = html(menu);
        if (nativeSupport) {
            menu.id = menu.id || (0 | 1E4 * Math.random()).toString(30);
            element.setAttribute("contextmenu", menu.id);
            return
        }
        element[cmKey] = menu;
        if (element.nodeName === "INPUT" || element.nodeName === "BUTTON") {
            element.addEventListener("mouseup", oncontextsheetbtnup);
            element.addEventListener("contextmenu", oncontextsheet)
        } else element.addEventListener("contextmenu", oncontextmenu)
    };
    contextmenu.noConflict =
        function() {
            window.contextmenu = old_contextmenu;
            return contextmenu
        };
    if (!nativeSupport) window.addEventListener("load", function(e) {
        inititalize();
        attachEventsToAllMenus();
        hookUpContextMenus();
        var i;
        for (i = 0; i < toAppend.length; i++) overlay.appendChild(toAppend[i])
    });
    if (typeof define === "function" && define.amd) define("contextMenu", [], function() {
        return contextmenu
    });
    else if (typeof module !== "undefined") module.exports = contextmenu;
    else window.contextmenu = contextmenu
})(document, window);
if (!Date.now) Date.now = function() {
    return (new Date).valueOf()
};
(function(factory) {
    if (typeof exports === "object") module.exports = factory();
    else if (typeof define === "function" && define.amd) define(factory);
    else {
        var glob;
        try {
            glob = window
        } catch (e) {
            glob = self
        }
        glob.SparkMD5 = factory()
    }
})(function(undefined) {
    var add32 = function(a, b) {
            return a + b & 4294967295
        },
        hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];

    function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32(a << s | a >>> 32 - s, b)
    }

    function md5cycle(x, k) {
        var a = x[0],
            b = x[1],
            c = x[2],
            d = x[3];
        a += (b &
            c | ~b & d) + k[0] - 680876936 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d = (d << 12 |
            d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] -
            373897302 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b +=
            (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) +
            k[7] + 1126891415 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c = (c << 15 | c >>>
            17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0
    }

    function md5blk(s) {
        var md5blks = [],
            i;
        for (i = 0; i < 64; i += 4) md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        return md5blks
    }

    function md5blk_array(a) {
        var md5blks = [],
            i;
        for (i = 0; i < 64; i += 4) md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        return md5blks
    }

    function md51(s) {
        var n = s.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i, length, tail, tmp, lo, hi;
        for (i = 64; i <= n; i += 64) md5cycle(state, md5blk(s.substring(i - 64, i)));
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) tail[i] = 0
        }
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(state, tail);
        return state
    }

    function md51_array(a) {
        var n = a.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i, length, tail, tmp, lo, hi;
        for (i = 64; i <= n; i += 64) md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0);
        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) tail[i >> 2] |= a[i] << (i % 4 << 3);
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i <
                16; i += 1) tail[i] = 0
        }
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(state, tail);
        return state
    }

    function rhex(n) {
        var s = "",
            j;
        for (j = 0; j < 4; j += 1) s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];
        return s
    }

    function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) x[i] = rhex(x[i]);
        return x.join("")
    }
    if (hex(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") add32 = function(x, y) {
        var lsw = (x & 65535) + (y & 65535),
            msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return msw <<
            16 | lsw & 65535
    };
    if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice)(function() {
        function clamp(val, length) {
            val = val | 0 || 0;
            if (val < 0) return Math.max(val + length, 0);
            return Math.min(val, length)
        }
        ArrayBuffer.prototype.slice = function(from, to) {
            var length = this.byteLength,
                begin = clamp(from, length),
                end = length,
                num, target, targetArray, sourceArray;
            if (to !== undefined) end = clamp(to, length);
            if (begin > end) return new ArrayBuffer(0);
            num = end - begin;
            target = new ArrayBuffer(num);
            targetArray = new Uint8Array(target);
            sourceArray =
                new Uint8Array(this, begin, num);
            targetArray.set(sourceArray);
            return target
        }
    })();

    function toUtf8(str) {
        if (/[\u0080-\uFFFF]/.test(str)) str = unescape(encodeURIComponent(str));
        return str
    }

    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length,
            buff = new ArrayBuffer(length),
            arr = new Uint8Array(buff),
            i;
        for (i = 0; i < length; i += 1) arr[i] = str.charCodeAt(i);
        return returnUInt8Array ? arr : buff
    }

    function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff))
    }

    function concatenateArrayBuffers(first,
        second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);
        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);
        return returnUInt8Array ? result : result.buffer
    }

    function hexToBinaryString(hex) {
        var bytes = [],
            length = hex.length,
            x;
        for (x = 0; x < length - 1; x += 2) bytes.push(parseInt(hex.substr(x, 2), 16));
        return String.fromCharCode.apply(String, bytes)
    }

    function SparkMD5() {
        this.reset()
    }
    SparkMD5.prototype.append = function(str) {
        this.appendBinary(toUtf8(str));
        return this
    };
    SparkMD5.prototype.appendBinary = function(contents) {
        this._buff += contents;
        this._length += contents.length;
        var length = this._buff.length,
            i;
        for (i = 64; i <= length; i += 64) md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        this._buff = this._buff.substring(i - 64);
        return this
    };
    SparkMD5.prototype.end = function(raw) {
        var buff = this._buff,
            length = buff.length,
            i, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ret;
        for (i = 0; i < length; i += 1) tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);
        this._finish(tail, length);
        ret = hex(this._hash);
        if (raw) ret =
            hexToBinaryString(ret);
        this.reset();
        return ret
    };
    SparkMD5.prototype.reset = function() {
        this._buff = "";
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this
    };
    SparkMD5.prototype.getState = function() {
        return {
            buff: this._buff,
            length: this._length,
            hash: this._hash
        }
    };
    SparkMD5.prototype.setState = function(state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;
        return this
    };
    SparkMD5.prototype.destroy = function() {
        delete this._hash;
        delete this._buff;
        delete this._length
    };
    SparkMD5.prototype._finish = function(tail, length) {
        var i = length,
            tmp, lo, hi;
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
            md5cycle(this._hash, tail);
            for (i = 0; i < 16; i += 1) tail[i] = 0
        }
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail)
    };
    SparkMD5.hash = function(str, raw) {
        return SparkMD5.hashBinary(toUtf8(str), raw)
    };
    SparkMD5.hashBinary = function(content, raw) {
        var hash = md51(content),
            ret = hex(hash);
        return raw ? hexToBinaryString(ret) :
            ret
    };
    SparkMD5.ArrayBuffer = function() {
        this.reset()
    };
    SparkMD5.ArrayBuffer.prototype.append = function(arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
            length = buff.length,
            i;
        this._length += arr.byteLength;
        for (i = 64; i <= length; i += 64) md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        this._buff = i - 64 < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);
        return this
    };
    SparkMD5.ArrayBuffer.prototype.end = function(raw) {
        var buff = this._buff,
            length = buff.length,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0
            ],
            i, ret;
        for (i = 0; i < length; i += 1) tail[i >> 2] |= buff[i] << (i % 4 << 3);
        this._finish(tail, length);
        ret = hex(this._hash);
        if (raw) ret = hexToBinaryString(ret);
        this.reset();
        return ret
    };
    SparkMD5.ArrayBuffer.prototype.reset = function() {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this
    };
    SparkMD5.ArrayBuffer.prototype.getState = function() {
        var state = SparkMD5.prototype.getState.call(this);
        state.buff = arrayBuffer2Utf8Str(state.buff);
        return state
    };
    SparkMD5.ArrayBuffer.prototype.setState =
        function(state) {
            state.buff = utf8Str2ArrayBuffer(state.buff, true);
            return SparkMD5.prototype.setState.call(this, state)
        };
    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;
    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;
    SparkMD5.ArrayBuffer.hash = function(arr, raw) {
        var hash = md51_array(new Uint8Array(arr)),
            ret = hex(hash);
        return raw ? hexToBinaryString(ret) : ret
    };
    return SparkMD5
});
(function() {
    var lastTime = 0;
    var vendors = ["webkit", "moz"];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
        window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"]
    }
    if (!window.requestAnimationFrame) window.requestAnimationFrame = function(callback, element) {
        var currTime = (new Date).getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function() {
            callback(currTime +
                timeToCall)
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id
    };
    if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) {
        clearTimeout(id)
    }
})();
window.matchMedia || (window.matchMedia = function() {
    var styleMedia = window.styleMedia || window.media;
    if (!styleMedia) {
        var style = document.createElement("style"),
            script = document.getElementsByTagName("script")[0],
            info = null;
        style.type = "text/css";
        style.id = "matchmediajs-test";
        script.parentNode.insertBefore(style, script);
        info = "getComputedStyle" in window && window.getComputedStyle(style, null) || style.currentStyle;
        styleMedia = {
            matchMedium: function(media) {
                var text = "@media " + media + "{ #matchmediajs-test { width: 1px; } }";
                if (style.styleSheet) style.styleSheet.cssText = text;
                else style.textContent = text;
                return info.width === "1px"
            }
        }
    }
    return function(media) {
        return {
            matches: styleMedia.matchMedium(media || "all"),
            media: media || "all"
        }
    }
}());
(function() {
    if (window.matchMedia && window.matchMedia("all").addListener) return false;
    var localMatchMedia = window.matchMedia,
        hasMediaQueries = localMatchMedia("only all").matches,
        isListening = false,
        timeoutID = 0,
        queries = [],
        handleChange = function(evt) {
            clearTimeout(timeoutID);
            timeoutID = setTimeout(function() {
                for (var i = 0, il = queries.length; i < il; i++) {
                    var mql = queries[i].mql,
                        listeners = queries[i].listeners || [],
                        matches = localMatchMedia(mql.media).matches;
                    if (matches !== mql.matches) {
                        mql.matches = matches;
                        for (var j = 0, jl = listeners.length; j <
                            jl; j++) listeners[j].call(window, mql)
                    }
                }
            }, 30)
        };
    window.matchMedia = function(media) {
        var mql = localMatchMedia(media),
            listeners = [],
            index = 0;
        mql.addListener = function(listener) {
            if (!hasMediaQueries) return;
            if (!isListening) {
                isListening = true;
                window.addEventListener("resize", handleChange, true)
            }
            if (index === 0) index = queries.push({
                mql: mql,
                listeners: listeners
            });
            listeners.push(listener)
        };
        mql.removeListener = function(listener) {
            for (var i = 0, il = listeners.length; i < il; i++)
                if (listeners[i] === listener) listeners.splice(i, 1)
        };
        return mql
    }
})();
(function() {
    var undefined;
    var VERSION = "4.13.1";
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var PLACEHOLDER = "__lodash_placeholder__";
    var BIND_FLAG = 1,
        BIND_KEY_FLAG = 2,
        CURRY_BOUND_FLAG = 4,
        CURRY_FLAG = 8,
        CURRY_RIGHT_FLAG = 16,
        PARTIAL_FLAG = 32,
        PARTIAL_RIGHT_FLAG = 64,
        ARY_FLAG = 128,
        REARG_FLAG = 256,
        FLIP_FLAG = 512;
    var UNORDERED_COMPARE_FLAG = 1,
        PARTIAL_COMPARE_FLAG = 2;
    var DEFAULT_TRUNC_LENGTH = 30,
        DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 150,
        HOT_SPAN =
        16;
    var LAZY_FILTER_FLAG = 1,
        LAZY_MAP_FLAG = 2,
        LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0,
        MAX_SAFE_INTEGER = 9007199254740991,
        MAX_INTEGER = 1.7976931348623157E308,
        NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var argsTag = "[object Arguments]",
        arrayTag = "[object Array]",
        boolTag = "[object Boolean]",
        dateTag = "[object Date]",
        errorTag = "[object Error]",
        funcTag = "[object Function]",
        genTag = "[object GeneratorFunction]",
        mapTag = "[object Map]",
        numberTag = "[object Number]",
        objectTag = "[object Object]",
        promiseTag = "[object Promise]",
        regexpTag = "[object RegExp]",
        setTag = "[object Set]",
        stringTag = "[object String]",
        symbolTag = "[object Symbol]",
        weakMapTag = "[object WeakMap]",
        weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]",
        dataViewTag = "[object DataView]",
        float32Tag = "[object Float32Array]",
        float64Tag = "[object Float64Array]",
        int8Tag = "[object Int8Array]",
        int16Tag = "[object Int16Array]",
        int32Tag = "[object Int32Array]",
        uint8Tag = "[object Uint8Array]",
        uint8ClampedTag =
        "[object Uint8ClampedArray]",
        uint16Tag = "[object Uint16Array]",
        uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g,
        reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
        reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
        reUnescapedHtml = /[&<>"'`]/g,
        reHasEscapedHtml = RegExp(reEscapedHtml.source),
        reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g,
        reEvaluate = /<%([\s\S]+?)%>/g,
        reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp =
        /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/,
        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(\.|\[\])(?:\4|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
        reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrim = /^\s+|\s+$/g,
        reTrimStart = /^\s+/,
        reTrimEnd = /\s+$/;
    var reBasicWord = /[a-zA-Z0-9]+/g;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reHasHexPrefix = /^0x/i;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff",
        rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23",
        rsComboSymbolsRange = "\\u20d0-\\u20f0",
        rsDingbatRange = "\\u2700-\\u27bf",
        rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff",
        rsMathOpRange = "\\xac\\xb1\\xd7\\xf7",
        rsNonCharRange =
        "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
        rsPunctuationRange = "\\u2000-\\u206f",
        rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
        rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde",
        rsVarRange = "\\ufe0e\\ufe0f",
        rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['’]",
        rsAstral = "[" + rsAstralRange + "]",
        rsBreak = "[" + rsBreakRange + "]",
        rsCombo = "[" + rsComboMarksRange +
        rsComboSymbolsRange + "]",
        rsDigits = "\\d+",
        rsDingbat = "[" + rsDingbatRange + "]",
        rsLower = "[" + rsLowerRange + "]",
        rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]",
        rsFitz = "\\ud83c[\\udffb-\\udfff]",
        rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")",
        rsNonAstral = "[^" + rsAstralRange + "]",
        rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
        rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
        rsUpper = "[" + rsUpperRange + "]",
        rsZWJ = "\\u200d";
    var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")",
        rsUpperMisc = "(?:" +
        rsUpper + "|" + rsMisc + ")",
        rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?",
        rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?",
        reOptMod = rsModifier + "?",
        rsOptVar = "[" + rsVarRange + "]?",
        rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*",
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq,
        rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos,
        "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reComplexSymbol = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reComplexWord = RegExp([rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")", rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")", rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr, rsUpper + "+" + rsOptUpperContr, rsDigits, rsEmoji].join("|"), "g");
    var reHasComplexSymbol = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange +
        rsVarRange + "]");
    var reHasComplexWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "Reflect", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "isFinite", "parseInt", "setTimeout"];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] =
        typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
        typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] =
        cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss"
    };
    var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "`": "&#96;"
    };
    var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'",
        "&#96;": "`"
    };
    var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
    };
    var freeParseFloat =
        parseFloat,
        freeParseInt = parseInt;
    var freeExports = typeof exports == "object" && exports;
    var freeModule = freeExports && typeof module == "object" && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeGlobal = checkGlobal(typeof global == "object" && global);
    var freeSelf = checkGlobal(typeof self == "object" && self);
    var thisGlobal = checkGlobal(typeof this == "object" && this);
    var root = freeGlobal || freeSelf || thisGlobal || Function("return this")();

    function addMapEntry(map, pair) {
        map.set(pair[0], pair[1]);
        return map
    }

    function addSetEntry(set, value) {
        set.add(value);
        return set
    }

    function apply(func, thisArg, args) {
        var length = args.length;
        switch (length) {
            case 0:
                return func.call(thisArg);
            case 1:
                return func.call(thisArg, args[0]);
            case 2:
                return func.call(thisArg, args[0], args[1]);
            case 3:
                return func.call(thisArg, args[0], args[1], args[2])
        }
        return func.apply(thisArg, args)
    }

    function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1,
            length = array ? array.length : 0;
        while (++index < length) {
            var value = array[index];
            setter(accumulator,
                value, iteratee(value), array)
        }
        return accumulator
    }

    function arrayEach(array, iteratee) {
        var index = -1,
            length = array ? array.length : 0;
        while (++index < length)
            if (iteratee(array[index], index, array) === false) break;
        return array
    }

    function arrayEachRight(array, iteratee) {
        var length = array ? array.length : 0;
        while (length--)
            if (iteratee(array[length], length, array) === false) break;
        return array
    }

    function arrayEvery(array, predicate) {
        var index = -1,
            length = array ? array.length : 0;
        while (++index < length)
            if (!predicate(array[index], index, array)) return false;
        return true
    }

    function arrayFilter(array, predicate) {
        var index = -1,
            length = array ? array.length : 0,
            resIndex = 0,
            result = [];
        while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) result[resIndex++] = value
        }
        return result
    }

    function arrayIncludes(array, value) {
        var length = array ? array.length : 0;
        return !!length && baseIndexOf(array, value, 0) > -1
    }

    function arrayIncludesWith(array, value, comparator) {
        var index = -1,
            length = array ? array.length : 0;
        while (++index < length)
            if (comparator(value, array[index])) return true;
        return false
    }

    function arrayMap(array, iteratee) {
        var index = -1,
            length = array ? array.length : 0,
            result = Array(length);
        while (++index < length) result[index] = iteratee(array[index], index, array);
        return result
    }

    function arrayPush(array, values) {
        var index = -1,
            length = values.length,
            offset = array.length;
        while (++index < length) array[offset + index] = values[index];
        return array
    }

    function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1,
            length = array ? array.length : 0;
        if (initAccum && length) accumulator = array[++index];
        while (++index <
            length) accumulator = iteratee(accumulator, array[index], index, array);
        return accumulator
    }

    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array ? array.length : 0;
        if (initAccum && length) accumulator = array[--length];
        while (length--) accumulator = iteratee(accumulator, array[length], length, array);
        return accumulator
    }

    function arraySome(array, predicate) {
        var index = -1,
            length = array ? array.length : 0;
        while (++index < length)
            if (predicate(array[index], index, array)) return true;
        return false
    }

    function baseFindKey(collection,
        predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) {
                result = key;
                return false
            }
        });
        return result
    }

    function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length)
            if (predicate(array[index], index, array)) return index;
        return -1
    }

    function baseIndexOf(array, value, fromIndex) {
        if (value !== value) return indexOfNaN(array, fromIndex);
        var index = fromIndex - 1,
            length =
            array.length;
        while (++index < length)
            if (array[index] === value) return index;
        return -1
    }

    function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1,
            length = array.length;
        while (++index < length)
            if (comparator(array[index], value)) return index;
        return -1
    }

    function baseMean(array, iteratee) {
        var length = array ? array.length : 0;
        return length ? baseSum(array, iteratee) / length : NAN
    }

    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection) {
            accumulator =
                initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection)
        });
        return accumulator
    }

    function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) array[length] = array[length].value;
        return array
    }

    function baseSum(array, iteratee) {
        var result, index = -1,
            length = array.length;
        while (++index < length) {
            var current = iteratee(array[index]);
            if (current !== undefined) result = result === undefined ? current : result + current
        }
        return result
    }

    function baseTimes(n, iteratee) {
        var index = -1,
            result = Array(n);
        while (++index < n) result[index] = iteratee(index);
        return result
    }

    function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
            return [key, object[key]]
        })
    }

    function baseUnary(func) {
        return function(value) {
            return func(value)
        }
    }

    function baseValues(object, props) {
        return arrayMap(props, function(key) {
            return object[key]
        })
    }

    function cacheHas(cache, key) {
        return cache.has(key)
    }

    function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1,
            length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols,
                strSymbols[index], 0) > -1);
        return index
    }

    function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1);
        return index
    }

    function checkGlobal(value) {
        return value && value.Object === Object ? value : null
    }

    function countHolders(array, placeholder) {
        var length = array.length,
            result = 0;
        while (length--)
            if (array[length] === placeholder) result++;
        return result
    }

    function deburrLetter(letter) {
        return deburredLetters[letter]
    }

    function escapeHtmlChar(chr) {
        return htmlEscapes[chr]
    }

    function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr]
    }

    function getValue(object, key) {
        return object == null ? undefined : object[key]
    }

    function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
            var other = array[index];
            if (other !== other) return index
        }
        return -1
    }

    function isHostObject(value) {
        var result = false;
        if (value != null && typeof value.toString != "function") try {
            result = !!(value + "")
        } catch (e) {}
        return result
    }

    function iteratorToArray(iterator) {
        var data,
            result = [];
        while (!(data = iterator.next()).done) result.push(data.value);
        return result
    }

    function mapToArray(map) {
        var index = -1,
            result = Array(map.size);
        map.forEach(function(value, key) {
            result[++index] = [key, value]
        });
        return result
    }

    function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = 0,
            result = [];
        while (++index < length) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
                array[index] = PLACEHOLDER;
                result[resIndex++] = index
            }
        }
        return result
    }

    function setToArray(set) {
        var index = -1,
            result = Array(set.size);
        set.forEach(function(value) {
            result[++index] = value
        });
        return result
    }

    function setToPairs(set) {
        var index = -1,
            result = Array(set.size);
        set.forEach(function(value) {
            result[++index] = [value, value]
        });
        return result
    }

    function stringSize(string) {
        if (!(string && reHasComplexSymbol.test(string))) return string.length;
        var result = reComplexSymbol.lastIndex = 0;
        while (reComplexSymbol.test(string)) result++;
        return result
    }

    function stringToArray(string) {
        return string.match(reComplexSymbol)
    }

    function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr]
    }

    function runInContext(context) {
        context = context ? _.defaults({}, context, _.pick(root, contextProps)) : root;
        var Date = context.Date,
            Error = context.Error,
            Math = context.Math,
            RegExp = context.RegExp,
            TypeError = context.TypeError;
        var arrayProto = context.Array.prototype,
            objectProto = context.Object.prototype,
            stringProto = context.String.prototype;
        var coreJsData = context["__core-js_shared__"];
        var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." +
                uid : ""
        }();
        var funcToString = context.Function.prototype.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var objectCtorString = funcToString.call(Object);
        var objectToString = objectProto.toString;
        var oldDash = root._;
        var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var Buffer = moduleExports ? context.Buffer : undefined,
            Reflect = context.Reflect,
            Symbol = context.Symbol,
            Uint8Array =
            context.Uint8Array,
            enumerate = Reflect ? Reflect.enumerate : undefined,
            getOwnPropertySymbols = Object.getOwnPropertySymbols,
            iteratorSymbol = typeof(iteratorSymbol = Symbol && Symbol.iterator) == "symbol" ? iteratorSymbol : undefined,
            objectCreate = Object.create,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            splice = arrayProto.splice;
        var setTimeout = function(func, wait) {
            return context.setTimeout.call(root, func, wait)
        };
        var nativeCeil = Math.ceil,
            nativeFloor = Math.floor,
            nativeGetPrototype = Object.getPrototypeOf,
            nativeIsFinite =
            context.isFinite,
            nativeJoin = arrayProto.join,
            nativeKeys = Object.keys,
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random,
            nativeReplace = stringProto.replace,
            nativeReverse = arrayProto.reverse,
            nativeSplit = stringProto.split;
        var DataView = getNative(context, "DataView"),
            Map = getNative(context, "Map"),
            Promise = getNative(context, "Promise"),
            Set = getNative(context, "Set"),
            WeakMap = getNative(context, "WeakMap"),
            nativeCreate = getNative(Object, "create");
        var metaMap = WeakMap && new WeakMap;
        var nonEnumShadows = !propertyIsEnumerable.call({
            "valueOf": 1
        }, "valueOf");
        var realNames = {};
        var dataViewCtorString = toSource(DataView),
            mapCtorString = toSource(Map),
            promiseCtorString = toSource(Promise),
            setCtorString = toSource(Set),
            weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol ? Symbol.prototype : undefined,
            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
            symbolToString = symbolProto ? symbolProto.toString : undefined;

        function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                if (value instanceof LodashWrapper) return value;
                if (hasOwnProperty.call(value, "__wrapped__")) return wrapperClone(value)
            }
            return new LodashWrapper(value)
        }

        function baseLodash() {}

        function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined
        }
        lodash.templateSettings = {
            "escape": reEscape,
            "evaluate": reEvaluate,
            "interpolate": reInterpolate,
            "variable": "",
            "imports": {
                "_": lodash
            }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;

        function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = []
        }

        function lazyClone() {
            var result = new LazyWrapper(this.__wrapped__);
            result.__actions__ = copyArray(this.__actions__);
            result.__dir__ = this.__dir__;
            result.__filtered__ = this.__filtered__;
            result.__iteratees__ = copyArray(this.__iteratees__);
            result.__takeCount__ = this.__takeCount__;
            result.__views__ = copyArray(this.__views__);
            return result
        }

        function lazyReverse() {
            if (this.__filtered__) {
                var result = new LazyWrapper(this);
                result.__dir__ = -1;
                result.__filtered__ = true
            } else {
                result = this.clone();
                result.__dir__ *= -1
            }
            return result
        }

        function lazyValue() {
            var array = this.__wrapped__.value(),
                dir = this.__dir__,
                isArr = isArray(array),
                isRight = dir < 0,
                arrLength = isArr ? array.length : 0,
                view = getView(0, arrLength, this.__views__),
                start = view.start,
                end = view.end,
                length = end - start,
                index = isRight ? end : start - 1,
                iteratees = this.__iteratees__,
                iterLength = iteratees.length,
                resIndex = 0,
                takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || arrLength < LARGE_ARRAY_SIZE || arrLength == length && takeCount == length) return baseWrapperValue(array, this.__actions__);
            var result = [];
            outer: while (length-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1,
                    value = array[index];
                while (++iterIndex < iterLength) {
                    var data = iteratees[iterIndex],
                        iteratee = data.iteratee,
                        type =
                        data.type,
                        computed = iteratee(value);
                    if (type == LAZY_MAP_FLAG) value = computed;
                    else if (!computed)
                        if (type == LAZY_FILTER_FLAG) continue outer;
                        else break outer
                }
                result[resIndex++] = value
            }
            return result
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;

        function Hash(entries) {
            var index = -1,
                length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1])
            }
        }

        function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {}
        }

        function hashDelete(key) {
            return this.has(key) && delete this.__data__[key]
        }

        function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
                var result = data[key];
                return result === HASH_UNDEFINED ? undefined : result
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined
        }

        function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key)
        }

        function hashSet(key, value) {
            var data = this.__data__;
            data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
            return this
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;

        function ListCache(entries) {
            var index = -1,
                length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1])
            }
        }

        function listCacheClear() {
            this.__data__ = []
        }

        function listCacheDelete(key) {
            var data = this.__data__,
                index = assocIndexOf(data, key);
            if (index < 0) return false;
            var lastIndex = data.length - 1;
            if (index == lastIndex) data.pop();
            else splice.call(data, index, 1);
            return true
        }

        function listCacheGet(key) {
            var data = this.__data__,
                index = assocIndexOf(data, key);
            return index < 0 ? undefined : data[index][1]
        }

        function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1
        }

        function listCacheSet(key, value) {
            var data = this.__data__,
                index = assocIndexOf(data, key);
            if (index < 0) data.push([key, value]);
            else data[index][1] = value;
            return this
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;

        function MapCache(entries) {
            var index = -1,
                length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1])
            }
        }

        function mapCacheClear() {
            this.__data__ = {
                "hash": new Hash,
                "map": new(Map || ListCache),
                "string": new Hash
            }
        }

        function mapCacheDelete(key) {
            return getMapData(this, key)["delete"](key)
        }

        function mapCacheGet(key) {
            return getMapData(this, key).get(key)
        }

        function mapCacheHas(key) {
            return getMapData(this,
                key).has(key)
        }

        function mapCacheSet(key, value) {
            getMapData(this, key).set(key, value);
            return this
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;

        function SetCache(values) {
            var index = -1,
                length = values ? values.length : 0;
            this.__data__ = new MapCache;
            while (++index < length) this.add(values[index])
        }

        function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this
        }

        function setCacheHas(value) {
            return this.__data__.has(value)
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;

        function Stack(entries) {
            this.__data__ = new ListCache(entries)
        }

        function stackClear() {
            this.__data__ = new ListCache
        }

        function stackDelete(key) {
            return this.__data__["delete"](key)
        }

        function stackGet(key) {
            return this.__data__.get(key)
        }

        function stackHas(key) {
            return this.__data__.has(key)
        }

        function stackSet(key, value) {
            var cache = this.__data__;
            if (cache instanceof ListCache && cache.__data__.length == LARGE_ARRAY_SIZE) cache = this.__data__ = new MapCache(cache.__data__);
            cache.set(key, value);
            return this
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;

        function assignInDefaults(objValue, srcValue, key, object) {
            if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) return srcValue;
            return objValue
        }

        function assignMergeValue(object,
            key, value) {
            if (value !== undefined && !eq(object[key], value) || typeof key == "number" && value === undefined && !(key in object)) object[key] = value
        }

        function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) object[key] = value
        }

        function assocIndexOf(array, key) {
            var length = array.length;
            while (length--)
                if (eq(array[length][0], key)) return length;
            return -1
        }

        function baseAggregator(collection, setter, iteratee, accumulator) {
            baseEach(collection,
                function(value, key, collection) {
                    setter(accumulator, value, iteratee(value), collection)
                });
            return accumulator
        }

        function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object)
        }

        function baseAt(object, paths) {
            var index = -1,
                isNil = object == null,
                length = paths.length,
                result = Array(length);
            while (++index < length) result[index] = isNil ? undefined : get(object, paths[index]);
            return result
        }

        function baseClamp(number, lower, upper) {
            if (number === number) {
                if (upper !== undefined) number = number <= upper ? number : upper;
                if (lower !== undefined) number = number >= lower ? number : lower
            }
            return number
        }

        function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
            var result;
            if (customizer) result = object ? customizer(value, key, object, stack) : customizer(value);
            if (result !== undefined) return result;
            if (!isObject(value)) return value;
            var isArr = isArray(value);
            if (isArr) {
                result = initCloneArray(value);
                if (!isDeep) return copyArray(value, result)
            } else {
                var tag = getTag(value),
                    isFunc = tag == funcTag || tag == genTag;
                if (isBuffer(value)) return cloneBuffer(value,
                    isDeep);
                if (tag == objectTag || tag == argsTag || isFunc && !object) {
                    if (isHostObject(value)) return object ? value : {};
                    result = initCloneObject(isFunc ? {} : value);
                    if (!isDeep) return copySymbols(value, baseAssign(result, value))
                } else {
                    if (!cloneableTags[tag]) return object ? value : {};
                    result = initCloneByTag(value, tag, baseClone, isDeep)
                }
            }
            stack || (stack = new Stack);
            var stacked = stack.get(value);
            if (stacked) return stacked;
            stack.set(value, result);
            if (!isArr) var props = isFull ? getAllKeys(value) : keys(value);
            arrayEach(props || value, function(subValue,
                key) {
                if (props) {
                    key = subValue;
                    subValue = value[key]
                }
                assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack))
            });
            return result
        }

        function baseConforms(source) {
            var props = keys(source),
                length = props.length;
            return function(object) {
                if (object == null) return !length;
                var index = length;
                while (index--) {
                    var key = props[index],
                        predicate = source[key],
                        value = object[key];
                    if (value === undefined && !(key in Object(object)) || !predicate(value)) return false
                }
                return true
            }
        }

        function baseCreate(proto) {
            return isObject(proto) ?
                objectCreate(proto) : {}
        }

        function baseDelay(func, wait, args) {
            if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
            return setTimeout(function() {
                func.apply(undefined, args)
            }, wait)
        }

        function baseDifference(array, values, iteratee, comparator) {
            var index = -1,
                includes = arrayIncludes,
                isCommon = true,
                length = array.length,
                result = [],
                valuesLength = values.length;
            if (!length) return result;
            if (iteratee) values = arrayMap(values, baseUnary(iteratee));
            if (comparator) {
                includes = arrayIncludesWith;
                isCommon = false
            } else if (values.length >=
                LARGE_ARRAY_SIZE) {
                includes = cacheHas;
                isCommon = false;
                values = new SetCache(values)
            }
            outer: while (++index < length) {
                var value = array[index],
                    computed = iteratee ? iteratee(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                    var valuesIndex = valuesLength;
                    while (valuesIndex--)
                        if (values[valuesIndex] === computed) continue outer;
                    result.push(value)
                } else if (!includes(values, computed, comparator)) result.push(value)
            }
            return result
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight,
            true);

        function baseEvery(collection, predicate) {
            var result = true;
            baseEach(collection, function(value, index, collection) {
                result = !!predicate(value, index, collection);
                return result
            });
            return result
        }

        function baseExtremum(array, iteratee, comparator) {
            var index = -1,
                length = array.length;
            while (++index < length) {
                var value = array[index],
                    current = iteratee(value);
                if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) var computed = current,
                    result = value
            }
            return result
        }

        function baseFill(array,
            value, start, end) {
            var length = array.length;
            start = toInteger(start);
            if (start < 0) start = -start > length ? 0 : length + start;
            end = end === undefined || end > length ? length : toInteger(end);
            if (end < 0) end += length;
            end = start > end ? 0 : toLength(end);
            while (start < end) array[start++] = value;
            return array
        }

        function baseFilter(collection, predicate) {
            var result = [];
            baseEach(collection, function(value, index, collection) {
                if (predicate(value, index, collection)) result.push(value)
            });
            return result
        }

        function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1,
                length = array.length;
            predicate || (predicate = isFlattenable);
            result || (result = []);
            while (++index < length) {
                var value = array[index];
                if (depth > 0 && predicate(value))
                    if (depth > 1) baseFlatten(value, depth - 1, predicate, isStrict, result);
                    else arrayPush(result, value);
                else if (!isStrict) result[result.length] = value
            }
            return result
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);

        function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys)
        }

        function baseForOwnRight(object, iteratee) {
            return object &&
                baseForRight(object, iteratee, keys)
        }

        function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
                return isFunction(object[key])
            })
        }

        function baseGet(object, path) {
            path = isKey(path, object) ? [path] : castPath(path);
            var index = 0,
                length = path.length;
            while (object != null && index < length) object = object[toKey(path[index++])];
            return index && index == length ? object : undefined
        }

        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object))
        }

        function baseGt(value, other) {
            return value > other
        }

        function baseHas(object, key) {
            return object != null && (hasOwnProperty.call(object, key) || typeof object == "object" && key in object && getPrototype(object) === null)
        }

        function baseHasIn(object, key) {
            return object != null && key in Object(object)
        }

        function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end)
        }

        function baseIntersection(arrays, iteratee, comparator) {
            var includes = comparator ? arrayIncludesWith : arrayIncludes,
                length = arrays[0].length,
                othLength = arrays.length,
                othIndex = othLength,
                caches = Array(othLength),
                maxLength = Infinity,
                result = [];
            while (othIndex--) {
                var array = arrays[othIndex];
                if (othIndex && iteratee) array = arrayMap(array, baseUnary(iteratee));
                maxLength = nativeMin(array.length, maxLength);
                caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined
            }
            array = arrays[0];
            var index = -1,
                seen = caches[0];
            outer: while (++index < length && result.length < maxLength) {
                var value = array[index],
                    computed = iteratee ? iteratee(value) :
                    value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                    othIndex = othLength;
                    while (--othIndex) {
                        var cache = caches[othIndex];
                        if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) continue outer
                    }
                    if (seen) seen.push(computed);
                    result.push(value)
                }
            }
            return result
        }

        function baseInverter(object, setter, iteratee, accumulator) {
            baseForOwn(object, function(value, key, object) {
                setter(accumulator, iteratee(value), key, object)
            });
            return accumulator
        }

        function baseInvoke(object, path, args) {
            if (!isKey(path, object)) {
                path = castPath(path);
                object = parent(object, path);
                path = last(path)
            }
            var func = object == null ? object : object[toKey(path)];
            return func == null ? undefined : apply(func, object, args)
        }

        function baseIsEqual(value, other, customizer, bitmask, stack) {
            if (value === other) return true;
            if (value == null || other == null || !isObject(value) && !isObjectLike(other)) return value !== value && other !== other;
            return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack)
        }

        function baseIsEqualDeep(object,
            other, equalFunc, customizer, bitmask, stack) {
            var objIsArr = isArray(object),
                othIsArr = isArray(other),
                objTag = arrayTag,
                othTag = arrayTag;
            if (!objIsArr) {
                objTag = getTag(object);
                objTag = objTag == argsTag ? objectTag : objTag
            }
            if (!othIsArr) {
                othTag = getTag(other);
                othTag = othTag == argsTag ? objectTag : othTag
            }
            var objIsObj = objTag == objectTag && !isHostObject(object),
                othIsObj = othTag == objectTag && !isHostObject(other),
                isSameTag = objTag == othTag;
            if (isSameTag && !objIsObj) {
                stack || (stack = new Stack);
                return objIsArr || isTypedArray(object) ? equalArrays(object,
                    other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack)
            }
            if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
                var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"),
                    othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object,
                        othUnwrapped = othIsWrapped ? other.value() : other;
                    stack || (stack = new Stack);
                    return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack)
                }
            }
            if (!isSameTag) return false;
            stack || (stack = new Stack);
            return equalObjects(object, other, equalFunc, customizer, bitmask, stack)
        }

        function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length,
                length = index,
                noCustomizer = !customizer;
            if (object == null) return !length;
            object = Object(object);
            while (index--) {
                var data = matchData[index];
                if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return false
            }
            while (++index < length) {
                data = matchData[index];
                var key = data[0],
                    objValue = object[key],
                    srcValue = data[1];
                if (noCustomizer &&
                    data[2]) {
                    if (objValue === undefined && !(key in object)) return false
                } else {
                    var stack = new Stack;
                    if (customizer) var result = customizer(objValue, srcValue, key, object, source, stack);
                    if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) return false
                }
            }
            return true
        }

        function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) return false;
            var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value))
        }

        function baseIteratee(value) {
            if (typeof value == "function") return value;
            if (value == null) return identity;
            if (typeof value == "object") return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            return property(value)
        }

        function baseKeys(object) {
            return nativeKeys(Object(object))
        }

        function baseKeysIn(object) {
            object = object == null ? object : Object(object);
            var result = [];
            for (var key in object) result.push(key);
            return result
        }
        if (enumerate && !propertyIsEnumerable.call({
                "valueOf": 1
            }, "valueOf")) baseKeysIn =
            function(object) {
                return iteratorToArray(enumerate(object))
            };

        function baseLt(value, other) {
            return value < other
        }

        function baseMap(collection, iteratee) {
            var index = -1,
                result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function(value, key, collection) {
                result[++index] = iteratee(value, key, collection)
            });
            return result
        }

        function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            return function(object) {
                return object ===
                    source || baseIsMatch(object, source, matchData)
            }
        }

        function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) return matchesStrictComparable(toKey(path), srcValue);
            return function(object) {
                var objValue = get(object, path);
                return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG)
            }
        }

        function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) return;
            if (!(isArray(source) ||
                    isTypedArray(source))) var props = keysIn(source);
            arrayEach(props || source, function(srcValue, key) {
                if (props) {
                    key = srcValue;
                    srcValue = source[key]
                }
                if (isObject(srcValue)) {
                    stack || (stack = new Stack);
                    baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack)
                } else {
                    var newValue = customizer ? customizer(object[key], srcValue, key + "", object, source, stack) : undefined;
                    if (newValue === undefined) newValue = srcValue;
                    assignMergeValue(object, key, newValue)
                }
            })
        }

        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer,
            stack) {
            var objValue = object[key],
                srcValue = source[key],
                stacked = stack.get(srcValue);
            if (stacked) {
                assignMergeValue(object, key, stacked);
                return
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined;
            var isCommon = newValue === undefined;
            if (isCommon) {
                newValue = srcValue;
                if (isArray(srcValue) || isTypedArray(srcValue))
                    if (isArray(objValue)) newValue = objValue;
                    else if (isArrayLikeObject(objValue)) newValue = copyArray(objValue);
                else {
                    isCommon = false;
                    newValue = baseClone(srcValue, true)
                } else if (isPlainObject(srcValue) ||
                    isArguments(srcValue))
                    if (isArguments(objValue)) newValue = toPlainObject(objValue);
                    else if (!isObject(objValue) || srcIndex && isFunction(objValue)) {
                    isCommon = false;
                    newValue = baseClone(srcValue, true)
                } else newValue = objValue;
                else isCommon = false
            }
            stack.set(srcValue, newValue);
            if (isCommon) mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
            assignMergeValue(object, key, newValue)
        }

        function baseNth(array, n) {
            var length = array.length;
            if (!length) return;
            n += n < 0 ? length : 0;
            return isIndex(n, length) ?
                array[n] : undefined
        }

        function baseOrderBy(collection, iteratees, orders) {
            var index = -1;
            iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
            var result = baseMap(collection, function(value, key, collection) {
                var criteria = arrayMap(iteratees, function(iteratee) {
                    return iteratee(value)
                });
                return {
                    "criteria": criteria,
                    "index": ++index,
                    "value": value
                }
            });
            return baseSortBy(result, function(object, other) {
                return compareMultiple(object, other, orders)
            })
        }

        function basePick(object, props) {
            object = Object(object);
            return arrayReduce(props, function(result, key) {
                if (key in object) result[key] = object[key];
                return result
            }, {})
        }

        function basePickBy(object, predicate) {
            var index = -1,
                props = getAllKeysIn(object),
                length = props.length,
                result = {};
            while (++index < length) {
                var key = props[index],
                    value = object[key];
                if (predicate(value, key)) result[key] = value
            }
            return result
        }

        function baseProperty(key) {
            return function(object) {
                return object == null ? undefined : object[key]
            }
        }

        function basePropertyDeep(path) {
            return function(object) {
                return baseGet(object,
                    path)
            }
        }

        function basePullAll(array, values, iteratee, comparator) {
            var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
                index = -1,
                length = values.length,
                seen = array;
            if (array === values) values = copyArray(values);
            if (iteratee) seen = arrayMap(array, baseUnary(iteratee));
            while (++index < length) {
                var fromIndex = 0,
                    value = values[index],
                    computed = iteratee ? iteratee(value) : value;
                while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
                    if (seen !== array) splice.call(seen, fromIndex, 1);
                    splice.call(array, fromIndex, 1)
                }
            }
            return array
        }

        function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0,
                lastIndex = length - 1;
            while (length--) {
                var index = indexes[length];
                if (length == lastIndex || index !== previous) {
                    var previous = index;
                    if (isIndex(index)) splice.call(array, index, 1);
                    else if (!isKey(index, array)) {
                        var path = castPath(index),
                            object = parent(array, path);
                        if (object != null) delete object[toKey(last(path))]
                    } else delete array[toKey(index)]
                }
            }
            return array
        }

        function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1))
        }

        function baseRange(start,
            end, step, fromRight) {
            var index = -1,
                length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
                result = Array(length);
            while (length--) {
                result[fromRight ? length : ++index] = start;
                start += step
            }
            return result
        }

        function baseRepeat(string, n) {
            var result = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) return result;
            do {
                if (n % 2) result += string;
                n = nativeFloor(n / 2);
                if (n) string += string
            } while (n);
            return result
        }

        function baseSet(object, path, value, customizer) {
            path = isKey(path, object) ? [path] : castPath(path);
            var index = -1,
                length = path.length,
                lastIndex =
                length - 1,
                nested = object;
            while (nested != null && ++index < length) {
                var key = toKey(path[index]);
                if (isObject(nested)) {
                    var newValue = value;
                    if (index != lastIndex) {
                        var objValue = nested[key];
                        newValue = customizer ? customizer(objValue, key, nested) : undefined;
                        if (newValue === undefined) newValue = objValue == null ? isIndex(path[index + 1]) ? [] : {} : objValue
                    }
                    assignValue(nested, key, newValue)
                }
                nested = nested[key]
            }
            return object
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func
        };

        function baseSlice(array,
            start, end) {
            var index = -1,
                length = array.length;
            if (start < 0) start = -start > length ? 0 : length + start;
            end = end > length ? length : end;
            if (end < 0) end += length;
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result = Array(length);
            while (++index < length) result[index] = array[index + start];
            return result
        }

        function baseSome(collection, predicate) {
            var result;
            baseEach(collection, function(value, index, collection) {
                result = predicate(value, index, collection);
                return !result
            });
            return !!result
        }

        function baseSortedIndex(array, value, retHighest) {
            var low =
                0,
                high = array ? array.length : low;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                while (low < high) {
                    var mid = low + high >>> 1,
                        computed = array[mid];
                    if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) low = mid + 1;
                    else high = mid
                }
                return high
            }
            return baseSortedIndexBy(array, value, identity, retHighest)
        }

        function baseSortedIndexBy(array, value, iteratee, retHighest) {
            value = iteratee(value);
            var low = 0,
                high = array ? array.length : 0,
                valIsNaN = value !== value,
                valIsNull = value === null,
                valIsSymbol = isSymbol(value),
                valIsUndefined = value === undefined;
            while (low < high) {
                var mid = nativeFloor((low + high) / 2),
                    computed = iteratee(array[mid]),
                    othIsDefined = computed !== undefined,
                    othIsNull = computed === null,
                    othIsReflexive = computed === computed,
                    othIsSymbol = isSymbol(computed);
                if (valIsNaN) var setLow = retHighest || othIsReflexive;
                else if (valIsUndefined) setLow = othIsReflexive && (retHighest || othIsDefined);
                else if (valIsNull) setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                else if (valIsSymbol) setLow = othIsReflexive &&
                    othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                else if (othIsNull || othIsSymbol) setLow = false;
                else setLow = retHighest ? computed <= value : computed < value;
                if (setLow) low = mid + 1;
                else high = mid
            }
            return nativeMin(high, MAX_ARRAY_INDEX)
        }

        function baseSortedUniq(array, iteratee) {
            var index = -1,
                length = array.length,
                resIndex = 0,
                result = [];
            while (++index < length) {
                var value = array[index],
                    computed = iteratee ? iteratee(value) : value;
                if (!index || !eq(computed, seen)) {
                    var seen = computed;
                    result[resIndex++] = value === 0 ? 0 : value
                }
            }
            return result
        }

        function baseToNumber(value) {
            if (typeof value == "number") return value;
            if (isSymbol(value)) return NAN;
            return +value
        }

        function baseToString(value) {
            if (typeof value == "string") return value;
            if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : "";
            var result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result
        }

        function baseUniq(array, iteratee, comparator) {
            var index = -1,
                includes = arrayIncludes,
                length = array.length,
                isCommon = true,
                result = [],
                seen = result;
            if (comparator) {
                isCommon = false;
                includes = arrayIncludesWith
            } else if (length >=
                LARGE_ARRAY_SIZE) {
                var set = iteratee ? null : createSet(array);
                if (set) return setToArray(set);
                isCommon = false;
                includes = cacheHas;
                seen = new SetCache
            } else seen = iteratee ? [] : result;
            outer: while (++index < length) {
                var value = array[index],
                    computed = iteratee ? iteratee(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                    var seenIndex = seen.length;
                    while (seenIndex--)
                        if (seen[seenIndex] === computed) continue outer;
                    if (iteratee) seen.push(computed);
                    result.push(value)
                } else if (!includes(seen, computed, comparator)) {
                    if (seen !==
                        result) seen.push(computed);
                    result.push(value)
                }
            }
            return result
        }

        function baseUnset(object, path) {
            path = isKey(path, object) ? [path] : castPath(path);
            object = parent(object, path);
            var key = toKey(last(path));
            return !(object != null && baseHas(object, key)) || delete object[key]
        }

        function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer)
        }

        function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length,
                index = fromRight ? length : -1;
            while ((fromRight ? index-- :
                    ++index < length) && predicate(array[index], index, array));
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index)
        }

        function baseWrapperValue(value, actions) {
            var result = value;
            if (result instanceof LazyWrapper) result = result.value();
            return arrayReduce(actions, function(result, action) {
                return action.func.apply(action.thisArg, arrayPush([result], action.args))
            }, result)
        }

        function baseXor(arrays, iteratee, comparator) {
            var index = -1,
                length = arrays.length;
            while (++index < length) var result = result ? arrayPush(baseDifference(result, arrays[index], iteratee, comparator), baseDifference(arrays[index], result, iteratee, comparator)) : arrays[index];
            return result && result.length ? baseUniq(result, iteratee, comparator) : []
        }

        function baseZipObject(props, values, assignFunc) {
            var index = -1,
                length = props.length,
                valsLength = values.length,
                result = {};
            while (++index < length) {
                var value = index < valsLength ? values[index] : undefined;
                assignFunc(result, props[index], value)
            }
            return result
        }

        function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ?
                value : []
        }

        function castFunction(value) {
            return typeof value == "function" ? value : identity
        }

        function castPath(value) {
            return isArray(value) ? value : stringToPath(value)
        }

        function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end)
        }

        function cloneBuffer(buffer, isDeep) {
            if (isDeep) return buffer.slice();
            var result = new buffer.constructor(buffer.length);
            buffer.copy(result);
            return result
        }

        function cloneArrayBuffer(arrayBuffer) {
            var result =
                new arrayBuffer.constructor(arrayBuffer.byteLength);
            (new Uint8Array(result)).set(new Uint8Array(arrayBuffer));
            return result
        }

        function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength)
        }

        function cloneMap(map, isDeep, cloneFunc) {
            var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
            return arrayReduce(array, addMapEntry, new map.constructor)
        }

        function cloneRegExp(regexp) {
            var result =
                new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result.lastIndex = regexp.lastIndex;
            return result
        }

        function cloneSet(set, isDeep, cloneFunc) {
            var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
            return arrayReduce(array, addSetEntry, new set.constructor)
        }

        function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {}
        }

        function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer,
                typedArray.byteOffset, typedArray.length)
        }

        function compareAscending(value, other) {
            if (value !== other) {
                var valIsDefined = value !== undefined,
                    valIsNull = value === null,
                    valIsReflexive = value === value,
                    valIsSymbol = isSymbol(value);
                var othIsDefined = other !== undefined,
                    othIsNull = other === null,
                    othIsReflexive = other === other,
                    othIsSymbol = isSymbol(other);
                if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined &&
                    othIsReflexive || !valIsReflexive) return 1;
                if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1
            }
            return 0
        }

        function compareMultiple(object, other, orders) {
            var index = -1,
                objCriteria = object.criteria,
                othCriteria = other.criteria,
                length = objCriteria.length,
                ordersLength = orders.length;
            while (++index < length) {
                var result = compareAscending(objCriteria[index],
                    othCriteria[index]);
                if (result) {
                    if (index >= ordersLength) return result;
                    var order = orders[index];
                    return result * (order == "desc" ? -1 : 1)
                }
            }
            return object.index - other.index
        }

        function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1,
                argsLength = args.length,
                holdersLength = holders.length,
                leftIndex = -1,
                leftLength = partials.length,
                rangeLength = nativeMax(argsLength - holdersLength, 0),
                result = Array(leftLength + rangeLength),
                isUncurried = !isCurried;
            while (++leftIndex < leftLength) result[leftIndex] = partials[leftIndex];
            while (++argsIndex <
                holdersLength)
                if (isUncurried || argsIndex < argsLength) result[holders[argsIndex]] = args[argsIndex];
            while (rangeLength--) result[leftIndex++] = args[argsIndex++];
            return result
        }

        function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1,
                argsLength = args.length,
                holdersIndex = -1,
                holdersLength = holders.length,
                rightIndex = -1,
                rightLength = partials.length,
                rangeLength = nativeMax(argsLength - holdersLength, 0),
                result = Array(rangeLength + rightLength),
                isUncurried = !isCurried;
            while (++argsIndex < rangeLength) result[argsIndex] =
                args[argsIndex];
            var offset = argsIndex;
            while (++rightIndex < rightLength) result[offset + rightIndex] = partials[rightIndex];
            while (++holdersIndex < holdersLength)
                if (isUncurried || argsIndex < argsLength) result[offset + holders[holdersIndex]] = args[argsIndex++];
            return result
        }

        function copyArray(source, array) {
            var index = -1,
                length = source.length;
            array || (array = Array(length));
            while (++index < length) array[index] = source[index];
            return array
        }

        function copyObject(source, props, object, customizer) {
            object || (object = {});
            var index = -1,
                length =
                props.length;
            while (++index < length) {
                var key = props[index];
                var newValue = customizer ? customizer(object[key], source[key], key, object, source) : source[key];
                assignValue(object, key, newValue)
            }
            return object
        }

        function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object)
        }

        function createAggregator(setter, initializer) {
            return function(collection, iteratee) {
                var func = isArray(collection) ? arrayAggregator : baseAggregator,
                    accumulator = initializer ? initializer() : {};
                return func(collection, setter, getIteratee(iteratee),
                    accumulator)
            }
        }

        function createAssigner(assigner) {
            return rest(function(object, sources) {
                var index = -1,
                    length = sources.length,
                    customizer = length > 1 ? sources[length - 1] : undefined,
                    guard = length > 2 ? sources[2] : undefined;
                customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined;
                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? undefined : customizer;
                    length = 1
                }
                object = Object(object);
                while (++index < length) {
                    var source = sources[index];
                    if (source) assigner(object, source,
                        index, customizer)
                }
                return object
            })
        }

        function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee) {
                if (collection == null) return collection;
                if (!isArrayLike(collection)) return eachFunc(collection, iteratee);
                var length = collection.length,
                    index = fromRight ? length : -1,
                    iterable = Object(collection);
                while (fromRight ? index-- : ++index < length)
                    if (iteratee(iterable[index], index, iterable) === false) break;
                return collection
            }
        }

        function createBaseFor(fromRight) {
            return function(object, iteratee, keysFunc) {
                var index = -1,
                    iterable = Object(object),
                    props = keysFunc(object),
                    length = props.length;
                while (length--) {
                    var key = props[fromRight ? length : ++index];
                    if (iteratee(iterable[key], key, iterable) === false) break
                }
                return object
            }
        }

        function createBaseWrapper(func, bitmask, thisArg) {
            var isBind = bitmask & BIND_FLAG,
                Ctor = createCtorWrapper(func);

            function wrapper() {
                var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                return fn.apply(isBind ? thisArg : this, arguments)
            }
            return wrapper
        }

        function createCaseFirst(methodName) {
            return function(string) {
                string =
                    toString(string);
                var strSymbols = reHasComplexSymbol.test(string) ? stringToArray(string) : undefined;
                var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                return chr[methodName]() + trailing
            }
        }

        function createCompounder(callback) {
            return function(string) {
                return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "")
            }
        }

        function createCtorWrapper(Ctor) {
            return function() {
                var args = arguments;
                switch (args.length) {
                    case 0:
                        return new Ctor;
                    case 1:
                        return new Ctor(args[0]);
                    case 2:
                        return new Ctor(args[0], args[1]);
                    case 3:
                        return new Ctor(args[0], args[1], args[2]);
                    case 4:
                        return new Ctor(args[0], args[1], args[2], args[3]);
                    case 5:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                    case 6:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                    case 7:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6])
                }
                var thisBinding = baseCreate(Ctor.prototype),
                    result = Ctor.apply(thisBinding, args);
                return isObject(result) ? result :
                    thisBinding
            }
        }

        function createCurryWrapper(func, bitmask, arity) {
            var Ctor = createCtorWrapper(func);

            function wrapper() {
                var length = arguments.length,
                    args = Array(length),
                    index = length,
                    placeholder = getHolder(wrapper);
                while (index--) args[index] = arguments[index];
                var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                length -= holders.length;
                if (length < arity) return createRecurryWrapper(func, bitmask, createHybridWrapper, wrapper.placeholder, undefined, args, holders, undefined,
                    undefined, arity - length);
                var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                return apply(fn, this, args)
            }
            return wrapper
        }

        function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
                var iterable = Object(collection);
                predicate = getIteratee(predicate, 3);
                if (!isArrayLike(collection)) var props = keys(collection);
                var index = findIndexFunc(props || collection, function(value, key) {
                    if (props) {
                        key = value;
                        value = iterable[key]
                    }
                    return predicate(value, key, iterable)
                }, fromIndex);
                return index > -1 ? collection[props ?
                    props[index] : index] : undefined
            }
        }

        function createFlow(fromRight) {
            return rest(function(funcs) {
                funcs = baseFlatten(funcs, 1);
                var length = funcs.length,
                    index = length,
                    prereq = LodashWrapper.prototype.thru;
                if (fromRight) funcs.reverse();
                while (index--) {
                    var func = funcs[index];
                    if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
                    if (prereq && !wrapper && getFuncName(func) == "wrapper") var wrapper = new LodashWrapper([], true)
                }
                index = wrapper ? index : length;
                while (++index < length) {
                    func = funcs[index];
                    var funcName = getFuncName(func),
                        data = funcName == "wrapper" ? getData(func) : undefined;
                    if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                    else wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func)
                }
                return function() {
                    var args = arguments,
                        value = args[0];
                    if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) return wrapper.plant(value).value();
                    var index = 0,
                        result = length ? funcs[index].apply(this,
                            args) : value;
                    while (++index < length) result = funcs[index].call(this, result);
                    return result
                }
            })
        }

        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            var isAry = bitmask & ARY_FLAG,
                isBind = bitmask & BIND_FLAG,
                isBindKey = bitmask & BIND_KEY_FLAG,
                isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG),
                isFlip = bitmask & FLIP_FLAG,
                Ctor = isBindKey ? undefined : createCtorWrapper(func);

            function wrapper() {
                var length = arguments.length,
                    args = Array(length),
                    index = length;
                while (index--) args[index] =
                    arguments[index];
                if (isCurried) var placeholder = getHolder(wrapper),
                    holdersCount = countHolders(args, placeholder);
                if (partials) args = composeArgs(args, partials, holders, isCurried);
                if (partialsRight) args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                length -= holdersCount;
                if (isCurried && length < arity) {
                    var newHolders = replaceHolders(args, placeholder);
                    return createRecurryWrapper(func, bitmask, createHybridWrapper, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length)
                }
                var thisBinding = isBind ?
                    thisArg : this,
                    fn = isBindKey ? thisBinding[func] : func;
                length = args.length;
                if (argPos) args = reorder(args, argPos);
                else if (isFlip && length > 1) args.reverse();
                if (isAry && ary < length) args.length = ary;
                if (this && this !== root && this instanceof wrapper) fn = Ctor || createCtorWrapper(fn);
                return fn.apply(thisBinding, args)
            }
            return wrapper
        }

        function createInverter(setter, toIteratee) {
            return function(object, iteratee) {
                return baseInverter(object, setter, toIteratee(iteratee), {})
            }
        }

        function createMathOperation(operator) {
            return function(value,
                other) {
                var result;
                if (value === undefined && other === undefined) return 0;
                if (value !== undefined) result = value;
                if (other !== undefined) {
                    if (result === undefined) return other;
                    if (typeof value == "string" || typeof other == "string") {
                        value = baseToString(value);
                        other = baseToString(other)
                    } else {
                        value = baseToNumber(value);
                        other = baseToNumber(other)
                    }
                    result = operator(value, other)
                }
                return result
            }
        }

        function createOver(arrayFunc) {
            return rest(function(iteratees) {
                iteratees = iteratees.length == 1 && isArray(iteratees[0]) ? arrayMap(iteratees[0], baseUnary(getIteratee())) :
                    arrayMap(baseFlatten(iteratees, 1, isFlattenableIteratee), baseUnary(getIteratee()));
                return rest(function(args) {
                    var thisArg = this;
                    return arrayFunc(iteratees, function(iteratee) {
                        return apply(iteratee, thisArg, args)
                    })
                })
            })
        }

        function createPadding(length, chars) {
            chars = chars === undefined ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) return charsLength ? baseRepeat(chars, length) : chars;
            var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return reHasComplexSymbol.test(chars) ? castSlice(stringToArray(result),
                0, length).join("") : result.slice(0, length)
        }

        function createPartialWrapper(func, bitmask, thisArg, partials) {
            var isBind = bitmask & BIND_FLAG,
                Ctor = createCtorWrapper(func);

            function wrapper() {
                var argsIndex = -1,
                    argsLength = arguments.length,
                    leftIndex = -1,
                    leftLength = partials.length,
                    args = Array(leftLength + argsLength),
                    fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                while (++leftIndex < leftLength) args[leftIndex] = partials[leftIndex];
                while (argsLength--) args[leftIndex++] = arguments[++argsIndex];
                return apply(fn, isBind ?
                    thisArg : this, args)
            }
            return wrapper
        }

        function createRange(fromRight) {
            return function(start, end, step) {
                if (step && typeof step != "number" && isIterateeCall(start, end, step)) end = step = undefined;
                start = toNumber(start);
                start = start === start ? start : 0;
                if (end === undefined) {
                    end = start;
                    start = 0
                } else end = toNumber(end) || 0;
                step = step === undefined ? start < end ? 1 : -1 : toNumber(step) || 0;
                return baseRange(start, end, step, fromRight)
            }
        }

        function createRelationalOperation(operator) {
            return function(value, other) {
                if (!(typeof value == "string" && typeof other ==
                        "string")) {
                    value = toNumber(value);
                    other = toNumber(other)
                }
                return operator(value, other)
            }
        }

        function createRecurryWrapper(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
            var isCurry = bitmask & CURRY_FLAG,
                newHolders = isCurry ? holders : undefined,
                newHoldersRight = isCurry ? undefined : holders,
                newPartials = isCurry ? partials : undefined,
                newPartialsRight = isCurry ? undefined : partials;
            bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
            if (!(bitmask & CURRY_BOUND_FLAG)) bitmask &=
                ~(BIND_FLAG | BIND_KEY_FLAG);
            var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity];
            var result = wrapFunc.apply(undefined, newData);
            if (isLaziable(func)) setData(result, newData);
            result.placeholder = placeholder;
            return result
        }

        function createRound(methodName) {
            var func = Math[methodName];
            return function(number, precision) {
                number = toNumber(number);
                precision = nativeMin(toInteger(precision), 292);
                if (precision) {
                    var pair = (toString(number) + "e").split("e"),
                        value = func(pair[0] +
                            "e" + (+pair[1] + precision));
                    pair = (toString(value) + "e").split("e");
                    return +(pair[0] + "e" + (+pair[1] - precision))
                }
                return func(number)
            }
        }
        var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function(values) {
            return new Set(values)
        };

        function createToPairs(keysFunc) {
            return function(object) {
                var tag = getTag(object);
                if (tag == mapTag) return mapToArray(object);
                if (tag == setTag) return setToPairs(object);
                return baseToPairs(object, keysFunc(object))
            }
        }

        function createWrapper(func, bitmask, thisArg, partials, holders,
            argPos, ary, arity) {
            var isBindKey = bitmask & BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
            var length = partials ? partials.length : 0;
            if (!length) {
                bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                partials = holders = undefined
            }
            ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
            arity = arity === undefined ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & PARTIAL_RIGHT_FLAG) {
                var partialsRight = partials,
                    holdersRight = holders;
                partials = holders = undefined
            }
            var data = isBindKey ?
                undefined : getData(func);
            var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
            if (data) mergeData(newData, data);
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] == null ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
            if (!bitmask || bitmask == BIND_FLAG) var result = createBaseWrapper(func, bitmask, thisArg);
            else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) result = createCurryWrapper(func, bitmask, arity);
            else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) result = createPartialWrapper(func, bitmask, thisArg, partials);
            else result = createHybridWrapper.apply(undefined, newData);
            var setter = data ? baseSetData : setData;
            return setter(result, newData)
        }

        function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
            var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                arrLength = array.length,
                othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
            var stacked = stack.get(array);
            if (stacked) return stacked == other;
            var index = -1,
                result = true,
                seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache : undefined;
            stack.set(array, other);
            while (++index < arrLength) {
                var arrValue = array[index],
                    othValue = other[index];
                if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                if (compared !== undefined) {
                    if (compared) continue;
                    result = false;
                    break
                }
                if (seen) {
                    if (!arraySome(other, function(othValue, othIndex) {
                            if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) return seen.add(othIndex)
                        })) {
                        result = false;
                        break
                    }
                } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                    result = false;
                    break
                }
            }
            stack["delete"](array);
            return result
        }

        function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
            switch (tag) {
                case dataViewTag:
                    if (object.byteLength != other.byteLength ||
                        object.byteOffset != other.byteOffset) return false;
                    object = object.buffer;
                    other = other.buffer;
                case arrayBufferTag:
                    if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) return false;
                    return true;
                case boolTag:
                case dateTag:
                    return +object == +other;
                case errorTag:
                    return object.name == other.name && object.message == other.message;
                case numberTag:
                    return object != +object ? other != +other : object == +other;
                case regexpTag:
                case stringTag:
                    return object == other + "";
                case mapTag:
                    var convert = mapToArray;
                case setTag:
                    var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
                    convert || (convert = setToArray);
                    if (object.size != other.size && !isPartial) return false;
                    var stacked = stack.get(object);
                    if (stacked) return stacked == other;
                    bitmask |= UNORDERED_COMPARE_FLAG;
                    stack.set(object, other);
                    return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
                case symbolTag:
                    if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other)
            }
            return false
        }

        function equalObjects(object, other, equalFunc, customizer,
            bitmask, stack) {
            var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                objProps = keys(object),
                objLength = objProps.length,
                othProps = keys(other),
                othLength = othProps.length;
            if (objLength != othLength && !isPartial) return false;
            var index = objLength;
            while (index--) {
                var key = objProps[index];
                if (!(isPartial ? key in other : baseHas(other, key))) return false
            }
            var stacked = stack.get(object);
            if (stacked) return stacked == other;
            var result = true;
            stack.set(object, other);
            var skipCtor = isPartial;
            while (++index < objLength) {
                key = objProps[index];
                var objValue =
                    object[key],
                    othValue = other[key];
                if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
                    result = false;
                    break
                }
                skipCtor || (skipCtor = key == "constructor")
            }
            if (result && !skipCtor) {
                var objCtor = object.constructor,
                    othCtor = other.constructor;
                if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor ==
                        "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) result = false
            }
            stack["delete"](object);
            return result
        }

        function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols)
        }

        function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn)
        }
        var getData = !metaMap ? noop : function(func) {
            return metaMap.get(func)
        };

        function getFuncName(func) {
            var result = func.name + "",
                array = realNames[result],
                length = hasOwnProperty.call(realNames, result) ? array.length :
                0;
            while (length--) {
                var data = array[length],
                    otherFunc = data.func;
                if (otherFunc == null || otherFunc == func) return data.name
            }
            return result
        }

        function getHolder(func) {
            var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder
        }

        function getIteratee() {
            var result = lodash.iteratee || iteratee;
            result = result === iteratee ? baseIteratee : result;
            return arguments.length ? result(arguments[0], arguments[1]) : result
        }
        var getLength = baseProperty("length");

        function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map
        }

        function getMatchData(object) {
            var result = keys(object),
                length = result.length;
            while (length--) {
                var key = result[length],
                    value = object[key];
                result[length] = [key, value, isStrictComparable(value)]
            }
            return result
        }

        function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined
        }

        function getPrototype(value) {
            return nativeGetPrototype(Object(value))
        }

        function getSymbols(object) {
            return getOwnPropertySymbols(Object(object))
        }
        if (!getOwnPropertySymbols) getSymbols = stubArray;
        var getSymbolsIn = !getOwnPropertySymbols ? getSymbols : function(object) {
            var result = [];
            while (object) {
                arrayPush(result, getSymbols(object));
                object = getPrototype(object)
            }
            return result
        };

        function getTag(value) {
            return objectToString.call(value)
        }
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) getTag =
            function(value) {
                var result = objectToString.call(value),
                    Ctor = result == objectTag ? value.constructor : undefined,
                    ctorString = Ctor ? toSource(Ctor) : undefined;
                if (ctorString) switch (ctorString) {
                    case dataViewCtorString:
                        return dataViewTag;
                    case mapCtorString:
                        return mapTag;
                    case promiseCtorString:
                        return promiseTag;
                    case setCtorString:
                        return setTag;
                    case weakMapCtorString:
                        return weakMapTag
                }
                return result
            };

        function getView(start, end, transforms) {
            var index = -1,
                length = transforms.length;
            while (++index < length) {
                var data = transforms[index],
                    size = data.size;
                switch (data.type) {
                    case "drop":
                        start += size;
                        break;
                    case "dropRight":
                        end -= size;
                        break;
                    case "take":
                        end = nativeMin(end, start + size);
                        break;
                    case "takeRight":
                        start = nativeMax(start, end - size);
                        break
                }
            }
            return {
                "start": start,
                "end": end
            }
        }

        function hasPath(object, path, hasFunc) {
            path = isKey(path, object) ? [path] : castPath(path);
            var result, index = -1,
                length = path.length;
            while (++index < length) {
                var key = toKey(path[index]);
                if (!(result = object != null && hasFunc(object, key))) break;
                object = object[key]
            }
            if (result) return result;
            var length =
                object ? object.length : 0;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isString(object) || isArguments(object))
        }

        function initCloneArray(array) {
            var length = array.length,
                result = array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
                result.index = array.index;
                result.input = array.input
            }
            return result
        }

        function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {}
        }

        function initCloneByTag(object,
            tag, cloneFunc, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
                case arrayBufferTag:
                    return cloneArrayBuffer(object);
                case boolTag:
                case dateTag:
                    return new Ctor(+object);
                case dataViewTag:
                    return cloneDataView(object, isDeep);
                case float32Tag:
                case float64Tag:
                case int8Tag:
                case int16Tag:
                case int32Tag:
                case uint8Tag:
                case uint8ClampedTag:
                case uint16Tag:
                case uint32Tag:
                    return cloneTypedArray(object, isDeep);
                case mapTag:
                    return cloneMap(object, isDeep, cloneFunc);
                case numberTag:
                case stringTag:
                    return new Ctor(object);
                case regexpTag:
                    return cloneRegExp(object);
                case setTag:
                    return cloneSet(object, isDeep, cloneFunc);
                case symbolTag:
                    return cloneSymbol(object)
            }
        }

        function indexKeys(object) {
            var length = object ? object.length : undefined;
            if (isLength(length) && (isArray(object) || isString(object) || isArguments(object))) return baseTimes(length, String);
            return null
        }

        function isFlattenable(value) {
            return isArray(value) || isArguments(value)
        }

        function isFlattenableIteratee(value) {
            return isArray(value) && !(value.length == 2 && !isFunction(value[0]))
        }

        function isIndex(value, length) {
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length)
        }

        function isIterateeCall(value, index, object) {
            if (!isObject(object)) return false;
            var type = typeof index;
            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) return eq(object[index], value);
            return false
        }

        function isKey(value, object) {
            if (isArray(value)) return false;
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) return true;
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object)
        }

        function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null
        }

        function isLaziable(func) {
            var funcName = getFuncName(func),
                other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) return false;
            if (func === other) return true;
            var data = getData(other);
            return !!data && func === data[0]
        }

        function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;

        function isPrototype(value) {
            var Ctor = value && value.constructor,
                proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto
        }

        function isStrictComparable(value) {
            return value === value && !isObject(value)
        }

        function matchesStrictComparable(key, srcValue) {
            return function(object) {
                if (object == null) return false;
                return object[key] === srcValue && (srcValue !== undefined || key in Object(object))
            }
        }

        function mergeData(data, source) {
            var bitmask = data[1],
                srcBitmask = source[1],
                newBitmask = bitmask | srcBitmask,
                isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);
            var isCombo = srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG || srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8] || srcBitmask == (ARY_FLAG | REARG_FLAG) && source[7].length <= source[8] && bitmask == CURRY_FLAG;
            if (!(isCommon || isCombo)) return data;
            if (srcBitmask & BIND_FLAG) {
                data[2] =
                    source[2];
                newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG
            }
            var value = source[3];
            if (value) {
                var partials = data[3];
                data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4]
            }
            value = source[5];
            if (value) {
                partials = data[5];
                data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6]
            }
            value = source[7];
            if (value) data[7] = value;
            if (srcBitmask & ARY_FLAG) data[8] = data[8] == null ? source[8] : nativeMin(data[8],
                source[8]);
            if (data[9] == null) data[9] = source[9];
            data[0] = source[0];
            data[1] = newBitmask;
            return data
        }

        function mergeDefaults(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) baseMerge(objValue, srcValue, undefined, mergeDefaults, stack.set(srcValue, objValue));
            return objValue
        }

        function parent(object, path) {
            return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1))
        }

        function reorder(array, indexes) {
            var arrLength = array.length,
                length = nativeMin(indexes.length, arrLength),
                oldArray =
                copyArray(array);
            while (length--) {
                var index = indexes[length];
                array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined
            }
            return array
        }
        var setData = function() {
            var count = 0,
                lastCalled = 0;
            return function(key, value) {
                var stamp = now(),
                    remaining = HOT_SPAN - (stamp - lastCalled);
                lastCalled = stamp;
                if (remaining > 0) {
                    if (++count >= HOT_COUNT) return key
                } else count = 0;
                return baseSetData(key, value)
            }
        }();
        var stringToPath = memoize(function(string) {
            var result = [];
            toString(string).replace(rePropName, function(match, number, quote, string) {
                result.push(quote ?
                    string.replace(reEscapeChar, "$1") : number || match)
            });
            return result
        });

        function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) return value;
            var result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result
        }

        function toSource(func) {
            if (func != null) {
                try {
                    return funcToString.call(func)
                } catch (e) {}
                try {
                    return func + ""
                } catch (e) {}
            }
            return ""
        }

        function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) return wrapper.clone();
            var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result.__actions__ =
                copyArray(wrapper.__actions__);
            result.__index__ = wrapper.__index__;
            result.__values__ = wrapper.__values__;
            return result
        }

        function chunk(array, size, guard) {
            if (guard ? isIterateeCall(array, size, guard) : size === undefined) size = 1;
            else size = nativeMax(toInteger(size), 0);
            var length = array ? array.length : 0;
            if (!length || size < 1) return [];
            var index = 0,
                resIndex = 0,
                result = Array(nativeCeil(length / size));
            while (index < length) result[resIndex++] = baseSlice(array, index, index += size);
            return result
        }

        function compact(array) {
            var index = -1,
                length =
                array ? array.length : 0,
                resIndex = 0,
                result = [];
            while (++index < length) {
                var value = array[index];
                if (value) result[resIndex++] = value
            }
            return result
        }

        function concat() {
            var length = arguments.length,
                args = Array(length ? length - 1 : 0),
                array = arguments[0],
                index = length;
            while (index--) args[index - 1] = arguments[index];
            return length ? arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1)) : []
        }
        var difference = rest(function(array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject,
                true)) : []
        });
        var differenceBy = rest(function(array, values) {
            var iteratee = last(values);
            if (isArrayLikeObject(iteratee)) iteratee = undefined;
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee)) : []
        });
        var differenceWith = rest(function(array, values) {
            var comparator = last(values);
            if (isArrayLikeObject(comparator)) comparator = undefined;
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : []
        });

        function drop(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) return [];
            n = guard || n === undefined ? 1 : toInteger(n);
            return baseSlice(array, n < 0 ? 0 : n, length)
        }

        function dropRight(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) return [];
            n = guard || n === undefined ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, 0, n < 0 ? 0 : n)
        }

        function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : []
        }

        function dropWhile(array, predicate) {
            return array &&
                array.length ? baseWhile(array, getIteratee(predicate, 3), true) : []
        }

        function fill(array, value, start, end) {
            var length = array ? array.length : 0;
            if (!length) return [];
            if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
                start = 0;
                end = length
            }
            return baseFill(array, value, start, end)
        }

        function findIndex(array, predicate, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) return -1;
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) index = nativeMax(length + index, 0);
            return baseFindIndex(array, getIteratee(predicate,
                3), index)
        }

        function findLastIndex(array, predicate, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) return -1;
            var index = length - 1;
            if (fromIndex !== undefined) {
                index = toInteger(fromIndex);
                index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index, true)
        }

        function flatten(array) {
            var length = array ? array.length : 0;
            return length ? baseFlatten(array, 1) : []
        }

        function flattenDeep(array) {
            var length = array ? array.length : 0;
            return length ? baseFlatten(array,
                INFINITY) : []
        }

        function flattenDepth(array, depth) {
            var length = array ? array.length : 0;
            if (!length) return [];
            depth = depth === undefined ? 1 : toInteger(depth);
            return baseFlatten(array, depth)
        }

        function fromPairs(pairs) {
            var index = -1,
                length = pairs ? pairs.length : 0,
                result = {};
            while (++index < length) {
                var pair = pairs[index];
                result[pair[0]] = pair[1]
            }
            return result
        }

        function head(array) {
            return array && array.length ? array[0] : undefined
        }

        function indexOf(array, value, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) return -1;
            var index =
                fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) index = nativeMax(length + index, 0);
            return baseIndexOf(array, value, index)
        }

        function initial(array) {
            return dropRight(array, 1)
        }
        var intersection = rest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : []
        });
        var intersectionBy = rest(function(arrays) {
            var iteratee = last(arrays),
                mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee === last(mapped)) iteratee = undefined;
            else mapped.pop();
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee)) : []
        });
        var intersectionWith = rest(function(arrays) {
            var comparator = last(arrays),
                mapped = arrayMap(arrays, castArrayLikeObject);
            if (comparator === last(mapped)) comparator = undefined;
            else mapped.pop();
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : []
        });

        function join(array, separator) {
            return array ? nativeJoin.call(array, separator) : ""
        }

        function last(array) {
            var length = array ? array.length :
                0;
            return length ? array[length - 1] : undefined
        }

        function lastIndexOf(array, value, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) return -1;
            var index = length;
            if (fromIndex !== undefined) {
                index = toInteger(fromIndex);
                index = (index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)) + 1
            }
            if (value !== value) return indexOfNaN(array, index - 1, true);
            while (index--)
                if (array[index] === value) return index;
            return -1
        }

        function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined
        }
        var pull = rest(pullAll);

        function pullAll(array, values) {
            return array && array.length && values && values.length ? basePullAll(array, values) : array
        }

        function pullAllBy(array, values, iteratee) {
            return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee)) : array
        }

        function pullAllWith(array, values, comparator) {
            return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array
        }
        var pullAt = rest(function(array, indexes) {
            indexes = baseFlatten(indexes, 1);
            var length = array ? array.length :
                0,
                result = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index) {
                return isIndex(index, length) ? +index : index
            }).sort(compareAscending));
            return result
        });

        function remove(array, predicate) {
            var result = [];
            if (!(array && array.length)) return result;
            var index = -1,
                indexes = [],
                length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                    result.push(value);
                    indexes.push(index)
                }
            }
            basePullAt(array, indexes);
            return result
        }

        function reverse(array) {
            return array ?
                nativeReverse.call(array) : array
        }

        function slice(array, start, end) {
            var length = array ? array.length : 0;
            if (!length) return [];
            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
                start = 0;
                end = length
            } else {
                start = start == null ? 0 : toInteger(start);
                end = end === undefined ? length : toInteger(end)
            }
            return baseSlice(array, start, end)
        }

        function sortedIndex(array, value) {
            return baseSortedIndex(array, value)
        }

        function sortedIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee))
        }

        function sortedIndexOf(array,
            value) {
            var length = array ? array.length : 0;
            if (length) {
                var index = baseSortedIndex(array, value);
                if (index < length && eq(array[index], value)) return index
            }
            return -1
        }

        function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true)
        }

        function sortedLastIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee), true)
        }

        function sortedLastIndexOf(array, value) {
            var length = array ? array.length : 0;
            if (length) {
                var index = baseSortedIndex(array, value, true) - 1;
                if (eq(array[index], value)) return index
            }
            return -1
        }

        function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : []
        }

        function sortedUniqBy(array, iteratee) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee)) : []
        }

        function tail(array) {
            return drop(array, 1)
        }

        function take(array, n, guard) {
            if (!(array && array.length)) return [];
            n = guard || n === undefined ? 1 : toInteger(n);
            return baseSlice(array, 0, n < 0 ? 0 : n)
        }

        function takeRight(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) return [];
            n = guard || n === undefined ? 1 : toInteger(n);
            n = length -
                n;
            return baseSlice(array, n < 0 ? 0 : n, length)
        }

        function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : []
        }

        function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : []
        }
        var union = rest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true))
        });
        var unionBy = rest(function(arrays) {
            var iteratee = last(arrays);
            if (isArrayLikeObject(iteratee)) iteratee = undefined;
            return baseUniq(baseFlatten(arrays,
                1, isArrayLikeObject, true), getIteratee(iteratee))
        });
        var unionWith = rest(function(arrays) {
            var comparator = last(arrays);
            if (isArrayLikeObject(comparator)) comparator = undefined;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator)
        });

        function uniq(array) {
            return array && array.length ? baseUniq(array) : []
        }

        function uniqBy(array, iteratee) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee)) : []
        }

        function uniqWith(array, comparator) {
            return array && array.length ? baseUniq(array, undefined,
                comparator) : []
        }

        function unzip(array) {
            if (!(array && array.length)) return [];
            var length = 0;
            array = arrayFilter(array, function(group) {
                if (isArrayLikeObject(group)) {
                    length = nativeMax(group.length, length);
                    return true
                }
            });
            return baseTimes(length, function(index) {
                return arrayMap(array, baseProperty(index))
            })
        }

        function unzipWith(array, iteratee) {
            if (!(array && array.length)) return [];
            var result = unzip(array);
            if (iteratee == null) return result;
            return arrayMap(result, function(group) {
                return apply(iteratee, undefined, group)
            })
        }
        var without =
            rest(function(array, values) {
                return isArrayLikeObject(array) ? baseDifference(array, values) : []
            });
        var xor = rest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject))
        });
        var xorBy = rest(function(arrays) {
            var iteratee = last(arrays);
            if (isArrayLikeObject(iteratee)) iteratee = undefined;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee))
        });
        var xorWith = rest(function(arrays) {
            var comparator = last(arrays);
            if (isArrayLikeObject(comparator)) comparator = undefined;
            return baseXor(arrayFilter(arrays,
                isArrayLikeObject), undefined, comparator)
        });
        var zip = rest(unzip);

        function zipObject(props, values) {
            return baseZipObject(props || [], values || [], assignValue)
        }

        function zipObjectDeep(props, values) {
            return baseZipObject(props || [], values || [], baseSet)
        }
        var zipWith = rest(function(arrays) {
            var length = arrays.length,
                iteratee = length > 1 ? arrays[length - 1] : undefined;
            iteratee = typeof iteratee == "function" ? (arrays.pop(), iteratee) : undefined;
            return unzipWith(arrays, iteratee)
        });

        function chain(value) {
            var result = lodash(value);
            result.__chain__ =
                true;
            return result
        }

        function tap(value, interceptor) {
            interceptor(value);
            return value
        }

        function thru(value, interceptor) {
            return interceptor(value)
        }
        var wrapperAt = rest(function(paths) {
            paths = baseFlatten(paths, 1);
            var length = paths.length,
                start = length ? paths[0] : 0,
                value = this.__wrapped__,
                interceptor = function(object) {
                    return baseAt(object, paths)
                };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) return this.thru(interceptor);
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
                "func": thru,
                "args": [interceptor],
                "thisArg": undefined
            });
            return (new LodashWrapper(value, this.__chain__)).thru(function(array) {
                if (length && !array.length) array.push(undefined);
                return array
            })
        });

        function wrapperChain() {
            return chain(this)
        }

        function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__)
        }

        function wrapperNext() {
            if (this.__values__ === undefined) this.__values__ = toArray(this.value());
            var done = this.__index__ >= this.__values__.length,
                value = done ? undefined : this.__values__[this.__index__++];
            return {
                "done": done,
                "value": value
            }
        }

        function wrapperToIterator() {
            return this
        }

        function wrapperPlant(value) {
            var result, parent = this;
            while (parent instanceof baseLodash) {
                var clone = wrapperClone(parent);
                clone.__index__ = 0;
                clone.__values__ = undefined;
                if (result) previous.__wrapped__ = clone;
                else result = clone;
                var previous = clone;
                parent = parent.__wrapped__
            }
            previous.__wrapped__ = value;
            return result
        }

        function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
                var wrapped = value;
                if (this.__actions__.length) wrapped = new LazyWrapper(this);
                wrapped = wrapped.reverse();
                wrapped.__actions__.push({
                    "func": thru,
                    "args": [reverse],
                    "thisArg": undefined
                });
                return new LodashWrapper(wrapped, this.__chain__)
            }
            return this.thru(reverse)
        }

        function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__)
        }
        var countBy = createAggregator(function(result, value, key) {
            hasOwnProperty.call(result, key) ? ++result[key] : result[key] = 1
        });

        function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection,
                    predicate, guard)) predicate = undefined;
            return func(collection, getIteratee(predicate, 3))
        }

        function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3))
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);

        function flatMap(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), 1)
        }

        function flatMapDeep(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), INFINITY)
        }

        function flatMapDepth(collection,
            iteratee, depth) {
            depth = depth === undefined ? 1 : toInteger(depth);
            return baseFlatten(map(collection, iteratee), depth)
        }

        function forEach(collection, iteratee) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee, 3))
        }

        function forEachRight(collection, iteratee) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee, 3))
        }
        var groupBy = createAggregator(function(result, value, key) {
            if (hasOwnProperty.call(result, key)) result[key].push(value);
            else result[key] = [value]
        });

        function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) fromIndex = nativeMax(length + fromIndex, 0);
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1
        }
        var invokeMap = rest(function(collection, path, args) {
            var index = -1,
                isFunc = typeof path ==
                "function",
                isProp = isKey(path),
                result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function(value) {
                var func = isFunc ? path : isProp && value != null ? value[path] : undefined;
                result[++index] = func ? apply(func, value, args) : baseInvoke(value, path, args)
            });
            return result
        });
        var keyBy = createAggregator(function(result, value, key) {
            result[key] = value
        });

        function map(collection, iteratee) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee, 3))
        }

        function orderBy(collection,
            iteratees, orders, guard) {
            if (collection == null) return [];
            if (!isArray(iteratees)) iteratees = iteratees == null ? [] : [iteratees];
            orders = guard ? undefined : orders;
            if (!isArray(orders)) orders = orders == null ? [] : [orders];
            return baseOrderBy(collection, iteratees, orders)
        }
        var partition = createAggregator(function(result, value, key) {
            result[key ? 0 : 1].push(value)
        }, function() {
            return [
                [],
                []
            ]
        });

        function reduce(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce,
                initAccum = arguments.length < 3;
            return func(collection,
                getIteratee(iteratee, 4), accumulator, initAccum, baseEach)
        }

        function reduceRight(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce,
                initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight)
        }

        function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            predicate = getIteratee(predicate, 3);
            return func(collection, function(value, index, collection) {
                return !predicate(value, index, collection)
            })
        }

        function sample(collection) {
            var array = isArrayLike(collection) ? collection : values(collection),
                length = array.length;
            return length > 0 ? array[baseRandom(0, length - 1)] : undefined
        }

        function sampleSize(collection, n, guard) {
            var index = -1,
                result = toArray(collection),
                length = result.length,
                lastIndex = length - 1;
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined) n = 1;
            else n = baseClamp(toInteger(n), 0, length);
            while (++index < n) {
                var rand = baseRandom(index, lastIndex),
                    value = result[rand];
                result[rand] = result[index];
                result[index] =
                    value
            }
            result.length = n;
            return result
        }

        function shuffle(collection) {
            return sampleSize(collection, MAX_ARRAY_LENGTH)
        }

        function size(collection) {
            if (collection == null) return 0;
            if (isArrayLike(collection)) {
                var result = collection.length;
                return result && isString(collection) ? stringSize(collection) : result
            }
            if (isObjectLike(collection)) {
                var tag = getTag(collection);
                if (tag == mapTag || tag == setTag) return collection.size
            }
            return keys(collection).length
        }

        function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome :
                baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) predicate = undefined;
            return func(collection, getIteratee(predicate, 3))
        }
        var sortBy = rest(function(collection, iteratees) {
            if (collection == null) return [];
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) iteratees = [];
            else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) iteratees = [iteratees[0]];
            iteratees = iteratees.length == 1 && isArray(iteratees[0]) ? iteratees[0] : baseFlatten(iteratees, 1,
                isFlattenableIteratee);
            return baseOrderBy(collection, iteratees, [])
        });

        function now() {
            return Date.now()
        }

        function after(n, func) {
            if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
            n = toInteger(n);
            return function() {
                if (--n < 1) return func.apply(this, arguments)
            }
        }

        function ary(func, n, guard) {
            n = guard ? undefined : n;
            n = func && n == null ? func.length : n;
            return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n)
        }

        function before(n, func) {
            var result;
            if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
            n = toInteger(n);
            return function() {
                if (--n > 0) result = func.apply(this, arguments);
                if (n <= 1) func = undefined;
                return result
            }
        }
        var bind = rest(function(func, thisArg, partials) {
            var bitmask = BIND_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, getHolder(bind));
                bitmask |= PARTIAL_FLAG
            }
            return createWrapper(func, bitmask, thisArg, partials, holders)
        });
        var bindKey = rest(function(object, key, partials) {
            var bitmask = BIND_FLAG | BIND_KEY_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, getHolder(bindKey));
                bitmask |=
                    PARTIAL_FLAG
            }
            return createWrapper(key, bitmask, object, partials, holders)
        });

        function curry(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrapper(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curry.placeholder;
            return result
        }

        function curryRight(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrapper(func, CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curryRight.placeholder;
            return result
        }

        function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0,
                leading = false,
                maxing = false,
                trailing = true;
            if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
                leading = !!options.leading;
                maxing = "maxWait" in options;
                maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                trailing = "trailing" in options ? !!options.trailing : trailing
            }

            function invokeFunc(time) {
                var args = lastArgs,
                    thisArg = lastThis;
                lastArgs = lastThis = undefined;
                lastInvokeTime = time;
                result = func.apply(thisArg, args);
                return result
            }

            function leadingEdge(time) {
                lastInvokeTime = time;
                timerId = setTimeout(timerExpired, wait);
                return leading ? invokeFunc(time) : result
            }

            function remainingWait(time) {
                var timeSinceLastCall = time - lastCallTime,
                    timeSinceLastInvoke = time - lastInvokeTime,
                    result = wait - timeSinceLastCall;
                return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result
            }

            function shouldInvoke(time) {
                var timeSinceLastCall = time - lastCallTime,
                    timeSinceLastInvoke =
                    time - lastInvokeTime;
                return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait
            }

            function timerExpired() {
                var time = now();
                if (shouldInvoke(time)) return trailingEdge(time);
                timerId = setTimeout(timerExpired, remainingWait(time))
            }

            function trailingEdge(time) {
                timerId = undefined;
                if (trailing && lastArgs) return invokeFunc(time);
                lastArgs = lastThis = undefined;
                return result
            }

            function cancel() {
                lastInvokeTime = 0;
                lastArgs = lastCallTime = lastThis = timerId = undefined
            }

            function flush() {
                return timerId ===
                    undefined ? result : trailingEdge(now())
            }

            function debounced() {
                var time = now(),
                    isInvoking = shouldInvoke(time);
                lastArgs = arguments;
                lastThis = this;
                lastCallTime = time;
                if (isInvoking) {
                    if (timerId === undefined) return leadingEdge(lastCallTime);
                    if (maxing) {
                        timerId = setTimeout(timerExpired, wait);
                        return invokeFunc(lastCallTime)
                    }
                }
                if (timerId === undefined) timerId = setTimeout(timerExpired, wait);
                return result
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced
        }
        var defer = rest(function(func, args) {
            return baseDelay(func,
                1, args)
        });
        var delay = rest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args)
        });

        function flip(func) {
            return createWrapper(func, FLIP_FLAG)
        }

        function memoize(func, resolver) {
            if (typeof func != "function" || resolver && typeof resolver != "function") throw new TypeError(FUNC_ERROR_TEXT);
            var memoized = function() {
                var args = arguments,
                    key = resolver ? resolver.apply(this, args) : args[0],
                    cache = memoized.cache;
                if (cache.has(key)) return cache.get(key);
                var result = func.apply(this, args);
                memoized.cache = cache.set(key,
                    result);
                return result
            };
            memoized.cache = new(memoize.Cache || MapCache);
            return memoized
        }
        memoize.Cache = MapCache;

        function negate(predicate) {
            if (typeof predicate != "function") throw new TypeError(FUNC_ERROR_TEXT);
            return function() {
                return !predicate.apply(this, arguments)
            }
        }

        function once(func) {
            return before(2, func)
        }
        var overArgs = rest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1, isFlattenableIteratee),
                baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return rest(function(args) {
                var index = -1,
                    length = nativeMin(args.length, funcsLength);
                while (++index < length) args[index] = transforms[index].call(this, args[index]);
                return apply(func, this, args)
            })
        });
        var partial = rest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrapper(func, PARTIAL_FLAG, undefined, partials, holders)
        });
        var partialRight = rest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrapper(func, PARTIAL_RIGHT_FLAG, undefined, partials, holders)
        });
        var rearg = rest(function(func, indexes) {
            return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes, 1))
        });

        function rest(func, start) {
            if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
            start = nativeMax(start === undefined ? func.length - 1 : toInteger(start), 0);
            return function() {
                var args = arguments,
                    index = -1,
                    length = nativeMax(args.length - start, 0),
                    array = Array(length);
                while (++index < length) array[index] =
                    args[start + index];
                switch (start) {
                    case 0:
                        return func.call(this, array);
                    case 1:
                        return func.call(this, args[0], array);
                    case 2:
                        return func.call(this, args[0], args[1], array)
                }
                var otherArgs = Array(start + 1);
                index = -1;
                while (++index < start) otherArgs[index] = args[index];
                otherArgs[start] = array;
                return apply(func, this, otherArgs)
            }
        }

        function spread(func, start) {
            if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
            start = start === undefined ? 0 : nativeMax(toInteger(start), 0);
            return rest(function(args) {
                var array = args[start],
                    otherArgs = castSlice(args, 0, start);
                if (array) arrayPush(otherArgs, array);
                return apply(func, this, otherArgs)
            })
        }

        function throttle(func, wait, options) {
            var leading = true,
                trailing = true;
            if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
            if (isObject(options)) {
                leading = "leading" in options ? !!options.leading : leading;
                trailing = "trailing" in options ? !!options.trailing : trailing
            }
            return debounce(func, wait, {
                "leading": leading,
                "maxWait": wait,
                "trailing": trailing
            })
        }

        function unary(func) {
            return ary(func, 1)
        }

        function wrap(value,
            wrapper) {
            wrapper = wrapper == null ? identity : wrapper;
            return partial(wrapper, value)
        }

        function castArray() {
            if (!arguments.length) return [];
            var value = arguments[0];
            return isArray(value) ? value : [value]
        }

        function clone(value) {
            return baseClone(value, false, true)
        }

        function cloneWith(value, customizer) {
            return baseClone(value, false, true, customizer)
        }

        function cloneDeep(value) {
            return baseClone(value, true, true)
        }

        function cloneDeepWith(value, customizer) {
            return baseClone(value, true, true, customizer)
        }

        function eq(value, other) {
            return value ===
                other || value !== value && other !== other
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
            return value >= other
        });

        function isArguments(value) {
            return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag)
        }
        var isArray = Array.isArray;

        function isArrayBuffer(value) {
            return isObjectLike(value) && objectToString.call(value) == arrayBufferTag
        }

        function isArrayLike(value) {
            return value !=
                null && isLength(getLength(value)) && !isFunction(value)
        }

        function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value)
        }

        function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag
        }
        var isBuffer = !Buffer ? stubFalse : function(value) {
            return value instanceof Buffer
        };

        function isDate(value) {
            return isObjectLike(value) && objectToString.call(value) == dateTag
        }

        function isElement(value) {
            return !!value && value.nodeType === 1 && isObjectLike(value) &&
                !isPlainObject(value)
        }

        function isEmpty(value) {
            if (isArrayLike(value) && (isArray(value) || isString(value) || isFunction(value.splice) || isArguments(value) || isBuffer(value))) return !value.length;
            if (isObjectLike(value)) {
                var tag = getTag(value);
                if (tag == mapTag || tag == setTag) return !value.size
            }
            for (var key in value)
                if (hasOwnProperty.call(value, key)) return false;
            return !(nonEnumShadows && keys(value).length)
        }

        function isEqual(value, other) {
            return baseIsEqual(value, other)
        }

        function isEqualWith(value, other, customizer) {
            customizer =
                typeof customizer == "function" ? customizer : undefined;
            var result = customizer ? customizer(value, other) : undefined;
            return result === undefined ? baseIsEqual(value, other, customizer) : !!result
        }

        function isError(value) {
            if (!isObjectLike(value)) return false;
            return objectToString.call(value) == errorTag || typeof value.message == "string" && typeof value.name == "string"
        }

        function isFinite(value) {
            return typeof value == "number" && nativeIsFinite(value)
        }

        function isFunction(value) {
            var tag = isObject(value) ? objectToString.call(value) : "";
            return tag == funcTag || tag == genTag
        }

        function isInteger(value) {
            return typeof value == "number" && value == toInteger(value)
        }

        function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER
        }

        function isObject(value) {
            var type = typeof value;
            return !!value && (type == "object" || type == "function")
        }

        function isObjectLike(value) {
            return !!value && typeof value == "object"
        }

        function isMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag
        }

        function isMatch(object, source) {
            return object === source ||
                baseIsMatch(object, source, getMatchData(source))
        }

        function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined;
            return baseIsMatch(object, source, getMatchData(source), customizer)
        }

        function isNaN(value) {
            return isNumber(value) && value != +value
        }

        function isNative(value) {
            if (isMaskable(value)) throw new Error("This method is not supported with `core-js`. Try https://github.com/es-shims.");
            return baseIsNative(value)
        }

        function isNull(value) {
            return value === null
        }

        function isNil(value) {
            return value ==
                null
        }

        function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag
        }

        function isPlainObject(value) {
            if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) return false;
            var proto = getPrototype(value);
            if (proto === null) return true;
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString
        }

        function isRegExp(value) {
            return isObject(value) &&
                objectToString.call(value) == regexpTag
        }

        function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER
        }

        function isSet(value) {
            return isObjectLike(value) && getTag(value) == setTag
        }

        function isString(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag
        }

        function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag
        }

        function isTypedArray(value) {
            return isObjectLike(value) &&
                isLength(value.length) && !!typedArrayTags[objectToString.call(value)]
        }

        function isUndefined(value) {
            return value === undefined
        }

        function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag
        }

        function isWeakSet(value) {
            return isObjectLike(value) && objectToString.call(value) == weakSetTag
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
            return value <= other
        });

        function toArray(value) {
            if (!value) return [];
            if (isArrayLike(value)) return isString(value) ?
                stringToArray(value) : copyArray(value);
            if (iteratorSymbol && value[iteratorSymbol]) return iteratorToArray(value[iteratorSymbol]());
            var tag = getTag(value),
                func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value)
        }

        function toFinite(value) {
            if (!value) return value === 0 ? value : 0;
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
                var sign = value < 0 ? -1 : 1;
                return sign * MAX_INTEGER
            }
            return value === value ? value : 0
        }

        function toInteger(value) {
            var result = toFinite(value),
                remainder = result % 1;
            return result ===
                result ? remainder ? result - remainder : result : 0
        }

        function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0
        }

        function toNumber(value) {
            if (typeof value == "number") return value;
            if (isSymbol(value)) return NAN;
            if (isObject(value)) {
                var other = isFunction(value.valueOf) ? value.valueOf() : value;
                value = isObject(other) ? other + "" : other
            }
            if (typeof value != "string") return value === 0 ? value : +value;
            value = value.replace(reTrim, "");
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ?
                freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value
        }

        function toPlainObject(value) {
            return copyObject(value, keysIn(value))
        }

        function toSafeInteger(value) {
            return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        }

        function toString(value) {
            return value == null ? "" : baseToString(value)
        }
        var assign = createAssigner(function(object, source) {
            if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
                copyObject(source, keys(source), object);
                return
            }
            for (var key in source)
                if (hasOwnProperty.call(source,
                        key)) assignValue(object, key, source[key])
        });
        var assignIn = createAssigner(function(object, source) {
            if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
                copyObject(source, keysIn(source), object);
                return
            }
            for (var key in source) assignValue(object, key, source[key])
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer)
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object,
                customizer)
        });
        var at = rest(function(object, paths) {
            return baseAt(object, baseFlatten(paths, 1))
        });

        function create(prototype, properties) {
            var result = baseCreate(prototype);
            return properties ? baseAssign(result, properties) : result
        }
        var defaults = rest(function(args) {
            args.push(undefined, assignInDefaults);
            return apply(assignInWith, undefined, args)
        });
        var defaultsDeep = rest(function(args) {
            args.push(undefined, mergeDefaults);
            return apply(mergeWith, undefined, args)
        });

        function findKey(object, predicate) {
            return baseFindKey(object,
                getIteratee(predicate, 3), baseForOwn)
        }

        function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight)
        }

        function forIn(object, iteratee) {
            return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn)
        }

        function forInRight(object, iteratee) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn)
        }

        function forOwn(object, iteratee) {
            return object && baseForOwn(object, getIteratee(iteratee, 3))
        }

        function forOwnRight(object, iteratee) {
            return object &&
                baseForOwnRight(object, getIteratee(iteratee, 3))
        }

        function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object))
        }

        function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object))
        }

        function get(object, path, defaultValue) {
            var result = object == null ? undefined : baseGet(object, path);
            return result === undefined ? defaultValue : result
        }

        function has(object, path) {
            return object != null && hasPath(object, path, baseHas)
        }

        function hasIn(object, path) {
            return object != null && hasPath(object,
                path, baseHasIn)
        }
        var invert = createInverter(function(result, value, key) {
            result[value] = key
        }, constant(identity));
        var invertBy = createInverter(function(result, value, key) {
            if (hasOwnProperty.call(result, value)) result[value].push(key);
            else result[value] = [key]
        }, getIteratee);
        var invoke = rest(baseInvoke);

        function keys(object) {
            var isProto = isPrototype(object);
            if (!(isProto || isArrayLike(object))) return baseKeys(object);
            var indexes = indexKeys(object),
                skipIndexes = !!indexes,
                result = indexes || [],
                length = result.length;
            for (var key in object)
                if (baseHas(object,
                        key) && !(skipIndexes && (key == "length" || isIndex(key, length))) && !(isProto && key == "constructor")) result.push(key);
            return result
        }

        function keysIn(object) {
            var index = -1,
                isProto = isPrototype(object),
                props = baseKeysIn(object),
                propsLength = props.length,
                indexes = indexKeys(object),
                skipIndexes = !!indexes,
                result = indexes || [],
                length = result.length;
            while (++index < propsLength) {
                var key = props[index];
                if (!(skipIndexes && (key == "length" || isIndex(key, length))) && !(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) result.push(key)
            }
            return result
        }

        function mapKeys(object, iteratee) {
            var result = {};
            iteratee = getIteratee(iteratee, 3);
            baseForOwn(object, function(value, key, object) {
                result[iteratee(value, key, object)] = value
            });
            return result
        }

        function mapValues(object, iteratee) {
            var result = {};
            iteratee = getIteratee(iteratee, 3);
            baseForOwn(object, function(value, key, object) {
                result[key] = iteratee(value, key, object)
            });
            return result
        }
        var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex)
        });
        var mergeWith = createAssigner(function(object,
            source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer)
        });
        var omit = rest(function(object, props) {
            if (object == null) return {};
            props = arrayMap(baseFlatten(props, 1), toKey);
            return basePick(object, baseDifference(getAllKeysIn(object), props))
        });

        function omitBy(object, predicate) {
            predicate = getIteratee(predicate);
            return basePickBy(object, function(value, key) {
                return !predicate(value, key)
            })
        }
        var pick = rest(function(object, props) {
            return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey))
        });

        function pickBy(object, predicate) {
            return object == null ? {} : basePickBy(object, getIteratee(predicate))
        }

        function result(object, path, defaultValue) {
            path = isKey(path, object) ? [path] : castPath(path);
            var index = -1,
                length = path.length;
            if (!length) {
                object = undefined;
                length = 1
            }
            while (++index < length) {
                var value = object == null ? undefined : object[toKey(path[index])];
                if (value === undefined) {
                    index = length;
                    value = defaultValue
                }
                object = isFunction(value) ? value.call(object) : value
            }
            return object
        }

        function set(object, path, value) {
            return object ==
                null ? object : baseSet(object, path, value)
        }

        function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined;
            return object == null ? object : baseSet(object, path, value, customizer)
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);

        function transform(object, iteratee, accumulator) {
            var isArr = isArray(object) || isTypedArray(object);
            iteratee = getIteratee(iteratee, 4);
            if (accumulator == null)
                if (isArr || isObject(object)) {
                    var Ctor = object.constructor;
                    if (isArr) accumulator =
                        isArray(object) ? new Ctor : [];
                    else accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {}
                } else accumulator = {};
                (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
                    return iteratee(accumulator, value, index, object)
                });
            return accumulator
        }

        function unset(object, path) {
            return object == null ? true : baseUnset(object, path)
        }

        function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater))
        }

        function updateWith(object, path, updater, customizer) {
            customizer =
                typeof customizer == "function" ? customizer : undefined;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer)
        }

        function values(object) {
            return object ? baseValues(object, keys(object)) : []
        }

        function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object))
        }

        function clamp(number, lower, upper) {
            if (upper === undefined) {
                upper = lower;
                lower = undefined
            }
            if (upper !== undefined) {
                upper = toNumber(upper);
                upper = upper === upper ? upper : 0
            }
            if (lower !== undefined) {
                lower = toNumber(lower);
                lower = lower ===
                    lower ? lower : 0
            }
            return baseClamp(toNumber(number), lower, upper)
        }

        function inRange(number, start, end) {
            start = toNumber(start) || 0;
            if (end === undefined) {
                end = start;
                start = 0
            } else end = toNumber(end) || 0;
            number = toNumber(number);
            return baseInRange(number, start, end)
        }

        function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) upper = floating = undefined;
            if (floating === undefined)
                if (typeof upper == "boolean") {
                    floating = upper;
                    upper = undefined
                } else if (typeof lower == "boolean") {
                floating =
                    lower;
                lower = undefined
            }
            if (lower === undefined && upper === undefined) {
                lower = 0;
                upper = 1
            } else {
                lower = toNumber(lower) || 0;
                if (upper === undefined) {
                    upper = lower;
                    lower = 0
                } else upper = toNumber(upper) || 0
            }
            if (lower > upper) {
                var temp = lower;
                lower = upper;
                upper = temp
            }
            if (floating || lower % 1 || upper % 1) {
                var rand = nativeRandom();
                return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper)
            }
            return baseRandom(lower, upper)
        }
        var camelCase = createCompounder(function(result, word, index) {
            word = word.toLowerCase();
            return result +
                (index ? capitalize(word) : word)
        });

        function capitalize(string) {
            return upperFirst(toString(string).toLowerCase())
        }

        function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, "")
        }

        function endsWith(string, target, position) {
            string = toString(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
            position -= target.length;
            return position >= 0 && string.indexOf(target, position) ==
                position
        }

        function escape(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string
        }

        function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string
        }
        var kebabCase = createCompounder(function(result, word, index) {
            return result + (index ? "-" : "") + word.toLowerCase()
        });
        var lowerCase = createCompounder(function(result, word, index) {
            return result + (index ? " " : "") + word.toLowerCase()
        });
        var lowerFirst = createCaseFirst("toLowerCase");

        function pad(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) return string;
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars)
        }

        function padEnd(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length -
                strLength, chars) : string
        }

        function padStart(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string
        }

        function parseInt(string, radix, guard) {
            if (guard || radix == null) radix = 0;
            else if (radix) radix = +radix;
            string = toString(string).replace(reTrim, "");
            return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10))
        }

        function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string,
                    n, guard) : n === undefined) n = 1;
            else n = toInteger(n);
            return baseRepeat(toString(string), n)
        }

        function replace() {
            var args = arguments,
                string = toString(args[0]);
            return args.length < 3 ? string : nativeReplace.call(string, args[1], args[2])
        }
        var snakeCase = createCompounder(function(result, word, index) {
            return result + (index ? "_" : "") + word.toLowerCase()
        });

        function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) separator = limit = undefined;
            limit = limit === undefined ? MAX_ARRAY_LENGTH :
                limit >>> 0;
            if (!limit) return [];
            string = toString(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
                separator = baseToString(separator);
                if (separator == "" && reHasComplexSymbol.test(string)) return castSlice(stringToArray(string), 0, limit)
            }
            return nativeSplit.call(string, separator, limit)
        }
        var startCase = createCompounder(function(result, word, index) {
            return result + (index ? " " : "") + upperFirst(word)
        });

        function startsWith(string, target, position) {
            string = toString(string);
            position = baseClamp(toInteger(position),
                0, string.length);
            return string.lastIndexOf(baseToString(target), position) == position
        }

        function template(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) options = undefined;
            string = toString(string);
            options = assignInWith({}, options, settings, assignInDefaults);
            var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),
                importsKeys = keys(imports),
                importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0,
                interpolate =
                options.interpolate || reNoMatch,
                source = "__p += '";
            var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
            var sourceURL = "//# sourceURL=" + ("sourceURL" in options ? options.sourceURL : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                interpolateValue ||
                    (interpolateValue = esTemplateValue);
                source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                if (escapeValue) {
                    isEscaping = true;
                    source += "' +\n__e(" + escapeValue + ") +\n'"
                }
                if (evaluateValue) {
                    isEvaluating = true;
                    source += "';\n" + evaluateValue + ";\n__p += '"
                }
                if (interpolateValue) source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                index = offset + match.length;
                return match
            });
            source += "';\n";
            var variable = options.variable;
            if (!variable) source = "with (obj) {\n" + source + "\n}\n";
            source =
                (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result = attempt(function() {
                return Function(importsKeys, sourceURL + "return " + source).apply(undefined,
                    importsValues)
            });
            result.source = source;
            if (isError(result)) throw result;
            return result
        }

        function toLower(value) {
            return toString(value).toLowerCase()
        }

        function toUpper(value) {
            return toString(value).toUpperCase()
        }

        function trim(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined)) return string.replace(reTrim, "");
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string),
                chrSymbols = stringToArray(chars),
                start = charsStartIndex(strSymbols, chrSymbols),
                end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("")
        }

        function trimEnd(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined)) return string.replace(reTrimEnd, "");
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string),
                end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("")
        }

        function trimStart(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars ===
                    undefined)) return string.replace(reTrimStart, "");
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string),
                start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("")
        }

        function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH,
                omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
                var separator = "separator" in options ? options.separator : separator;
                length = "length" in options ? toInteger(options.length) : length;
                omission = "omission" in
                    options ? baseToString(options.omission) : omission
            }
            string = toString(string);
            var strLength = string.length;
            if (reHasComplexSymbol.test(string)) {
                var strSymbols = stringToArray(string);
                strLength = strSymbols.length
            }
            if (length >= strLength) return string;
            var end = length - stringSize(omission);
            if (end < 1) return omission;
            var result = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined) return result + omission;
            if (strSymbols) end += result.length - end;
            if (isRegExp(separator)) {
                if (string.slice(end).search(separator)) {
                    var match,
                        substring = result;
                    if (!separator.global) separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g");
                    separator.lastIndex = 0;
                    while (match = separator.exec(substring)) var newEnd = match.index;
                    result = result.slice(0, newEnd === undefined ? end : newEnd)
                }
            } else if (string.indexOf(baseToString(separator), end) != end) {
                var index = result.lastIndexOf(separator);
                if (index > -1) result = result.slice(0, index)
            }
            return result + omission
        }

        function unescape(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ?
                string.replace(reEscapedHtml, unescapeHtmlChar) : string
        }
        var upperCase = createCompounder(function(result, word, index) {
            return result + (index ? " " : "") + word.toUpperCase()
        });
        var upperFirst = createCaseFirst("toUpperCase");

        function words(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined : pattern;
            if (pattern === undefined) pattern = reHasComplexWord.test(string) ? reComplexWord : reBasicWord;
            return string.match(pattern) || []
        }
        var attempt = rest(function(func, args) {
            try {
                return apply(func, undefined, args)
            } catch (e) {
                return isError(e) ?
                    e : new Error(e)
            }
        });
        var bindAll = rest(function(object, methodNames) {
            arrayEach(baseFlatten(methodNames, 1), function(key) {
                key = toKey(key);
                object[key] = bind(object[key], object)
            });
            return object
        });

        function cond(pairs) {
            var length = pairs ? pairs.length : 0,
                toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
                if (typeof pair[1] != "function") throw new TypeError(FUNC_ERROR_TEXT);
                return [toIteratee(pair[0]), pair[1]]
            });
            return rest(function(args) {
                var index = -1;
                while (++index < length) {
                    var pair = pairs[index];
                    if (apply(pair[0],
                            this, args)) return apply(pair[1], this, args)
                }
            })
        }

        function conforms(source) {
            return baseConforms(baseClone(source, true))
        }

        function constant(value) {
            return function() {
                return value
            }
        }
        var flow = createFlow();
        var flowRight = createFlow(true);

        function identity(value) {
            return value
        }

        function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, true))
        }

        function matches(source) {
            return baseMatches(baseClone(source, true))
        }

        function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue,
                true))
        }
        var method = rest(function(path, args) {
            return function(object) {
                return baseInvoke(object, path, args)
            }
        });
        var methodOf = rest(function(object, args) {
            return function(path) {
                return baseInvoke(object, path, args)
            }
        });

        function mixin(object, source, options) {
            var props = keys(source),
                methodNames = baseFunctions(source, props);
            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
                options = source;
                source = object;
                object = this;
                methodNames = baseFunctions(source, keys(source))
            }
            var chain = !(isObject(options) &&
                    "chain" in options) || !!options.chain,
                isFunc = isFunction(object);
            arrayEach(methodNames, function(methodName) {
                var func = source[methodName];
                object[methodName] = func;
                if (isFunc) object.prototype[methodName] = function() {
                    var chainAll = this.__chain__;
                    if (chain || chainAll) {
                        var result = object(this.__wrapped__),
                            actions = result.__actions__ = copyArray(this.__actions__);
                        actions.push({
                            "func": func,
                            "args": arguments,
                            "thisArg": object
                        });
                        result.__chain__ = chainAll;
                        return result
                    }
                    return func.apply(object, arrayPush([this.value()], arguments))
                }
            });
            return object
        }

        function noConflict() {
            if (root._ === this) root._ = oldDash;
            return this
        }

        function noop() {}

        function nthArg(n) {
            n = toInteger(n);
            return rest(function(args) {
                return baseNth(args, n)
            })
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);

        function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path)
        }

        function propertyOf(object) {
            return function(path) {
                return object == null ? undefined : baseGet(object, path)
            }
        }
        var range = createRange();
        var rangeRight = createRange(true);

        function stubArray() {
            return []
        }

        function stubFalse() {
            return false
        }

        function stubObject() {
            return {}
        }

        function stubString() {
            return ""
        }

        function stubTrue() {
            return true
        }

        function times(n, iteratee) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) return [];
            var index = MAX_ARRAY_LENGTH,
                length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee = getIteratee(iteratee);
            n -= MAX_ARRAY_LENGTH;
            var result = baseTimes(length, iteratee);
            while (++index < n) iteratee(index);
            return result
        }

        function toPath(value) {
            if (isArray(value)) return arrayMap(value,
                toKey);
            return isSymbol(value) ? [value] : copyArray(stringToPath(value))
        }

        function uniqueId(prefix) {
            var id = ++idCounter;
            return toString(prefix) + id
        }
        var add = createMathOperation(function(augend, addend) {
            return augend + addend
        });
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor
        });
        var floor = createRound("floor");

        function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined
        }

        function maxBy(array, iteratee) {
            return array && array.length ?
                baseExtremum(array, getIteratee(iteratee), baseGt) : undefined
        }

        function mean(array) {
            return baseMean(array, identity)
        }

        function meanBy(array, iteratee) {
            return baseMean(array, getIteratee(iteratee))
        }

        function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined
        }

        function minBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee), baseLt) : undefined
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand
        });
        var round =
            createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend
        });

        function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0
        }

        function sumBy(array, iteratee) {
            return array && array.length ? baseSum(array, getIteratee(iteratee)) : 0
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey =
            bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop =
            drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection =
            intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin =
            mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt =
            pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile =
            takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values =
            values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.deburr = deburr;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn =
            forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer =
            isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean =
            mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template =
            template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
                if (!hasOwnProperty.call(lodash.prototype, methodName)) source[methodName] = func
            });
            return source
        }(), {
            "chain": false
        });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash
        });
        arrayEach(["drop", "take"], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n) {
                var filtered = this.__filtered__;
                if (filtered && !index) return new LazyWrapper(this);
                n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
                var result = this.clone();
                if (filtered) result.__takeCount__ = nativeMin(n, result.__takeCount__);
                else result.__views__.push({
                    "size": nativeMin(n, MAX_ARRAY_LENGTH),
                    "type": methodName + (result.__dir__ < 0 ? "Right" : "")
                });
                return result
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
                return this.reverse()[methodName](n).reverse()
            }
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
            var type = index + 1,
                isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee) {
                var result = this.clone();
                result.__iteratees__.push({
                    "iteratee": getIteratee(iteratee, 3),
                    "type": type
                });
                result.__filtered__ = result.__filtered__ || isFilter;
                return result
            }
        });
        arrayEach(["head", "last"], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
                return this[takeName](1).value()[0]
            }
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] =
                function() {
                    return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1)
                }
        });
        LazyWrapper.prototype.compact = function() {
            return this.filter(identity)
        };
        LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head()
        };
        LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate)
        };
        LazyWrapper.prototype.invokeMap = rest(function(path, args) {
            if (typeof path == "function") return new LazyWrapper(this);
            return this.map(function(value) {
                return baseInvoke(value, path, args)
            })
        });
        LazyWrapper.prototype.reject = function(predicate) {
            predicate = getIteratee(predicate, 3);
            return this.filter(function(value) {
                return !predicate(value)
            })
        };
        LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result = this;
            if (result.__filtered__ && (start > 0 || end < 0)) return new LazyWrapper(result);
            if (start < 0) result = result.takeRight(-start);
            else if (start) result = result.drop(start);
            if (end !== undefined) {
                end = toInteger(end);
                result = end < 0 ? result.dropRight(-end) : result.take(end - start)
            }
            return result
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse()
        };
        LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH)
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
                isTaker = /^(?:head|last)$/.test(methodName),
                lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName],
                retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) return;
            lodash.prototype[methodName] = function() {
                var value = this.__wrapped__,
                    args = isTaker ? [1] : arguments,
                    isLazy = value instanceof LazyWrapper,
                    iteratee = args[0],
                    useLazy = isLazy || isArray(value);
                var interceptor = function(value) {
                    var result = lodashFunc.apply(lodash, arrayPush([value], args));
                    return isTaker && chainAll ? result[0] : result
                };
                if (useLazy && checkIteratee && typeof iteratee == "function" && iteratee.length != 1) isLazy = useLazy = false;
                var chainAll = this.__chain__,
                    isHybrid = !!this.__actions__.length,
                    isUnwrapped = retUnwrapped && !chainAll,
                    onlyLazy = isLazy && !isHybrid;
                if (!retUnwrapped && useLazy) {
                    value = onlyLazy ? value : new LazyWrapper(this);
                    var result = func.apply(value, args);
                    result.__actions__.push({
                        "func": thru,
                        "args": [interceptor],
                        "thisArg": undefined
                    });
                    return new LodashWrapper(result, chainAll)
                }
                if (isUnwrapped && onlyLazy) return func.apply(this, args);
                result = this.thru(interceptor);
                return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result
            }
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName],
                chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru",
                retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
                var args = arguments;
                if (retUnwrapped && !this.__chain__) {
                    var value = this.value();
                    return func.apply(isArray(value) ? value : [], args)
                }
                return this[chainName](function(value) {
                    return func.apply(isArray(value) ? value : [], args)
                })
            }
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
                var key = lodashFunc.name +
                    "",
                    names = realNames[key] || (realNames[key] = []);
                names.push({
                    "name": methodName,
                    "func": lodashFunc
                })
            }
        });
        realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse =
            wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        if (iteratorSymbol) lodash.prototype[iteratorSymbol] = wrapperToIterator;
        return lodash
    }
    var _ = runInContext();
    (freeSelf || {})._ = _;
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) define(function() {
        return _
    });
    else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _
    } else root._ = _
}).call(this);
(function(global, factory) {
    if (typeof module === "object" && typeof module.exports === "object") module.exports = global.document ? factory(global, true) : function(w) {
        if (!w.document) throw new Error("jQuery requires a window with a document");
        return factory(w)
    };
    else factory(global)
})(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
    var arr = [];
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var support = {};
    var document = window.document,
        version = "2.1.1",
        jQuery = function(selector, context) {
            return new jQuery.fn.init(selector, context)
        },
        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
        rmsPrefix = /^-ms-/,
        rdashAlpha = /-([\da-z])/gi,
        fcamelCase = function(all, letter) {
            return letter.toUpperCase()
        };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        selector: "",
        length: 0,
        toArray: function() {
            return slice.call(this)
        },
        get: function(num) {
            return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this)
        },
        pushStack: function(elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            return ret
        },
        each: function(callback, args) {
            return jQuery.each(this, callback, args)
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem)
            }))
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments))
        },
        first: function() {
            return this.eq(0)
        },
        last: function() {
            return this.eq(-1)
        },
        eq: function(i) {
            var len = this.length,
                j = +i + (i < 0 ?
                    len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : [])
        },
        end: function() {
            return this.prevObject || this.constructor(null)
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;
        if (typeof target === "boolean") {
            deep = target;
            target = arguments[i] || {};
            i++
        }
        if (typeof target !== "object" && !jQuery.isFunction(target)) target = {};
        if (i === length) {
            target = this;
            i--
        }
        for (; i < length; i++)
            if ((options =
                    arguments[i]) != null)
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) continue;
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : []
                        } else clone = src && jQuery.isPlainObject(src) ? src : {};
                        target[name] = jQuery.extend(deep, clone, copy)
                    } else if (copy !== undefined) target[name] = copy
                }
            return target
    };
    jQuery.extend({
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        isReady: true,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        isFunction: function(obj) {
            return jQuery.type(obj) === "function"
        },
        isArray: Array.isArray,
        isWindow: function(obj) {
            return obj != null && obj === obj.window
        },
        isNumeric: function(obj) {
            return !jQuery.isArray(obj) && obj - parseFloat(obj) >= 0
        },
        isPlainObject: function(obj) {
            if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) return false;
            if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) return false;
            return true
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) return false;
            return true
        },
        type: function(obj) {
            if (obj == null) return obj + "";
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj
        },
        globalEval: function(code) {
            var script, indirect = eval;
            code = jQuery.trim(code);
            if (code)
                if (code.indexOf("use strict") === 1) {
                    script = document.createElement("script");
                    script.text = code;
                    document.head.appendChild(script).parentNode.removeChild(script)
                } else indirect(code)
        },
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha,
                fcamelCase)
        },
        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase()
        },
        each: function(obj, callback, args) {
            var value, i = 0,
                length = obj.length,
                isArray = isArraylike(obj);
            if (args)
                if (isArray)
                    for (; i < length; i++) {
                        value = callback.apply(obj[i], args);
                        if (value === false) break
                    } else
                        for (i in obj) {
                            value = callback.apply(obj[i], args);
                            if (value === false) break
                        } else if (isArray)
                            for (; i < length; i++) {
                                value = callback.call(obj[i], i, obj[i]);
                                if (value === false) break
                            } else
                                for (i in obj) {
                                    value = callback.call(obj[i],
                                        i, obj[i]);
                                    if (value === false) break
                                }
                        return obj
        },
        trim: function(text) {
            return text == null ? "" : (text + "").replace(rtrim, "")
        },
        makeArray: function(arr, results) {
            var ret = results || [];
            if (arr != null)
                if (isArraylike(Object(arr))) jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
                else push.call(ret, arr);
            return ret
        },
        inArray: function(elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i)
        },
        merge: function(first, second) {
            var len = +second.length,
                j = 0,
                i = first.length;
            for (; j < len; j++) first[i++] = second[j];
            first.length = i;
            return first
        },
        grep: function(elems, callback, invert) {
            var callbackInverse, matches = [],
                i = 0,
                length = elems.length,
                callbackExpect = !invert;
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) matches.push(elems[i])
            }
            return matches
        },
        map: function(elems, callback, arg) {
            var value, i = 0,
                length = elems.length,
                isArray = isArraylike(elems),
                ret = [];
            if (isArray)
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) ret.push(value)
                } else
                    for (i in elems) {
                        value = callback(elems[i], i, arg);
                        if (value !=
                            null) ret.push(value)
                    }
            return concat.apply([], ret)
        },
        guid: 1,
        proxy: function(fn, context) {
            var tmp, args, proxy;
            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp
            }
            if (!jQuery.isFunction(fn)) return undefined;
            args = slice.call(arguments, 2);
            proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)))
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy
        },
        now: Date.now,
        support: support
    });
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i,
        name) {
        class2type["[object " + name + "]"] = name.toLowerCase()
    });

    function isArraylike(obj) {
        var length = obj.length,
            type = jQuery.type(obj);
        if (type === "function" || jQuery.isWindow(obj)) return false;
        if (obj.nodeType === 1 && length) return true;
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj
    }
    var Sizzle = function(window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches,
            matches, contains, expando = "sizzle" + -new Date,
            preferredDoc = window.document,
            dirruns = 0,
            done = 0,
            classCache = createCache(),
            tokenCache = createCache(),
            compilerCache = createCache(),
            sortOrder = function(a, b) {
                if (a === b) hasDuplicate = true;
                return 0
            },
            strundefined = typeof undefined,
            MAX_NEGATIVE = 1 << 31,
            hasOwn = {}.hasOwnProperty,
            arr = [],
            pop = arr.pop,
            push_native = arr.push,
            push = arr.push,
            slice = arr.slice,
            indexOf = arr.indexOf || function(elem) {
                var i = 0,
                    len = this.length;
                for (; i < len; i++)
                    if (this[i] === elem) return i;
                return -1
            },
            booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
            whitespace = "[\\x20\\t\\r\\n\\f]",
            characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
            identifier = characterEncoding.replace("w", "w#"),
            attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
            pseudos = ":(" + characterEncoding + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
            rtrim = new RegExp("^" +
                whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
            rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
            rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
            rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
            rpseudo = new RegExp(pseudos),
            ridentifier = new RegExp("^" + identifier + "$"),
            matchExpr = {
                "ID": new RegExp("^#(" + characterEncoding + ")"),
                "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
                "TAG": new RegExp("^(" + characterEncoding.replace("w",
                    "w*") + ")"),
                "ATTR": new RegExp("^" + attributes),
                "PSEUDO": new RegExp("^" + pseudos),
                "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                "bool": new RegExp("^(?:" + booleans + ")$", "i"),
                "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
            },
            rinputs = /^(?:input|select|textarea|button)$/i,
            rheader = /^h\d$/i,
            rnative = /^[^{]+\{\s*\[native \w/,
            rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
            rsibling = /[+~]/,
            rescape = /'|\\/g,
            runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
            funescape = function(_, escaped, escapedWhitespace) {
                var high = "0x" + escaped - 65536;
                return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
            };
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr[preferredDoc.childNodes.length].nodeType
        } catch (e) {
            push = {
                apply: arr.length ? function(target, els) {
                    push_native.apply(target, slice.call(els))
                } : function(target, els) {
                    var j = target.length,
                        i = 0;
                    while (target[j++] = els[i++]);
                    target.length = j - 1
                }
            }
        }

        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
            if ((context ? context.ownerDocument || context : preferredDoc) !== document) setDocument(context);
            context = context || document;
            results = results || [];
            if (!selector || typeof selector !==
                "string") return results;
            if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) return [];
            if (documentIsHTML && !seed) {
                if (match = rquickExpr.exec(selector))
                    if (m = match[1])
                        if (nodeType === 9) {
                            elem = context.getElementById(m);
                            if (elem && elem.parentNode) {
                                if (elem.id === m) {
                                    results.push(elem);
                                    return results
                                }
                            } else return results
                        } else {
                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results
                            }
                        } else if (match[2]) {
                    push.apply(results, context.getElementsByTagName(selector));
                    return results
                } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                    push.apply(results, context.getElementsByClassName(m));
                    return results
                }
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    nid = old = expando;
                    newContext = context;
                    newSelector = nodeType === 9 && selector;
                    if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                        groups = tokenize(selector);
                        if (old = context.getAttribute("id")) nid = old.replace(rescape, "\\$&");
                        else context.setAttribute("id", nid);
                        nid = "[id='" + nid +
                            "'] ";
                        i = groups.length;
                        while (i--) groups[i] = nid + toSelector(groups[i]);
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        newSelector = groups.join(",")
                    }
                    if (newSelector) try {
                        push.apply(results, newContext.querySelectorAll(newSelector));
                        return results
                    } catch (qsaError) {} finally {
                        if (!old) context.removeAttribute("id")
                    }
                }
            }
            return select(selector.replace(rtrim, "$1"), context, results, seed)
        }

        function createCache() {
            var keys = [];

            function cache(key, value) {
                if (keys.push(key + " ") > Expr.cacheLength) delete cache[keys.shift()];
                return cache[key + " "] = value
            }
            return cache
        }

        function markFunction(fn) {
            fn[expando] = true;
            return fn
        }

        function assert(fn) {
            var div = document.createElement("div");
            try {
                return !!fn(div)
            } catch (e) {
                return false
            } finally {
                if (div.parentNode) div.parentNode.removeChild(div);
                div = null
            }
        }

        function addHandle(attrs, handler) {
            var arr = attrs.split("|"),
                i = attrs.length;
            while (i--) Expr.attrHandle[arr[i]] = handler
        }

        function siblingCheck(a, b) {
            var cur = b && a,
                diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex ||
                    MAX_NEGATIVE);
            if (diff) return diff;
            if (cur)
                while (cur = cur.nextSibling)
                    if (cur === b) return -1;
            return a ? 1 : -1
        }

        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type
            }
        }

        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type
            }
        }

        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed,
                    matches) {
                    var j, matchIndexes = fn([], seed.length, argument),
                        i = matchIndexes.length;
                    while (i--)
                        if (seed[j = matchIndexes[i]]) seed[j] = !(matches[j] = seed[j])
                })
            })
        }

        function testContext(context) {
            return context && typeof context.getElementsByTagName !== strundefined && context
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function(elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false
        };
        setDocument = Sizzle.setDocument = function(node) {
            var hasCompare,
                doc = node ? node.ownerDocument || node : preferredDoc,
                parent = doc.defaultView;
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) return document;
            document = doc;
            docElem = doc.documentElement;
            documentIsHTML = !isXML(doc);
            if (parent && parent !== parent.top)
                if (parent.addEventListener) parent.addEventListener("unload", function() {
                    setDocument()
                }, false);
                else if (parent.attachEvent) parent.attachEvent("onunload", function() {
                setDocument()
            });
            support.attributes = assert(function(div) {
                div.className = "i";
                return !div.getAttribute("className")
            });
            support.getElementsByTagName = assert(function(div) {
                div.appendChild(doc.createComment(""));
                return !div.getElementsByTagName("*").length
            });
            support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function(div) {
                div.innerHTML = "<div class='a'></div><div class='a i'></div>";
                div.firstChild.className = "i";
                return div.getElementsByClassName("i").length === 2
            });
            support.getById = assert(function(div) {
                docElem.appendChild(div).id = expando;
                return !doc.getElementsByName || !doc.getElementsByName(expando).length
            });
            if (support.getById) {
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== strundefined && documentIsHTML) {
                        var m = context.getElementById(id);
                        return m && m.parentNode ? [m] : []
                    }
                };
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        return elem.getAttribute("id") === attrId
                    }
                }
            } else {
                delete Expr.find["ID"];
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        var node = typeof elem.getAttributeNode !== strundefined &&
                            elem.getAttributeNode("id");
                        return node && node.value === attrId
                    }
                }
            }
            Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                if (typeof context.getElementsByTagName !== strundefined) return context.getElementsByTagName(tag)
            } : function(tag, context) {
                var elem, tmp = [],
                    i = 0,
                    results = context.getElementsByTagName(tag);
                if (tag === "*") {
                    while (elem = results[i++])
                        if (elem.nodeType === 1) tmp.push(elem);
                    return tmp
                }
                return results
            };
            Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                if (typeof context.getElementsByClassName !==
                    strundefined && documentIsHTML) return context.getElementsByClassName(className)
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support.qsa = rnative.test(doc.querySelectorAll)) {
                assert(function(div) {
                    div.innerHTML = "<select msallowclip=''><option selected=''></option></select>";
                    if (div.querySelectorAll("[msallowclip^='']").length) rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                    if (!div.querySelectorAll("[selected]").length) rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                    if (!div.querySelectorAll(":checked").length) rbuggyQSA.push(":checked")
                });
                assert(function(div) {
                    var input = doc.createElement("input");
                    input.setAttribute("type", "hidden");
                    div.appendChild(input).setAttribute("name", "D");
                    if (div.querySelectorAll("[name=d]").length) rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                    if (!div.querySelectorAll(":enabled").length) rbuggyQSA.push(":enabled", ":disabled");
                    div.querySelectorAll("*,:x");
                    rbuggyQSA.push(",.*:")
                })
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector ||
                    docElem.msMatchesSelector)) assert(function(div) {
                support.disconnectedMatch = matches.call(div, "div");
                matches.call(div, "[s!='']:x");
                rbuggyMatches.push("!=", pseudos)
            });
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a,
                    bup = b && b.parentNode;
                return a === bup || !!(bup &&
                    bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16))
            } : function(a, b) {
                if (b)
                    while (b = b.parentNode)
                        if (b === a) return true;
                return false
            };
            sortOrder = hasCompare ? function(a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) return compare;
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) ===
                    compare) {
                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) return -1;
                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) return 1;
                    return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0
                }
                return compare & 4 ? -1 : 1
            } : function(a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0
                }
                var cur, i = 0,
                    aup = a.parentNode,
                    bup = b.parentNode,
                    ap = [a],
                    bp = [b];
                if (!aup || !bup) return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                else if (aup ===
                    bup) return siblingCheck(a, b);
                cur = a;
                while (cur = cur.parentNode) ap.unshift(cur);
                cur = b;
                while (cur = cur.parentNode) bp.unshift(cur);
                while (ap[i] === bp[i]) i++;
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0
            };
            return doc
        };
        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements)
        };
        Sizzle.matchesSelector = function(elem, expr) {
            if ((elem.ownerDocument || elem) !== document) setDocument(elem);
            expr = expr.replace(rattributeQuotes, "='$1']");
            if (support.matchesSelector && documentIsHTML &&
                (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) try {
                var ret = matches.call(elem, expr);
                if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) return ret
            } catch (e) {}
            return Sizzle(expr, document, null, [elem]).length > 0
        };
        Sizzle.contains = function(context, elem) {
            if ((context.ownerDocument || context) !== document) setDocument(context);
            return contains(context, elem)
        };
        Sizzle.attr = function(elem, name) {
            if ((elem.ownerDocument || elem) !== document) setDocument(elem);
            var fn =
                Expr.attrHandle[name.toLowerCase()],
                val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
        };
        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [],
                j = 0,
                i = 0;
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable &&
                results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++])
                    if (elem === results[i]) j = duplicates.push(i);
                while (j--) results.splice(duplicates[j], 1)
            }
            sortInput = null;
            return results
        };
        getText = Sizzle.getText = function(elem) {
            var node, ret = "",
                i = 0,
                nodeType = elem.nodeType;
            if (!nodeType)
                while (node = elem[i++]) ret += getText(node);
            else if (nodeType === 1 || nodeType === 9 || nodeType === 11)
                if (typeof elem.textContent === "string") return elem.textContent;
                else
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) ret +=
                        getText(elem);
            else if (nodeType === 3 || nodeType === 4) return elem.nodeValue;
            return ret
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: true
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: true
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                "ATTR": function(match) {
                    match[1] = match[1].replace(runescape, funescape);
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                    if (match[2] === "~=") match[3] =
                        " " + match[3] + " ";
                    return match.slice(0, 4)
                },
                "CHILD": function(match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === "nth") {
                        if (!match[3]) Sizzle.error(match[0]);
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                        match[5] = +(match[7] + match[8] || match[3] === "odd")
                    } else if (match[3]) Sizzle.error(match[0]);
                    return match
                },
                "PSEUDO": function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr["CHILD"].test(match[0])) return null;
                    if (match[3]) match[2] = match[4] || match[5] ||
                        "";
                    else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess)
                    }
                    return match.slice(0, 3)
                }
            },
            filter: {
                "TAG": function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === "*" ? function() {
                        return true
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName
                    }
                },
                "CLASS": function(className) {
                    var pattern =
                        classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "")
                    })
                },
                "ATTR": function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) return operator === "!=";
                        if (!operator) return true;
                        result += "";
                        return operator === "=" ? result === check :
                            operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false
                    }
                },
                "CHILD": function(type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== "nth",
                        forward = type.slice(-4) !== "last",
                        ofType = what === "of-type";
                    return first === 1 && last === 0 ? function(elem) {
                            return !!elem.parentNode
                        } :
                        function(elem, context, xml) {
                            var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling",
                                parent = elem.parentNode,
                                name = ofType && elem.nodeName.toLowerCase(),
                                useCache = !xml && !ofType;
                            if (parent) {
                                if (simple) {
                                    while (dir) {
                                        node = elem;
                                        while (node = node[dir])
                                            if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) return false;
                                        start = dir = type === "only" && !start && "nextSibling"
                                    }
                                    return true
                                }
                                start = [forward ? parent.firstChild : parent.lastChild];
                                if (forward && useCache) {
                                    outerCache = parent[expando] ||
                                        (parent[expando] = {});
                                    cache = outerCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = cache[0] === dirruns && cache[2];
                                    node = nodeIndex && parent.childNodes[nodeIndex];
                                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())
                                        if (node.nodeType === 1 && ++diff && node === elem) {
                                            outerCache[type] = [dirruns, nodeIndex, diff];
                                            break
                                        }
                                } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) diff = cache[1];
                                else
                                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())
                                        if ((ofType ?
                                                node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                            if (useCache)(node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                                            if (node === elem) break
                                        }
                                diff -= last;
                                return diff === first || diff % first === 0 && diff / first >= 0
                            }
                        }
                },
                "PSEUDO": function(pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    if (fn[expando]) return fn(argument);
                    if (fn.length > 1) {
                        args = [pseudo, pseudo, "", argument];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                            markFunction(function(seed, matches) {
                                var idx, matched = fn(seed, argument),
                                    i = matched.length;
                                while (i--) {
                                    idx = indexOf.call(seed, matched[i]);
                                    seed[idx] = !(matches[idx] = matched[i])
                                }
                            }) : function(elem) {
                                return fn(elem, 0, args)
                            }
                    }
                    return fn
                }
            },
            pseudos: {
                "not": markFunction(function(selector) {
                    var input = [],
                        results = [],
                        matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []),
                            i = seed.length;
                        while (i--)
                            if (elem = unmatched[i]) seed[i] = !(matches[i] = elem)
                    }) : function(elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        return !results.pop()
                    }
                }),
                "has": markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0
                    }
                }),
                "contains": markFunction(function(text) {
                    return function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1
                    }
                }),
                "lang": markFunction(function(lang) {
                    if (!ridentifier.test(lang || "")) Sizzle.error("unsupported lang: " + lang);
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function(elem) {
                        var elemLang;
                        do
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + "-") === 0
                            }
                        while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false
                    }
                }),
                "target": function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id
                },
                "root": function(elem) {
                    return elem === docElem
                },
                "focus": function(elem) {
                    return elem === document.activeElement && (!document.hasFocus ||
                        document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex)
                },
                "enabled": function(elem) {
                    return elem.disabled === false
                },
                "disabled": function(elem) {
                    return elem.disabled === true
                },
                "checked": function(elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected
                },
                "selected": function(elem) {
                    if (elem.parentNode) elem.parentNode.selectedIndex;
                    return elem.selected === true
                },
                "empty": function(elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling)
                        if (elem.nodeType <
                            6) return false;
                    return true
                },
                "parent": function(elem) {
                    return !Expr.pseudos["empty"](elem)
                },
                "header": function(elem) {
                    return rheader.test(elem.nodeName)
                },
                "input": function(elem) {
                    return rinputs.test(elem.nodeName)
                },
                "button": function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button"
                },
                "text": function(elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text")
                },
                "first": createPositionalPseudo(function() {
                    return [0]
                }),
                "last": createPositionalPseudo(function(matchIndexes, length) {
                    return [length - 1]
                }),
                "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument]
                }),
                "even": createPositionalPseudo(function(matchIndexes, length) {
                    var i = 0;
                    for (; i < length; i += 2) matchIndexes.push(i);
                    return matchIndexes
                }),
                "odd": createPositionalPseudo(function(matchIndexes, length) {
                    var i = 1;
                    for (; i < length; i += 2) matchIndexes.push(i);
                    return matchIndexes
                }),
                "lt": createPositionalPseudo(function(matchIndexes,
                    length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; --i >= 0;) matchIndexes.push(i);
                    return matchIndexes
                }),
                "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; ++i < length;) matchIndexes.push(i);
                    return matchIndexes
                })
            }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        for (i in {
                radio: true,
                checkbox: true,
                file: true,
                password: true,
                image: true
            }) Expr.pseudos[i] = createInputPseudo(i);
        for (i in {
                submit: true,
                reset: true
            }) Expr.pseudos[i] = createButtonPseudo(i);

        function setFilters() {}
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters;
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) return parseOnly ? 0 : cached.slice(0);
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) soFar = soFar.slice(match[0].length) || soFar;
                    groups.push(tokens = [])
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    matched =
                        match.shift();
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, " ")
                    });
                    soFar = soFar.slice(matched.length)
                }
                for (type in Expr.filter)
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length)
                    }
                if (!matched) break
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0)
        };

        function toSelector(tokens) {
            var i = 0,
                len = tokens.length,
                selector = "";
            for (; i < len; i++) selector += tokens[i].value;
            return selector
        }

        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir,
                checkNonElements = base && dir === "parentNode",
                doneName = done++;
            return combinator.first ? function(elem, context, xml) {
                while (elem = elem[dir])
                    if (elem.nodeType === 1 || checkNonElements) return matcher(elem, context, xml)
            } : function(elem, context, xml) {
                var oldCache, outerCache, newCache = [dirruns, doneName];
                if (xml)
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements)
                            if (matcher(elem,
                                    context, xml)) return true
                    } else
                        while (elem = elem[dir])
                            if (elem.nodeType === 1 || checkNonElements) {
                                outerCache = elem[expando] || (elem[expando] = {});
                                if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) return newCache[2] = oldCache[2];
                                else {
                                    outerCache[dir] = newCache;
                                    if (newCache[2] = matcher(elem, context, xml)) return true
                                }
                            }
            }
        }

        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                    var i = matchers.length;
                    while (i--)
                        if (!matchers[i](elem, context, xml)) return false;
                    return true
                } :
                matchers[0]
        }

        function multipleContexts(selector, contexts, results) {
            var i = 0,
                len = contexts.length;
            for (; i < len; i++) Sizzle(selector, contexts[i], results);
            return results
        }

        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [],
                i = 0,
                len = unmatched.length,
                mapped = map != null;
            for (; i < len; i++)
                if (elem = unmatched[i])
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) map.push(i)
                    }
            return newUnmatched
        }

        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter &&
                !postFilter[expando]) postFilter = setMatcher(postFilter);
            if (postFinder && !postFinder[expando]) postFinder = setMatcher(postFinder, postSelector);
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [],
                    postMap = [],
                    preexisting = results.length,
                    elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
                    matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
                    matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) matcher(matcherIn, matcherOut, context, xml);
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--)
                        if (elem = temp[i]) matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem)
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--)
                                if (elem = matcherOut[i]) temp.push(matcherIn[i] = elem);
                            postFinder(null, matcherOut = [], temp, xml)
                        }
                        i = matcherOut.length;
                        while (i--)
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed,
                                    elem) : preMap[i]) > -1) seed[temp] = !(results[temp] = elem)
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) postFinder(null, results, matcherOut, xml);
                    else push.apply(results, matcherOut)
                }
            })
        }

        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length,
                leadingRelative = Expr.relative[tokens[0].type],
                implicitRelative = leadingRelative || Expr.relative[" "],
                i = leadingRelative ? 1 : 0,
                matchContext = addCombinator(function(elem) {
                    return elem ===
                        checkContext
                }, implicitRelative, true),
                matchAnyContext = addCombinator(function(elem) {
                    return indexOf.call(checkContext, elem) > -1
                }, implicitRelative, true),
                matchers = [function(elem, context, xml) {
                    return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml))
                }];
            for (; i < len; i++)
                if (matcher = Expr.relative[tokens[i].type]) matchers = [addCombinator(elementMatcher(matchers), matcher)];
                else {
                    matcher = Expr.filter[tokens[i].type].apply(null,
                        tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (; j < len; j++)
                            if (Expr.relative[tokens[j].type]) break;
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                            value: tokens[i - 2].type === " " ? "*" : ""
                        })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens))
                    }
                    matchers.push(matcher)
                }
            return elementMatcher(matchers)
        }

        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet =
                setMatchers.length > 0,
                byElement = elementMatchers.length > 0,
                superMatcher = function(seed, context, xml, results, outermost) {
                    var elem, j, matcher, matchedCount = 0,
                        i = "0",
                        unmatched = seed && [],
                        setMatched = [],
                        contextBackup = outermostContext,
                        elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || .1,
                        len = elems.length;
                    if (outermost) outermostContext = context !== document && context;
                    for (; i !== len && (elem = elems[i]) != null; i++) {
                        if (byElement && elem) {
                            j = 0;
                            while (matcher = elementMatchers[j++])
                                if (matcher(elem,
                                        context, xml)) {
                                    results.push(elem);
                                    break
                                }
                            if (outermost) dirruns = dirrunsUnique
                        }
                        if (bySet) {
                            if (elem = !matcher && elem) matchedCount--;
                            if (seed) unmatched.push(elem)
                        }
                    }
                    matchedCount += i;
                    if (bySet && i !== matchedCount) {
                        j = 0;
                        while (matcher = setMatchers[j++]) matcher(unmatched, setMatched, context, xml);
                        if (seed) {
                            if (matchedCount > 0)
                                while (i--)
                                    if (!(unmatched[i] || setMatched[i])) setMatched[i] = pop.call(results);
                            setMatched = condense(setMatched)
                        }
                        push.apply(results, setMatched);
                        if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length >
                            1) Sizzle.uniqueSort(results)
                    }
                    if (outermost) {
                        dirruns = dirrunsUnique;
                        outermostContext = contextBackup
                    }
                    return unmatched
                };
            return bySet ? markFunction(superMatcher) : superMatcher
        }
        compile = Sizzle.compile = function(selector, match) {
            var i, setMatchers = [],
                elementMatchers = [],
                cached = compilerCache[selector + " "];
            if (!cached) {
                if (!match) match = tokenize(selector);
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) setMatchers.push(cached);
                    else elementMatchers.push(cached)
                }
                cached = compilerCache(selector,
                    matcherFromGroupMatchers(elementMatchers, setMatchers));
                cached.selector = selector
            }
            return cached
        };
        select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === "function" && selector,
                match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context =
                        (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) return results;
                    else if (compiled) context = context.parentNode;
                    selector = selector.slice(tokens.shift().value.length)
                }
                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];
                    if (Expr.relative[type = token.type]) break;
                    if (find = Expr.find[type])
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            tokens.splice(i,
                                1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results
                            }
                            break
                        }
                }
            }(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
            return results
        };
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function(div1) {
            return div1.compareDocumentPosition(document.createElement("div")) & 1
        });
        if (!assert(function(div) {
                div.innerHTML = "<a href='#'></a>";
                return div.firstChild.getAttribute("href") === "#"
            })) addHandle("type|href|height|width", function(elem, name, isXML) {
            if (!isXML) return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2)
        });
        if (!support.attributes || !assert(function(div) {
                div.innerHTML = "<input/>";
                div.firstChild.setAttribute("value", "");
                return div.firstChild.getAttribute("value") === ""
            })) addHandle("value", function(elem, name, isXML) {
            if (!isXML && elem.nodeName.toLowerCase() === "input") return elem.defaultValue
        });
        if (!assert(function(div) {
                return div.getAttribute("disabled") == null
            })) addHandle(booleans, function(elem, name, isXML) {
            var val;
            if (!isXML) return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
        });
        return Sizzle
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var risSimple = /^.[^:#\[\.,]*$/;

    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) return jQuery.grep(elements, function(elem, i) {
            return !!qualifier.call(elem, i, elem) !== not
        });
        if (qualifier.nodeType) return jQuery.grep(elements, function(elem) {
            return elem === qualifier !== not
        });
        if (typeof qualifier === "string") {
            if (risSimple.test(qualifier)) return jQuery.filter(qualifier, elements, not);
            qualifier = jQuery.filter(qualifier, elements)
        }
        return jQuery.grep(elements,
            function(elem) {
                return indexOf.call(qualifier, elem) >= 0 !== not
            })
    }
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) expr = ":not(" + expr + ")";
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return elem.nodeType === 1
        }))
    };
    jQuery.fn.extend({
        find: function(selector) {
            var i, len = this.length,
                ret = [],
                self = this;
            if (typeof selector !== "string") return this.pushStack(jQuery(selector).filter(function() {
                for (i =
                    0; i < len; i++)
                    if (jQuery.contains(self[i], this)) return true
            }));
            for (i = 0; i < len; i++) jQuery.find(selector, self[i], ret);
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false))
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true))
        },
        is: function(selector) {
            return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) :
                selector || [], false).length
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
        init = jQuery.fn.init = function(selector, context) {
            var match, elem;
            if (!selector) return this;
            if (typeof selector === "string") {
                if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) match = [null, selector, null];
                else match = rquickExpr.exec(selector);
                if (match && (match[1] || !context))
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;
                        jQuery.merge(this, jQuery.parseHTML(match[1], context &&
                            context.nodeType ? context.ownerDocument || context : document, true));
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context))
                            for (match in context)
                                if (jQuery.isFunction(this[match])) this[match](context[match]);
                                else this.attr(match, context[match]);
                        return this
                    } else {
                        elem = document.getElementById(match[2]);
                        if (elem && elem.parentNode) {
                            this.length = 1;
                            this[0] = elem
                        }
                        this.context = document;
                        this.selector = selector;
                        return this
                    } else if (!context || context.jquery) return (context || rootjQuery).find(selector);
                else return this.constructor(context).find(selector)
            } else if (selector.nodeType) {
                this.context =
                    this[0] = selector;
                this.length = 1;
                return this
            } else if (jQuery.isFunction(selector)) return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) : selector(jQuery);
            if (selector.selector !== undefined) {
                this.selector = selector.selector;
                this.context = selector.context
            }
            return jQuery.makeArray(selector, this)
        };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/,
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };
    jQuery.extend({
        dir: function(elem,
            dir, until) {
            var matched = [],
                truncate = until !== undefined;
            while ((elem = elem[dir]) && elem.nodeType !== 9)
                if (elem.nodeType === 1) {
                    if (truncate && jQuery(elem).is(until)) break;
                    matched.push(elem)
                }
            return matched
        },
        sibling: function(n, elem) {
            var matched = [];
            for (; n; n = n.nextSibling)
                if (n.nodeType === 1 && n !== elem) matched.push(n);
            return matched
        }
    });
    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this),
                l = targets.length;
            return this.filter(function() {
                var i = 0;
                for (; i < l; i++)
                    if (jQuery.contains(this, targets[i])) return true
            })
        },
        closest: function(selectors, context) {
            var cur, i = 0,
                l = this.length,
                matched = [],
                pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
            for (; i < l; i++)
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode)
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur);
                        break
                    }
            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched)
        },
        index: function(elem) {
            if (!elem) return this[0] && this[0].parentNode ?
                this.first().prevAll().length : -1;
            if (typeof elem === "string") return indexOf.call(jQuery(elem), this[0]);
            return indexOf.call(this, elem.jquery ? elem[0] : elem)
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))))
        },
        addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector))
        }
    });

    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1);
        return cur
    }
    jQuery.each({
        parent: function(elem) {
            var parent =
                elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null
        },
        parents: function(elem) {
            return jQuery.dir(elem, "parentNode")
        },
        parentsUntil: function(elem, i, until) {
            return jQuery.dir(elem, "parentNode", until)
        },
        next: function(elem) {
            return sibling(elem, "nextSibling")
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling")
        },
        nextAll: function(elem) {
            return jQuery.dir(elem, "nextSibling")
        },
        prevAll: function(elem) {
            return jQuery.dir(elem, "previousSibling")
        },
        nextUntil: function(elem, i, until) {
            return jQuery.dir(elem,
                "nextSibling", until)
        },
        prevUntil: function(elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until)
        },
        siblings: function(elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem)
        },
        children: function(elem) {
            return jQuery.sibling(elem.firstChild)
        },
        contents: function(elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes)
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== "Until") selector = until;
            if (selector && typeof selector ===
                "string") matched = jQuery.filter(selector, matched);
            if (this.length > 1) {
                if (!guaranteedUnique[name]) jQuery.unique(matched);
                if (rparentsprev.test(name)) matched.reverse()
            }
            return this.pushStack(matched)
        }
    });
    var rnotwhite = /\S+/g;
    var optionsCache = {};

    function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
            object[flag] = true
        });
        return object
    }
    jQuery.Callbacks = function(options) {
        options = typeof options === "string" ? optionsCache[options] || createOptions(options) :
            jQuery.extend({}, options);
        var memory, fired, firing, firingStart, firingLength, firingIndex, list = [],
            stack = !options.once && [],
            fire = function(data) {
                memory = options.memory && data;
                fired = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                firing = true;
                for (; list && firingIndex < firingLength; firingIndex++)
                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                        memory = false;
                        break
                    }
                firing = false;
                if (list)
                    if (stack) {
                        if (stack.length) fire(stack.shift())
                    } else if (memory) list = [];
                else self.disable()
            },
            self = {
                add: function() {
                    if (list) {
                        var start = list.length;
                        (function add(args) {
                            jQuery.each(args, function(_, arg) {
                                var type = jQuery.type(arg);
                                if (type === "function") {
                                    if (!options.unique || !self.has(arg)) list.push(arg)
                                } else if (arg && arg.length && type !== "string") add(arg)
                            })
                        })(arguments);
                        if (firing) firingLength = list.length;
                        else if (memory) {
                            firingStart = start;
                            fire(memory)
                        }
                    }
                    return this
                },
                remove: function() {
                    if (list) jQuery.each(arguments, function(_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index,
                                1);
                            if (firing) {
                                if (index <= firingLength) firingLength--;
                                if (index <= firingIndex) firingIndex--
                            }
                        }
                    });
                    return this
                },
                has: function(fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length)
                },
                empty: function() {
                    list = [];
                    firingLength = 0;
                    return this
                },
                disable: function() {
                    list = stack = memory = undefined;
                    return this
                },
                disabled: function() {
                    return !list
                },
                lock: function() {
                    stack = undefined;
                    if (!memory) self.disable();
                    return this
                },
                locked: function() {
                    return !stack
                },
                fireWith: function(context, args) {
                    if (list && (!fired || stack)) {
                        args = args || [];
                        args = [context, args.slice ? args.slice() : args];
                        if (firing) stack.push(args);
                        else fire(args)
                    }
                    return this
                },
                fire: function() {
                    self.fireWith(this, arguments);
                    return this
                },
                fired: function() {
                    return !!fired
                }
            };
        return self
    };
    jQuery.extend({
        Deferred: function(func) {
            var tuples = [
                    ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
                    ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
                    ["notify", "progress", jQuery.Callbacks("memory")]
                ],
                state = "pending",
                promise = {
                    state: function() {
                        return state
                    },
                    always: function() {
                        deferred.done(arguments).fail(arguments);
                        return this
                    },
                    then: function() {
                        var fns = arguments;
                        return jQuery.Deferred(function(newDefer) {
                            jQuery.each(tuples, function(i, tuple) {
                                var fn = jQuery.isFunction(fns[i]) && fns[i];
                                deferred[tuple[1]](function() {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                    else newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments)
                                })
                            });
                            fns = null
                        }).promise()
                    },
                    promise: function(obj) {
                        return obj !=
                            null ? jQuery.extend(obj, promise) : promise
                    }
                },
                deferred = {};
            promise.pipe = promise.then;
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2],
                    stateString = tuple[3];
                promise[tuple[1]] = list.add;
                if (stateString) list.add(function() {
                    state = stateString
                }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this
                };
                deferred[tuple[0] + "With"] = list.fireWith
            });
            promise.promise(deferred);
            if (func) func.call(deferred, deferred);
            return deferred
        },
        when: function(subordinate) {
            var i = 0,
                resolveValues = slice.call(arguments),
                length = resolveValues.length,
                remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,
                deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
                updateFunc = function(i, contexts, values) {
                    return function(value) {
                        contexts[i] = this;
                        values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (values === progressValues) deferred.notifyWith(contexts, values);
                        else if (!--remaining) deferred.resolveWith(contexts, values)
                    }
                },
                progressValues,
                progressContexts, resolveContexts;
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (; i < length; i++)
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                    else --remaining
            }
            if (!remaining) deferred.resolveWith(resolveContexts, resolveValues);
            return deferred.promise()
        }
    });
    var readyList;
    jQuery.fn.ready = function(fn) {
        jQuery.ready.promise().done(fn);
        return this
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        holdReady: function(hold) {
            if (hold) jQuery.readyWait++;
            else jQuery.ready(true)
        },
        ready: function(wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) return;
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) return;
            readyList.resolveWith(document, [jQuery]);
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler("ready");
                jQuery(document).off("ready")
            }
        }
    });

    function completed() {
        document.removeEventListener("DOMContentLoaded",
            completed, false);
        window.removeEventListener("load", completed, false);
        jQuery.ready()
    }
    jQuery.ready.promise = function(obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            if (document.readyState === "complete") setTimeout(jQuery.ready);
            else {
                document.addEventListener("DOMContentLoaded", completed, false);
                window.addEventListener("load", completed, false)
            }
        }
        return readyList.promise(obj)
    };
    jQuery.ready.promise();
    var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0,
            len = elems.length,
            bulk = key ==
            null;
        if (jQuery.type(key) === "object") {
            chainable = true;
            for (i in key) jQuery.access(elems, fn, i, key[i], true, emptyGet, raw)
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) raw = true;
            if (bulk)
                if (raw) {
                    fn.call(elems, value);
                    fn = null
                } else {
                    bulk = fn;
                    fn = function(elem, key, value) {
                        return bulk.call(jQuery(elem), value)
                    }
                }
            if (fn)
                for (; i < len; i++) fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)))
        }
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet
    };
    jQuery.acceptData = function(owner) {
        return owner.nodeType ===
            1 || owner.nodeType === 9 || !+owner.nodeType
    };

    function Data() {
        Object.defineProperty(this.cache = {}, 0, {
            get: function() {
                return {}
            }
        });
        this.expando = jQuery.expando + Math.random()
    }
    Data.uid = 1;
    Data.accepts = jQuery.acceptData;
    Data.prototype = {
        key: function(owner) {
            if (!Data.accepts(owner)) return 0;
            var descriptor = {},
                unlock = owner[this.expando];
            if (!unlock) {
                unlock = Data.uid++;
                try {
                    descriptor[this.expando] = {
                        value: unlock
                    };
                    Object.defineProperties(owner, descriptor)
                } catch (e) {
                    descriptor[this.expando] = unlock;
                    jQuery.extend(owner, descriptor)
                }
            }
            if (!this.cache[unlock]) this.cache[unlock] = {};
            return unlock
        },
        set: function(owner, data, value) {
            var prop, unlock = this.key(owner),
                cache = this.cache[unlock];
            if (typeof data === "string") cache[data] = value;
            else if (jQuery.isEmptyObject(cache)) jQuery.extend(this.cache[unlock], data);
            else
                for (prop in data) cache[prop] = data[prop];
            return cache
        },
        get: function(owner, key) {
            var cache = this.cache[this.key(owner)];
            return key === undefined ? cache : cache[key]
        },
        access: function(owner, key, value) {
            var stored;
            if (key === undefined || key && typeof key === "string" && value === undefined) {
                stored =
                    this.get(owner, key);
                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key))
            }
            this.set(owner, key, value);
            return value !== undefined ? value : key
        },
        remove: function(owner, key) {
            var i, name, camel, unlock = this.key(owner),
                cache = this.cache[unlock];
            if (key === undefined) this.cache[unlock] = {};
            else {
                if (jQuery.isArray(key)) name = key.concat(key.map(jQuery.camelCase));
                else {
                    camel = jQuery.camelCase(key);
                    if (key in cache) name = [key, camel];
                    else {
                        name = camel;
                        name = name in cache ? [name] : name.match(rnotwhite) || []
                    }
                }
                i = name.length;
                while (i--) delete cache[name[i]]
            }
        },
        hasData: function(owner) {
            return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {})
        },
        discard: function(owner) {
            if (owner[this.expando]) delete this.cache[owner[this.expando]]
        }
    };
    var data_priv = new Data;
    var data_user = new Data;
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /([A-Z])/g;

    function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data ===
                "string") {
                try {
                    data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data
                } catch (e) {}
                data_user.set(elem, key, data)
            } else data = undefined
        }
        return data
    }
    jQuery.extend({
        hasData: function(elem) {
            return data_user.hasData(elem) || data_priv.hasData(elem)
        },
        data: function(elem, name, data) {
            return data_user.access(elem, name, data)
        },
        removeData: function(elem, name) {
            data_user.remove(elem, name)
        },
        _data: function(elem, name, data) {
            return data_priv.access(elem,
                name, data)
        },
        _removeData: function(elem, name) {
            data_priv.remove(elem, name)
        }
    });
    jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0],
                attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = data_user.get(elem);
                    if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while (i--)
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf("data-") === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name])
                                }
                            }
                        data_priv.set(elem, "hasDataAttrs", true)
                    }
                }
                return data
            }
            if (typeof key ===
                "object") return this.each(function() {
                data_user.set(this, key)
            });
            return access(this, function(value) {
                var data, camelKey = jQuery.camelCase(key);
                if (elem && value === undefined) {
                    data = data_user.get(elem, key);
                    if (data !== undefined) return data;
                    data = data_user.get(elem, camelKey);
                    if (data !== undefined) return data;
                    data = dataAttr(elem, camelKey, undefined);
                    if (data !== undefined) return data;
                    return
                }
                this.each(function() {
                    var data = data_user.get(this, camelKey);
                    data_user.set(this, camelKey, value);
                    if (key.indexOf("-") !== -1 && data !== undefined) data_user.set(this,
                        key, value)
                })
            }, null, value, arguments.length > 1, null, true)
        },
        removeData: function(key) {
            return this.each(function() {
                data_user.remove(this, key)
            })
        }
    });
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) {
                type = (type || "fx") + "queue";
                queue = data_priv.get(elem, type);
                if (data)
                    if (!queue || jQuery.isArray(data)) queue = data_priv.access(elem, type, jQuery.makeArray(data));
                    else queue.push(data);
                return queue || []
            }
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks(elem, type),
                next = function() {
                    jQuery.dequeue(elem, type)
                };
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--
            }
            if (fn) {
                if (type === "fx") queue.unshift("inprogress");
                delete hooks.stop;
                fn.call(elem, next, hooks)
            }
            if (!startLength && hooks) hooks.empty.fire()
        },
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return data_priv.get(elem, key) || data_priv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    data_priv.remove(elem, [type + "queue", key])
                })
            })
        }
    });
    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--
            }
            if (arguments.length < setter) return jQuery.queue(this[0], type);
            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === "fx" && queue[0] !== "inprogress") jQuery.dequeue(this, type)
            })
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type)
            })
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", [])
        },
        promise: function(type, obj) {
            var tmp, count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function() {
                    if (!--count) defer.resolveWith(elements, [elements])
                };
            if (typeof type !== "string") {
                obj = type;
                type = undefined
            }
            type = type || "fx";
            while (i--) {
                tmp = data_priv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve)
                }
            }
            resolve();
            return defer.promise(obj)
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var cssExpand = ["Top", "Right", "Bottom", "Left"];
    var isHidden = function(elem,
        el) {
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem)
    };
    var rcheckableType = /^(?:checkbox|radio)$/i;
    (function() {
        var fragment = document.createDocumentFragment(),
            div = fragment.appendChild(document.createElement("div")),
            input = document.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue
    })();
    var strundefined = typeof undefined;
    support.focusinBubbles = "onfocusin" in window;
    var rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

    function returnTrue() {
        return true
    }

    function returnFalse() {
        return false
    }

    function safeActiveElement() {
        try {
            return document.activeElement
        } catch (err) {}
    }
    jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
            if (!elemData) return;
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector
            }
            if (!handler.guid) handler.guid = jQuery.guid++;
            if (!(events = elemData.events)) events = elemData.events = {};
            if (!(eventHandle = elemData.handle)) eventHandle = elemData.handle = function(e) {
                return typeof jQuery !== strundefined &&
                    jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined
            };
            types = (types || "").match(rnotwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) continue;
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false)
                        if (elem.addEventListener) elem.addEventListener(type, eventHandle, false)
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) handleObj.handler.guid = handler.guid
                }
                if (selector) handlers.splice(handlers.delegateCount++,
                    0, handleObj);
                else handlers.push(handleObj);
                jQuery.event.global[type] = true
            }
        },
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
            if (!elemData || !(events = elemData.events)) return;
            types = (types || "").match(rnotwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                    for (type in events) jQuery.event.remove(elem,
                        type + types[t], handler, selector, true);
                    continue
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j,
                            1);
                        if (handleObj.selector) handlers.delegateCount--;
                        if (special.remove) special.remove.call(elem, handleObj)
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) jQuery.removeEvent(elem, type, elemData.handle);
                    delete events[type]
                }
            }
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;
                data_priv.remove(elem, "events")
            }
        },
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document],
                type =
                hasOwn.call(event, "type") ? event.type : event,
                namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) return;
            if (rfocusMorph.test(type + jQuery.event.triggered)) return;
            if (type.indexOf(".") >= 0) {
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort()
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace =
                namespaces.join(".");
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = undefined;
            if (!event.target) event.target = elem;
            data = data == null ? [event] : jQuery.makeArray(data, [event]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) return;
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) cur =
                    cur.parentNode;
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur
                }
                if (tmp === (elem.ownerDocument || document)) eventPath.push(tmp.defaultView || tmp.parentWindow || window)
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
                if (handle) handle.apply(cur, data);
                handle = ontype && cur[ontype];
                if (handle && handle.apply && jQuery.acceptData(cur)) {
                    event.result = handle.apply(cur,
                        data);
                    if (event.result === false) event.preventDefault()
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented())
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem))
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) elem[ontype] = null;
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (tmp) elem[ontype] = tmp
                    }
            return event.result
        },
        dispatch: function(event) {
            event = jQuery.event.fix(event);
            var i,
                j, ret, matched, handleObj, handlerQueue = [],
                args = slice.call(arguments),
                handlers = (data_priv.get(this, "events") || {})[event.type] || [],
                special = jQuery.event.special[event.type] || {};
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) return;
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped())
                    if (!event.namespace_re ||
                        event.namespace_re.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined)
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation()
                            }
                    }
            }
            if (special.postDispatch) special.postDispatch.call(this, event);
            return event.result
        },
        handlers: function(event, handlers) {
            var i, matches, sel, handleObj, handlerQueue = [],
                delegateCount = handlers.delegateCount,
                cur =
                event.target;
            if (delegateCount && cur.nodeType && (!event.button || event.type !== "click"))
                for (; cur !== this; cur = cur.parentNode || this)
                    if (cur.disabled !== true || event.type !== "click") {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + " ";
                            if (matches[sel] === undefined) matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
                            if (matches[sel]) matches.push(handleObj)
                        }
                        if (matches.length) handlerQueue.push({
                            elem: cur,
                            handlers: matches
                        })
                    }
            if (delegateCount <
                handlers.length) handlerQueue.push({
                elem: this,
                handlers: handlers.slice(delegateCount)
            });
            return handlerQueue
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {
                if (event.which == null) event.which = original.charCode != null ? original.charCode : original.keyCode;
                return event
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(event, original) {
                var eventDoc, doc, body, button = original.button;
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)
                }
                if (!event.which && button !== undefined) event.which =
                    button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                return event
            }
        },
        fix: function(event) {
            if (event[jQuery.expando]) return event;
            var i, prop, copy, type = event.type,
                originalEvent = event,
                fixHook = this.fixHooks[type];
            if (!fixHook) this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery.Event(originalEvent);
            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop]
            }
            if (!event.target) event.target =
                document;
            if (event.target.nodeType === 3) event.target = event.target.parentNode;
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event
        },
        special: {
            load: {
                noBubble: true
            },
            focus: {
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false
                    }
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                        this.click();
                        return false
                    }
                },
                _default: function(event) {
                    return jQuery.nodeName(event.target, "a")
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    if (event.result !== undefined && event.originalEvent) event.originalEvent.returnValue = event.result
                }
            }
        },
        simulate: function(type, elem, event, bubble) {
            var e = jQuery.extend(new jQuery.Event, event, {
                type: type,
                isSimulated: true,
                originalEvent: {}
            });
            if (bubble) jQuery.event.trigger(e, null, elem);
            else jQuery.event.dispatch.call(elem, e);
            if (e.isDefaultPrevented()) event.preventDefault()
        }
    };
    jQuery.removeEvent =
        function(elem, type, handle) {
            if (elem.removeEventListener) elem.removeEventListener(type, handle, false)
        };
    jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event)) return new jQuery.Event(src, props);
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse
        } else this.type = src;
        if (props) jQuery.extend(this, props);
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] =
            true
    };
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && e.preventDefault) e.preventDefault()
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && e.stopPropagation) e.stopPropagation()
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && e.stopImmediatePropagation) e.stopImmediatePropagation();
            this.stopPropagation()
        }
    };
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this,
                        arguments);
                    event.type = fix
                }
                return ret
            }
        }
    });
    if (!support.focusinBubbles) jQuery.each({
        focus: "focusin",
        blur: "focusout"
    }, function(orig, fix) {
        var handler = function(event) {
            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true)
        };
        jQuery.event.special[fix] = {
            setup: function() {
                var doc = this.ownerDocument || this,
                    attaches = data_priv.access(doc, fix);
                if (!attaches) doc.addEventListener(orig, handler, true);
                data_priv.access(doc, fix, (attaches || 0) + 1)
            },
            teardown: function() {
                var doc = this.ownerDocument || this,
                    attaches =
                    data_priv.access(doc, fix) - 1;
                if (!attaches) {
                    doc.removeEventListener(orig, handler, true);
                    data_priv.remove(doc, fix)
                } else data_priv.access(doc, fix, attaches)
            }
        }
    });
    jQuery.fn.extend({
        on: function(types, selector, data, fn, one) {
            var origFn, type;
            if (typeof types === "object") {
                if (typeof selector !== "string") {
                    data = data || selector;
                    selector = undefined
                }
                for (type in types) this.on(type, selector, data, types[type], one);
                return this
            }
            if (data == null && fn == null) {
                fn = selector;
                data = selector = undefined
            } else if (fn == null)
                if (typeof selector === "string") {
                    fn =
                        data;
                    data = undefined
                } else {
                    fn = data;
                    data = selector;
                    selector = undefined
                }
            if (fn === false) fn = returnFalse;
            else if (!fn) return this;
            if (one === 1) {
                origFn = fn;
                fn = function(event) {
                    jQuery().off(event);
                    return origFn.apply(this, arguments)
                };
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)
            }
            return this.each(function() {
                jQuery.event.add(this, types, fn, data, selector)
            })
        },
        one: function(types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1)
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault &&
                types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this
            }
            if (typeof types === "object") {
                for (type in types) this.off(type, selector, types[type]);
                return this
            }
            if (selector === false || typeof selector === "function") {
                fn = selector;
                selector = undefined
            }
            if (fn === false) fn = returnFalse;
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector)
            })
        },
        trigger: function(type,
            data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this)
            })
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) return jQuery.event.trigger(type, data, elem, true)
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
        rtagName = /<([\w:]+)/,
        rhtml = /<|&#?\w+;/,
        rnoInnerhtml = /<(?:script|style|link)/i,
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptType = /^$|\/(?:java|ecma)script/i,
        rscriptTypeMasked = /^true\/(.*)/,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
        wrapMap = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
        };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !==
            11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem
    }

    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem
    }

    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) elem.type = match[1];
        else elem.removeAttribute("type");
        return elem
    }

    function setGlobalEval(elems, refElements) {
        var i = 0,
            l = elems.length;
        for (; i < l; i++) data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"))
    }

    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (dest.nodeType !== 1) return;
        if (data_priv.hasData(src)) {
            pdataOld = data_priv.access(src);
            pdataCur = data_priv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};
                for (type in events)
                    for (i = 0, l = events[type].length; i < l; i++) jQuery.event.add(dest, type, events[type][i])
            }
        }
        if (data_user.hasData(src)) {
            udataOld = data_user.access(src);
            udataCur = jQuery.extend({}, udataOld);
            data_user.set(dest, udataCur)
        }
    }

    function getAll(context, tag) {
        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret
    }

    function fixInput(src, dest) {
        return;
        var nodeName = dest.nodeName.toLowerCase();
        if (nodeName === "input" && rcheckableType.test(src.type)) dest.checked = src.checked;
        else if (nodeName === "input" ||
            nodeName === "textarea") dest.defaultValue = src.defaultValue
    }
    jQuery.extend({
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true),
                inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l = srcElements.length; i < l; i++) fixInput(srcElements[i], destElements[i])
            }
            if (dataAndEvents)
                if (deepDataAndEvents) {
                    srcElements =
                        srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0, l = srcElements.length; i < l; i++) cloneCopyEvent(srcElements[i], destElements[i])
                } else cloneCopyEvent(elem, clone);
            destElements = getAll(clone, "script");
            if (destElements.length > 0) setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            return clone
        },
        buildFragment: function(elems, context, scripts, selection) {
            var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(),
                nodes = [],
                i = 0,
                l = elems.length;
            for (; i < l; i++) {
                elem = elems[i];
                if (elem || elem === 0)
                    if (jQuery.type(elem) === "object") jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                    else if (!rhtml.test(elem)) nodes.push(context.createTextNode(elem));
                else {
                    tmp = tmp || fragment.appendChild(context.createElement("div"));
                    tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
                    j = wrap[0];
                    while (j--) tmp = tmp.lastChild;
                    jQuery.merge(nodes, tmp.childNodes);
                    tmp = fragment.firstChild;
                    tmp.textContent = ""
                }
            }
            fragment.textContent =
                "";
            i = 0;
            while (elem = nodes[i++]) {
                if (selection && jQuery.inArray(elem, selection) !== -1) continue;
                contains = jQuery.contains(elem.ownerDocument, elem);
                tmp = getAll(fragment.appendChild(elem), "script");
                if (contains) setGlobalEval(tmp);
                if (scripts) {
                    j = 0;
                    while (elem = tmp[j++])
                        if (rscriptType.test(elem.type || "")) scripts.push(elem)
                }
            }
            return fragment
        },
        cleanData: function(elems) {
            var data, elem, type, key, special = jQuery.event.special,
                i = 0;
            for (;
                (elem = elems[i]) !== undefined; i++) {
                if (jQuery.acceptData(elem)) {
                    key = elem[data_priv.expando];
                    if (key && (data = data_priv.cache[key])) {
                        if (data.events)
                            for (type in data.events)
                                if (special[type]) jQuery.event.remove(elem, type);
                                else jQuery.removeEvent(elem, type, data.handle);
                        if (data_priv.cache[key]) delete data_priv.cache[key]
                    }
                }
                delete data_user.cache[elem[data_user.expando]]
            }
        }
    });
    jQuery.fn.extend({
        text: function(value) {
            return access(this, function(value) {
                    return value === undefined ? jQuery.text(this) : this.empty().each(function() {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) this.textContent = value
                    })
                },
                null, value, arguments.length)
        },
        append: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem)
                }
            })
        },
        prepend: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild)
                }
            })
        },
        before: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) this.parentNode.insertBefore(elem,
                    this)
            })
        },
        after: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) this.parentNode.insertBefore(elem, this.nextSibling)
            })
        },
        remove: function(selector, keepData) {
            var elem, elems = selector ? jQuery.filter(selector, this) : this,
                i = 0;
            for (;
                (elem = elems[i]) != null; i++) {
                if (!keepData && elem.nodeType === 1) jQuery.cleanData(getAll(elem));
                if (elem.parentNode) {
                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) setGlobalEval(getAll(elem, "script"));
                    elem.parentNode.removeChild(elem)
                }
            }
            return this
        },
        empty: function() {
            var elem,
                i = 0;
            for (;
                (elem = this[i]) != null; i++)
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.textContent = ""
                }
            return this
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents)
            })
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {},
                    i = 0,
                    l = this.length;
                if (value === undefined &&
                    elem.nodeType === 1) return elem.innerHTML;
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, "<$1></$2>");
                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value
                            }
                        }
                        elem = 0
                    } catch (e) {}
                }
                if (elem) this.empty().append(value)
            }, null, value, arguments.length)
        },
        replaceWith: function() {
            var arg = arguments[0];
            this.domManip(arguments, function(elem) {
                arg = this.parentNode;
                jQuery.cleanData(getAll(this));
                if (arg) arg.replaceChild(elem, this)
            });
            return arg && (arg.length || arg.nodeType) ? this : this.remove()
        },
        detach: function(selector) {
            return this.remove(selector, true)
        },
        domManip: function(args, callback) {
            args = concat.apply([], args);
            var fragment, first, scripts, hasScripts, node, doc, i = 0,
                l = this.length,
                set = this,
                iNoClone = l - 1,
                value = args[0],
                isFunction = jQuery.isFunction(value);
            if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) return this.each(function(index) {
                var self =
                    set.eq(index);
                if (isFunction) args[0] = value.call(this, index, self.html());
                self.domManip(args, callback)
            });
            if (l) {
                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                first = fragment.firstChild;
                if (fragment.childNodes.length === 1) fragment = first;
                if (first) {
                    scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                    hasScripts = scripts.length;
                    for (; i < l; i++) {
                        node = fragment;
                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);
                            if (hasScripts) jQuery.merge(scripts, getAll(node, "script"))
                        }
                        callback.call(this[i],
                            node, i)
                    }
                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;
                        jQuery.map(scripts, restoreScript);
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node))
                                if (node.src) {
                                    if (jQuery._evalUrl) jQuery._evalUrl(node.src)
                                } else jQuery.globalEval(node.textContent.replace(rcleanScript, ""))
                        }
                    }
                }
            }
            return this
        }
    });
    jQuery.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        },
        function(name, original) {
            jQuery.fn[name] = function(selector) {
                var elems, ret = [],
                    insert = jQuery(selector),
                    last = insert.length - 1,
                    i = 0;
                for (; i <= last; i++) {
                    elems = i === last ? this : this.clone(true);
                    jQuery(insert[i])[original](elems);
                    push.apply(ret, elems.get())
                }
                return this.pushStack(ret)
            }
        });
    var iframe, elemdisplay = {};

    function actualDisplay(name, doc) {
        var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body),
            display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0],
                "display");
        elem.detach();
        return display
    }

    function defaultDisplay(nodeName) {
        var doc = document,
            display = elemdisplay[nodeName];
        if (!display) {
            display = actualDisplay(nodeName, doc);
            if (display === "none" || !display) {
                iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
                doc = iframe[0].contentDocument;
                doc.write();
                doc.close();
                display = actualDisplay(nodeName, doc);
                iframe.detach()
            }
            elemdisplay[nodeName] = display
        }
        return display
    }
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp("^(" +
        pnum + ")(?!px)[a-z%]+$", "i");
    var getStyles = function(elem) {
        return elem.ownerDocument.defaultView.getComputedStyle(elem, null)
    };

    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        computed = computed || getStyles(elem);
        if (computed) ret = computed.getPropertyValue(name) || computed[name];
        if (computed) {
            if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) ret = jQuery.style(elem, name);
            if (rnumnonpx.test(ret) && rmargin.test(name)) {
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth
            }
        }
        return ret !== undefined ? ret + "" : ret
    }

    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function() {
                if (conditionFn()) {
                    delete this.get;
                    return
                }
                return (this.get = hookFn).apply(this, arguments)
            }
        }
    }(function() {
        var pixelPositionVal, boxSizingReliableVal, docElem = document.documentElement,
            container = document.createElement("div"),
            div = document.createElement("div");
        if (!div.style) return;
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" + "position:absolute";
        container.appendChild(div);

        function computePixelPositionAndBoxSizingReliable() {
            div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;display:block;margin-top:1%;top:1%;" + "border:1px;padding:1px;width:4px;position:absolute";
            div.innerHTML = "";
            docElem.appendChild(container);
            var divStyle = window.getComputedStyle(div, null);
            pixelPositionVal = divStyle.top !== "1%";
            boxSizingReliableVal = divStyle.width === "4px";
            docElem.removeChild(container)
        }
        if (window.getComputedStyle) jQuery.extend(support, {
            pixelPosition: function() {
                computePixelPositionAndBoxSizingReliable();
                return pixelPositionVal
            },
            boxSizingReliable: function() {
                if (boxSizingReliableVal == null) computePixelPositionAndBoxSizingReliable();
                return boxSizingReliableVal
            },
            reliableMarginRight: function() {
                var ret,
                    marginDiv = div.appendChild(document.createElement("div"));
                marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                marginDiv.style.marginRight = marginDiv.style.width = "0";
                div.style.width = "1px";
                docElem.appendChild(container);
                ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
                docElem.removeChild(container);
                return ret
            }
        })
    })();
    jQuery.swap = function(elem, options, callback, args) {
        var ret,
            name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name]
        }
        ret = callback.apply(elem, args || []);
        for (name in options) elem.style[name] = old[name];
        return ret
    };
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
        rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),
        cssShow = {
            position: "absolute",
            visibility: "hidden",
            display: "block"
        },
        cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
        },
        cssPrefixes = ["Webkit", "O", "Moz", "ms"];

    function vendorPropName(style,
        name) {
        if (name in style) return name;
        var capName = name[0].toUpperCase() + name.slice(1),
            origName = name,
            i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) return name
        }
        return origName
    }

    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value
    }

    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0,
            val = 0;
        for (; i < 4; i += 2) {
            if (extra === "margin") val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            if (isBorderBox) {
                if (extra === "content") val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                if (extra !== "margin") val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles)
            } else {
                val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                if (extra !== "padding") val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles)
            }
        }
        return val
    }

    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true,
            val = name ===
            "width" ? elem.offsetWidth : elem.offsetHeight,
            styles = getStyles(elem),
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
        if (val <= 0 || val == null) {
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) val = elem.style[name];
            if (rnumnonpx.test(val)) return val;
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            val = parseFloat(val) || 0
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px"
    }

    function showHide(elements,
        show) {
        var display, elem, hidden, values = [],
            index = 0,
            length = elements.length;
        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) continue;
            values[index] = data_priv.get(elem, "olddisplay");
            display = elem.style.display;
            if (show) {
                if (!values[index] && display === "none") elem.style.display = "";
                if (elem.style.display === "" && isHidden(elem)) values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName))
            } else {
                hidden = isHidden(elem);
                if (display !== "none" || !hidden) data_priv.set(elem, "olddisplay", hidden ?
                    display : jQuery.css(elem, "display"))
            }
        }
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) continue;
            if (!show || elem.style.display === "none" || elem.style.display === "") elem.style.display = show ? values[index] || "" : "none"
        }
        return elements
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret
                    }
                }
            }
        },
        cssNumber: {
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },
        cssProps: {
            "float": "cssFloat"
        },
        style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) return;
            var ret, type, hooks, origName = jQuery.camelCase(name),
                style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === "string" && (ret = rrelNum.exec(value))) {
                    value =
                        (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    type = "number"
                }
                if (value == null || value !== value) return;
                if (type === "number" && !jQuery.cssNumber[origName]) value += "px";
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) style[name] = "inherit";
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) style[name] = value
            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) return ret;
                return style[name]
            }
        },
        css: function(elem, name, extra, styles) {
            var val,
                num, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && "get" in hooks) val = hooks.get(elem, true, extra);
            if (val === undefined) val = curCSS(elem, name, styles);
            if (val === "normal" && name in cssNormalTransform) val = cssNormalTransform[name];
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || jQuery.isNumeric(num) ? num || 0 : val
            }
            return val
        }
    });
    jQuery.each(["height",
        "width"
    ], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed) return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function() {
                    return getWidthOrHeight(elem, name, extra)
                }) : getWidthOrHeight(elem, name, extra)
            },
            set: function(elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0)
            }
        }
    });
    jQuery.cssHooks.marginRight =
        addGetHookIf(support.reliableMarginRight, function(elem, computed) {
            if (computed) return jQuery.swap(elem, {
                "display": "inline-block"
            }, curCSS, [elem, "marginRight"])
        });
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i = 0,
                    expanded = {},
                    parts = typeof value === "string" ? value.split(" ") : [value];
                for (; i < 4; i++) expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                return expanded
            }
        };
        if (!rmargin.test(prefix)) jQuery.cssHooks[prefix +
            suffix].set = setPositiveNumber
    });
    jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {},
                    i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (; i < len; i++) map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    return map
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name)
            }, name, value, arguments.length > 1)
        },
        show: function() {
            return showHide(this, true)
        },
        hide: function() {
            return showHide(this)
        },
        toggle: function(state) {
            if (typeof state ===
                "boolean") return state ? this.show() : this.hide();
            return this.each(function() {
                if (isHidden(this)) jQuery(this).show();
                else jQuery(this).hide()
            })
        }
    });

    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing)
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || "swing";
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ?
                "" : "px")
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this)
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            else this.pos = eased = percent;
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) this.options.step.call(this.elem, this.now, this);
            if (hooks && hooks.set) hooks.set(this);
            else Tween.propHooks._default.set(this);
            return this
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) return tween.elem[tween.prop];
                result = jQuery.css(tween.elem, tween.prop, "");
                return !result || result === "auto" ? 0 : result
            },
            set: function(tween) {
                if (jQuery.fx.step[tween.prop]) jQuery.fx.step[tween.prop](tween);
                else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] !=
                        null || jQuery.cssHooks[tween.prop])) jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                else tween.elem[tween.prop] = tween.now
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) tween.elem[tween.prop] = tween.now
        }
    };
    jQuery.easing = {
        linear: function(p) {
            return p
        },
        swing: function(p) {
            return .5 - Math.cos(p * Math.PI) / 2
        }
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/,
        rfxnum = new RegExp("^(?:([+-])=|)(" +
            pnum + ")([a-z%]*)$", "i"),
        rrun = /queueHooks$/,
        animationPrefilters = [defaultPrefilter],
        tweeners = {
            "*": [function(prop, value) {
                var tween = this.createTween(prop, value),
                    target = tween.cur(),
                    parts = rfxnum.exec(value),
                    unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
                    start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),
                    scale = 1,
                    maxIterations = 20;
                if (start && start[3] !== unit) {
                    unit = unit || start[3];
                    parts = parts || [];
                    start = +target || 1;
                    do {
                        scale = scale || ".5";
                        start = start / scale;
                        jQuery.style(tween.elem,
                            prop, start + unit)
                    } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations)
                }
                if (parts) {
                    start = tween.start = +start || +target || 0;
                    tween.unit = unit;
                    tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2]
                }
                return tween
            }]
        };

    function createFxNow() {
        setTimeout(function() {
            fxNow = undefined
        });
        return fxNow = jQuery.now()
    }

    function genFx(type, includeWidth) {
        var which, i = 0,
            attrs = {
                height: type
            };
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] =
                type
        }
        if (includeWidth) attrs.opacity = attrs.width = type;
        return attrs
    }

    function createTween(value, prop, animation) {
        var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]),
            index = 0,
            length = collection.length;
        for (; index < length; index++)
            if (tween = collection[index].call(animation, prop, value)) return tween
    }

    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHidden(elem),
            dataShow = data_priv.get(elem,
                "fxshow");
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) oldfire()
                }
            }
            hooks.unqueued++;
            anim.always(function() {
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) hooks.empty.fire()
                })
            })
        }
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];
            display = jQuery.css(elem, "display");
            checkDisplay = display ===
                "none" ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
            if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") style.display = "inline-block"
        }
        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2]
            })
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show"))
                    if (value === "show" &&
                        dataShow && dataShow[prop] !== undefined) hidden = true;
                    else continue;
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop)
            } else display = undefined
        }
        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ("hidden" in dataShow) hidden = dataShow.hidden
            } else dataShow = data_priv.access(elem, "fxshow", {});
            if (toggle) dataShow.hidden = !hidden;
            if (hidden) jQuery(elem).show();
            else anim.done(function() {
                jQuery(elem).hide()
            });
            anim.done(function() {
                var prop;
                data_priv.remove(elem, "fxshow");
                for (prop in orig) jQuery.style(elem, prop,
                    orig[prop])
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0
                    }
                }
            }
        } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") style.display = display
    }

    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing =
                    value[1];
                value = props[index] = value[0]
            }
            if (index !== name) {
                props[name] = value;
                delete props[index]
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value)
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing
                    }
            } else specialEasing[name] = easing
        }
    }

    function Animation(elem, properties, options) {
        var result, stopped, index = 0,
            length = animationPrefilters.length,
            deferred = jQuery.Deferred().always(function() {
                delete tick.elem
            }),
            tick = function() {
                if (stopped) return false;
                var currentTime = fxNow || createFxNow(),
                    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
                    temp = remaining / animation.duration || 0,
                    percent = 1 - temp,
                    index = 0,
                    length = animation.tweens.length;
                for (; index < length; index++) animation.tweens[index].run(percent);
                deferred.notifyWith(elem, [animation, percent, remaining]);
                if (percent < 1 && length) return remaining;
                else {
                    deferred.resolveWith(elem, [animation]);
                    return false
                }
            },
            animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, {
                    specialEasing: {}
                }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function(prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween
                },
                stop: function(gotoEnd) {
                    var index = 0,
                        length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) return this;
                    stopped = true;
                    for (; index < length; index++) animation.tweens[index].run(1);
                    if (gotoEnd) deferred.resolveWith(elem, [animation, gotoEnd]);
                    else deferred.rejectWith(elem, [animation, gotoEnd]);
                    return this
                }
            }),
            props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) return result
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) animation.opts.start.call(elem, animation);
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always)
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function(props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = ["*"]
            } else props = props.split(" ");
            var prop, index = 0,
                length = props.length;
            for (; index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback)
            }
        },
        prefilter: function(callback,
            prepend) {
            if (prepend) animationPrefilters.unshift(callback);
            else animationPrefilters.push(callback)
        }
    });
    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) opt.queue = "fx";
        opt.old = opt.complete;
        opt.complete = function() {
            if (jQuery.isFunction(opt.old)) opt.old.call(this);
            if (opt.queue) jQuery.dequeue(this, opt.queue)
        };
        return opt
    };
    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHidden).css("opacity", 0).show().end().animate({
                opacity: to
            }, speed, easing, callback)
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop),
                optall = jQuery.speed(speed, easing, callback),
                doAnimation =
                function() {
                    var anim = Animation(this, jQuery.extend({}, prop), optall);
                    if (empty || data_priv.get(this, "finish")) anim.stop(true)
                };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation)
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd)
            };
            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined
            }
            if (clearQueue && type !== false) this.queue(type || "fx", []);
            return this.each(function() {
                var dequeue = true,
                    index = type != null && type + "queueHooks",
                    timers = jQuery.timers,
                    data = data_priv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) stopQueue(data[index])
                } else
                    for (index in data)
                        if (data[index] && data[index].stop && rrun.test(index)) stopQueue(data[index]); for (index = timers.length; index--;)
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1)
                    }
                if (dequeue || !gotoEnd) jQuery.dequeue(this,
                    type)
            })
        },
        finish: function(type) {
            if (type !== false) type = type || "fx";
            return this.each(function() {
                var index, data = data_priv.get(this),
                    queue = data[type + "queue"],
                    hooks = data[type + "queueHooks"],
                    timers = jQuery.timers,
                    length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) hooks.stop.call(this, true);
                for (index = timers.length; index--;)
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1)
                    }
                for (index = 0; index < length; index++)
                    if (queue[index] &&
                        queue[index].finish) queue[index].finish.call(this);
                delete data.finish
            })
        }
    });
    jQuery.each(["toggle", "show", "hide"], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback)
        }
    });
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name,
        props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback)
        }
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer, i = 0,
            timers = jQuery.timers;
        fxNow = jQuery.now();
        for (; i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) timers.splice(i--, 1)
        }
        if (!timers.length) jQuery.fx.stop();
        fxNow = undefined
    };
    jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        if (timer()) jQuery.fx.start();
        else jQuery.timers.pop()
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start =
        function() {
            if (!timerId) timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval)
        };
    jQuery.fx.stop = function() {
        clearInterval(timerId);
        timerId = null
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function() {
                clearTimeout(timeout)
            }
        })
    };
    (function() {
        var input = document.createElement("input"),
            select = document.createElement("select"),
            opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t"
    })();
    var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1)
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this,
                    name)
            })
        }
    });
    jQuery.extend({
        attr: function(elem, name, value) {
            var hooks, ret, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) return;
            if (typeof elem.getAttribute === strundefined) return jQuery.prop(elem, name, value);
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook)
            }
            if (value !== undefined)
                if (value === null) jQuery.removeAttr(elem, name);
                else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) return ret;
            else {
                elem.setAttribute(name, value + "");
                return value
            } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) return ret;
            else {
                ret = jQuery.find.attr(elem, name);
                return ret == null ? undefined : ret
            }
        },
        removeAttr: function(elem, value) {
            var name, propName, i = 0,
                attrNames = value && value.match(rnotwhite);
            if (attrNames && elem.nodeType === 1)
                while (name = attrNames[i++]) {
                    propName = jQuery.propFix[name] || name;
                    if (jQuery.expr.match.bool.test(name)) elem[propName] = false;
                    elem.removeAttribute(name)
                }
        },
        attrHooks: {
            type: {
                set: function(elem,
                    value) {
                    if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) elem.value = val;
                        return value
                    }
                }
            }
        }
    });
    boolHook = {
        set: function(elem, value, name) {
            if (value === false) jQuery.removeAttr(elem, name);
            else elem.setAttribute(name, name);
            return name
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle
            }
            return ret
        }
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1)
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name]
            })
        }
    });
    jQuery.extend({
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },
        prop: function(elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) return;
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
            if (notxml) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name]
            }
            if (value !== undefined) return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
            else return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name]
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1
                }
            }
        }
    });
    if (!support.optSelected) jQuery.propHooks.selected = {
        get: function(elem) {
            var parent = elem.parentNode;
            if (parent && parent.parentNode) parent.parentNode.selectedIndex;
            return null
        }
    };
    jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
        jQuery.propFix[this.toLowerCase()] = this
    });
    var rclass = /[\t\r\n\f]/g;
    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = typeof value === "string" &&
                value,
                i = 0,
                len = this.length;
            if (jQuery.isFunction(value)) return this.each(function(j) {
                jQuery(this).addClass(value.call(this, j, this.className))
            });
            if (proceed) {
                classes = (value || "").match(rnotwhite) || [];
                for (; i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++])
                            if (cur.indexOf(" " + clazz + " ") < 0) cur += clazz + " ";
                        finalValue = jQuery.trim(cur);
                        if (elem.className !== finalValue) elem.className = finalValue
                    }
                }
            }
            return this
        },
        removeClass: function(value) {
            var classes,
                elem, cur, clazz, j, finalValue, proceed = arguments.length === 0 || typeof value === "string" && value,
                i = 0,
                len = this.length;
            if (jQuery.isFunction(value)) return this.each(function(j) {
                jQuery(this).removeClass(value.call(this, j, this.className))
            });
            if (proceed) {
                classes = (value || "").match(rnotwhite) || [];
                for (; i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++])
                            while (cur.indexOf(" " + clazz + " ") >= 0) cur = cur.replace(" " + clazz + " ",
                                " ");
                        finalValue = value ? jQuery.trim(cur) : "";
                        if (elem.className !== finalValue) elem.className = finalValue
                    }
                }
            }
            return this
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === "boolean" && type === "string") return stateVal ? this.addClass(value) : this.removeClass(value);
            if (jQuery.isFunction(value)) return this.each(function(i) {
                jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal)
            });
            return this.each(function() {
                if (type === "string") {
                    var className, i = 0,
                        self = jQuery(this),
                        classNames = value.match(rnotwhite) || [];
                    while (className = classNames[i++])
                        if (self.hasClass(className)) self.removeClass(className);
                        else self.addClass(className)
                } else if (type === strundefined || type === "boolean") {
                    if (this.className) data_priv.set(this, "__className__", this.className);
                    this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || ""
                }
            })
        },
        hasClass: function(selector) {
            var className = " " + selector + " ",
                i = 0,
                l = this.length;
            for (; i < l; i++)
                if (this[i].nodeType === 1 && (" " + this[i].className +
                        " ").replace(rclass, " ").indexOf(className) >= 0) return true;
            return false
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) return ret;
                    ret = elem.value;
                    return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret
                }
                return
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function(i) {
                var val;
                if (this.nodeType !== 1) return;
                if (isFunction) val = value.call(this, i, jQuery(this).val());
                else val = value;
                if (val == null) val = "";
                else if (typeof val === "number") val += "";
                else if (jQuery.isArray(val)) val = jQuery.map(val, function(value) {
                    return value == null ? "" : value + ""
                });
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) this.value = val
            })
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem,
                        "value");
                    return val != null ? val : jQuery.trim(jQuery.text(elem))
                }
            },
            select: {
                get: function(elem) {
                    var value, option, options = elem.options,
                        index = elem.selectedIndex,
                        one = elem.type === "select-one" || index < 0,
                        values = one ? null : [],
                        max = one ? index + 1 : options.length,
                        i = index < 0 ? max : one ? index : 0;
                    for (; i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                            value = jQuery(option).val();
                            if (one) return value;
                            values.push(value)
                        }
                    }
                    return values
                },
                set: function(elem, value) {
                    var optionSet, option, options = elem.options,
                        values = jQuery.makeArray(value),
                        i = options.length;
                    while (i--) {
                        option = options[i];
                        if (option.selected = jQuery.inArray(option.value, values) >= 0) optionSet = true
                    }
                    if (!optionSet) elem.selectedIndex = -1;
                    return values
                }
            }
        }
    });
    jQuery.each(["radio", "checkbox"], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (jQuery.isArray(value)) return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >=
                    0
            }
        };
        if (!support.checkOn) jQuery.valHooks[this].get = function(elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value
        }
    });
    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name)
        }
    });
    jQuery.fn.extend({
        hover: function(fnOver,
            fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)
        },
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn)
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn)
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn)
        },
        undelegate: function(selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn)
        }
    });
    var nonce = jQuery.now();
    var rquery = /\?/;
    jQuery.parseJSON = function(data) {
        return JSON.parse(data + "")
    };
    jQuery.parseXML =
        function(data) {
            var xml, tmp;
            if (!data || typeof data !== "string") return null;
            try {
                tmp = new DOMParser;
                xml = tmp.parseFromString(data, "text/xml")
            } catch (e) {
                xml = undefined
            }
            if (!xml || xml.getElementsByTagName("parsererror").length) jQuery.error("Invalid XML: " + data);
            return xml
        };
    var ajaxLocParts, ajaxLocation, rhash = /#.*$/,
        rts = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
        rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
        prefilters = {},
        transports = {},
        allTypes = "*/".concat("*");
    try {
        ajaxLocation = location.href
    } catch (e) {
        ajaxLocation = document.createElement("a");
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href
    }
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

    function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*"
            }
            var dataType, i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func))
                while (dataType =
                    dataTypes[i++])
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func)
                    } else(structure[dataType] = structure[dataType] || []).push(func)
        }
    }

    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {},
            seekingTransport = structure === transports;

        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options,
                    originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false
                } else if (seekingTransport) return !(selected = dataTypeOrTransport)
            });
            return selected
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*")
    }

    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src)
            if (src[key] !== undefined)(flatOptions[key] ?
                target : deep || (deep = {}))[key] = src[key];
        if (deep) jQuery.extend(true, target, deep);
        return target
    }

    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents,
            dataTypes = s.dataTypes;
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) ct = s.mimeType || jqXHR.getResponseHeader("Content-Type")
        }
        if (ct)
            for (type in contents)
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break
                }
        if (dataTypes[0] in responses) finalDataType = dataTypes[0];
        else {
            for (type in responses) {
                if (!dataTypes[0] ||
                    s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break
                }
                if (!firstDataType) firstDataType = type
            }
            finalDataType = finalDataType || firstDataType
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) dataTypes.unshift(finalDataType);
            return responses[finalDataType]
        }
    }

    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {},
            dataTypes = s.dataTypes.slice();
        if (dataTypes[1])
            for (conv in s.converters) converters[conv.toLowerCase()] = s.converters[conv];
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) jqXHR[s.responseFields[current]] =
                response;
            if (!prev && isSuccess && s.dataFilter) response = s.dataFilter(response, s.dataType);
            prev = current;
            current = dataTypes.shift();
            if (current)
                if (current === "*") current = prev;
                else if (prev !== "*" && prev !== current) {
                conv = converters[prev + " " + current] || converters["* " + current];
                if (!conv)
                    for (conv2 in converters) {
                        tmp = conv2.split(" ");
                        if (tmp[1] === current) {
                            conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                            if (conv) {
                                if (conv === true) conv = converters[conv2];
                                else if (converters[conv2] !== true) {
                                    current = tmp[0];
                                    dataTypes.unshift(tmp[1])
                                }
                                break
                            }
                        }
                    }
                if (conv !==
                    true)
                    if (conv && s["throws"]) response = conv(response);
                    else try {
                        response = conv(response)
                    } catch (e) {
                        return {
                            state: "parsererror",
                            error: conv ? e : "No conversion from " + prev + " to " + current
                        }
                    }
            }
        }
        return {
            state: "success",
            data: response
        }
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: ajaxLocation,
            type: "GET",
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": true,
                "text json": jQuery.parseJSON,
                "text xml": jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target)
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
            if (typeof url === "object") {
                options = url;
                url = undefined
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options),
                callbackContext = s.context || s,
                globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks("once memory"),
                statusCode = s.statusCode || {},
                requestHeaders = {},
                requestHeadersNames = {},
                state = 0,
                strAbort = "canceled",
                jqXHR = {
                    readyState: 0,
                    getResponseHeader: function(key) {
                        var match;
                        if (state === 2) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while (match = rheaders.exec(responseHeadersString)) responseHeaders[match[1].toLowerCase()] = match[2]
                            }
                            match = responseHeaders[key.toLowerCase()]
                        }
                        return match == null ? null : match
                    },
                    getAllResponseHeaders: function() {
                        return state === 2 ? responseHeadersString : null
                    },
                    setRequestHeader: function(name, value) {
                        var lname =
                            name.toLowerCase();
                        if (!state) {
                            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                            requestHeaders[name] = value
                        }
                        return this
                    },
                    overrideMimeType: function(type) {
                        if (!state) s.mimeType = type;
                        return this
                    },
                    statusCode: function(map) {
                        var code;
                        if (map)
                            if (state < 2)
                                for (code in map) statusCode[code] = [statusCode[code], map[code]];
                            else jqXHR.always(map[jqXHR.status]);
                        return this
                    },
                    abort: function(statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) transport.abort(finalText);
                        done(0, finalText);
                        return this
                    }
                };
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ?
                    "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))))
            }
            if (s.data && s.processData && typeof s.data !== "string") s.data = jQuery.param(s.data, s.traditional);
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (state === 2) return jqXHR;
            fireGlobals = s.global;
            if (fireGlobals && jQuery.active++ === 0) jQuery.event.trigger("ajaxStart");
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url;
            if (!s.hasContent) {
                if (s.data) {
                    cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") +
                        s.data;
                    delete s.data
                }
                if (s.cache === false) s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                if (jQuery.etag[cacheURL]) jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) jqXHR.setRequestHeader("Content-Type", s.contentType);
            jqXHR.setRequestHeader("Accept",
                s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers) jqXHR.setRequestHeader(i, s.headers[i]);
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) return jqXHR.abort();
            strAbort = "abort";
            for (i in {
                    success: 1,
                    error: 1,
                    complete: 1
                }) jqXHR[i](s[i]);
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) done(-1, "No Transport");
            else {
                jqXHR.readyState = 1;
                if (fireGlobals) globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                if (s.async && s.timeout > 0) timeoutTimer = setTimeout(function() {
                    jqXHR.abort("timeout")
                }, s.timeout);
                try {
                    state = 1;
                    transport.send(requestHeaders, done)
                } catch (e) {
                    if (state < 2) done(-1, e);
                    else throw e;
                }
            }

            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (state === 2) return;
                state = 2;
                if (timeoutTimer) clearTimeout(timeoutTimer);
                transport = undefined;
                responseHeadersString = headers || "";
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >=
                    200 && status < 300 || status === 304;
                if (responses) response = ajaxHandleResponses(s, jqXHR, responses);
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) jQuery.lastModified[cacheURL] = modified;
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) jQuery.etag[cacheURL] = modified
                    }
                    if (status === 204 || s.type === "HEAD") statusText = "nocontent";
                    else if (status === 304) statusText = "notmodified";
                    else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) status = 0
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                if (isSuccess) deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                else deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                    if (!--jQuery.active) jQuery.event.trigger("ajaxStop")
                }
            }
            return jqXHR
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json")
        },
        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script")
        }
    });
    jQuery.each(["get", "post"], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined
            }
            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            })
        }
    });
    jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn)
        }
    });
    jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            "throws": true
        })
    };
    jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            if (jQuery.isFunction(html)) return this.each(function(i) {
                jQuery(this).wrapAll(html.call(this,
                    i))
            });
            if (this[0]) {
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) wrap.insertBefore(this[0]);
                wrap.map(function() {
                    var elem = this;
                    while (elem.firstElementChild) elem = elem.firstElementChild;
                    return elem
                }).append(this)
            }
            return this
        },
        wrapInner: function(html) {
            if (jQuery.isFunction(html)) return this.each(function(i) {
                jQuery(this).wrapInner(html.call(this, i))
            });
            return this.each(function() {
                var self = jQuery(this),
                    contents = self.contents();
                if (contents.length) contents.wrapAll(html);
                else self.append(html)
            })
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html)
            })
        },
        unwrap: function() {
            return this.parent().each(function() {
                if (!jQuery.nodeName(this, "body")) jQuery(this).replaceWith(this.childNodes)
            }).end()
        }
    });
    jQuery.expr.filters.hidden = function(elem) {
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0
    };
    jQuery.expr.filters.visible = function(elem) {
        return !jQuery.expr.filters.hidden(elem)
    };
    var r20 = /%20/g,
        rbracket = /\[\]$/,
        rCRLF =
        /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) jQuery.each(obj, function(i, v) {
            if (traditional || rbracket.test(prefix)) add(prefix, v);
            else buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add)
        });
        else if (!traditional && jQuery.type(obj) === "object")
            for (name in obj) buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
        else add(prefix, obj)
    }
    jQuery.param = function(a, traditional) {
        var prefix, s = [],
            add = function(key, value) {
                value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
                s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value)
            };
        if (traditional === undefined) traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) jQuery.each(a, function() {
            add(this.name, this.value)
        });
        else
            for (prefix in a) buildParams(prefix, a[prefix], traditional, add);
        return s.join("&").replace(r20,
            "+")
    };
    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray())
        },
        serializeArray: function() {
            return this.map(function() {
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this
            }).filter(function() {
                var type = this.type;
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type))
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ?
                    jQuery.map(val, function(val) {
                        return {
                            name: elem.name,
                            value: val.replace(rCRLF, "\r\n")
                        }
                    }) : {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    }
            }).get()
        }
    });
    jQuery.ajaxSettings.xhr = function() {
        try {
            return new XMLHttpRequest
        } catch (e) {}
    };
    var xhrId = 0,
        xhrCallbacks = {},
        xhrSuccessStatus = {
            0: 200,
            1223: 204
        },
        xhrSupported = jQuery.ajaxSettings.xhr();
    if (window.ActiveXObject) jQuery(window).on("unload", function() {
        for (var key in xhrCallbacks) xhrCallbacks[key]()
    });
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax =
        xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
        var callback;
        if (support.cors || xhrSupported && !options.crossDomain) return {
            send: function(headers, complete) {
                var i, xhr = options.xhr(),
                    id = ++xhrId;
                xhr.open(options.type, options.url, options.async, options.username, options.password);
                if (options.xhrFields)
                    for (i in options.xhrFields) xhr[i] = options.xhrFields[i];
                if (options.mimeType && xhr.overrideMimeType) xhr.overrideMimeType(options.mimeType);
                if (!options.crossDomain && !headers["X-Requested-With"]) headers["X-Requested-With"] =
                    "XMLHttpRequest";
                for (i in headers) xhr.setRequestHeader(i, headers[i]);
                callback = function(type) {
                    return function() {
                        if (callback) {
                            delete xhrCallbacks[id];
                            callback = xhr.onload = xhr.onerror = null;
                            if (type === "abort") xhr.abort();
                            else if (type === "error") complete(xhr.status, xhr.statusText);
                            else complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === "string" ? {
                                text: xhr.responseText
                            } : undefined, xhr.getAllResponseHeaders())
                        }
                    }
                };
                xhr.onload = callback();
                xhr.onerror = callback("error");
                callback =
                    xhrCallbacks[id] = callback("abort");
                try {
                    xhr.send(options.hasContent && options.data || null)
                } catch (e) {
                    if (callback) throw e;
                }
            },
            abort: function() {
                if (callback) callback()
            }
        }
    });
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text
            }
        }
    });
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) s.cache = false;
        if (s.crossDomain) s.type =
            "GET"
    });
    jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").prop({
                        async: true,
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove();
                        callback = null;
                        if (evt) complete(evt.type === "error" ? 404 : 200, evt.type)
                    });
                    document.head.appendChild(script[0])
                },
                abort: function() {
                    if (callback) callback()
                }
            }
        }
    });
    var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback =
                oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            this[callback] = true;
            return callback
        }
    });
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
        if (jsonProp || s.dataTypes[0] === "jsonp") {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            else if (s.jsonp !== false) s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            s.converters["script json"] = function() {
                if (!responseContainer) jQuery.error(callbackName + " was not called");
                return responseContainer[0]
            };
            s.dataTypes[0] = "json";
            overwritten = window[callbackName];
            window[callbackName] = function() {
                responseContainer = arguments
            };
            jqXHR.always(function() {
                window[callbackName] = overwritten;
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName)
                }
                if (responseContainer && jQuery.isFunction(overwritten)) overwritten(responseContainer[0]);
                responseContainer = overwritten = undefined
            });
            return "script"
        }
    });
    jQuery.parseHTML = function(data, context, keepScripts) {
        if (!data || typeof data !== "string") return null;
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false
        }
        context = context || document;
        var parsed = rsingleTag.exec(data),
            scripts = !keepScripts && [];
        if (parsed) return [context.createElement(parsed[1])];
        parsed = jQuery.buildFragment([data],
            context, scripts);
        if (scripts && scripts.length) jQuery(scripts).remove();
        return jQuery.merge([], parsed.childNodes)
    };
    var _load = jQuery.fn.load;
    jQuery.fn.load = function(url, params, callback) {
        if (typeof url !== "string" && _load) return _load.apply(this, arguments);
        var selector, type, response, self = this,
            off = url.indexOf(" ");
        if (off >= 0) {
            selector = jQuery.trim(url.slice(off));
            url = url.slice(0, off)
        }
        if (jQuery.isFunction(params)) {
            callback = params;
            params = undefined
        } else if (params && typeof params === "object") type = "POST";
        if (self.length >
            0) jQuery.ajax({
            url: url,
            type: type,
            dataType: "html",
            data: params
        }).done(function(responseText) {
            response = arguments;
            self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText)
        }).complete(callback && function(jqXHR, status) {
            self.each(callback, response || [jqXHR.responseText, status, jqXHR])
        });
        return this
    };
    jQuery.expr.filters.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem
        }).length
    };
    var docElem = window.document.documentElement;

    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView
    }
    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"),
                curElem = jQuery(elem),
                props = {};
            if (position === "static") elem.style.position = "relative";
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") &&
                (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0
            }
            if (jQuery.isFunction(options)) options = options.call(elem, i, curOffset);
            if (options.top != null) props.top = options.top - curOffset.top + curTop;
            if (options.left != null) props.left = options.left - curOffset.left + curLeft;
            if ("using" in options) options.using.call(elem, props);
            else curElem.css(props)
        }
    };
    jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length) return options ===
                undefined ? this : this.each(function(i) {
                    jQuery.offset.setOffset(this, options, i)
                });
            var docElem, win, elem = this[0],
                box = {
                    top: 0,
                    left: 0
                },
                doc = elem && elem.ownerDocument;
            if (!doc) return;
            docElem = doc.documentElement;
            if (!jQuery.contains(docElem, elem)) return box;
            if (typeof elem.getBoundingClientRect !== strundefined) box = elem.getBoundingClientRect();
            win = getWindow(doc);
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            }
        },
        position: function() {
            if (!this[0]) return;
            var offsetParent,
                offset, elem = this[0],
                parentOffset = {
                    top: 0,
                    left: 0
                };
            if (jQuery.css(elem, "position") === "fixed") offset = elem.getBoundingClientRect();
            else {
                offsetParent = this.offsetParent();
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], "html")) parentOffset = offsetParent.offset();
                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true)
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left -
                    jQuery.css(elem, "marginLeft", true)
            }
        },
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent || docElem;
                while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) offsetParent = offsetParent.offsetParent;
                return offsetParent || docElem
            })
        }
    });
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win =
                    getWindow(elem);
                if (val === undefined) return win ? win[prop] : elem[method];
                if (win) win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
                else elem[method] = val
            }, method, val, arguments.length, null)
        }
    });
    jQuery.each(["top", "left"], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed
            }
        })
    });
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name,
        type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) return elem.document.documentElement["client" + name];
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body["scroll" + name],
                            doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra)
                }, type, chainable ? margin : undefined, chainable, null)
            }
        })
    });
    jQuery.fn.size = function() {
        return this.length
    };
    jQuery.fn.andSelf = jQuery.fn.addBack;
    if (typeof define === "function" && define.amd) define("jquery", [], function() {
        return jQuery
    });
    var _jQuery = window.jQuery,
        _$ = window.$;
    jQuery.noConflict = function(deep) {
        if (window.$ === jQuery) window.$ = _$;
        if (deep &&
            window.jQuery === jQuery) window.jQuery = _jQuery;
        return jQuery
    };
    if (typeof noGlobal === strundefined) window.jQuery = window.$ = jQuery;
    return jQuery
});
(function($, undefined) {
    var incrementalElementId = 0;
    var mutex = 0;
    $.fn.tap = function(threshold, callback, touchOnly) {
        if (typeof threshold === "function") {
            touchOnly = callback;
            callback = threshold;
            threshold = 15
        }
        if ("ontouchstart" in window) this.each(function() {
            var moveDistance = 0;
            var touch = null;
            var elementId = ++incrementalElementId;
            var startPoint = null;
            var touching = false;
            var self = this;
            var $self = $(this);
            $self.bind("touchstart", function(e) {
                if (mutex != 0) return;
                else mutex = elementId;
                touching = true;
                moveDistance = 0;
                if (e.originalEvent.touches &&
                    e.originalEvent.touches[0]) {
                    touch = e.originalEvent.touches[0];
                    startPoint = {
                        x: touch.screenX,
                        y: touch.screenY
                    }
                }
            });
            $self.bind("touchend", function(e) {
                if (mutex == elementId) mutex = 0;
                if (!touching) return;
                touching = false;
                if (moveDistance < threshold) callback.apply(self, [].slice.call(arguments));
                else $self.trigger("tap-failed")
            });
            $self.bind("touchmove", function(e) {
                if (!touching) return;
                if (e.originalEvent.touches.length == 0 || startPoint === null) return touching = false;
                touch = e.originalEvent.touches[0];
                moveDistance = Math.sqrt(Math.pow(touch.screenX -
                    startPoint.x, 2) + Math.pow(touch.screenY - startPoint.y, 2));
                if (moveDistance > threshold) {
                    $self.trigger("exceed-tap-threshold");
                    touching = false
                }
            });
            $self.bind("touchcancel", function() {
                if (mutex == elementId) mutex = 0;
                touching = false;
                $self.trigger("tap-failed")
            })
        });
        else if (!touchOnly) this.click(callback);
        return this
    }
})(window.jQuery || window.$);
var Args = function() {
    var _extractSchemeEl = function(rawSchemeEl) {
        var schemeEl = {};
        schemeEl.defValue = undefined;
        schemeEl.typeValue = undefined;
        schemeEl.customCheck = undefined;
        for (var name in rawSchemeEl) {
            if (!rawSchemeEl.hasOwnProperty(name)) continue;
            if (name === "_default") schemeEl.defValue = rawSchemeEl[name];
            else if (name === "_type") schemeEl.typeValue = rawSchemeEl[name];
            else if (name === "_check") schemeEl.customCheck = rawSchemeEl[name];
            else schemeEl.sname = name
        }
        schemeEl.sarg = rawSchemeEl[schemeEl.sname];
        if (typeof schemeEl.customCheck ===
            "object" && schemeEl.customCheck instanceof RegExp) {
            var schemeRegexp = schemeEl.customCheck;
            schemeEl.customCheck = function(arg) {
                return !!arg.toString().match(schemeRegexp)
            }
        }
        return schemeEl
    };
    var _typeMatches = function(arg, schemeEl) {
        var ok = false;
        if ((schemeEl.sarg & Args.ANY) !== 0) ok = true;
        else if ((schemeEl.sarg & Args.STRING) !== 0 && typeof arg === "string") ok = true;
        else if ((schemeEl.sarg & Args.FUNCTION) !== 0 && typeof arg === "function") ok = true;
        else if ((schemeEl.sarg & Args.INT) !== 0 && (typeof arg === "number" && Math.floor(arg) ===
                arg)) ok = true;
        else if ((schemeEl.sarg & Args.FLOAT) !== 0 && typeof arg === "number") ok = true;
        else if ((schemeEl.sarg & Args.ARRAY) !== 0 && arg instanceof Array) ok = true;
        else if (((schemeEl.sarg & Args.OBJECT) !== 0 || schemeEl.typeValue !== undefined) && (typeof arg === "object" && (schemeEl.typeValue === undefined || arg instanceof schemeEl.typeValue))) ok = true;
        else if ((schemeEl.sarg & Args.ARRAY_BUFFER) !== 0 && arg.toString().match(/ArrayBuffer/)) ok = true;
        else if ((schemeEl.sarg & Args.DATE) !== 0 && arg instanceof Date) ok = true;
        else if ((schemeEl.sarg &
                Args.BOOL) !== 0 && typeof arg === "boolean") ok = true;
        else if ((schemeEl.sarg & Args.DOM_EL) !== 0 && (arg instanceof HTMLElement || window.$ !== undefined && arg instanceof window.$)) ok = true;
        if (schemeEl.customCheck !== undefined && typeof schemeEl.customCheck === "function")
            if (schemeEl.customCheck(arg)) ok = true;
            else ok = false;
        return ok
    };
    var _isTypeSpecified = function(schemeEl) {
        return (schemeEl.sarg & (Args.ANY | Args.STRING | Args.FUNCTION | Args.INT | Args.FLOAT | Args.OBJECT | Args.ARRAY_BUFFER | Args.DATE | Args.BOOL | Args.DOM_EL | Args.ARRAY)) !=
            0 || schemeEl.typeValue !== undefined
    };
    var _getTypeString = function(schemeEl) {
        var sarg = schemeEl.sarg;
        var typeValue = schemeEl.typeValue;
        var customCheck = schemeEl.customCheck;
        if ((sarg & Args.STRING) !== 0) return "String";
        if ((sarg & Args.FUNCTION) !== 0) return "Function";
        if ((sarg & Args.INT) !== 0) return "Int";
        if ((sarg & Args.FLOAT) !== 0) return "Float";
        if ((sarg & Args.ARRAY) !== 0) return "Array";
        if ((sarg & Args.OBJECT) !== 0)
            if (typeValue !== undefined) return "Object (" + typeValue.toString() + ")";
            else return "Object";
        if ((sarg & Args.ARRAY_BUFFER) !==
            0) return "Arry Buffer";
        if ((sarg & Args.DATE) !== 0) return "Date";
        if ((sarg & Args.BOOL) !== 0) return "Bool";
        if ((sarg & Args.DOM_EL) !== 0) return "DOM Element";
        if (customCheck !== undefined) return "[Custom checker]";
        return "unknown"
    };
    var _checkNamedArgs = function(namedArgs, scheme, returns) {
        var foundOne = false;
        for (var s = 0; s < scheme.length; s++) {
            var found = function(schemeEl) {
                var argFound = false;
                for (var name in namedArgs) {
                    var namedArg = namedArgs[name];
                    if (name === schemeEl.sname)
                        if (_typeMatches(namedArg, schemeEl)) {
                            returns[name] = namedArg;
                            argFound = true;
                            break
                        }
                }
                return argFound
            }(_extractSchemeEl(scheme[s]));
            if (found) scheme.splice(s--, 1);
            foundOne |= found
        }
        return foundOne
    };
    var _schemesMatch = function(schemeA, schemeB) {
        if (!schemeA || !schemeB) return false;
        return (schemeA.sarg & ~(Args.Optional | Args.Required)) === (schemeB.sarg & ~(Args.Optional | Args.Required)) && schemeA.typeValue === schemeB.typeValue
    };
    var _isRequired = function(sarg) {
        return !_isOptional(sarg)
    };
    var _isOptional = function(sarg) {
        return (sarg & Args.Optional) !== 0
    };
    var _reasonForFailure = function(schemeEl,
        a, arg) {
        var err = "";
        if (_isTypeSpecified(schemeEl)) err = "Argument " + a + " (" + schemeEl.sname + ") should be type " + _getTypeString(schemeEl) + ", but it was type " + typeof arg + " with value " + arg + ".";
        else if (schemeEl.customCheck !== undefined) {
            var funcString = schemeEl.customCheck.toString();
            if (funcString.length > 50) funcString = funcString.substr(0, 40) + "..." + funcString.substr(funcString.length - 10);
            err = "Argument " + a + " (" + schemeEl.sname + ") does not pass the custom check (" + funcString + ")."
        } else err = "Argument " + a + " (" + schemeEl.sname +
            ") has no valid type specified.";
        return err
    };
    var Args = function(scheme, args) {
        if (scheme === undefined) throw new Error("The scheme has not been passed.");
        if (args === undefined) throw new Error("The arguments have not been passed.");
        args = Array.prototype.slice.call(args, 0);
        var returns = {};
        var err = undefined;
        var runType = undefined;
        var run = [];
        var _addToRun = function(schemeEl) {
            if (!runType || !_schemesMatch(runType, schemeEl) || _isRequired(runType.sarg) && _isOptional(schemeEl.sarg)) run = [];
            if (run.length > 0 || _isOptional(schemeEl.sarg)) {
                runType =
                    schemeEl;
                run.push(schemeEl)
            }
        };
        var _shiftRun = function(schemeEl, a, r) {
            if (r === undefined) r = run.length - 1;
            if (r < 0) return;
            var lastMatch = run[r];
            var arg = returns[lastMatch.sname];
            if (_typeMatches(arg, schemeEl)) {
                returns[schemeEl.sname] = arg;
                returns[lastMatch.sname] = lastMatch.defValue || undefined;
                if ((lastMatch.sarg & Args.Optional) === 0) _shiftRun(lastMatch, a, r - 1)
            } else return _reasonForFailure(schemeEl, a, arg)
        };
        var a, s;
        if (typeof args[args.length - 1] === "object")
            if (_checkNamedArgs(args[args.length - 1], scheme, returns)) args.splice(args.length -
                1, 1);
        for (a = 0, s = 0; s < scheme.length; s++) {
            a = function(a, s) {
                var arg = args[a];
                if (scheme[s] instanceof Array)
                    if (arg === null || arg === undefined) {
                        err = "Argument " + a + " is null or undefined but it must be not null.";
                        return a
                    } else {
                        var group = scheme[s];
                        var retName = undefined;
                        for (var g = 0; g < group.length; g++) {
                            var schemeEl = _extractSchemeEl(group[g]);
                            if (_typeMatches(arg, schemeEl)) retName = schemeEl.sname
                        }
                        if (retName === undefined) {
                            err = "Argument " + a + " should be one of: ";
                            for (var g = 0; g < group.length; g++) {
                                var schemeEl = _extractSchemeEl(group[g]);
                                err += _getTypeString(schemeEl) + ", "
                            }
                            err += "but it was type " + typeof arg + " with value " + arg + ".";
                            return a
                        } else {
                            returns[retName] = arg;
                            return a + 1
                        }
                    } else {
                    var schemeEl = _extractSchemeEl(scheme[s]);
                    if ((schemeEl.sarg & Args.Optional) !== 0)
                        if (arg === null || arg === undefined) {
                            if (schemeEl.defValue !== undefined) returns[schemeEl.sname] = schemeEl.defValue;
                            else returns[schemeEl.sname] = arg;
                            return a + 1
                        } else if (_typeMatches(arg, schemeEl)) {
                        returns[schemeEl.sname] = arg;
                        _addToRun(schemeEl);
                        return a + 1
                    } else {
                        if (schemeEl.defValue !== undefined) {
                            returns[schemeEl.sname] =
                                schemeEl.defValue;
                            return a
                        }
                    } else if (arg === null || arg === undefined)
                        if (_isTypeSpecified(schemeEl) && _schemesMatch(schemeEl, runType)) {
                            err = _shiftRun(schemeEl, a);
                            if (err === "") _addToRun(schemeEl);
                            return a
                        } else {
                            err = "Argument " + a + " (" + schemeEl.sname + ") is null or undefined but it must be not null.";
                            return a
                        } else if (!_typeMatches(arg, schemeEl)) {
                        if (_isTypeSpecified(schemeEl) && _schemesMatch(schemeEl, runType)) {
                            err = _shiftRun(schemeEl, a);
                            if (err === "") {
                                _addToRun(schemeEl);
                                return a + 1
                            }
                        } else err = _reasonForFailure(schemeEl,
                            a, arg);
                        return a
                    } else {
                        returns[schemeEl.sname] = arg;
                        _addToRun(schemeEl);
                        return a + 1
                    }
                }
                return a
            }(a, s);
            if (err) break
        }
        if (err) throw new Error(err);
        return returns
    };
    Args.ANY = 1;
    Args.STRING = 1 << 1;
    Args.FUNCTION = 1 << 2;
    Args.INT = 1 << 3;
    Args.FLOAT = 1 << 4;
    Args.ARRAY_BUFFER = 1 << 5;
    Args.OBJECT = 1 << 6;
    Args.DATE = 1 << 7;
    Args.BOOL = 1 << 8;
    Args.DOM_EL = 1 << 9;
    Args.ARRAY = 1 << 10;
    Args.Optional = 1 << 11;
    Args.NotNull = Args.Required = 1 << 12;
    return Args
}();
try {
    module.exports = Args
} catch (e) {}
(function() {
    function Cache(maxSize, debug, storage) {
        this.maxSize_ = maxSize || -1;
        this.debug_ = debug || false;
        this.storage_ = storage || new Cache.BasicCacheStorage;
        this.fillFactor_ = .75;
        this.stats_ = {};
        this.stats_["hits"] = 0;
        this.stats_["misses"] = 0;
        this.log_("Initialized cache with size " + maxSize)
    }
    Cache.Priority = {
        "LOW": 1,
        "NORMAL": 2,
        "HIGH": 4
    };
    Cache.BasicCacheStorage = function() {
        this.items_ = {};
        this.count_ = 0
    };
    Cache.BasicCacheStorage.prototype.get = function(key) {
        return this.items_[key]
    };
    Cache.BasicCacheStorage.prototype.set =
        function(key, value) {
            if (typeof this.get(key) === "undefined") this.count_++;
            this.items_[key] = value
        };
    Cache.BasicCacheStorage.prototype.size = function(key, value) {
        return this.count_
    };
    Cache.BasicCacheStorage.prototype.remove = function(key) {
        var item = this.get(key);
        if (typeof item !== "undefined") this.count_--;
        delete this.items_[key];
        return item
    };
    Cache.BasicCacheStorage.prototype.keys = function() {
        var ret = [],
            p;
        for (p in this.items_) ret.push(p);
        return ret
    };
    Cache.LocalStorageCacheStorage = function(namespace) {
        this.prefix_ =
            "cache-storage." + (namespace || "default") + ".";
        var escapedPrefix = this.prefix_.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
        this.regexp_ = new RegExp("^" + escapedPrefix)
    };
    Cache.LocalStorageCacheStorage.prototype.get = function(key) {
        var item = window.localStorage[this.prefix_ + key];
        if (item) return JSON.parse(item);
        return null
    };
    Cache.LocalStorageCacheStorage.prototype.set = function(key, value) {
        window.localStorage[this.prefix_ + key] = JSON.stringify(value)
    };
    Cache.LocalStorageCacheStorage.prototype.size = function(key, value) {
        return this.keys().length
    };
    Cache.LocalStorageCacheStorage.prototype.remove = function(key) {
        var item = this.get(key);
        delete window.localStorage[this.prefix_ + key];
        return item
    };
    Cache.LocalStorageCacheStorage.prototype.keys = function() {
        var ret = [],
            p;
        for (p in window.localStorage)
            if (p.match(this.regexp_)) ret.push(p.replace(this.prefix_, ""));
        return ret
    };
    Cache.prototype.getItem = function(key) {
        var item = this.storage_.get(key);
        if (item != null)
            if (!this.isExpired_(item)) item.lastAccessed = (new Date).getTime();
            else {
                this.removeItem(key);
                item = null
            }
        var returnVal =
            item ? item.value : null;
        if (returnVal) {
            this.stats_["hits"]++;
            this.log_("Cache HIT for key " + key)
        } else {
            this.stats_["misses"]++;
            this.log_("Cache MISS for key " + key)
        }
        return returnVal
    };
    Cache._CacheItem = function(k, v, o) {
        if (!k) throw new Error("key cannot be null or empty");
        this.key = k;
        this.value = v;
        o = o || {};
        if (o.expirationAbsolute) o.expirationAbsolute = o.expirationAbsolute.getTime();
        if (!o.priority) o.priority = Cache.Priority.NORMAL;
        this.options = o;
        this.lastAccessed = (new Date).getTime()
    };
    Cache.prototype.setItem = function(key,
        value, options) {
        if (this.storage_.get(key) != null) this.removeItem(key);
        this.addItem_(new Cache._CacheItem(key, value, options));
        this.log_("Setting key " + key);
        if (this.maxSize_ > 0 && this.size() > this.maxSize_) {
            var that = this;
            setTimeout(function() {
                that.purge_.call(that)
            }, 0)
        }
    };
    Cache.prototype.clear = function() {
        var keys = this.storage_.keys();
        for (var i = 0; i < keys.length; i++) this.removeItem(keys[i]);
        this.log_("Cache cleared")
    };
    Cache.prototype.getStats = function() {
        return this.stats_
    };
    Cache.prototype.toHtmlString = function() {
        var returnStr =
            this.size() + " item(s) in cache<br /><ul>";
        var keys = this.storage_.keys();
        for (var i = 0; i < keys.length; i++) {
            var item = this.storage_.get(keys[i]);
            returnStr = returnStr + "<li>" + item.key.toString() + " = " + item.value.toString() + "</li>"
        }
        returnStr = returnStr + "</ul>";
        return returnStr
    };
    Cache.prototype.resize = function(newMaxSize) {
        this.log_("Resizing Cache from " + this.maxSize_ + " to " + newMaxSize);
        var oldMaxSize = this.maxSize_;
        this.maxSize_ = newMaxSize;
        if (newMaxSize > 0 && (oldMaxSize < 0 || newMaxSize < oldMaxSize))
            if (this.size() >
                newMaxSize) this.purge_();
        this.log_("Resizing done")
    };
    Cache.prototype.purge_ = function() {
        var tmparray = new Array;
        var purgeSize = Math.round(this.maxSize_ * this.fillFactor_);
        if (this.maxSize_ < 0) purgeSize = this.size() * this.fillFactor_;
        var keys = this.storage_.keys();
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var item = this.storage_.get(key);
            if (this.isExpired_(item)) this.removeItem(key);
            else tmparray.push(item)
        }
        if (tmparray.length > purgeSize) {
            tmparray = tmparray.sort(function(a, b) {
                if (a.options.priority != b.options.priority) return b.options.priority -
                    a.options.priority;
                else return b.lastAccessed - a.lastAccessed
            });
            while (tmparray.length > purgeSize) {
                var ritem = tmparray.pop();
                this.removeItem(ritem.key)
            }
        }
        this.log_("Purged cached")
    };
    Cache.prototype.addItem_ = function(item, attemptedAlready) {
        var cache = this;
        try {
            this.storage_.set(item.key, item)
        } catch (err) {
            if (attemptedAlready) {
                this.log_("Failed setting again, giving up: " + err.toString());
                throw err;
            }
            this.log_("Error adding item, purging and trying again: " + err.toString());
            this.purge_();
            this.addItem_(item, true)
        }
    };
    Cache.prototype.removeItem = function(key) {
        var item = this.storage_.remove(key);
        this.log_("removed key " + key);
        if (item && item.options && item.options.callback) setTimeout(function() {
            item.options.callback.call(null, item.key, item.value)
        }, 0);
        return item ? item.value : null
    };
    Cache.prototype.removeWhere = function(test) {
        var keys = this.storage_.keys();
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var item = this.storage_.get(key);
            if (test(key, item.value) === true) this.removeItem(key)
        }
    };
    Cache.prototype.size = function() {
        return this.storage_.size()
    };
    Cache.prototype.isExpired_ = function(item) {
        var now = (new Date).getTime();
        var expired = false;
        if (item.options.expirationAbsolute && item.options.expirationAbsolute < now) expired = true;
        if (!expired && item.options.expirationSliding) {
            var lastAccess = item.lastAccessed + item.options.expirationSliding * 1E3;
            if (lastAccess < now) expired = true
        }
        return expired
    };
    Cache.prototype.log_ = function(msg) {
        if (this.debug_) console.log(msg)
    };
    var root = this;
    if (typeof module !== "undefined" && module.exports) module.exports = Cache;
    else if (typeof define ==
        "function" && define.amd) define(function() {
        return Cache
    });
    else root.Cache = Cache
})();
(function() {
    function $$utils$$objectOrFunction(x) {
        return typeof x === "function" || typeof x === "object" && x !== null
    }

    function $$utils$$isFunction(x) {
        return typeof x === "function"
    }

    function $$utils$$isMaybeThenable(x) {
        return typeof x === "object" && x !== null
    }
    var $$utils$$_isArray;
    if (!Array.isArray) $$utils$$_isArray = function(x) {
        return Object.prototype.toString.call(x) === "[object Array]"
    };
    else $$utils$$_isArray = Array.isArray;
    var $$utils$$isArray = $$utils$$_isArray;
    var $$utils$$now = Date.now || function() {
        return (new Date).getTime()
    };

    function $$utils$$F() {}
    var $$utils$$o_create = Object.create || function(o) {
        if (arguments.length > 1) throw new Error("Second argument not supported");
        if (typeof o !== "object") throw new TypeError("Argument must be an object");
        $$utils$$F.prototype = o;
        return new $$utils$$F
    };
    var $$asap$$len = 0;
    var $$asap$$default = function asap(callback, arg) {
        $$asap$$queue[$$asap$$len] = callback;
        $$asap$$queue[$$asap$$len + 1] = arg;
        $$asap$$len += 2;
        if ($$asap$$len === 2) $$asap$$scheduleFlush()
    };
    var $$asap$$browserGlobal = typeof window !== "undefined" ?
        window : {};
    var $$asap$$BrowserMutationObserver = $$asap$$browserGlobal.MutationObserver || $$asap$$browserGlobal.WebKitMutationObserver;
    var $$asap$$isWorker = typeof Uint8ClampedArray !== "undefined" && typeof importScripts !== "undefined" && typeof MessageChannel !== "undefined";

    function $$asap$$useNextTick() {
        return function() {
            process.nextTick($$asap$$flush)
        }
    }

    function $$asap$$useMutationObserver() {
        var iterations = 0;
        var observer = new $$asap$$BrowserMutationObserver($$asap$$flush);
        var node = document.createTextNode("");
        observer.observe(node, {
            characterData: true
        });
        return function() {
            node.data = iterations = ++iterations % 2
        }
    }

    function $$asap$$useMessageChannel() {
        var channel = new MessageChannel;
        channel.port1.onmessage = $$asap$$flush;
        return function() {
            channel.port2.postMessage(0)
        }
    }

    function $$asap$$useSetTimeout() {
        return function() {
            setTimeout($$asap$$flush, 1)
        }
    }
    var $$asap$$queue = new Array(1E3);

    function $$asap$$flush() {
        for (var i = 0; i < $$asap$$len; i += 2) {
            var callback = $$asap$$queue[i];
            var arg = $$asap$$queue[i + 1];
            callback(arg);
            $$asap$$queue[i] =
                undefined;
            $$asap$$queue[i + 1] = undefined
        }
        $$asap$$len = 0
    }
    var $$asap$$scheduleFlush;
    if (typeof process !== "undefined" && {}.toString.call(process) === "[object process]") $$asap$$scheduleFlush = $$asap$$useNextTick();
    else if ($$asap$$BrowserMutationObserver) $$asap$$scheduleFlush = $$asap$$useMutationObserver();
    else if ($$asap$$isWorker) $$asap$$scheduleFlush = $$asap$$useMessageChannel();
    else $$asap$$scheduleFlush = $$asap$$useSetTimeout();

    function $$$internal$$noop() {}
    var $$$internal$$PENDING = void 0;
    var $$$internal$$FULFILLED =
        1;
    var $$$internal$$REJECTED = 2;
    var $$$internal$$GET_THEN_ERROR = new $$$internal$$ErrorObject;

    function $$$internal$$selfFullfillment() {
        return new TypeError("You cannot resolve a promise with itself")
    }

    function $$$internal$$cannotReturnOwn() {
        return new TypeError("A promises callback cannot return that same promise.")
    }

    function $$$internal$$getThen(promise) {
        try {
            return promise.then
        } catch (error) {
            $$$internal$$GET_THEN_ERROR.error = error;
            return $$$internal$$GET_THEN_ERROR
        }
    }

    function $$$internal$$tryThen(then,
        value, fulfillmentHandler, rejectionHandler) {
        try {
            then.call(value, fulfillmentHandler, rejectionHandler)
        } catch (e) {
            return e
        }
    }

    function $$$internal$$handleForeignThenable(promise, thenable, then) {
        $$asap$$default(function(promise) {
            var sealed = false;
            var error = $$$internal$$tryThen(then, thenable, function(value) {
                    if (sealed) return;
                    sealed = true;
                    if (thenable !== value) $$$internal$$resolve(promise, value);
                    else $$$internal$$fulfill(promise, value)
                }, function(reason) {
                    if (sealed) return;
                    sealed = true;
                    $$$internal$$reject(promise, reason)
                },
                "Settle: " + (promise._label || " unknown promise"));
            if (!sealed && error) {
                sealed = true;
                $$$internal$$reject(promise, error)
            }
        }, promise)
    }

    function $$$internal$$handleOwnThenable(promise, thenable) {
        if (thenable._state === $$$internal$$FULFILLED) $$$internal$$fulfill(promise, thenable._result);
        else if (promise._state === $$$internal$$REJECTED) $$$internal$$reject(promise, thenable._result);
        else $$$internal$$subscribe(thenable, undefined, function(value) {
            $$$internal$$resolve(promise, value)
        }, function(reason) {
            $$$internal$$reject(promise,
                reason)
        })
    }

    function $$$internal$$handleMaybeThenable(promise, maybeThenable) {
        if (maybeThenable.constructor === promise.constructor) $$$internal$$handleOwnThenable(promise, maybeThenable);
        else {
            var then = $$$internal$$getThen(maybeThenable);
            if (then === $$$internal$$GET_THEN_ERROR) $$$internal$$reject(promise, $$$internal$$GET_THEN_ERROR.error);
            else if (then === undefined) $$$internal$$fulfill(promise, maybeThenable);
            else if ($$utils$$isFunction(then)) $$$internal$$handleForeignThenable(promise, maybeThenable, then);
            else $$$internal$$fulfill(promise,
                maybeThenable)
        }
    }

    function $$$internal$$resolve(promise, value) {
        if (promise === value) $$$internal$$reject(promise, $$$internal$$selfFullfillment());
        else if ($$utils$$objectOrFunction(value)) $$$internal$$handleMaybeThenable(promise, value);
        else $$$internal$$fulfill(promise, value)
    }

    function $$$internal$$publishRejection(promise) {
        if (promise._onerror) promise._onerror(promise._result);
        $$$internal$$publish(promise)
    }

    function $$$internal$$fulfill(promise, value) {
        if (promise._state !== $$$internal$$PENDING) return;
        promise._result =
            value;
        promise._state = $$$internal$$FULFILLED;
        if (promise._subscribers.length === 0);
        else $$asap$$default($$$internal$$publish, promise)
    }

    function $$$internal$$reject(promise, reason) {
        if (promise._state !== $$$internal$$PENDING) return;
        promise._state = $$$internal$$REJECTED;
        promise._result = reason;
        $$asap$$default($$$internal$$publishRejection, promise)
    }

    function $$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
        var subscribers = parent._subscribers;
        var length = subscribers.length;
        parent._onerror = null;
        subscribers[length] =
            child;
        subscribers[length + $$$internal$$FULFILLED] = onFulfillment;
        subscribers[length + $$$internal$$REJECTED] = onRejection;
        if (length === 0 && parent._state) $$asap$$default($$$internal$$publish, parent)
    }

    function $$$internal$$publish(promise) {
        var subscribers = promise._subscribers;
        var settled = promise._state;
        if (subscribers.length === 0) return;
        var child, callback, detail = promise._result;
        for (var i = 0; i < subscribers.length; i += 3) {
            child = subscribers[i];
            callback = subscribers[i + settled];
            if (child) $$$internal$$invokeCallback(settled,
                child, callback, detail);
            else callback(detail)
        }
        promise._subscribers.length = 0
    }

    function $$$internal$$ErrorObject() {
        this.error = null
    }
    var $$$internal$$TRY_CATCH_ERROR = new $$$internal$$ErrorObject;

    function $$$internal$$tryCatch(callback, detail) {
        try {
            return callback(detail)
        } catch (e) {
            $$$internal$$TRY_CATCH_ERROR.error = e;
            return $$$internal$$TRY_CATCH_ERROR
        }
    }

    function $$$internal$$invokeCallback(settled, promise, callback, detail) {
        var hasCallback = $$utils$$isFunction(callback),
            value, error, succeeded, failed;
        if (hasCallback) {
            value =
                $$$internal$$tryCatch(callback, detail);
            if (value === $$$internal$$TRY_CATCH_ERROR) {
                failed = true;
                error = value.error;
                value = null
            } else succeeded = true;
            if (promise === value) {
                $$$internal$$reject(promise, $$$internal$$cannotReturnOwn());
                return
            }
        } else {
            value = detail;
            succeeded = true
        }
        if (promise._state !== $$$internal$$PENDING);
        else if (hasCallback && succeeded) $$$internal$$resolve(promise, value);
        else if (failed) $$$internal$$reject(promise, error);
        else if (settled === $$$internal$$FULFILLED) $$$internal$$fulfill(promise, value);
        else if (settled ===
            $$$internal$$REJECTED) $$$internal$$reject(promise, value)
    }

    function $$$internal$$initializePromise(promise, resolver) {
        try {
            resolver(function resolvePromise(value) {
                $$$internal$$resolve(promise, value)
            }, function rejectPromise(reason) {
                $$$internal$$reject(promise, reason)
            })
        } catch (e) {
            $$$internal$$reject(promise, e)
        }
    }

    function $$$enumerator$$makeSettledResult(state, position, value) {
        if (state === $$$internal$$FULFILLED) return {
            state: "fulfilled",
            value: value
        };
        else return {
            state: "rejected",
            reason: value
        }
    }

    function $$$enumerator$$Enumerator(Constructor,
        input, abortOnReject, label) {
        this._instanceConstructor = Constructor;
        this.promise = new Constructor($$$internal$$noop, label);
        this._abortOnReject = abortOnReject;
        if (this._validateInput(input)) {
            this._input = input;
            this.length = input.length;
            this._remaining = input.length;
            this._init();
            if (this.length === 0) $$$internal$$fulfill(this.promise, this._result);
            else {
                this.length = this.length || 0;
                this._enumerate();
                if (this._remaining === 0) $$$internal$$fulfill(this.promise, this._result)
            }
        } else $$$internal$$reject(this.promise, this._validationError())
    }
    $$$enumerator$$Enumerator.prototype._validateInput = function(input) {
        return $$utils$$isArray(input)
    };
    $$$enumerator$$Enumerator.prototype._validationError = function() {
        return new Error("Array Methods must be provided an Array")
    };
    $$$enumerator$$Enumerator.prototype._init = function() {
        this._result = new Array(this.length)
    };
    var $$$enumerator$$default = $$$enumerator$$Enumerator;
    $$$enumerator$$Enumerator.prototype._enumerate = function() {
        var length = this.length;
        var promise = this.promise;
        var input = this._input;
        for (var i =
                0; promise._state === $$$internal$$PENDING && i < length; i++) this._eachEntry(input[i], i)
    };
    $$$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
        var c = this._instanceConstructor;
        if ($$utils$$isMaybeThenable(entry))
            if (entry.constructor === c && entry._state !== $$$internal$$PENDING) {
                entry._onerror = null;
                this._settledAt(entry._state, i, entry._result)
            } else this._willSettleAt(c.resolve(entry), i);
        else {
            this._remaining--;
            this._result[i] = this._makeResult($$$internal$$FULFILLED, i, entry)
        }
    };
    $$$enumerator$$Enumerator.prototype._settledAt =
        function(state, i, value) {
            var promise = this.promise;
            if (promise._state === $$$internal$$PENDING) {
                this._remaining--;
                if (this._abortOnReject && state === $$$internal$$REJECTED) $$$internal$$reject(promise, value);
                else this._result[i] = this._makeResult(state, i, value)
            }
            if (this._remaining === 0) $$$internal$$fulfill(promise, this._result)
        };
    $$$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {
        return value
    };
    $$$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
        var enumerator = this;
        $$$internal$$subscribe(promise,
            undefined,
            function(value) {
                enumerator._settledAt($$$internal$$FULFILLED, i, value)
            },
            function(reason) {
                enumerator._settledAt($$$internal$$REJECTED, i, reason)
            })
    };
    var $$promise$all$$default = function all(entries, label) {
        return (new $$$enumerator$$default(this, entries, true, label)).promise
    };
    var $$promise$race$$default = function race(entries, label) {
        var Constructor = this;
        var promise = new Constructor($$$internal$$noop, label);
        if (!$$utils$$isArray(entries)) {
            $$$internal$$reject(promise, new TypeError("You must pass an array to race."));
            return promise
        }
        var length = entries.length;

        function onFulfillment(value) {
            $$$internal$$resolve(promise, value)
        }

        function onRejection(reason) {
            $$$internal$$reject(promise, reason)
        }
        for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) $$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
        return promise
    };
    var $$promise$resolve$$default = function resolve(object, label) {
        var Constructor = this;
        if (object && typeof object === "object" && object.constructor === Constructor) return object;
        var promise = new Constructor($$$internal$$noop, label);
        $$$internal$$resolve(promise, object);
        return promise
    };
    var $$promise$reject$$default = function reject(reason, label) {
        var Constructor = this;
        var promise = new Constructor($$$internal$$noop, label);
        $$$internal$$reject(promise, reason);
        return promise
    };
    var $$es6$promise$promise$$counter = 0;

    function $$es6$promise$promise$$needsResolver() {
        throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
    }

    function $$es6$promise$promise$$needsNew() {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }
    var $$es6$promise$promise$$default = $$es6$promise$promise$$Promise;

    function $$es6$promise$promise$$Promise(resolver) {
        this._id = $$es6$promise$promise$$counter++;
        this._state = undefined;
        this._result = undefined;
        this._subscribers = [];
        if ($$$internal$$noop !== resolver) {
            if (!$$utils$$isFunction(resolver)) $$es6$promise$promise$$needsResolver();
            if (!(this instanceof $$es6$promise$promise$$Promise)) $$es6$promise$promise$$needsNew();
            $$$internal$$initializePromise(this, resolver)
        }
    }
    $$es6$promise$promise$$Promise.all = $$promise$all$$default;
    $$es6$promise$promise$$Promise.race = $$promise$race$$default;
    $$es6$promise$promise$$Promise.resolve = $$promise$resolve$$default;
    $$es6$promise$promise$$Promise.reject = $$promise$reject$$default;
    $$es6$promise$promise$$Promise.prototype = {
        constructor: $$es6$promise$promise$$Promise,
        then: function(onFulfillment, onRejection) {
            var parent = this;
            var state = parent._state;
            if (state === $$$internal$$FULFILLED && !onFulfillment || state === $$$internal$$REJECTED && !onRejection) return this;
            var child = new this.constructor($$$internal$$noop);
            var result = parent._result;
            if (state) {
                var callback = arguments[state - 1];
                $$asap$$default(function() {
                    $$$internal$$invokeCallback(state, child, callback, result)
                })
            } else $$$internal$$subscribe(parent, child, onFulfillment, onRejection);
            return child
        },
        "catch": function(onRejection) {
            return this.then(null, onRejection)
        }
    };
    var $$es6$promise$polyfill$$default = function polyfill() {
        var local;
        if (typeof global !== "undefined") local = global;
        else if (typeof window !== "undefined" && window.document) local = window;
        else local = self;
        var es6PromiseSupport =
            "Promise" in local && "resolve" in local.Promise && "reject" in local.Promise && "all" in local.Promise && "race" in local.Promise && function() {
                var resolve;
                new local.Promise(function(r) {
                    resolve = r
                });
                return $$utils$$isFunction(resolve)
            }();
        if (!es6PromiseSupport) local.Promise = $$es6$promise$promise$$default
    };
    var es6$promise$umd$$ES6Promise = {
        "Promise": $$es6$promise$promise$$default,
        "polyfill": $$es6$promise$polyfill$$default
    };
    if (typeof define === "function" && define["amd"]) define(function() {
        return es6$promise$umd$$ES6Promise
    });
    else if (typeof module !== "undefined" && module["exports"]) module["exports"] = es6$promise$umd$$ES6Promise;
    else if (typeof this !== "undefined") this["ES6Promise"] = es6$promise$umd$$ES6Promise
}).call(this);
(function(root, factory) {
    if (typeof define === "function" && define.amd) define("utils/MapUtils", factory);
    else {
        if (typeof root.regulaModules === "undefined") root.regulaModules = {};
        root.regulaModules.MapUtils = factory()
    }
}(this, function() {
    return {
        iterateOverMap: function(map, callback) {
            var index = 0;
            for (var property in map)
                if (map.hasOwnProperty(property) && property !== "__size__") {
                    callback.call(map, property, map[property], index);
                    index++
                }
        },
        exists: function(array, value) {
            var found = false;
            var i = 0;
            while (!found && i < array.length) {
                found =
                    value == array[i];
                i++
            }
            return found
        },
        put: function(map, key, value) {
            if (!map.__size__) map.__size__ = 0;
            if (!map[key]) map.__size__++;
            map[key] = value
        },
        isEmpty: function(map) {
            for (var key in map)
                if (map.hasOwnProperty(key)) return false;
            return true
        }
    }
}));
(function(root, factory) {
    if (typeof define === "function" && define.amd) define("utils/DOMUtils", factory);
    else {
        if (typeof root.regulaModules === "undefined") root.regulaModules = {};
        root.regulaModules.DOMUtils = factory()
    }
})(this, function() {
    var friendlyInputNames = {
        form: "The form",
        select: "The select box",
        textarea: "The text area",
        checkbox: "The checkbox",
        radio: "The radio button",
        text: "The text field",
        password: "The password",
        email: "The email",
        url: "The URL",
        number: "The number",
        datetime: "The datetime",
        "datetime-local": "The local datetime",
        date: "The date",
        month: "The month",
        time: "The time",
        week: "The week",
        range: "The range",
        tel: "The telephone number",
        color: "The color"
    };

    function getElementsByAttribute(oElm, strTagName, strAttributeName, strAttributeValue) {
        var arrElements = strTagName == "*" && oElm.all ? oElm.all : oElm.getElementsByTagName(strTagName);
        var arrReturnElements = [];
        var oAttributeValue = typeof strAttributeValue !== "undefined" ? new XRegExp("(^|\\s)" + strAttributeValue + "(\\s|$)") : null;
        var oCurrent;
        var oAttribute;
        for (var i = 0; i < arrElements.length; i++) {
            oCurrent =
                arrElements[i];
            oAttribute = oCurrent.getAttribute && oCurrent.getAttribute(strAttributeName);
            if (typeof oAttribute == "string" && oAttribute.length > 0)
                if (typeof strAttributeValue === "undefined" || oAttributeValue && oAttributeValue.test(oAttribute)) arrReturnElements.push(oCurrent)
        }
        return arrReturnElements
    }

    function hasShadowDom() {
        if (document.head.createShadowRoot) return true;
        else return false
    }

    function getSelector(s) {
        if (hasShadowDom()) return "html /deep/ " + s;
        return s
    }

    function getAttributeValueForElement(element, attribute) {
        var result =
            element.getAttribute && element.getAttribute(attribute) || null;
        if (!result) {
            var attributes = element.attributes;
            for (var i = 0; i < attributes.length; i++)
                if (attributes[i].nodeName === attribute) result = attributes[i].nodeValue
        }
        return result
    }

    function generateRandomId() {
        return "regula-generated-" + Math.floor(Math.random() * 1E6)
    }

    function supportsHTML5Validation() {
        return typeof document.createElement("input").checkValidity === "function"
    }
    return {
        friendlyInputNames: friendlyInputNames,
        getElementsByAttribute: getElementsByAttribute,
        getAttributeValueForElement: getAttributeValueForElement,
        generateRandomId: generateRandomId,
        hasShadowDom: hasShadowDom,
        getSelector: getSelector,
        supportsHTML5Validation: supportsHTML5Validation
    }
});
(function(root, factory) {
    if (typeof define === "function" && define.amd) define("service/GroupService", factory);
    else {
        if (typeof root.regulaModules === "undefined") root.regulaModules = {};
        root.regulaModules.GroupService = factory()
    }
})(this, function() {
    var Group = {
        Default: 0
    };
    var ReverseGroup = {
        0: "Default"
    };
    var deletedGroupIndices = [];
    var firstCustomGroupIndex = 1;
    return {
        Group: Group,
        ReverseGroup: ReverseGroup,
        deletedGroupIndices: deletedGroupIndices,
        firstCustomGroupIndex: firstCustomGroupIndex
    }
});
(function(root, factory) {
    if (typeof define === "function" && define.amd) define("utils/ArrayUtils", factory);
    else {
        if (typeof root.regulaModules === "undefined") root.regulaModules = {};
        root.regulaModules.ArrayUtils = factory()
    }
}(this, function() {
    function explode(array, delimeter) {
        var str = "";
        for (var i = 0; i < array.length; i++) str += array[i] + delimeter;
        return str.replace(new XRegExp(delimeter + "$"), "")
    }
    return {
        explode: explode
    }
}));
(function(root, factory) {
    if (typeof define === "function" && define.amd) define("service/ExceptionService", ["utils/ArrayUtils"], factory);
    else {
        if (typeof root.regulaModules === "undefined") root.regulaModules = {};
        root.regulaModules.ExceptionService = factory(root.regulaModules.ArrayUtils)
    }
})(this, function(ArrayUtils) {
    var Exception = {
        IllegalArgumentException: function(message) {
            this.name = "IllegalArgumentException";
            this.message = message
        },
        ConstraintDefinitionException: function(message) {
            this.name = "ConstraintDefinitionException";
            this.message = message
        },
        BindException: function(message) {
            this.name = "BindException";
            this.message = message
        },
        MissingFeatureException: function(message) {
            this.name = "MissingFeatureException";
            this.message = message
        }
    };
    for (var errorType in Exception)
        if (Exception.hasOwnProperty(errorType)) {
            var error = Exception[errorType];
            error.prototype = new Error;
            error.prototype.constructor = error
        }
    function generateExceptionMessage(element, constraintName, message) {
        var errorMessage = "";
        if (element != null) {
            errorMessage = element.id;
            if (constraintName ==
                "" || constraintName == null || constraintName == undefined) errorMessage += ": ";
            else errorMessage += "." + constraintName + ": "
        } else if (constraintName != "" && constraintName != null && constraintName != undefined) errorMessage = "@" + constraintName + ": ";
        return errorMessage + message
    }

    function explodeParameters(options) {
        var str = "Function received: {";
        for (var argument in options)
            if (options.hasOwnProperty(argument))
                if (typeof options[argument] == "string") str += argument + ": " + options[argument] + ", ";
                else if (options[argument] instanceof Array) str += argument + ": [" + ArrayUtils.explode(options[argument], ", ") + "], ";
        str = str.replace(/, $/, "") + "}";
        return str
    }
    return {
        Exception: Exception,
        generateExceptionMessage: generateExceptionMessage,
        explodeParameters: explodeParameters
    }
});
(function(root, factory) {
    if (typeof define === "function" && define.amd) define("service/ValidationService", ["utils/DOMUtils", "utils/MapUtils", "service/GroupService", "service/ExceptionService", "utils/ArrayUtils"], factory);
    else {
        if (typeof root.regulaModules === "undefined") root.regulaModules = {};
        root.regulaModules.ValidationService = factory(root.regulaModules.DOMUtils, root.regulaModules.MapUtils, root.regulaModules.GroupService, root.regulaModules.ExceptionService, root.regulaModules.ArrayUtils)
    }
})(this, function(DOMUtils,
    MapUtils, GroupService, ExceptionService, ArrayUtils) {
    var config = {};
    var ReverseConstraint = {};
    var constraintDefinitions = {};
    var boundConstraints = {};
    var processedConstraints = {};
    var processedRadioGroups = {};
    var publicValidator = {};

    function initializePublicValidators(constraintDefinitions) {
        for (var constraintName in constraintDefinitions)
            if (constraintDefinitions.hasOwnProperty(constraintName)) createPublicValidator(constraintName, constraintDefinitions)
    }

    function init(options) {
        config = options.config;
        ReverseConstraint =
            options.ReverseConstraint;
        constraintDefinitions = options.constraintDefinitions;
        boundConstraints = options.boundConstraints
    }
    var Validator = {
        checked: function(params) {
            var result = false;
            if (this.type.toLowerCase() === "radio" && this.name.replace(/\s/g, "") !== "") {
                var elements = DOMUtils.getElementsByAttribute(document.body, "input", "name", this.name.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"));
                var i = 0;
                while (i < elements.length && !result) {
                    result = elements[i].checked;
                    i++
                }
            } else result = this.checked;
            return result
        },
        selected: function(params) {
            return this.selectedIndex > 0
        },
        max: function(params) {
            var result = true;
            if (shouldValidate(this, params)) result = parseFloat(this.value) <= parseFloat(params["value"]);
            return result
        },
        min: function(params) {
            var result = true;
            if (shouldValidate(this, params)) result = parseFloat(this.value) >= parseFloat(params["value"]);
            return result
        },
        range: function(params) {
            var result = true;
            if (shouldValidate(this, params)) result = this.value.replace(/\s/g, "") != "" && parseFloat(this.value) <= parseFloat(params["max"]) &&
                parseFloat(this.value) >= parseFloat(params["min"]);
            return result
        },
        notBlank: function(params) {
            if (this.value == null) return false;
            if (typeof this.value !== "string") return true;
            return this.value.replace(/\s/g, "") != ""
        },
        blank: function(params) {
            if (this.value == null) return true;
            if (typeof this.value !== "string") return false;
            return this.value.replace(/\s/g, "") === ""
        },
        matches: function(params) {
            var result = true;
            if (shouldValidate(this, params)) {
                var re;
                var regex;
                if (typeof params["regex"] === "string") regex = params["regex"].replace(/^\//,
                    "").replace(/\/$/, "");
                else regex = params["regex"];
                if (typeof params["flags"] !== "undefined") re = new XRegExp(regex.toString().replace(/^\//, "").replace(/\/[^\/]*$/, ""), params["flags"]);
                else re = new XRegExp(regex);
                result = re.test(this.value)
            }
            return result
        },
        email: function(params) {
            var result = true;
            if (shouldValidate(this, params)) result = /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(this.value);
            return result
        },
        alpha: function(params) {
            var result =
                true;
            if (shouldValidate(this, params)) result = /^[A-Za-z]+$/.test(this.value);
            return result
        },
        numeric: function(params) {
            var result = true;
            if (shouldValidate(this, params)) result = /^[0-9]+$/.test(this.value);
            return result
        },
        integer: function(params) {
            var result = true;
            if (shouldValidate(this, params)) result = /^-?[0-9]+$/.test(this.value);
            return result
        },
        real: function(params) {
            var result = true;
            if (shouldValidate(this, params)) result = /^-?([0-9]+(\.[0-9]+)?|\.[0-9]+)$/.test(this.value);
            return result
        },
        alphaNumeric: function(params) {
            var result =
                true;
            if (shouldValidate(this, params)) result = /^[0-9A-Za-z]+$/.test(this.value);
            return result
        },
        completelyFilled: function(params) {
            var unfilledElements = [];
            for (var i = 0; i < this.elements.length; i++) {
                var element = this.elements[i];
                if (!Validator.required.call(element)) unfilledElements.push(element)
            }
            return unfilledElements
        },
        passwordsMatch: function(params) {
            var failingElements = [];
            var passwordField1 = document.getElementById(params["field1"]);
            var passwordField2 = document.getElementById(params["field2"]);
            if (passwordField1.value !=
                passwordField2.value) failingElements = [passwordField1, passwordField2];
            return failingElements
        },
        required: function(params) {
            var result = true;
            if (this.tagName)
                if (this.tagName.toLowerCase() === "select") result = Validator.selected.call(this);
                else if (this.type.toLowerCase() === "checkbox" || this.type.toLowerCase() === "radio") result = Validator.checked.call(this);
            else if (this.tagName.toLowerCase() === "input" || this.tagName.toLowerCase() === "textarea")
                if (this.type.toLowerCase() != "button") result = Validator.notBlank.call(this);
            return result
        },
        length: function(params) {
            var result = true;
            if (shouldValidate(this, params)) {
                var length = this.value ? this.value.length : 0;
                result = length >= params["min"] && length <= params["max"]
            }
            return result
        },
        digits: function(params) {
            var result = true;
            if (shouldValidate(this, params)) {
                this.value = this.value ? this.value.toString() : "";
                var value = this.value.replace(/\s/g, "");
                var parts = null;
                if (value.indexOf(",") >= 0) parts = value.split(/,/);
                else parts = value.split(/\./);
                var error = false;
                for (var i = 0; i < parts.length; i++) {
                    error = parts[i].match(/^[0-9]+$/) ==
                        null;
                    if (error) break
                }
                result = false;
                if (!error && value.length > 0) {
                    if (parts.length == 1) parts[1] = "";
                    if (params["integer"] > 0) result = parts[0].length <= params["integer"];
                    else result = true;
                    if (params["fraction"] > 0) result = result && parts[1].length <= params["fraction"]
                }
            }
            return result
        },
        past: function(params) {
            var result = true;
            if (shouldValidate(this, params)) {
                var dates = parseDates.call(this, params);
                if (dates != null) result = dates.dateToValidate < dates.dateToTestAgainst
            }
            return result
        },
        future: function(params) {
            var result = true;
            if (shouldValidate(this,
                    params)) {
                var dates = parseDates.call(this, params);
                if (dates != null) result = dates.dateToValidate > dates.dateToTestAgainst
            }
            return result
        },
        url: function(params) {
            var result = true;
            if (shouldValidate(this, params)) result = /^([a-z]([a-z]|\d|\+|-|\.)*):(\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?((\[(|(v[\da-f]{1,}\.(([a-z]|\d|-|\.|_|~)|[!\$&'\(\)\*\+,;=]|:)+))\])|((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=])*)(:\d*)?)(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*|(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)|((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)|((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)){0})(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(this.value);
            return result
        },
        step: function(params) {
            var result = true;
            if (shouldValidate(this, params)) {
                var value = parseFloat(this.value);
                var max = parseFloat(params["max"]);
                var min = parseFloat(params["min"]);
                var step = parseFloat(params["value"]);
                result = value <= max && value >= min && value % step === 0
            }
            return result
        },
        html5Required: function(params) {
            return !this.validity.valueMissing
        },
        html5Email: html5TypeValidator,
        html5URL: html5TypeValidator,
        html5Number: html5TypeValidator,
        html5DateTime: html5TypeValidator,
        html5DateTimeLocal: html5TypeValidator,
        html5Date: html5TypeValidator,
        html5Month: html5TypeValidator,
        html5Time: html5TypeValidator,
        html5Week: html5TypeValidator,
        html5Range: html5TypeValidator,
        html5Tel: html5TypeValidator,
        html5Color: html5TypeValidator,
        html5Pattern: function(params) {
            return !this.validity.patternMismatch
        },
        html5MaxLength: function(params) {
            return !this.validity.tooLong
        },
        html5Min: function(params) {
            return !this.validity.rangeUnderflow
        },
        html5Max: function(params) {
            return !this.validity.rangeOverflow
        },
        html5Step: function(params) {
            return !this.validity.stepMismatch
        }
    };

    function createPublicValidator(constraintName, constraintDefinitions) {
        var constraintDefinition = constraintDefinitions[constraintName];
        var lowerCasedConstraintName = constraintName.replace(/(^[A-Z]+)/, function(group) {
            return group.toLowerCase()
        });
        if (constraintDefinition.async) publicValidator[lowerCasedConstraintName] = function(element, params, callback) {
            if (typeof callback === "undefined") throw new ExceptionService.Exception.IllegalArgumentException(constraintName + " is an asynchronous constraint, but you have not provided a callback.");
            return constraintDefinition.validator.call(element, params, publicValidator, callback)
        };
        else publicValidator[lowerCasedConstraintName] = function(element, params) {
            return constraintDefinition.validator.call(element, params, publicValidator)
        }
    }

    function compoundValidator(params, currentGroup, compoundConstraint, callback) {
        function mergeParams(composingConstraintParams, compoundConstraintParams) {
            var mergedParams = {};
            for (var paramName in composingConstraintParams)
                if (composingConstraintParams.hasOwnProperty(paramName) &&
                    paramName != "__size__") MapUtils.put(mergedParams, paramName, composingConstraintParams[paramName]);
            if (compoundConstraintParams.length > 0)
                for (var paramName in params)
                    if (params.hasOwnProperty(paramName) && paramName != "__size__") MapUtils.put(mergedParams, paramName, params[paramName]);
            return mergedParams
        }

        function processValidationResult(validationResult, id, currentGroup, mergedParams) {
            var constraintName = ReverseConstraint[composingConstraint.constraintType];
            var errorMessage = interpolateConstraintDefaultMessage(id,
                constraintName, mergedParams);
            var constraintViolation = {
                group: currentGroup,
                constraintName: validationResult.constraintName,
                custom: constraintDefinitions[constraintName].custom,
                compound: constraintDefinitions[constraintName].compound,
                async: constraintDefinitions[constraintName].async,
                constraintParameters: composingConstraint.params,
                failingElements: validationResult.failingElements,
                message: errorMessage
            };
            if (!compoundConstraint.reportAsSingleViolation) constraintViolation.composingConstraintViolations = validationResult.composingConstraintViolations || [];
            return constraintViolation
        }
        var synchronousComposingConstraints = [];
        var asynchronousComposingConstraints = [];
        for (var i = 0; i < compoundConstraint.composingConstraints.length; i++) {
            var constraint = compoundConstraint.composingConstraints[i];
            var constraintName = ReverseConstraint[constraint.constraintType];
            if (constraintDefinitions[constraintName].async) asynchronousComposingConstraints.push(constraint);
            else synchronousComposingConstraints.push(constraint)
        }
        var constraintViolations = null;
        var _this = this;
        if (shouldValidate(this,
                params)) {
            if (synchronousComposingConstraints.length > 0) {
                constraintViolations = [];
                for (var i = 0; i < synchronousComposingConstraints.length; i++) {
                    var composingConstraint = synchronousComposingConstraints[i];
                    var composingConstraintName = ReverseConstraint[composingConstraint.constraintType];
                    var mergedParams = mergeParams(composingConstraint.params, compoundConstraint.params);
                    var validationResult = runValidatorFor(currentGroup, _this.id, composingConstraintName, mergedParams);
                    if (!validationResult.constraintPassed) {
                        var constraintViolation =
                            processValidationResult(validationResult, _this.id, currentGroup, mergedParams);
                        if (config.enableHTML5Validation)
                            for (var j = 0; j < validationResult.failingElements.length; j++) validationResult.failingElements[j].setCustomValidity(constraintViolation.message);
                        constraintViolations.push(constraintViolation)
                    }
                }
            }
            if (asynchronousComposingConstraints.length > 0) {
                if (constraintViolations === null) constraintViolations = [];
                var numberConstraintsValidated = 0;
                for (var i = 0; i < asynchronousComposingConstraints.length; i++) {
                    var composingConstraint =
                        asynchronousComposingConstraints[i];
                    var composingConstraintName = ReverseConstraint[composingConstraint.constraintType];
                    var mergedParams = mergeParams(composingConstraint.params, compoundConstraint.params);
                    asynchronouslyRunValidatorFor(currentGroup, _this.id, composingConstraintName, mergedParams, validationHandler)
                }

                function validationHandler(validationResult) {
                    if (!validationResult.constraintPassed) {
                        var constraintViolation = processValidationResult(validationResult, _this.id, currentGroup, mergedParams);
                        if (config.enableHTML5Validation)
                            for (var j =
                                    0; j < validationResult.failingElements.length; j++) validationResult.failingElements[j].setCustomValidity(constraintViolation.message);
                        constraintViolations.push(constraintViolation)
                    }
                    numberConstraintsValidated++;
                    if (numberConstraintsValidated === asynchronousComposingConstraints.length) callback(constraintViolations)
                }
            }
        } else constraintViolations = [];
        return constraintViolations
    }

    function shouldValidate(element, params) {
        var validateEmptyFields = config.validateEmptyFields;
        if (typeof params["ignoreEmpty"] !== "undefined") validateEmptyFields = !params["ignoreEmpty"];
        return !(Validator.blank.call(element) && !validateEmptyFields)
    }

    function parseDates(params) {
        var DateFormatIndices = {
            YMD: {
                Year: 0,
                Month: 1,
                Day: 2
            },
            MDY: {
                Month: 0,
                Day: 1,
                Year: 2
            },
            DMY: {
                Day: 0,
                Month: 1,
                Year: 2
            }
        };
        if (this.value == null) return null;
        var dateFormatIndices = DateFormatIndices[params["format"]];
        var separator = params["separator"];
        if (typeof params["separator"] === "undefined") separator = /\//.test(this.value) ? "/" : /\./.test(this.value) ? "." : / /.test(this.value) ? " " : /[^0-9]+/;
        var parts = this.value.split(separator);
        var dateToValidate = new Date(parts[dateFormatIndices.Year], parts[dateFormatIndices.Month] - 1, parts[dateFormatIndices.Day]);
        var dateToTestAgainst = new Date;
        if (typeof params["date"] !== "undefined") {
            parts = params["date"].split(separator);
            dateToTestAgainst = new Date(parts[dateFormatIndices.Year], parts[dateFormatIndices.Month] - 1, parts[dateFormatIndices.Day])
        }
        return {
            dateToValidate: dateToValidate,
            dateToTestAgainst: dateToTestAgainst
        }
    }

    function wrapValidatorWithEmptyCheck(validatorFunction) {
        return function(params,
            validator, callback) {
            var result = true;
            if (shouldValidate(this, params)) result = validatorFunction.call(this, params, validator, callback);
            return result
        }
    }

    function html5TypeValidator() {
        return !this.validity.typeMismatch
    }

    function validate(options) {
        processedConstraints = {};
        processedRadioGroups = {};

        function generateKey(options) {
            var groups = options.groups || null;
            var elementId = options.elementIds || null;
            var constraintType = (typeof options.constraintType === "undefined" ? null : options.constraintType) || null;
            var key = "";
            key += groups ==
                null ? "0" : "1";
            key += elementId == null ? "0" : "1";
            key += constraintType == null ? "0" : "1";
            return key
        }
        var functionTable = {
            "000": validateAll,
            "001": validateConstraint,
            "010": validateElements,
            "011": validateElementsWithConstraint,
            100: validateGroups,
            101: validateGroupsWithConstraint,
            110: validateGroupsWithElements,
            111: validateGroupsElementsWithConstraint
        };
        if (!options || typeof options === "undefined") options = {};
        if (typeof options.independent === "undefined") options.independent = true;
        if (typeof options.constraintType !== "undefined") options.constraintType =
            ReverseConstraint[options.constraintType];
        if (typeof options.groups !== "undefined") {
            var groups = options.groups;
            options.groups = [];
            for (var i = 0; i < groups.length; i++) options.groups.push(GroupService.ReverseGroup[groups[i]])
        }
        if (typeof options.elements !== "undefined") {
            options.elementIds = [];
            for (var i = 0; i < options.elements.length; i++) options.elementIds.push(options.elements[i].id)
        } else if (typeof options.elementId !== "undefined") options.elementIds = [options.elementId];
        return functionTable[generateKey(options)](options)
    }

    function validateAll(options) {
        var constraintsToValidate = {
            asyncContexts: [],
            syncContexts: []
        };
        for (var group in boundConstraints)
            if (boundConstraints.hasOwnProperty(group)) {
                var groupElements = boundConstraints[group];
                for (var elementId in groupElements)
                    if (groupElements.hasOwnProperty(elementId))
                        if (!document.querySelector(DOMUtils.getSelector("#" + elementId))) delete groupElements[elementId];
                        else {
                            var elementConstraints = groupElements[elementId];
                            for (var elementConstraint in elementConstraints)
                                if (elementConstraints.hasOwnProperty(elementConstraint)) {
                                    var context =
                                        createConstraintValidationContext(group, elementId, elementConstraint);
                                    if (context.async) constraintsToValidate.asyncContexts.push(context);
                                    else constraintsToValidate.syncContexts.push(context)
                                }
                        }
            }
        constraintsToValidate = removeDuplicateContexts(constraintsToValidate);
        return processConstraintsToValidate(constraintsToValidate, options)
    }

    function validateConstraint(options) {
        var constraintsToValidate = {
            asyncContexts: [],
            syncContexts: []
        };
        for (var group in boundConstraints)
            if (boundConstraints.hasOwnProperty(group)) {
                var groupElements =
                    boundConstraints[group];
                for (var elementId in groupElements)
                    if (groupElements.hasOwnProperty(elementId)) {
                        var elementConstraints = groupElements[elementId];
                        if (elementConstraints[options.constraintType]) {
                            var context = createConstraintValidationContext(group, elementId, options.constraintType);
                            if (context.async) constraintsToValidate.asyncContexts.push(context);
                            else constraintsToValidate.syncContexts.push(context)
                        }
                    }
            }
        constraintsToValidate = removeDuplicateContexts(constraintsToValidate);
        return processConstraintsToValidate(constraintsToValidate,
            options)
    }

    function validateElements(options) {
        var unboundElements = [];
        var constraintsToValidate = {
            asyncContexts: [],
            syncContexts: []
        };
        for (var group in boundConstraints)
            if (boundConstraints.hasOwnProperty(group)) {
                var groupElements = boundConstraints[group];
                for (var i = 0; i < options.elementIds.length; i++) {
                    var elementId = options.elementIds[i];
                    var elementConstraints = groupElements[elementId];
                    if (typeof elementConstraints !== "undefined")
                        for (var elementConstraint in elementConstraints) {
                            if (elementConstraints.hasOwnProperty(elementConstraint)) {
                                var context =
                                    createConstraintValidationContext(group, elementId, elementConstraint);
                                if (context.async) constraintsToValidate.asyncContexts.push(context);
                                else constraintsToValidate.syncContexts.push(context)
                            }
                        } else unboundElements.push(elementId)
                }
            }
        if (unboundElements.length > 0) throw new ExceptionService.Exception.IllegalArgumentException("No constraints have been bound to the specified elements: " + ArrayUtils.explode(unboundElements) + ". " + ExceptionService.explodeParameters(options));
        constraintsToValidate = removeDuplicateContexts(constraintsToValidate);
        return processConstraintsToValidate(constraintsToValidate, options)
    }

    function validateElementsWithConstraint(options) {
        var unboundElements = [];
        var constraintsToValidate = {
            asyncContexts: [],
            syncContexts: []
        };
        for (var group in boundConstraints)
            if (boundConstraints.hasOwnProperty(group)) {
                var groupElements = boundConstraints[group];
                for (var i = 0; i < options.elementIds.length; i++) {
                    var elementId = options.elementIds[i];
                    var elementConstraints = groupElements[elementId];
                    if (typeof elementConstraints !== "undefined") {
                        var context =
                            createConstraintValidationContext(group, elementId, options.constraintType);
                        if (context.async) constraintsToValidate.asyncContexts.push(context);
                        else constraintsToValidate.syncContexts.push(context)
                    } else unboundElements.push(elementId)
                }
            }
        if (unboundElements.length > 0) throw new ExceptionService.Exception.IllegalArgumentException("No constraints have been bound to the specified elements: " + ArrayUtils.explode(unboundElements) + ". " + ExceptionService.explodeParameters(options));
        constraintsToValidate = removeDuplicateContexts(constraintsToValidate);
        return processConstraintsToValidate(constraintsToValidate, options)
    }

    function validateGroups(options) {
        var async = false;
        var constraintsToValidate = {
            groupedContexts: {}
        };
        var i = 0;
        while (i < options.groups.length) {
            var group = options.groups[i];
            var groupElements = boundConstraints[group];
            if (typeof groupElements !== "undefined")
                for (var elementId in groupElements) {
                    if (groupElements.hasOwnProperty(elementId)) {
                        var elementConstraints = groupElements[elementId];
                        for (var elementConstraint in elementConstraints)
                            if (elementConstraints.hasOwnProperty(elementConstraint)) {
                                var context =
                                    createConstraintValidationContext(group, elementId, elementConstraint);
                                if (!constraintsToValidate.groupedContexts[group]) constraintsToValidate.groupedContexts[group] = {
                                    asyncContexts: [],
                                    syncContexts: []
                                };
                                if (context.async) {
                                    async = true;
                                    constraintsToValidate.groupedContexts[group].asyncContexts.push(context)
                                } else constraintsToValidate.groupedContexts[group].syncContexts.push(context)
                            }
                    }
                } else throw new ExceptionService.Exception.IllegalArgumentException("Undefined group in group list. " + ExceptionService.explodeParameters(options));
            i++
        }
        var result = removeDuplicateGroupedContexts(constraintsToValidate);
        options.groups = result.groups;
        constraintsToValidate = result.uniqueConstraintsToValidate;
        return processGroupedConstraintsToValidate(options, constraintsToValidate, async)
    }

    function validateGroupsWithConstraint(options) {
        var async = false;
        var constraintsToValidate = {
            groupedContexts: {}
        };
        var i = 0;
        while (i < options.groups.length) {
            var group = options.groups[i];
            var groupElements = boundConstraints[group];
            if (typeof groupElements !== "undefined") {
                var constraintFound =
                    false;
                for (var elementId in groupElements)
                    if (groupElements.hasOwnProperty(elementId)) {
                        var elementConstraints = groupElements[elementId];
                        if (elementConstraints[options.constraintType]) {
                            constraintFound = true;
                            var context = createConstraintValidationContext(group, elementId, options.constraintType);
                            if (!constraintsToValidate.groupedContexts[group]) constraintsToValidate.groupedContexts[group] = {
                                asyncContexts: [],
                                syncContexts: []
                            };
                            if (context.async) {
                                async = true;
                                constraintsToValidate.groupedContexts[group].asyncContexts.push(context)
                            } else constraintsToValidate.groupedContexts[group].syncContexts.push(context)
                        }
                    }
                if (!constraintFound) throw new ExceptionService.Exception.IllegalArgumentException("Constraint " +
                    options.constraintType + " has not been bound to any element under group " + group + ". " + ExceptionService.explodeParameters(options));
            } else throw new ExceptionService.Exception.IllegalArgumentException("Undefined group in group list. " + ExceptionService.explodeParameters(options));
            i++
        }
        var result = removeDuplicateGroupedContexts(constraintsToValidate);
        options.groups = result.groups;
        constraintsToValidate = result.uniqueConstraintsToValidate;
        return processGroupedConstraintsToValidate(options, constraintsToValidate,
            async)
    }

    function validateGroupsWithElements(options) {
        var notFound = [];
        var unboundElements = [];
        var async = false;
        var constraintsToValidate = {
            groupedContexts: {}
        };
        var i = 0;
        while (i < options.groups.length) {
            var group = options.groups[i];
            var groupElements = boundConstraints[group];
            if (groupElements)
                for (var j = 0; j < options.elementIds.length; j++) {
                    var elementId = options.elementIds[j];
                    var elementConstraints = groupElements[elementId];
                    if (elementConstraints)
                        for (var elementConstraint in elementConstraints) {
                            if (elementConstraints.hasOwnProperty(elementConstraint)) {
                                var context =
                                    createConstraintValidationContext(group, elementId, elementConstraint);
                                if (!constraintsToValidate.groupedContexts[group]) constraintsToValidate.groupedContexts[group] = {
                                    asyncContexts: [],
                                    syncContexts: []
                                };
                                if (context.async) {
                                    async = true;
                                    constraintsToValidate.groupedContexts[group].asyncContexts.push(context)
                                } else constraintsToValidate.groupedContexts[group].syncContexts.push(context)
                            }
                        } else {
                            notFound.push(group);
                            unboundElements.push(elementId)
                        }
                } else throw new ExceptionService.Exception.IllegalArgumentException("Undefined group in group list. " +
                    ExceptionService.explodeParameters(options));
            i++
        }
        if (notFound.length > 0) throw new ExceptionService.Exception.IllegalArgumentException("The following elements: " + ArrayUtils.explode(unboundElements) + " were not found in one or more of the following group(s): [" + ArrayUtils.explode(notFound, ",").replace(/,/g, ", ") + "]. " + ExceptionService.explodeParameters(options));
        var result = removeDuplicateGroupedContexts(constraintsToValidate);
        options.groups = result.groups;
        constraintsToValidate = result.uniqueConstraintsToValidate;
        return processGroupedConstraintsToValidate(options, constraintsToValidate, async)
    }

    function validateGroupsElementsWithConstraint(options) {
        var async = false;
        var constraintsToValidate = {
            groupedContexts: {}
        };
        var i = 0;
        while (i < options.groups.length) {
            var group = options.groups[i];
            for (var j = 0; j < options.elementIds.length; j++) {
                var elementId = options.elementIds[j];
                var context = createConstraintValidationContext(group, elementId, options.constraintType);
                if (!constraintsToValidate.groupedContexts[group]) constraintsToValidate.groupedContexts[group] = {
                    asyncContexts: [],
                    syncContexts: []
                };
                if (context.async) {
                    async = true;
                    constraintsToValidate.groupedContexts[group].asyncContexts.push(context)
                } else constraintsToValidate.groupedContexts[group].syncContexts.push(context)
            }
            i++
        }
        var result = removeDuplicateGroupedContexts(constraintsToValidate);
        options.groups = result.groups;
        constraintsToValidate = result.uniqueConstraintsToValidate;
        return processGroupedConstraintsToValidate(options, constraintsToValidate, async)
    }

    function hasConstraintBeenValidated(context) {
        var validated =
            true;
        if (!processedConstraints[context.elementId]) processedConstraints[context.elementId] = {};
        var element = document.querySelector(DOMUtils.getSelector("#" + context.elementId));
        var name = "";
        if (element.name) name = element.name.replace(/\s/g, "");
        if (typeof element.type !== "undefined" && element.type.toLowerCase() === "radio" && name !== "") {
            if (!processedRadioGroups[name]) processedRadioGroups[name] = {}
        } else processedRadioGroups[name] = {};
        if (!processedConstraints[context.elementId][context.elementConstraint] && !processedRadioGroups[name][context.elementConstraint]) {
            validated =
                false;
            processedConstraints[context.elementId][context.elementConstraint] = true;
            if (typeof element.type !== "undefined" && element.type.toLowerCase() === "radio" && name !== "") processedRadioGroups[name][context.elementConstraint] = true
        }
        return validated
    }

    function removeDuplicateContexts(constraintsToValidate) {
        var uniqueConstraintsToValidate = {
            asyncContexts: [],
            syncContexts: []
        };
        for (var i = 0; i < constraintsToValidate.syncContexts.length; i++) {
            var context = constraintsToValidate.syncContexts[i];
            if (!hasConstraintBeenValidated(context)) uniqueConstraintsToValidate.syncContexts.push(context)
        }
        for (var i =
                0; i < constraintsToValidate.asyncContexts.length; i++) {
            var context = constraintsToValidate.asyncContexts[i];
            if (!hasConstraintBeenValidated(context)) uniqueConstraintsToValidate.asyncContexts.push(context)
        }
        return uniqueConstraintsToValidate
    }

    function removeDuplicateGroupedContexts(constraintsToValidate) {
        var groups = [];
        var uniqueConstraintsToValidate = {
            groupedContexts: {}
        };
        for (var group in constraintsToValidate.groupedContexts)
            if (constraintsToValidate.groupedContexts.hasOwnProperty(group)) {
                for (var i = 0; i < constraintsToValidate.groupedContexts[group].syncContexts.length; i++) {
                    var context =
                        constraintsToValidate.groupedContexts[group].syncContexts[i];
                    if (!hasConstraintBeenValidated(context)) {
                        if (!uniqueConstraintsToValidate.groupedContexts[group]) uniqueConstraintsToValidate.groupedContexts[group] = {
                            asyncContexts: [],
                            syncContexts: []
                        };
                        uniqueConstraintsToValidate.groupedContexts[group].syncContexts.push(context);
                        if (groups.indexOf(group) == -1) groups.push(group)
                    }
                }
                for (var i = 0; i < constraintsToValidate.groupedContexts[group].asyncContexts.length; i++) {
                    var context = constraintsToValidate.groupedContexts[group].asyncContexts[i];
                    if (!hasConstraintBeenValidated(context)) {
                        if (!uniqueConstraintsToValidate.groupedContexts[group]) uniqueConstraintsToValidate.groupedContexts[group] = {
                            asyncContexts: [],
                            syncContexts: []
                        };
                        uniqueConstraintsToValidate.groupedContexts[group].asyncContexts.push(context);
                        if (groups.indexOf(group) == -1) groups.push(group)
                    }
                }
            }
        return {
            groups: groups,
            uniqueConstraintsToValidate: uniqueConstraintsToValidate
        }
    }

    function processConstraintsToValidate(constraintsToValidate, options) {
        var constraintViolations = [];
        if (constraintsToValidate.syncContexts.length >
            0) constraintViolations = validateConstraintContexts(constraintsToValidate);
        if (constraintsToValidate.asyncContexts.length > 0) {
            if (!options.callback) throw new ExceptionService.Exception.IllegalArgumentException("One or more constraints to be validated are asynchronous, but a callback has not been provided.");
            asynchronouslyValidateConstraintContexts(constraintsToValidate, function(asynchronousConstraintViolations) {
                if (constraintViolations.length > 0) constraintViolations = constraintViolations.concat(asynchronousConstraintViolations);
                else constraintViolations = asynchronousConstraintViolations;
                options.callback(constraintViolations)
            })
        } else if (options.callback) options.callback(constraintViolations);
        return constraintViolations
    }

    function processGroupedConstraintsToValidate(options, constraintsToValidate, async) {
        var constraintViolations = validateGroupedConstraintContexts(options.groups, options.independent, constraintsToValidate);
        if (async) {
            if (!options.callback) throw new ExceptionService.Exception.IllegalArgumentException("One or more constraints to be validated are asynchronous, but a callback has not been provided.");
            if (!options.independent)
                if (constraintViolations.length > 0) {
                    var failedGroup = constraintViolations[0].group;
                    var failedGroupContexts = constraintsToValidate.groupedContexts[failedGroup];
                    constraintsToValidate.groupedContexts = {};
                    constraintsToValidate.groupedContexts[failedGroup] = failedGroupContexts
                }
            asynchronouslyValidateGroupedConstraintContexts(options.groups, options.independent, constraintsToValidate, function(asynchronousConstraintViolations) {
                if (constraintViolations.length > 0) constraintViolations = constraintViolations.concat(asynchronousConstraintViolations);
                else constraintViolations = asynchronousConstraintViolations;
                options.callback(constraintViolations)
            })
        } else if (options.callback) options.callback(constraintViolations);
        return constraintViolations
    }

    function createConstraintValidationContext(group, elementId, elementConstraint) {
        var groupElements = boundConstraints[group];
        if (!groupElements) throw new ExceptionService.Exception.IllegalArgumentException("Undefined group in group list (group: " + group + ", elementId: " + elementId + ", constraint: " + elementConstraint + ")");
        var elementConstraints = groupElements[elementId];
        if (!elementConstraints) throw new ExceptionService.Exception.IllegalArgumentException("No constraints have been defined for the element with id: " + elementId + " in group " + group);
        var params = elementConstraints[elementConstraint];
        if (!params) throw new ExceptionService.Exception.IllegalArgumentException("Constraint " + elementConstraint + " in group " + group + " hasn't been bound to the element with id " + elementId);
        return {
            group: group,
            elementId: elementId,
            elementConstraint: elementConstraint,
            params: params,
            async: constraintDefinitions[elementConstraint].async
        }
    }

    function validateConstraintContexts(constraintsToValidate) {
        var constraintViolations = [];
        var i = 0;
        while (i < constraintsToValidate.syncContexts.length) {
            var context = constraintsToValidate.syncContexts[i];
            var constraintViolation = validateGroupElementConstraintCombination(context.group, context.elementId, context.elementConstraint, context.params);
            if (constraintViolation) constraintViolations.push(constraintViolation);
            i++
        }
        return constraintViolations
    }

    function asynchronouslyValidateConstraintContexts(constraintsToValidate, callback) {
        var constraintViolations = [];
        var numContextsProcessed = 0;
        for (var i = 0; i < constraintsToValidate.asyncContexts.length; i++) {
            var context = constraintsToValidate.asyncContexts[i];
            asynchronouslyValidateGroupElementConstraintCombination(context.group, context.elementId, context.elementConstraint, context.params, validationHandler)
        }

        function validationHandler(constraintViolation) {
            numContextsProcessed++;
            if (constraintViolation) constraintViolations.push(constraintViolation);
            if (numContextsProcessed === constraintsToValidate.asyncContexts.length) callback(constraintViolations)
        }
    }

    function validateGroupedConstraintContexts(groups, independent, constraintsToValidate) {
        var constraintViolations = [];
        var i = 0;
        var successful = true;
        while (i < groups.length && successful) {
            var group = groups[i];
            var contexts = constraintsToValidate.groupedContexts[group].syncContexts;
            for (var j = 0; j < contexts.length; j++) {
                var context = contexts[j];
                var constraintViolation = validateGroupElementConstraintCombination(context.group,
                    context.elementId, context.elementConstraint, context.params);
                if (constraintViolation) constraintViolations.push(constraintViolation)
            }
            i++;
            successful = constraintViolations.length == 0 || independent && constraintViolations.length != 0
        }
        return constraintViolations
    }

    function asynchronouslyValidateGroupedConstraintContexts(groups, independent, constraintsToValidate, callback) {
        var constraintViolations = [];
        var successful = true;
        (function validateGroupedContexts(i) {
            if (i < groups.length && successful) {
                var group = groups[i];
                var contexts =
                    constraintsToValidate.groupedContexts[group].asyncContexts;
                var numContextsProcessed = 0;
                for (var j = 0; j < contexts.length; j++) {
                    var context = contexts[j];
                    asynchronouslyValidateGroupElementConstraintCombination(context.group, context.elementId, context.elementConstraint, context.params, validationHandler)
                }

                function validationHandler(constraintViolation) {
                    numContextsProcessed++;
                    if (constraintViolation) constraintViolations.push(constraintViolation);
                    if (numContextsProcessed === contexts.length) {
                        successful = constraintViolations.length ===
                            0 || independent && constraintViolations.length != 0;
                        validateGroupedContexts(++i)
                    }
                }
            } else callback(constraintViolations)
        })(0)
    }

    function validateGroupElementConstraintCombination(group, elementId, elementConstraint, params) {
        var constraintViolation;
        var validationResult = runValidatorFor(group, elementId, elementConstraint, params);
        var errorMessage = "";
        if (!validationResult.constraintPassed) {
            errorMessage = interpolateConstraintDefaultMessage(elementId, elementConstraint, params);
            constraintViolation = {
                group: group,
                constraintName: elementConstraint,
                formSpecific: constraintDefinitions[elementConstraint].formSpecific,
                custom: constraintDefinitions[elementConstraint].custom,
                compound: constraintDefinitions[elementConstraint].compound,
                async: constraintDefinitions[elementConstraint].async,
                composingConstraintViolations: validationResult.composingConstraintViolations || [],
                constraintParameters: params,
                failingElements: validationResult.failingElements,
                message: errorMessage
            }
        }
        if (config.enableHTML5Validation)
            for (var i = 0; i < validationResult.failingElements.length; i++) validationResult.failingElements[i].setCustomValidity("");
        return constraintViolation
    }

    function asynchronouslyValidateGroupElementConstraintCombination(group, elementId, elementConstraint, params, callback) {
        var constraintViolation;
        asynchronouslyRunValidatorFor(group, elementId, elementConstraint, params, function(validationResult) {
            var errorMessage = "";
            if (!validationResult.constraintPassed) {
                errorMessage = interpolateConstraintDefaultMessage(elementId, elementConstraint, params);
                constraintViolation = {
                    group: group,
                    constraintName: elementConstraint,
                    formSpecific: constraintDefinitions[elementConstraint].formSpecific,
                    custom: constraintDefinitions[elementConstraint].custom,
                    compound: constraintDefinitions[elementConstraint].compound,
                    async: constraintDefinitions[elementConstraint].async,
                    composingConstraintViolations: validationResult.composingConstraintViolations || [],
                    constraintParameters: params,
                    failingElements: validationResult.failingElements,
                    message: errorMessage
                }
            }
            if (config.enableHTML5Validation)
                for (var i = 0; i < validationResult.failingElements.length; i++) validationResult.failingElements[i].setCustomValidity("");
            callback(constraintViolation)
        })
    }

    function runValidatorFor(currentGroup, elementId, elementConstraint, params) {
        var constraintPassed = false;
        var failingElements = [];
        var element = document.querySelector(DOMUtils.getSelector("#" + elementId));
        var composingConstraintViolations = [];
        if (constraintDefinitions[elementConstraint].formSpecific) {
            failingElements = constraintDefinitions[elementConstraint].validator.call(element, params, publicValidator);
            constraintPassed = failingElements.length == 0
        } else if (constraintDefinitions[elementConstraint].compound) {
            composingConstraintViolations =
                constraintDefinitions[elementConstraint].validator.call(element, params, currentGroup, constraintDefinitions[elementConstraint], null);
            constraintPassed = composingConstraintViolations.length == 0;
            if (!constraintPassed) failingElements.push(element)
        } else {
            constraintPassed = constraintDefinitions[elementConstraint].validator.call(element, params, publicValidator);
            if (!constraintPassed) failingElements.push(element)
        }
        var name = element.name.replace(/\s/g, "");
        var type = element.type;
        if (typeof type !== "undefined" && type.toLowerCase() ===
            "radio" && name !== "") failingElements = DOMUtils.getElementsByAttribute(document.body, "input", "name", name.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"));
        var validationResult = {
            constraintName: elementConstraint,
            constraintPassed: constraintPassed,
            failingElements: failingElements
        };
        if (!constraintDefinitions[elementConstraint].reportAsSingleViolation) validationResult.composingConstraintViolations = composingConstraintViolations;
        return validationResult
    }

    function asynchronouslyRunValidatorFor(currentGroup, elementId,
        elementConstraint, params, callback) {
        var element = document.querySelector(DOMUtils.getSelector("#" + elementId));
        if (constraintDefinitions[elementConstraint].formSpecific) constraintDefinitions[elementConstraint].validator.call(element, params, publicValidator, function(failingElements) {
            processValidationResult(failingElements.length === 0, null, failingElements, callback)
        });
        else if (constraintDefinitions[elementConstraint].compound) constraintDefinitions[elementConstraint].validator.call(element, params, currentGroup,
            constraintDefinitions[elementConstraint],
            function(composingConstraintViolations) {
                var failingElements = [];
                var constraintPassed = composingConstraintViolations.length === 0;
                if (!constraintPassed) failingElements.push(element);
                processValidationResult(constraintPassed, composingConstraintViolations, failingElements, callback)
            });
        else constraintDefinitions[elementConstraint].validator.call(element, params, publicValidator, function(constraintPassed) {
            var failingElements = [];
            if (!constraintPassed) failingElements.push(element);
            processValidationResult(constraintPassed, null, failingElements, callback)
        });

        function processValidationResult(constraintPassed, composingConstraintViolations, failingElements, callback) {
            var name = element.name.replace(/\s/g, "");
            var type = element.type;
            if (typeof type !== "undefined" && type.toLowerCase() === "radio" && name !== "") failingElements = DOMUtils.getElementsByAttribute(document.body, "input", "name", name);
            var validationResult = {
                constraintName: elementConstraint,
                constraintPassed: constraintPassed,
                failingElements: failingElements
            };
            if (!constraintDefinitions[elementConstraint].reportAsSingleViolation) validationResult.composingConstraintViolations = composingConstraintViolations;
            callback(validationResult)
        }
    }

    function interpolateConstraintDefaultMessage(elementId, elementConstraint, params) {
        var element = document.querySelector(DOMUtils.getSelector("#" + elementId));
        var errorMessage = "";
        if (params["message"]) errorMessage = params["message"];
        else if (params["msg"]) errorMessage = params["msg"];
        else errorMessage = constraintDefinitions[elementConstraint].defaultMessage;
        for (var param in params)
            if (params.hasOwnProperty(param)) {
                var re = new XRegExp("{" + param + "}", "g");
                errorMessage = errorMessage.replace(re, params[param])
            }
        if (constraintDefinitions[elementConstraint].compound && typeof constraintDefinitions[elementConstraint].composingConstraints !== "undefined")
            for (var i = 0; i < constraintDefinitions[elementConstraint].composingConstraints.length; i++) {
                var composingConstraint = constraintDefinitions[elementConstraint].composingConstraints[i];
                for (var param in composingConstraint.params)
                    if (composingConstraint.params.hasOwnProperty(param)) {
                        var re =
                            new XRegExp("{" + param + "}", "g");
                        errorMessage = errorMessage.replace(re, composingConstraint.params[param])
                    }
            }
        if (/{label}/.test(errorMessage)) {
            var friendlyInputName = DOMUtils.friendlyInputNames[element.tagName.toLowerCase()];
            if (!friendlyInputName) friendlyInputName = DOMUtils.friendlyInputNames[element.type.toLowerCase()];
            errorMessage = errorMessage.replace(/{label}/, friendlyInputName);
            errorMessage = errorMessage.replace(/{flags}/g, "")
        }
        errorMessage = errorMessage.replace(/\\\"/g, '"');
        return errorMessage
    }
    return {
        Validator: Validator,
        init: init,
        wrapValidatorWithEmptyCheck: wrapValidatorWithEmptyCheck,
        initializePublicValidators: initializePublicValidators,
        compoundValidator: compoundValidator,
        validate: validate,
        runValidatorFor: runValidatorFor,
        interpolateConstraintDefaultMessage: interpolateConstraintDefaultMessage,
        createPublicValidator: createPublicValidator
    }
});
(function(root, factory) {
    if (typeof define === "function" && define.amd) define("domain/CompositionGraph", factory);
    else {
        if (typeof root.regulaModules === "undefined") root.regulaModules = {};
        root.regulaModules.CompositionGraph = factory()
    }
}(this, function() {
    var typeToNodeMap = {};
    var root = {
        visited: false,
        name: "RootNode",
        type: -1,
        parents: [],
        children: []
    };

    function addNode(options) {
        var type = options.type;
        var name = options.name;
        var parent = options.parent;
        var newNode = typeof typeToNodeMap[type] === "undefined" ? {
            visited: false,
            name: name,
            type: type,
            parents: [],
            children: []
        } : typeToNodeMap[type];
        if (parent == null) root.children.push(newNode);
        else {
            parent.children.push(newNode);
            newNode.parents.push(parent)
        }
        typeToNodeMap[type] = newNode
    }

    function clone() {
        var clonedTypeToNodeMap = {};
        var clonedRoot = function _clone(node, parent) {
            var cloned = typeof clonedTypeToNodeMap[node.type] === "undefined" ? {
                visited: node.visited,
                name: node.name,
                type: node.type,
                parents: [],
                children: []
            } : clonedTypeToNodeMap[node.type];
            if (parent !== null) cloned.parents.push(parent);
            for (var i =
                    0; i < node.children.length; i++) cloned.children.push(_clone(node.children[i], cloned));
            clonedTypeToNodeMap[node.type] = cloned;
            return cloned
        }(root, null);
        return {
            typeToNodeMap: clonedTypeToNodeMap,
            root: clonedRoot
        }
    }

    function getNodeByType(type) {
        var node = typeToNodeMap[type];
        return typeof node === "undefined" ? null : node
    }

    function analyze(startNode) {
        var result = function traverse(node, path) {
            var result = {
                cycle: false,
                path: path
            };
            if (node.visited) result.cycle = true;
            else {
                node.visited = true;
                var i = 0;
                while (i < node.children.length &&
                    !result.cycle) {
                    result = traverse(node.children[i], path + "." + node.children[i].name);
                    i++
                }
            }
            return result
        }(startNode, startNode.name);
        if (!result.cycle) clearVisited();
        return result
    }

    function clearVisited() {
        (function clear(node) {
            node.visited = false;
            for (var i = 0; i < node.children.length; i++) clear(node.children[i])
        })(root)
    }

    function getRoot() {
        return root
    }

    function setRoot(newRoot) {
        root = newRoot
    }

    function initializeFromClone(clone) {
        typeToNodeMap = clone.typeToNodeMap;
        root = clone.root
    }
    return {
        ROOT: -1,
        addNode: addNode,
        getNodeByType: getNodeByType,
        analyze: analyze,
        getRoot: getRoot,
        setRoot: setRoot,
        clone: clone,
        initializeFromClone: initializeFromClone
    }
}));
(function(root, factory) {
    if (typeof define === "function" && define.amd) define("service/ConstraintService", ["service/ValidationService", "domain/CompositionGraph", "service/ExceptionService", "utils/MapUtils", "utils/ArrayUtils"], factory);
    else {
        if (typeof root.regulaModules === "undefined") root.regulaModules = {};
        root.regulaModules.ConstraintService = factory(root.regulaModules.ValidationService, root.regulaModules.CompositionGraph, root.regulaModules.ExceptionService, root.regulaModules.MapUtils, root.regulaModules.ArrayUtils)
    }
})(this,
    function(ValidationService, CompositionGraph, ExceptionService, MapUtils, ArrayUtils) {
        var Constraint = {};
        var ReverseConstraint = {};
        var firstCustomConstraintIndex = 0;
        (function(constraints) {
            for (var i = 0; i < constraints.length; i++) {
                Constraint[constraints[i]] = i;
                ReverseConstraint[i] = constraints[i]
            }
            firstCustomConstraintIndex = i;
            Constraint["Between"] = Constraint.Range;
            Constraint["Matches"] = Constraint.Pattern;
            Constraint["Empty"] = Constraint.Blank;
            Constraint["NotEmpty"] = Constraint.NotBlank;
            Constraint["IsAlpha"] = Constraint.Alpha;
            Constraint["IsNumeric"] = Constraint.Numeric;
            Constraint["IsAlphaNumeric"] = Constraint.AlphaNumeric
        })(["Checked", "Selected", "Max", "Min", "Range", "Between", "NotBlank", "NotEmpty", "Blank", "Empty", "Pattern", "Matches", "Email", "Alpha", "IsAlpha", "Numeric", "IsNumeric", "AlphaNumeric", "IsAlphaNumeric", "Integer", "Real", "CompletelyFilled", "PasswordsMatch", "Required", "Length", "Digits", "Past", "Future", "Step", "URL", "HTML5Required", "HTML5Email", "HTML5URL", "HTML5MaxLength", "HTML5Pattern", "HTML5Min", "HTML5Max", "HTML5Step"]);
        var constraintDefinitions = {
            Checked: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.checked,
                constraintType: Constraint.Checked,
                custom: false,
                compound: false,
                params: [],
                defaultMessage: "{label} needs to be checked."
            },
            Selected: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.selected,
                constraintType: Constraint.Selected,
                custom: false,
                compound: false,
                params: [],
                defaultMessage: "{label} needs to be selected."
            },
            Max: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.max,
                constraintType: Constraint.Max,
                custom: false,
                compound: false,
                params: ["value"],
                defaultMessage: "{label} needs to be lesser than or equal to {value}."
            },
            Min: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.min,
                constraintType: Constraint.Min,
                custom: false,
                compound: false,
                params: ["value"],
                defaultMessage: "{label} needs to be greater than or equal to {value}."
            },
            Range: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.range,
                constraintType: Constraint.Range,
                custom: false,
                compound: false,
                params: ["min", "max"],
                defaultMessage: "{label} needs to be between {min} and {max}."
            },
            NotBlank: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.notBlank,
                constraintType: Constraint.NotBlank,
                custom: false,
                compound: false,
                params: [],
                defaultMessage: "{label} cannot be blank."
            },
            Blank: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.blank,
                constraintType: Constraint.Blank,
                custom: false,
                compound: false,
                params: [],
                defaultMessage: "{label} needs to be blank."
            },
            Pattern: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.matches,
                constraintType: Constraint.Pattern,
                custom: false,
                compound: false,
                params: ["regex"],
                defaultMessage: "{label} needs to match {regex}{flags}."
            },
            Email: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.email,
                constraintType: Constraint.Email,
                custom: false,
                compound: false,
                params: [],
                defaultMessage: "{label} is not a valid email."
            },
            Alpha: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.alpha,
                constraintType: Constraint.Alpha,
                custom: false,
                compound: false,
                params: [],
                defaultMessage: "{label} can only contain letters."
            },
            Numeric: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.numeric,
                constraintType: Constraint.Numeric,
                custom: false,
                compound: false,
                params: [],
                defaultMessage: "{label} can only contain numbers."
            },
            AlphaNumeric: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.alphaNumeric,
                constraintType: Constraint.AlphaNumeric,
                custom: false,
                compound: false,
                params: [],
                defaultMessage: "{label} can only contain numbers and letters."
            },
            Integer: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.integer,
                constraintType: Constraint.Integer,
                custom: false,
                compound: false,
                params: [],
                defaultMessage: "{label} must be an integer."
            },
            Real: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.real,
                constraintType: Constraint.Real,
                custom: false,
                compound: false,
                params: [],
                defaultMessage: "{label} must be a real number."
            },
            CompletelyFilled: {
                async: false,
                html5: false,
                formSpecific: true,
                validator: ValidationService.Validator.completelyFilled,
                constraintType: Constraint.CompletelyFilled,
                custom: false,
                compound: false,
                params: [],
                defaultMessage: "{label} must be completely filled."
            },
            PasswordsMatch: {
                async: false,
                html5: false,
                formSpecific: true,
                validator: ValidationService.Validator.passwordsMatch,
                constraintType: Constraint.PasswordsMatch,
                custom: false,
                compound: false,
                params: ["field1",
                    "field2"
                ],
                defaultMessage: "Passwords do not match."
            },
            Required: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.required,
                constraintType: Constraint.Required,
                custom: false,
                compound: false,
                params: [],
                defaultMessage: "{label} is required."
            },
            Length: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.length,
                constraintType: Constraint.Length,
                custom: false,
                compound: false,
                params: ["min", "max"],
                defaultMessage: "{label} length must be between {min} and {max}."
            },
            Digits: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.digits,
                constraintType: Constraint.Digits,
                custom: false,
                compound: false,
                params: ["integer", "fraction"],
                defaultMessage: "{label} must have up to {integer} digits and {fraction} fractional digits."
            },
            Past: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.past,
                constraintType: Constraint.Past,
                custom: false,
                compound: false,
                params: ["format"],
                defaultMessage: "{label} must be in the past."
            },
            Future: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.future,
                constraintType: Constraint.Future,
                custom: false,
                compound: false,
                params: ["format"],
                defaultMessage: "{label} must be in the future."
            },
            Step: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.step,
                constraintType: Constraint.Step,
                custom: false,
                compound: false,
                params: ["min", "max", "value"],
                defaultMessage: "{label} must be equal to {min} or greater, and equal to {max} or lesser, at increments of {value}."
            },
            URL: {
                async: false,
                html5: false,
                formSpecific: false,
                validator: ValidationService.Validator.url,
                constraintType: Constraint.URL,
                custom: false,
                compound: false,
                params: [],
                defaultMessage: "{label} must be a valid URL."
            },
            HTML5Required: {
                async: false,
                html5: true,
                inputType: null,
                attribute: "required",
                formSpecific: false,
                validator: ValidationService.Validator.html5Required,
                constraintType: Constraint.HTML5Required,
                custom: false,
                compound: false,
                params: [],
                defaultMessage: "{label} is required."
            },
            HTML5Email: {
                async: false,
                html5: true,
                inputType: "email",
                attribute: null,
                formSpecific: false,
                validator: ValidationService.Validator.html5Email,
                constraintType: Constraint.HTML5Email,
                custom: false,
                compound: false,
                params: [],
                defaultMessage: "{label} is not a valid email."
            },
            HTML5Pattern: {
                async: false,
                html5: true,
                inputType: null,
                attribute: "pattern",
                formSpecific: false,
                validator: ValidationService.Validator.html5Pattern,
                constraintType: Constraint.HTML5Pattern,
                custom: false,
                compound: false,
                params: ["pattern"],
                defaultMessage: "{label} needs to match {pattern}."
            },
            HTML5URL: {
                async: false,
                html5: true,
                inputType: "url",
                attribute: null,
                formSpecific: false,
                validator: ValidationService.Validator.html5URL,
                constraintType: Constraint.HTML5URL,
                custom: false,
                compound: false,
                params: [],
                defaultMessage: "{label} is not a valid URL."
            },
            HTML5MaxLength: {
                async: false,
                html5: true,
                inputType: null,
                attribute: "maxlength",
                formSpecific: false,
                validator: ValidationService.Validator.html5MaxLength,
                constraintType: Constraint.HTML5MaxLength,
                custom: false,
                compound: false,
                params: ["maxlength"],
                defaultMessage: "{label} must be less than {maxlength} characters."
            },
            HTML5Min: {
                async: false,
                html5: true,
                inputType: null,
                attribute: "min",
                formSpecific: false,
                validator: ValidationService.Validator.html5Min,
                constraintType: Constraint.HTML5Min,
                custom: false,
                compound: false,
                params: ["min"],
                defaultMessage: "{label} needs to be greater than or equal to {min}."
            },
            HTML5Max: {
                async: false,
                html5: true,
                inputType: null,
                attribute: "max",
                formSpecific: false,
                validator: ValidationService.Validator.html5Max,
                constraintType: Constraint.HTML5Max,
                custom: false,
                compound: false,
                params: ["max"],
                defaultMessage: "{label} needs to be lesser than or equal to {max}."
            },
            HTML5Step: {
                async: false,
                html5: true,
                inputType: null,
                attribute: "step",
                formSpecific: false,
                validator: ValidationService.Validator.html5Step,
                constraintType: Constraint.HTML5Step,
                custom: false,
                compound: false,
                params: ["step"],
                defaultMessage: "{label} must be equal to the minimum value or greater at increments of {step}."
            }
        };

        function override(options) {
            var async = typeof options.async === "undefined" ? constraintDefinitions[options.name].async : options.async;
            var validator = options.validator;
            if (options.validatorRedefined &&
                !options.formSpecific) validator = ValidationService.wrapValidatorWithEmptyCheck(validator);
            var graphNode = CompositionGraph.getNodeByType(options.constraintType);
            if (options.compound) {
                verifyComposingConstraints(options.name, options.composingConstraints, options.params);
                var clone = CompositionGraph.clone();
                updateCompositionGraph(options.name, options.composingConstraints);
                var result = CompositionGraph.analyze(graphNode);
                if (result.cycle) {
                    CompositionGraph.initializeFromClone(clone);
                    throw new ExceptionService.Exception.ConstraintDefinitionException("regula.override: The overriding composing-constraints you have specified have created a cyclic composition: " +
                        result.path);
                }
                async = false;
                var i = 0;
                while (i < options.composingConstraints.length && !async) {
                    var composingConstraint = options.composingConstraints[i];
                    var constraintDefinition = constraintDefinitions[ReverseConstraint[composingConstraint.constraintType]];
                    async = constraintDefinition.async;
                    i++
                }
            }
            if (graphNode !== null)(function propagateAsync(node) {
                for (var i = 0; i < node.parents.length; i++) {
                    var parent = node.parents[i];
                    if (parent.type !== CompositionGraph.ROOT) {
                        var constraintName = ReverseConstraint[parent.type];
                        var constraintDefinition =
                            constraintDefinitions[constraintName];
                        constraintDefinition.async = async;
                        propagateAsync(parent)
                    }
                }
            })(graphNode);
            constraintDefinitions[options.name] = {
                async: async,
                formSpecific: options.formSpecific,
                constraintType: Constraint[options.name],
                custom: true,
                compound: options.compound,
                params: options.params,
                composingConstraints: options.composingConstraints,
                defaultMessage: options.defaultMessage,
                validator: validator
            };
            if (constraintDefinitions[options.name].custom && options.validatorRedefined) ValidationService.createPublicValidator(options.name,
                constraintDefinitions)
        }

        function custom(options) {
            Constraint[options.name] = firstCustomConstraintIndex;
            ReverseConstraint[firstCustomConstraintIndex++] = options.name;
            var validator = options.validator;
            if (!options.formSpecific) validator = ValidationService.wrapValidatorWithEmptyCheck(options.validator);
            constraintDefinitions[options.name] = {
                async: options.async,
                formSpecific: options.formSpecific,
                validator: validator,
                constraintType: Constraint[options.name],
                custom: true,
                compound: false,
                params: options.params,
                defaultMessage: options.defaultMessage
            };
            ValidationService.createPublicValidator(options.name, constraintDefinitions)
        }

        function compound(options) {
            verifyComposingConstraints(options.name, options.constraints, options.params);
            var async = false;
            var i = 0;
            while (i < options.constraints.length && !async) {
                var constraint = options.constraints[i];
                var constraintName = ReverseConstraint[constraint.constraintType];
                async = async || constraintDefinitions[constraintName].async;
                i++
            }
            Constraint[options.name] = firstCustomConstraintIndex;
            ReverseConstraint[firstCustomConstraintIndex++] =
                options.name;
            constraintDefinitions[options.name] = {
                async: async,
                formSpecific: options.formSpecific,
                constraintType: Constraint[options.name],
                custom: true,
                compound: true,
                params: options.params,
                reportAsSingleViolation: options.reportAsSingleViolation,
                composingConstraints: options.constraints,
                defaultMessage: options.defaultMessage,
                validator: ValidationService.compoundValidator
            };
            ValidationService.createPublicValidator(options.name, constraintDefinitions);
            updateCompositionGraph(options.name, options.constraints)
        }

        function verifyConstraintDefinition(element,
            constraintName, definedParameters) {
            var result = {
                successful: true,
                message: "",
                data: null
            };
            var clonedElement = element;
            if (clonedElement.tagName.toLowerCase() == "form" && !constraintDefinitions[constraintName].formSpecific) result = {
                successful: false,
                message: ExceptionService.generateExceptionMessage(element, constraintName, "@" + constraintName + " is not a form constraint, but you are trying to bind it to a form"),
                data: null
            };
            else if (clonedElement.tagName.toLowerCase() != "form" && constraintDefinitions[constraintName].formSpecific) result = {
                successful: false,
                message: ExceptionService.generateExceptionMessage(element, constraintName, "@" + constraintName + " is a form constraint, but you are trying to bind it to a non-form element"),
                data: null
            };
            else if ((typeof clonedElement.type === "undefined" || clonedElement.type.toLowerCase() != "checkbox" && clonedElement.type.toLowerCase() != "radio") && constraintName == "Checked") result = {
                successful: false,
                message: ExceptionService.generateExceptionMessage(element, constraintName, "@" + constraintName + " is only applicable to checkboxes and radio buttons. You are trying to bind it to an input element that is neither a checkbox nor a radio button."),
                data: null
            };
            else if (clonedElement.tagName.toLowerCase() != "select" && constraintName == "Selected") result = {
                successful: false,
                message: ExceptionService.generateExceptionMessage(element, constraintName, "@" + constraintName + " is only applicable to select boxes. You are trying to bind it to an input element that is not a select box."),
                data: null
            };
            else {
                var parameterResult = verifyParameterCountMatches(element, constraintDefinitions[constraintName], definedParameters);
                if (parameterResult.error) result = {
                    successful: false,
                    message: parameterResult.message,
                    data: null
                };
                else result.data = definedParameters
            }
            return result
        }

        function verifyParameterCountMatches(element, constraint, receivedParameters) {
            var result = {
                error: false,
                message: ""
            };
            if (receivedParameters.__size__ < constraint.params.length) result = {
                error: true,
                message: ExceptionService.generateExceptionMessage(element, ReverseConstraint[constraint.constraintType], "@" + ReverseConstraint[constraint.constraintType] + " expects at least " + constraint.params.length + " parameter(s). However, you have provided only " +
                    receivedParameters.__size__),
                data: null
            };
            var missingParams = [];
            for (var j = 0; j < constraint.params.length; j++) {
                var param = constraint.params[j];
                if (typeof receivedParameters[param] === "undefined") missingParams.push(param)
            }
            if (missingParams.length > 0) result = {
                error: true,
                message: ExceptionService.generateExceptionMessage(element, ReverseConstraint[constraint.constraintType], "You seem to have provided some optional or required parameters for @" + ReverseConstraint[constraint.constraintType] + ", but you are still missing the following " +
                    missingParams.length + " required parameter(s): " + ArrayUtils.explode(missingParams, ", ")),
                data: null
            };
            return result
        }

        function updateCompositionGraph(constraintName, composingConstraints) {
            var graphNode = CompositionGraph.getNodeByType(Constraint[constraintName]);
            if (graphNode == null) {
                CompositionGraph.addNode({
                    type: Constraint[constraintName],
                    name: constraintName,
                    parent: null
                });
                graphNode = CompositionGraph.getNodeByType(Constraint[constraintName])
            }
            for (var i = 0; i < graphNode.children.length; i++) {
                var childNode = graphNode.children[i];
                var parents = [];
                for (var j = 0; j < childNode.parents.length; j++)
                    if (childNode.parents[j] !== graphNode) parents.push(childNode.parents[j]);
                childNode.parents = parents
            }
            graphNode.children = [];
            for (var i = 0; i < composingConstraints.length; i++) {
                var composingConstraintName = ReverseConstraint[composingConstraints[i].constraintType];
                var composingConstraint = constraintDefinitions[composingConstraintName];
                CompositionGraph.addNode({
                    type: composingConstraint.constraintType,
                    name: ReverseConstraint[composingConstraint.constraintType],
                    parent: graphNode
                })
            }
        }

        function verifyComposingConstraints(name, constraints, params) {
            for (var i = 0; i < constraints.length; i++) {
                if (typeof constraints[i].constraintType === "undefined") throw new ExceptionService.Exception.ConstraintDefinitionException("In compound constraint " + name + ": A composing constraint has no constraint type specified.");
                var constraint = constraints[i];
                var constraintName = ReverseConstraint[constraint.constraintType];
                var definedParameters = {
                    __size__: 0
                };
                constraint.params = constraint.params || {};
                for (var paramName in constraint.params)
                    if (constraint.params.hasOwnProperty(paramName)) MapUtils.put(definedParameters, paramName, constraint.params[paramName]);
                var size = 0;
                for (var param in constraint.params)
                    if (constraint.params.hasOwnProperty(param)) size++;
                constraint.params["__size__"] = size;
                for (var j = 0; j < params.length; j++) MapUtils.put(definedParameters, params[j], null);
                var result = verifyParameterCountMatches(null, constraintDefinitions[constraintName], definedParameters);
                if (result.error) throw new ExceptionService.Exception.ConstraintDefinitionException("In compound constraint " +
                    name + ": " + result.message);
            }
        }
        return {
            Constraint: Constraint,
            ReverseConstraint: ReverseConstraint,
            firstCustomConstraintIndex: firstCustomConstraintIndex,
            constraintDefinitions: constraintDefinitions,
            override: override,
            custom: custom,
            compound: compound,
            verifyConstraintDefinition: verifyConstraintDefinition,
            verifyParameterCountMatches: verifyParameterCountMatches
        }
    });
(function(root, factory) {
    if (typeof define === "function" && define.amd) define("parser/Parser", ["utils/MapUtils", "service/ExceptionService", "service/ConstraintService"], factory);
    else {
        if (typeof root.regulaModules === "undefined") root.regulaModules = {};
        root.regulaModules.Parser = factory(root.regulaModules.MapUtils, root.regulaModules.ExceptionService, root.regulaModules.ConstraintService)
    }
}(this, function(MapUtils, ExceptionService, ConstraintService) {
    function trim(str) {
        return str ? str.replace(/^\s+/, "").replace(/\s+$/,
            "") : ""
    }

    function peek(arr) {
        return arr[0]
    }

    function tokenize(options) {
        var str = options.str;
        var delimiters = options.delimiters.split("");
        var returnDelimiters = options.returnDelimiters || false;
        var returnEmptyTokens = options.returnEmptyTokens || false;
        var tokens = [];
        var lastTokenIndex = 0;
        for (var i = 0; i < str.length; i++)
            if (MapUtils.exists(delimiters, str.charAt(i))) {
                var token = str.substring(lastTokenIndex, i);
                if (token.length == 0) {
                    if (returnEmptyTokens) tokens.push(token)
                } else tokens.push(token);
                if (returnDelimiters) tokens.push(str.charAt(i));
                lastTokenIndex = i + 1
            }
        if (lastTokenIndex < str.length) {
            var token = str.substring(lastTokenIndex, str.length);
            if (token.length == 0) {
                if (returnEmptyTokens) tokens.push(token)
            } else tokens.push(token)
        }
        return tokens
    }

    function parse(element, constraintDefinitionString) {
        var currentConstraintName = "";
        var tokens = tokenize({
            str: trim(constraintDefinitionString.replace(/\s*\n\s*/g, "")),
            delimiters: '@()[]=,"\\/-\\.',
            returnDelimiters: true,
            returnEmptyTokens: false
        });
        return constraints(tokens);

        function constraints(tokens) {
            var result = {
                successful: true,
                message: "",
                data: null
            };
            var constraintsToAttach = [];
            while (tokens.length > 0 && result.successful) {
                result = constraint(tokens);
                constraintsToAttach.push(result.data)
            }
            result.data = constraintsToAttach;
            return result
        }

        function constraint(tokens) {
            var result = {
                successful: true,
                message: "",
                data: null
            };
            var token = tokens.shift();
            if (trim(token).length == 0) token = tokens.shift();
            if (token == "@") result = constraintDef(tokens);
            else result = {
                successful: false,
                message: ExceptionService.generateExceptionMessage(element, currentConstraintName,
                    "Invalid constraint. Constraint definitions need to start with '@'") + " " + result.message,
                data: null
            };
            return result
        }

        function constraintDef(tokens) {
            var alias = {
                Between: "Range",
                Matches: "Pattern",
                Empty: "Blank",
                NotEmpty: "NotBlank",
                IsAlpha: "Alpha",
                IsNumeric: "Integer",
                IsAlphaNumeric: "AlphaNumeric"
            };
            var result = constraintName(tokens);
            if (result.successful) {
                currentConstraintName = result.data;
                currentConstraintName = alias[currentConstraintName] ? alias[currentConstraintName] : currentConstraintName;
                if (ConstraintService.constraintDefinitions[currentConstraintName]) {
                    result =
                        paramDef(tokens);
                    if (result.successful) {
                        result = ConstraintService.verifyConstraintDefinition(element, currentConstraintName, result.data);
                        if (result.successful) {
                            var definedParameters = result.data;
                            result.data = {
                                element: element,
                                constraintName: currentConstraintName,
                                definedParameters: definedParameters
                            }
                        }
                    }
                } else result = {
                    successful: false,
                    message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "I cannot find the specified constraint name. If this is a custom constraint, you need to define it before you bind to it") +
                        " " + result.message,
                    data: null
                }
            } else result = {
                successful: false,
                message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Invalid constraint name in constraint definition") + " " + result.message,
                data: null
            };
            return result
        }

        function constraintName(tokens) {
            var token = trim(tokens.shift());
            var result = validStartingCharacter(token.charAt(0));
            if (result.successful) {
                var i = 1;
                while (i < token.length && result.successful) {
                    result = validCharacter(token.charAt(i));
                    i++
                }
                if (result.successful) result.data = token
            } else result = {
                successful: false,
                message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Invalid starting character for constraint name. Can only include A-Z, a-z, and _") + " " + result.message,
                data: null
            };
            return result
        }

        function validStartingCharacter(character) {
            var result = {
                successful: true,
                message: "",
                data: null
            };
            if (!/[A-Za-z_]/.test(character) || typeof character === "undefined" || character == null) result = {
                successful: false,
                message: ExceptionService.generateExceptionMessage(element, currentConstraintName,
                    "Invalid starting character"),
                data: null
            };
            return result
        }

        function validCharacter(character) {
            var result = {
                successful: true,
                message: "",
                data: null
            };
            if (!/[0-9A-Za-z_]/.test(character)) result = {
                successful: false,
                message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Invalid character in identifier. Can only include 0-9, A-Z, a-z, and _") + " " + result.message,
                data: null
            };
            return result
        }

        function paramDef(tokens) {
            var result = {
                successful: true,
                message: "",
                data: {}
            };
            if (peek(tokens) == "(") {
                tokens.shift();
                var data = {};
                if (peek(tokens) == ")") tokens.shift();
                else {
                    result = param(tokens);
                    if (result.successful) {
                        MapUtils.put(data, result.data.name, result.data.value);
                        if (trim(peek(tokens)).length == 0) tokens.shift();
                        while (tokens.length > 0 && peek(tokens) == "," && result.successful) {
                            tokens.shift();
                            result = param(tokens);
                            if (result.successful) {
                                MapUtils.put(data, result.data.name, result.data.value);
                                if (trim(peek(tokens)).length == 0) tokens.shift()
                            }
                        }
                        if (result.successful) {
                            var token = tokens.shift();
                            if (trim(token).length == 0) token = tokens.shift();
                            if (token != ")") result = {
                                successful: false,
                                message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Cannot find matching closing ) in parameter list") + " " + result.message,
                                data: null
                            };
                            else result.data = data
                        }
                    } else result = {
                        successful: false,
                        message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Invalid parameter definition") + " " + result.message,
                        data: null
                    }
                }
            } else if (peek(tokens) !== undefined && peek(tokens) != "@") result = {
                successful: false,
                message: ExceptionService.generateExceptionMessage(element,
                    currentConstraintName, "Unexpected character '" + peek(tokens) + "'" + " after constraint definition") + " " + result.message,
                data: null
            };
            return result
        }

        function param(tokens) {
            var result = paramName(tokens);
            if (result.successful) {
                var parameterName = result.data;
                var token = tokens.shift();
                if (token == "=") {
                    result = paramValue(tokens);
                    if (result.successful) result.data = {
                        name: parameterName,
                        value: result.data
                    };
                    else result = {
                        successful: false,
                        message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Invalid parameter value") +
                            " " + result.message,
                        data: null
                    }
                } else {
                    tokens.unshift(token);
                    result = {
                        successful: false,
                        message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "'=' expected after parameter name" + " " + result.message),
                        data: null
                    }
                }
            } else result = {
                successful: false,
                message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Invalid parameter name. You might have unmatched parentheses") + " " + result.message,
                data: null
            };
            return result
        }

        function paramName(tokens) {
            var token = trim(tokens.shift());
            if (token.length == 0) token = tokens.shift();
            var result = {
                successful: false,
                message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Invalid starting character for parameter name. Can only include A-Z, a-z, and _"),
                data: null
            };
            if (typeof token !== "undefined") {
                result = validStartingCharacter(token.charAt(0));
                if (result.successful) {
                    var i = 1;
                    while (i < token.length && result.successful) {
                        result = validCharacter(token.charAt(i));
                        i++
                    }
                    if (result.successful) result.data = token
                } else result = {
                    successful: false,
                    message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Invalid starting character for parameter name. Can only include A-Z, a-z, and _") + " " + result.message,
                    data: null
                }
            }
            return result
        }

        function paramValue(tokens) {
            if (trim(peek(tokens)).length == 0) tokens.shift();
            var result = {
                successful: true,
                message: "",
                data: []
            };
            if (peek(tokens) == ")") result = {
                successful: false,
                message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Parameter value expected") + " " + result.message,
                data: null
            };
            else {
                result = number(tokens);
                var message = result.message;
                if (!result.successful) {
                    result = quotedString(tokens);
                    result.message = result.message + " " + message;
                    message = result.message;
                    if (!result.successful) {
                        result = regularExpression(tokens);
                        result.message = result.message + " " + message;
                        message = result.message;
                        if (!result.successful) {
                            result = booleanValue(tokens);
                            result.message = result.message + " " + message;
                            message = result.message;
                            if (!result.successful) {
                                result = groupDefinition(tokens);
                                result.message = result.message +
                                    " " + message;
                                message = result.message;
                                if (!result.successful) result = {
                                    successful: false,
                                    message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Parameter value must be a number, quoted string, regular expression, or a boolean") + " " + message,
                                    data: null
                                }
                            }
                        }
                    }
                }
            }
            return result
        }

        function number(tokens) {
            var result = negative(tokens);
            if (!result.successful) {
                result = positive(tokens);
                if (!result.successful) result = {
                    successful: false,
                    message: ExceptionService.generateExceptionMessage(element, currentConstraintName,
                        "Parameter value is not a number") + " " + result.message,
                    data: null
                }
            }
            return result
        }

        function negative(tokens) {
            var token = tokens.shift();
            var result = {
                successful: true,
                message: "",
                data: null
            };
            if (token == "-") {
                result = positive(tokens);
                if (result.successful) result.data = token + result.data
            } else {
                tokens.unshift(token);
                result = {
                    successful: false,
                    message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Not a negative number"),
                    data: null
                }
            }
            return result
        }

        function positive(tokens) {
            var result = null;
            if (peek(tokens) !=
                ".") {
                result = integer(tokens);
                if (peek(tokens) == ".") {
                    var integerPart = result.data;
                    result = fractional(tokens);
                    if (result.successful) result.data = integerPart + result.data
                }
            } else result = fractional(tokens);
            if (!result.successful) result = {
                successful: false,
                message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Not a positive number") + " " + result.message,
                data: null
            };
            return result
        }

        function fractional(tokens) {
            var token = tokens.shift();
            var result = integer(tokens);
            if (result.successful) result.data =
                token + result.data;
            else result = {
                successful: false,
                message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Not a valid fraction"),
                data: null
            };
            return result
        }

        function integer(tokens) {
            var token = trim(tokens.shift());
            var result = digit(token.charAt(0));
            if (result.successful) {
                var i = 1;
                while (i < token.length && result.successful) {
                    result = digit(token.charAt(i));
                    i++
                }
                if (result.successful) result.data = token
            } else {
                tokens.unshift(token);
                result = {
                    successful: false,
                    message: ExceptionService.generateExceptionMessage(element,
                        currentConstraintName, "Not a valid integer") + " " + result.message,
                    data: []
                }
            }
            return result
        }

        function digit(character) {
            var result = {
                successful: true,
                message: "",
                data: null
            };
            if (!/[0-9]/.test(character)) result = {
                successful: false,
                message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Not a valid digit"),
                data: null
            };
            return result
        }

        function quotedString(tokens) {
            var token = tokens.shift();
            var data = "";
            var result = {
                successful: true,
                message: "",
                data: null
            };
            if (token == '"') {
                var done = false;
                while (tokens.length >
                    0 && result.successful && !done)
                    if (peek(tokens) == '"') {
                        done = true;
                        tokens.shift()
                    } else {
                        result = character(tokens);
                        data += result.data
                    }
                if (!done) result = {
                    successful: false,
                    message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Unterminated string literal"),
                    data: null
                }
            } else {
                tokens.unshift(token);
                result = {
                    successful: false,
                    message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Invalid quoted string"),
                    data: null
                }
            }
            result.successful = result.successful && done;
            result.data =
                data;
            return result
        }

        function character(tokens) {
            var data = "";
            var token = tokens.shift();
            if (token == "\\") data = tokens.shift();
            return {
                successful: true,
                message: "",
                data: token + data
            }
        }

        function regularExpression(tokens) {
            var data = "";
            var token = tokens.shift();
            var result = {
                successful: true,
                message: "",
                data: null
            };
            if (token == "/") {
                data = token;
                var done = false;
                while (tokens.length > 0 && result.successful && !done)
                    if (peek(tokens) == "/") {
                        data += tokens.shift();
                        done = true
                    } else {
                        result = character(tokens);
                        data += result.data
                    }
                if (!done) result = {
                    successful: false,
                    message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Unterminated regex literal"),
                    data: null
                }
            } else {
                tokens.unshift(token);
                result = {
                    successful: false,
                    message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Not a regular expression"),
                    data: null
                }
            }
            result.successful = result.successful && done;
            result.data = data;
            return result
        }

        function booleanValue(tokens) {
            var token = tokens.shift();
            var result = {
                successful: true,
                message: "",
                data: null
            };
            if (trim(token) == "true" || trim(token) ==
                "false") result = {
                successful: true,
                message: "",
                data: !!(token === "true")
            };
            else {
                tokens.unshift(token);
                result = {
                    successful: false,
                    message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Not a boolean"),
                    data: null
                }
            }
            return result
        }

        function groupDefinition(tokens) {
            var data = [];
            var token = tokens.shift();
            var result = {
                successful: true,
                message: "",
                data: null
            };
            if (token == "[") {
                if (trim(peek(tokens)).length == 0) tokens.shift();
                if (peek(tokens) == "]") result = {
                    successful: true,
                    message: "",
                    data: ""
                };
                else result =
                    group(tokens);
                if (result.successful) {
                    data.push(result.data);
                    if (trim(peek(tokens)).length == 0) tokens.shift();
                    while (tokens.length > 0 && peek(tokens) == "," && result.successful) {
                        tokens.shift();
                        result = group(tokens);
                        data.push(result.data);
                        if (trim(peek(tokens)).length == 0) tokens.shift()
                    }
                    result.data = data;
                    token = tokens.shift();
                    if (trim(token).length == 0) tokens.shift();
                    if (token != "]") result = {
                        successful: false,
                        message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Cannot find matching closing ] in group definition") +
                            " " + result.message,
                        data: null
                    }
                } else result = {
                    successful: false,
                    message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Invalid group definition") + " " + result.message,
                    data: null
                }
            } else {
                tokens.unshift(token);
                result = {
                    successful: false,
                    message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Not a valid group definition"),
                    data: null
                }
            }
            return result
        }

        function group(tokens) {
            var result = {
                successful: true,
                message: "",
                data: ""
            };
            var token = trim(tokens.shift());
            if (token.length ==
                0) token = tokens.shift();
            result = validStartingCharacter(token.charAt(0));
            if (result.successful) {
                var i = 1;
                while (i < token.length && result.successful) {
                    result = validCharacter(token.charAt(i));
                    i++
                }
                if (result.successful) result.data = token
            } else result = {
                successful: false,
                message: ExceptionService.generateExceptionMessage(element, currentConstraintName, "Invalid starting character for group name. Can only include A-Z, a-z, and _") + " " + result.message,
                data: null
            };
            return result
        }
    }
    return {
        parse: parse
    }
}));
(function(root, factory) {
    if (typeof define === "function" && define.amd) define("service/BindingService", ["utils/MapUtils", "service/GroupService", "utils/DOMUtils", "parser/Parser", "service/ConstraintService", "service/ExceptionService"], factory);
    else {
        if (typeof root.regulaModules === "undefined") root.regulaModules = {};
        root.regulaModules.BindingService = factory(root.regulaModules.MapUtils, root.regulaModules.GroupService, root.regulaModules.DOMUtils, root.regulaModules.Parser, root.regulaModules.ConstraintService, root.regulaModules.ExceptionService)
    }
}(this,
    function(MapUtils, GroupService, DOMUtils, Parser, ConstraintService, ExceptionService) {
        var boundConstraints = null;
        var modifiedElements = {};

        function initializeBoundConstraints() {
            if (boundConstraints === null) resetBoundConstraints()
        }

        function resetBoundConstraints() {
            boundConstraints = {
                Default: {}
            }
        }

        function getBoundConstraints() {
            return boundConstraints
        }

        function removeElementAndGroupFromBoundConstraintsIfEmpty(id, group) {
            if (MapUtils.isEmpty(boundConstraints[group][id])) {
                delete boundConstraints[group][id];
                if (MapUtils.isEmpty(boundConstraints[group])) {
                    delete boundConstraints[group];
                    var groupIndex = GroupService.Group[group];
                    delete GroupService.Group[group];
                    delete GroupService.ReverseGroup[groupIndex];
                    GroupService.deletedGroupIndices.push(groupIndex)
                }
            }
        }

        function checkElementBindability(element) {
            var result = {
                successful: true,
                message: "",
                data: null
            };
            var clonedElement = element;
            var tagName = null;
            if (typeof clonedElement.tagName !== "undefined") tagName = clonedElement.tagName.toLowerCase();
            if (false && tagName !== "form" && tagName !== "select" && tagName !== "textarea" && tagName !== "input") result = {
                successful: false,
                message: tagName + "#" + element.id + " is not an input, select, textarea, or form element! Validation constraints can only be attached to input, select, textarea, or form elements.",
                data: null
            };
            else if (tagName === "input" && element.getAttribute("type") === null) result = {
                successful: false,
                message: tagName + "#" + element.id + " does not have a type attribute.",
                data: null
            };
            return result
        }

        function bindAfterParsing(options) {
            var element = options.element;
            var elementsWithRegulaValidation;
            if (element === null) {
                elementsWithRegulaValidation =
                    document.querySelectorAll(DOMUtils.getSelector("[data-constraints]"));
                console.log("elementsWithRegulaValidation:", elementsWithRegulaValidation)
            } else elementsWithRegulaValidation = [element];
            var result = {
                successful: true,
                message: "",
                data: null
            };
            var i = 0;
            while (i < elementsWithRegulaValidation.length && result.successful) {
                element = elementsWithRegulaValidation[i];
                result = checkElementBindability(element);
                if (result.successful) {
                    if (!element.id) element.id = DOMUtils.generateRandomId();
                    var dataConstraintsAttribute = element.getAttribute("data-constraints");
                    if (dataConstraintsAttribute !== null) {
                        result = Parser.parse(element, dataConstraintsAttribute);
                        if (result.successful && result.data !== null) {
                            var constraintsToAttach = result.data;
                            var j = 0;
                            while (result.successful && j < constraintsToAttach.length) {
                                var constraintToAttach = constraintsToAttach[j];
                                result = attachConstraintDefinitionToElement(constraintToAttach.element, constraintToAttach.constraintName, constraintToAttach.definedParameters);
                                j++
                            }
                        }
                    }
                    i++
                }
            }
            return result
        }

        function bindHTML5ValidationConstraints(options) {
            var element =
                options.element;
            var result = {
                successful: true,
                message: "",
                data: null
            };
            var html5Constraints = [{
                attribute: "required",
                value: null,
                constraint: ConstraintService.Constraint.HTML5Required
            }, {
                attribute: "type",
                value: "email",
                constraint: ConstraintService.Constraint.HTML5Email
            }, {
                attribute: "type",
                value: "url",
                constraint: ConstraintService.Constraint.HTML5URL
            }, {
                attribute: "pattern",
                value: null,
                constraint: ConstraintService.Constraint.HTML5Pattern
            }, {
                attribute: "maxlength",
                value: null,
                constraint: ConstraintService.Constraint.HTML5MaxLength
            }, {
                attribute: "min",
                value: null,
                constraint: ConstraintService.Constraint.HTML5Min
            }, {
                attribute: "max",
                value: null,
                constraint: ConstraintService.Constraint.HTML5Max
            }, {
                attribute: "step",
                value: null,
                constraint: ConstraintService.Constraint.HTML5Step
            }];
            var typeToRegulaConstraint = {
                email: ConstraintService.Constraint.HTML5Email,
                url: ConstraintService.Constraint.HTML5URL
            };

            function addConstraintToElementMap(elementMap, elements, html5Constraint) {
                for (var i = 0; i < elements.length; i++) {
                    var element = elements[i];
                    if (!element.id) element.id =
                        DOMUtils.generateRandomId();
                    if (!elementMap[element.id]) elementMap[element.id] = [];
                    var constraintDefinition = {
                        constraint: html5Constraint.constraint,
                        params: {}
                    };
                    if (html5Constraint.value === null) constraintDefinition.params[html5Constraint.attribute] = DOMUtils.getAttributeValueForElement(element, html5Constraint.attribute);
                    elementMap[element.id].push(constraintDefinition)
                }
            }
            var elementsWithHTML5Validation = {};
            if (element === null)
                for (var i = 0; i < html5Constraints.length; i++) {
                    var html5Constraint = html5Constraints[i];
                    var elements = null;
                    if (html5Constraint.value == null) elements = document.querySelectorAll(DOMUtils.getSelector("[" + html5Constraint.attribute + "]"));
                    else elements = document.querySelectorAll(DOMUtils.getSelector("[" + html5Constraint.attribute + '="' + html5Constraint.value + '"]'));
                    addConstraintToElementMap(elementsWithHTML5Validation, elements, html5Constraint)
                } else {
                    if (!element.id) element.id = DOMUtils.generateRandomId();
                    result = checkElementBindability(element);
                    if (result.successful) {
                        elementsWithHTML5Validation[element.id] = [];
                        for (var i = 0; i < html5Constraints.length; i++) {
                            var html5Constraint = html5Constraints[i];
                            if (html5Constraint.value === null) {
                                if (DOMUtils.getAttributeValueForElement(element, html5Constraint.attribute) != null) {
                                    var constraintDefinition = {
                                        constraint: html5Constraint.constraint,
                                        params: {}
                                    };
                                    constraintDefinition.params[html5Constraint.attribute] = DOMUtils.getAttributeValueForElement(element, html5Constraint.attribute);
                                    elementsWithHTML5Validation[element.id].push(constraintDefinition)
                                }
                            } else {
                                var value = DOMUtils.getAttributeValueForElement(element,
                                    html5Constraint.attribute);
                                if (value != null && typeof typeToRegulaConstraint[value] !== "undefined") elementsWithHTML5Validation[element.id].push({
                                    constraint: typeToRegulaConstraint[value],
                                    params: {}
                                })
                            }
                        }
                    }
                }
            MapUtils.iterateOverMap(elementsWithHTML5Validation, function(elementId, constraintDefinitions, index) {
                var element = document.querySelector(DOMUtils.getSelector("#" + elementId));
                for (var i = 0; i < constraintDefinitions.length; i++) {
                    var constraintDefinition = constraintDefinitions[i];
                    result = attachConstraintDefinitionToElement(element,
                        ConstraintService.ReverseConstraint[constraintDefinition.constraint], constraintDefinition.params)
                }
            });
            return result
        }

        function bindFromOptions(options) {
            var result = {
                successful: true,
                message: "",
                data: null
            };
            var element = options.element;
            var constraints = options.constraints || [];
            var tagName = element && element.tagName ? element.tagName.toLowerCase() : null;
            if (!element) result = {
                successful: false,
                message: "regula.bind expects a non-null element attribute in the options argument. " + ExceptionService.explodeParameters(options),
                data: null
            };
            else if (element.nodeType !== 1) result = {
                successful: false,
                message: "regula.bind: element attribute is expected to be an HTMLElement, but was of unexpected type: " + typeof element + ". " + ExceptionService.explodeParameters(options),
                data: null
            };
            else if (false && tagName != "form" && tagName != "select" && tagName != "textarea" && tagName != "input") result = {
                successful: false,
                message: tagName + "#" + element.id + " is not an input, select, textarea, or form element! Validation constraints can only be attached to input, select, textarea, or form elements. " +
                    ExceptionService.explodeParameters(options),
                data: null
            };
            else if (constraints.length > 0) {
                var i = 0;
                while (i < constraints.length && result.successful) {
                    result = bindUsingConstraintDefinition(constraints[i], options);
                    i++
                }
            } else result = bindAfterParsing({
                element: element
            });
            return result
        }

        function bindUsingConstraintDefinition(constraint, options) {
            function union(first, second) {
                var inserted = {};
                var union = [];
                for (var i = 0; i < first.length; i++) {
                    union.push(first[i]);
                    inserted[first[i]] = true
                }
                for (var j = 0; j < second.length; j++)
                    if (!inserted[second[j]]) union.push(second[j]);
                return union
            }

            function subtract(second, first) {
                var difference = [];
                for (var i = 0; i < first.length; i++)
                    if (!MapUtils.exists(second, first[i])) difference.push(first[i]);
                return difference
            }

            function overwriteGroups(element, constraintType, definedParameters) {
                var oldGroups = boundConstraints[GroupService.ReverseGroup[GroupService.Group.Default]][element.id][ConstraintService.ReverseConstraint[constraintType]]["groups"];
                var newGroups = [];
                if (definedParameters["groups"]) newGroups = definedParameters["groups"];
                else newGroups.push(GroupService.ReverseGroup[GroupService.Group.Default]);
                if (!MapUtils.exists(newGroups, GroupService.ReverseGroup[GroupService.Group.Default])) newGroups.push(GroupService.ReverseGroup[GroupService.Group.Default]);
                var groupsToRemoveConstraintFrom = subtract(newGroups, union(oldGroups, newGroups));
                for (var i = 0; i < groupsToRemoveConstraintFrom.length; i++) {
                    var group = groupsToRemoveConstraintFrom[i];
                    delete boundConstraints[group][element.id][ConstraintService.ReverseConstraint[constraintType]];
                    removeElementAndGroupFromBoundConstraintsIfEmpty(element.id, group)
                }
            }
            var result = {
                successful: true,
                message: "",
                data: null
            };
            var element = options.element;
            var overwriteConstraint = constraint.overwriteConstraint || false;
            var overwriteParameters = constraint.overwriteParameters || false;
            var constraintType = constraint.constraintType;
            var definedParameters = constraint.params || {};
            var newParameters = {
                __size__: 0
            };
            var originalGroups = definedParameters["groups"];
            if (typeof constraintType === "undefined") result = {
                successful: false,
                message: "regula.bind expects a valid constraint type for each constraint in constraints attribute of the options argument. " +
                    ExceptionService.explodeParameters(options),
                data: null
            };
            else if (definedParameters && definedParameters["groups"])
                if (definedParameters["groups"] instanceof Array) {
                    var normalizedGroups = [];
                    var j = 0;
                    while (j < definedParameters["groups"].length && result.successful) {
                        if (typeof definedParameters["groups"][j] == "string") normalizedGroups.push(definedParameters["groups"][j]);
                        else if (typeof GroupService.ReverseGroup[definedParameters["groups"][j]] !== "undefined") normalizedGroups.push(GroupService.ReverseGroup[definedParameters["groups"][j]]);
                        else result = {
                            successful: false,
                            message: "Invalid group: " + definedParameters["groups"][j] + ". " + ExceptionService.explodeParameters(options),
                            data: null
                        };
                        j++
                    }
                    if (result.successful) definedParameters["groups"] = normalizedGroups
                } else result = {
                    successful: false,
                    message: "The groups parameter must be an array of enums or strings " + ExceptionService.explodeParameters(options),
                    data: null
                };
            if (result.successful) {
                if (!boundConstraints[GroupService.ReverseGroup[GroupService.Group.Default]][element.id] || !boundConstraints[GroupService.ReverseGroup[GroupService.Group.Default]][element.id][ConstraintService.ReverseConstraint[constraintType]]) {
                    for (var param in definedParameters)
                        if (definedParameters.hasOwnProperty(param)) MapUtils.put(newParameters,
                            param, definedParameters[param]);
                    result = ConstraintService.verifyConstraintDefinition(element, ConstraintService.ReverseConstraint[constraintType], newParameters)
                } else if (overwriteConstraint) {
                    for (var param in definedParameters)
                        if (definedParameters.hasOwnProperty(param)) MapUtils.put(newParameters, param, definedParameters[param]);
                    result = ConstraintService.verifyConstraintDefinition(element, ConstraintService.ReverseConstraint[constraintType], newParameters);
                    if (result.successful) overwriteGroups(element, constraintType,
                        definedParameters)
                } else {
                    var oldParameters = boundConstraints[GroupService.ReverseGroup[GroupService.Group.Default]][element.id][ConstraintService.ReverseConstraint[constraintType]];
                    for (var param in oldParameters)
                        if (oldParameters.hasOwnProperty(param)) MapUtils.put(newParameters, param, oldParameters[param]);
                    if (overwriteParameters) {
                        for (var param in definedParameters)
                            if (definedParameters.hasOwnProperty(param)) MapUtils.put(newParameters, param, definedParameters[param]);
                        result = ConstraintService.verifyConstraintDefinition(element,
                            ConstraintService.ReverseConstraint[constraintType], newParameters);
                        if (result.successful) overwriteGroups(element, constraintType, newParameters)
                    } else
                        for (var param in definedParameters)
                            if (definedParameters.hasOwnProperty(param))
                                if (!oldParameters[param]) MapUtils.put(newParameters, param, definedParameters[param])
                }
                if (result.successful) result = attachConstraintDefinitionToElement(element, ConstraintService.ReverseConstraint[constraintType], newParameters)
            }
            definedParameters["groups"] = originalGroups;
            return result
        }

        function attachConstraintDefinitionToElement(element, constraintName, definedParameters) {
            var result = {
                successful: true,
                message: "",
                data: null
            };
            if (!definedParameters["groups"]) MapUtils.put(definedParameters, "groups", [GroupService.ReverseGroup[GroupService.Group.Default]]);
            var groups = definedParameters["groups"];
            if (groups.indexOf(GroupService.ReverseGroup[GroupService.Group.Default]) === -1) {
                groups.push(GroupService.ReverseGroup[GroupService.Group.Default]);
                definedParameters["groups"] = groups
            }
            for (var i = 0; i < groups.length; i++) {
                var group =
                    groups[i];
                if (!boundConstraints[group]) {
                    var newIndex = -1;
                    if (GroupService.deletedGroupIndices.length > 0) newIndex = GroupService.deletedGroupIndices.pop();
                    else newIndex = GroupService.firstCustomGroupIndex++;
                    GroupService.Group[group] = newIndex;
                    GroupService.ReverseGroup[newIndex] = group;
                    boundConstraints[group] = {}
                }
                if (!boundConstraints[group][element.id]) boundConstraints[group][element.id] = {};
                boundConstraints[group][element.id][constraintName] = definedParameters
            }
            if (ConstraintService.constraintDefinitions[constraintName].html5)
                if (element.getAttribute("type") !==
                    null && ConstraintService.constraintDefinitions[constraintName].inputType !== null && element.getAttribute("type") !== ConstraintService.constraintDefinitions[constraintName].inputType) result = {
                    successful: false,
                    message: ExceptionService.generateExceptionMessage(element, constraintName, "Element type of " + element.getAttribute("type") + " conflicts with type of constraint @" + constraintName + ": " + ConstraintService.constraintDefinitions[constraintName].inputType),
                    data: null
                };
                else {
                    var attribute = ConstraintService.constraintDefinitions[constraintName].attribute;
                    var inputType = ConstraintService.constraintDefinitions[constraintName].inputType;
                    if (attribute !== null && element.getAttribute(attribute) === null || inputType !== null && element.getAttribute("type") === null) attachHTML5Attributes(element, constraintName, definedParameters)
                }
            return result
        }

        function attachHTML5Attributes(element, constraintName, definedParameters) {
            if (constraintName === ConstraintService.ReverseConstraint[ConstraintService.Constraint.HTML5Required]) element.setAttribute("required", "true");
            else {
                var constraint =
                    ConstraintService.constraintDefinitions[constraintName];
                for (var i = 0; i < constraint.params.length; i++) element.setAttribute(constraint.params[i], definedParameters[constraint.params[i]])
            }
            var classes = element.getAttribute("class");
            if (!/regula-modified/.test(classes)) element.setAttribute("class", classes + " regula-modified")
        }

        function unbind(options) {
            var removed = false;
            for (var i = 0; i < options.elements.length; i++) {
                var id = options.elements[i].id;
                var constraints = options.constraints || [];
                if (constraints.length == 0)
                    for (var group in boundConstraints) {
                        if (boundConstraints.hasOwnProperty(group))
                            if (typeof boundConstraints[group][id] !==
                                "undefined") {
                                delete boundConstraints[group][id];
                                if (group !== "Default") removeElementAndGroupFromBoundConstraintsIfEmpty(id, group);
                                removed = true
                            }
                    } else
                        for (var j = 0; j < constraints.length; j++) {
                            var constraint = constraints[j];
                            for (var group in boundConstraints)
                                if (boundConstraints.hasOwnProperty(group))
                                    if (typeof boundConstraints[group][id] !== "undefined") {
                                        delete boundConstraints[group][id][ConstraintService.ReverseConstraint[constraint]];
                                        if (group !== "Default") removeElementAndGroupFromBoundConstraintsIfEmpty(id,
                                            group);
                                        removed = true
                                    }
                        }
            }
            if (options.elements.length > 0 && !removed) throw new ExceptionService.Exception.IllegalArgumentException("Element with id " + id + " does not have any constraints bound to it. " + ExceptionService.explodeParameters(options));
        }

        function isBound(options) {
            var elementId = options.elementId;
            var group = options.group;
            var constraint = options.constraint;
            var bound = typeof boundConstraints[GroupService.ReverseGroup[GroupService.Group.Default]][elementId] !== "undefined";
            if (bound && typeof group !== "undefined" &&
                typeof constraint === "undefined") {
                var groupString = GroupService.ReverseGroup[group];
                bound = typeof groupString !== "undefined" && typeof boundConstraints[groupString][elementId] !== "undefined"
            } else if (bound && typeof group === "undefined" && typeof constraint !== "undefined") {
                var constraintString = ConstraintService.ReverseConstraint[constraint];
                bound = typeof constraintString !== "undefined" && typeof boundConstraints[GroupService.ReverseGroup[GroupService.Group.Default]][elementId][constraintString] !== "undefined"
            } else if (bound &&
                typeof group !== "undefined" && typeof constraint !== "undefined") {
                var groupString = GroupService.ReverseGroup[group];
                var constraintString = ConstraintService.ReverseConstraint[constraint];
                bound = typeof groupString !== "undefined" && typeof constraintString !== "undefined" && typeof boundConstraints[groupString][elementId] !== "undefined" && typeof boundConstraints[groupString][elementId][constraintString] !== "undefined"
            }
            return bound
        }
        return {
            initializeBoundConstraints: initializeBoundConstraints,
            resetBoundConstraints: resetBoundConstraints,
            getBoundConstraints: getBoundConstraints,
            removeElementAndGroupFromBoundConstraintsIfEmpty: removeElementAndGroupFromBoundConstraintsIfEmpty,
            bindAfterParsing: bindAfterParsing,
            bindHTML5ValidationConstraints: bindHTML5ValidationConstraints,
            bindFromOptions: bindFromOptions,
            unbind: unbind,
            isBound: isBound
        }
    }));
(function(root, factory) {
    if (typeof define === "function" && define.amd) define("regula", ["utils/MapUtils", "utils/DOMUtils", "service/BindingService", "service/ExceptionService", "service/ConstraintService", "service/ValidationService", "service/GroupService"], factory);
    else {
        root.regula = factory(root.regulaModules.MapUtils, root.regulaModules.DOMUtils, root.regulaModules.BindingService, root.regulaModules.ExceptionService, root.regulaModules.ConstraintService, root.regulaModules.ValidationService, root.regulaModules.GroupService);
        root.regula._modules = root.regulaModules;
        root.regulaModules = undefined
    }
})(this, function(MapUtils, DOMUtils, BindingService, ExceptionService, ConstraintService, ValidationService, GroupService) {
    var config = {
        validateEmptyFields: false,
        enableHTML5Validation: false,
        debug: false
    };
    var DateFormat = {
        DMY: "DMY",
        MDY: "MDY",
        YMD: "YMD"
    };
    BindingService.initializeBoundConstraints();
    ValidationService.initializePublicValidators(ConstraintService.constraintDefinitions);

    function configure(options) {
        MapUtils.iterateOverMap(options,
            function(key, value, index) {
                if (typeof config[key] !== "undefined") config[key] = value
            })
    }

    function bind(options) {
        var result = {
            successful: true,
            message: "",
            data: null
        };
        if (typeof options === "undefined" || !options) {
            BindingService.resetBoundConstraints();
            if (config.enableHTML5Validation && DOMUtils.supportsHTML5Validation()) result = BindingService.bindHTML5ValidationConstraints({
                element: null
            });
            if (result.successful) result = BindingService.bindAfterParsing({
                element: null
            })
        } else {
            var elements = options.elements;
            if (typeof elements ===
                "undefined" || !elements) {
                if (config.enableHTML5Validation && DOMUtils.supportsHTML5Validation() && (typeof options.element !== "undefined" && options.element !== null)) result = BindingService.bindHTML5ValidationConstraints({
                    element: options.element
                });
                if (result.successful) result = BindingService.bindFromOptions(options)
            } else {
                var i = 0;
                while (result.successful && i < elements.length) {
                    options.element = elements[i];
                    if (config.enableHTML5Validation && DOMUtils.supportsHTML5Validation()) result = BindingService.bindHTML5ValidationConstraints({
                        element: options.element
                    });
                    if (result.successful) {
                        result = BindingService.bindFromOptions(options);
                        if (!result.successful) result.message = "regula.bind: Element " + (i + 1) + " of " + elements.length + " failed: " + result.message
                    } else result.message = "regula.bind: Failed binding HTML5 validation constraints: Element " + (i + 1) + " of " + elements.length + " failed: " + result.message;
                    i++
                }
            }
        }
        if (!result.successful) throw new ExceptionService.Exception.BindException(result.message);
    }

    function unbind(options) {
        if (typeof options === "undefined" || !options) BindingService.resetBoundConstraints();
        else {
            if (typeof options.elementId === "undefined" && typeof options.elements === "undefined") throw new ExceptionService.Exception.IllegalArgumentException("regula.unbind requires an elementId attribute, or an elements attribute if options are provided");
            if (typeof options.elements !== "undefined" && !(options.elements instanceof Array)) throw new ExceptionService.Exception.IllegalArgumentException("regula.unbind expects the elements attribute to be an array, if it is provided");
            if (typeof options.elements === "undefined") {
                options.elements =
                    document.querySelector(DOMUtils.getSelector("#" + options.elementId));
                if (options.elements[0] === null) throw new ExceptionService.Exception.IllegalArgumentException("Element with id " + options.elementId + " does not have any constraints bound to it. " + ExceptionService.explodeParameters(options));
            }
            BindingService.unbind(options)
        }
    }

    function isBound(options) {
        if (typeof options === "undefined") throw new ExceptionService.Exception.IllegalArgumentException("regula.isBound expects options");
        var element = options.element;
        var elementId = options.elementId;
        if (typeof element === "undefined" && typeof elementId === "undefined") throw new ExceptionService.Exception.IllegalArgumentException("regula.isBound expects at the very least, either an element or elementId attribute");
        if (options.hasOwnProperty("constraint") && typeof options.constraint === "undefined") throw new ExceptionService.Exception.IllegalArgumentException("Undefined constraint was supplied as a parameter");
        if (options.hasOwnProperty("group") && typeof options.group === "undefined") throw new ExceptionService.Exception.IllegalArgumentException("Undefined group was supplied as a parameter");
        if (typeof element !== "undefined") elementId = element.id;
        return BindingService.isBound({
            elementId: elementId,
            group: options.group,
            constraint: options.constraint
        })
    }

    function override(options) {
        if (!options) throw new ExceptionService.Exception.IllegalArgumentException("regula.override expects options");
        if (typeof options.constraintType == "undefined") throw new ExceptionService.Exception.IllegalArgumentException("regula.override expects a valid constraintType attribute in the options argument");
        var name = ConstraintService.ReverseConstraint[options.constraintType];
        if (typeof name === "undefined") throw new ExceptionService.Exception.IllegalArgumentException("regula.override: I could not find the specified constraint. Perhaps it has not been defined? Function received: " + ExceptionService.explodeParameters(options));
        else {
            var validatorRedefined = false;
            var formSpecific = ConstraintService.constraintDefinitions[name].formSpecific;
            if (ConstraintService.constraintDefinitions[name].custom) formSpecific = typeof options.formSpecific === "undefined" ? ConstraintService.constraintDefinitions[name].formSpecific :
                options.formSpecific;
            var async = ConstraintService.constraintDefinitions[name].custom && typeof options.async !== "undefined" ? options.async : ConstraintService.constraintDefinitions[name].async;
            var params = ConstraintService.constraintDefinitions[name].custom ? options.params || ConstraintService.constraintDefinitions[name].params : ConstraintService.constraintDefinitions[name].params;
            var defaultMessage = options.defaultMessage || ConstraintService.constraintDefinitions[name].defaultMessage;
            var compound = ConstraintService.constraintDefinitions[name].compound;
            var composingConstraints = options.constraints || ConstraintService.constraintDefinitions[name].constraints;
            var validator = ConstraintService.constraintDefinitions[name].validator;
            if (ConstraintService.constraintDefinitions[name].custom && !ConstraintService.constraintDefinitions[name].compound && typeof options.validator !== "undefined") {
                validator = options.validator;
                validatorRedefined = true
            }
            if (typeof formSpecific != "boolean") throw new ExceptionService.Exception.IllegalArgumentException("regula.override expects the formSpecific attribute in the options argument to be a boolean");
            if (typeof validator != "function") throw new ExceptionService.Exception.IllegalArgumentException("regula.override expects the validator attribute in the options argument to be a function");
            if (!(params instanceof Array)) throw new ExceptionService.Exception.IllegalArgumentException("regula.override expects the params attribute in the options argument to be an array");
            if (typeof defaultMessage != "string") throw new ExceptionService.Exception.IllegalArgumentException("regula.override expects the defaultMessage attribute in the options argument to be a string");
            ConstraintService.override({
                async: async,
                formSpecific: formSpecific,
                name: name,
                constraintType: options.constraintType,
                compound: compound,
                params: params,
                composingConstraints: composingConstraints,
                defaultMessage: defaultMessage,
                validator: validator,
                validatorRedefined: validatorRedefined
            })
        }
    }

    function custom(options) {
        if (!options) throw new ExceptionService.Exception.IllegalArgumentException("regula.custom expects options");
        var name = options.name;
        var formSpecific = options.formSpecific || false;
        var validator = options.validator;
        var params = options.params || [];
        var defaultMessage = options.defaultMessage || "";
        var async = typeof options.async === "undefined" ? false : options.async;
        if (!name) throw new ExceptionService.Exception.IllegalArgumentException("regula.custom expects a name attribute in the options argument");
        else if (typeof name != "string") throw new ExceptionService.Exception.IllegalArgumentException("regula.custom expects the name attribute in the options argument to be a string");
        else if (name.replace(/\s/g, "").length == 0) throw new ExceptionService.Exception.IllegalArgumentException("regula.custom cannot accept an empty string for the name attribute in the options argument");
        if (typeof formSpecific != "boolean") throw new ExceptionService.Exception.IllegalArgumentException("regula.custom expects the formSpecific attribute in the options argument to be a boolean");
        if (!validator) throw new ExceptionService.Exception.IllegalArgumentException("regula.custom expects a validator attribute in the options argument");
        else if (typeof validator != "function") throw new ExceptionService.Exception.IllegalArgumentException("regula.custom expects the validator attribute in the options argument to be a function");
        if (params.constructor.toString().indexOf("Array") < 0) throw new ExceptionService.Exception.IllegalArgumentException("regula.custom expects the params attribute in the options argument to be an array");
        if (typeof defaultMessage != "string") throw new ExceptionService.Exception.IllegalArgumentException("regula.custom expects the defaultMessage attribute in the options argument to be a string");
        if (ConstraintService.constraintDefinitions[name]) throw new ExceptionService.Exception.IllegalArgumentException("There is already a constraint called " +
            name + ". If you wish to override this constraint, use regula.override");
        else ConstraintService.custom({
            async: async,
            name: name,
            formSpecific: formSpecific,
            validator: validator,
            custom: true,
            compound: false,
            params: params,
            defaultMessage: defaultMessage
        })
    }

    function compound(options) {
        if (!options) throw new ExceptionService.Exception.IllegalArgumentException("regula.compound expects options");
        var name = options.name;
        var constraints = options.constraints || [];
        var formSpecific = options.formSpecific || false;
        var defaultMessage =
            options.defaultMessage || "";
        var params = options.params || [];
        var reportAsSingleViolation = typeof options.reportAsSingleViolation === "undefined" ? false : options.reportAsSingleViolation;
        if (!name) throw new ExceptionService.Exception.IllegalArgumentException("regula.compound expects a name attribute in the options argument");
        if (typeof name != "string") throw new ExceptionService.Exception.IllegalArgumentException("regula.compound expects name to be a string parameter");
        if (params.constructor.toString().indexOf("Array") <
            0) throw new ExceptionService.Exception.IllegalArgumentException("regula.compound expects the params attribute in the options argument to be an array");
        if (constraints.length == 0) throw new ExceptionService.Exception.IllegalArgumentException("regula.compound expects an array of composing constraints under a constraints attribute in the options argument");
        if (ConstraintService.constraintDefinitions[name]) throw new ExceptionService.Exception.IllegalArgumentException("regula.compound: There is already a constraint called " +
            name + ". If you wish to override this constraint, use regula.override");
        ConstraintService.compound({
            name: name,
            formSpecific: formSpecific,
            params: params,
            reportAsSingleViolation: reportAsSingleViolation,
            constraints: constraints,
            defaultMessage: defaultMessage
        })
    }

    function validate(options, callback) {
        ValidationService.init({
            config: config,
            ReverseConstraint: ConstraintService.ReverseConstraint,
            constraintDefinitions: ConstraintService.constraintDefinitions,
            boundConstraints: BindingService.getBoundConstraints()
        });
        var result = [];
        if (typeof options !== "undefined" && typeof options.groups !== "undefined" && !(options.groups instanceof Array)) throw new ExceptionService.Exception.IllegalArgumentException("regula.validate: If a groups attribute is provided, it must be an array.");
        if (typeof options !== "undefined" && typeof options.groups !== "undefined" && options.groups.length == 0) throw new ExceptionService.Exception.IllegalArgumentException("regula.validate: If a groups attribute is provided, it must not be empty.");
        if (typeof options !== "undefined" &&
            options.hasOwnProperty("constraintType") && typeof options.constraintType === "undefined") throw new ExceptionService.Exception.IllegalArgumentException("regula.validate: If a constraintType attribute is provided, it cannot be undefined.");
        if (typeof callback === "undefined" && typeof options === "function") options = {
            callback: options
        };
        if (typeof callback !== "undefined") options.callback = callback;
        if (typeof options !== "undefined" && typeof options.elements !== "undefined")
            if (options.elements instanceof Array) {
                if (options.elements.length ==
                    0) throw new ExceptionService.Exception.IllegalArgumentException("regula.validate: If an elements attribute is provided, it must not be empty.");
                result = ValidationService.validate(options)
            } else throw new ExceptionService.Exception.IllegalArgumentException("regula.validate: If an elements attribute is provided, it must be an array.");
        else result = ValidationService.validate(options);
        return result
    }
    return {
        configure: configure,
        bind: bind,
        unbind: unbind,
        isBound: isBound,
        validate: validate,
        custom: custom,
        compound: compound,
        override: override,
        Constraint: ConstraintService.Constraint,
        Group: GroupService.Group,
        DateFormat: DateFormat,
        Exception: ExceptionService.Exception
    }
});
(function(undefined) {
    var moment, VERSION = "2.9.0",
        globalScope = typeof global !== "undefined" && (typeof window === "undefined" || window === global.window) ? global : this,
        oldGlobalMoment, round = Math.round,
        hasOwnProperty = Object.prototype.hasOwnProperty,
        i, YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,
        locales = {},
        momentProperties = [],
        hasModule = typeof module !== "undefined" && module && module.exports,
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        parseTokenOneOrTwoDigits = /\d\d?/,
        parseTokenOneToThreeDigits = /\d{1,3}/,
        parseTokenOneToFourDigits = /\d{1,4}/,
        parseTokenOneToSixDigits =
        /[+\-]?\d{1,6}/,
        parseTokenDigits = /\d+/,
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi,
        parseTokenT = /T/i,
        parseTokenOffsetMs = /[\+\-]?\d+/,
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/,
        parseTokenOneDigit = /\d/,
        parseTokenTwoDigits = /\d\d/,
        parseTokenThreeDigits = /\d{3}/,
        parseTokenFourDigits = /\d{4}/,
        parseTokenSixDigits = /[+-]?\d{6}/,
        parseTokenSignedNumber = /[+-]?\d+/,
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        isoFormat = "YYYY-MM-DDTHH:mm:ssZ",
        isoDates = [
            ["YYYYYY-MM-DD", /[+-]\d{6}-\d{2}-\d{2}/],
            ["YYYY-MM-DD", /\d{4}-\d{2}-\d{2}/],
            ["GGGG-[W]WW-E", /\d{4}-W\d{2}-\d/],
            ["GGGG-[W]WW", /\d{4}-W\d{2}/],
            ["YYYY-DDD", /\d{4}-\d{3}/]
        ],
        isoTimes = [
            ["HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d+/],
            ["HH:mm:ss", /(T| )\d\d:\d\d:\d\d/],
            ["HH:mm", /(T| )\d\d:\d\d/],
            ["HH", /(T| )\d\d/]
        ],
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,
        proxyGettersAndSetters = "Date|Hours|Minutes|Seconds|Milliseconds".split("|"),
        unitMillisecondFactors = {
            "Milliseconds": 1,
            "Seconds": 1E3,
            "Minutes": 6E4,
            "Hours": 36E5,
            "Days": 864E5,
            "Months": 2592E6,
            "Years": 31536E6
        },
        unitAliases = {
            ms: "millisecond",
            s: "second",
            m: "minute",
            h: "hour",
            d: "day",
            D: "date",
            w: "week",
            W: "isoWeek",
            M: "month",
            Q: "quarter",
            y: "year",
            DDD: "dayOfYear",
            e: "weekday",
            E: "isoWeekday",
            gg: "weekYear",
            GG: "isoWeekYear"
        },
        camelFunctions = {
            dayofyear: "dayOfYear",
            isoweekday: "isoWeekday",
            isoweek: "isoWeek",
            weekyear: "weekYear",
            isoweekyear: "isoWeekYear"
        },
        formatFunctions = {},
        relativeTimeThresholds = {
            s: 45,
            m: 45,
            h: 22,
            d: 26,
            M: 11
        },
        ordinalizeTokens =
        "DDD w W M D d".split(" "),
        paddedTokens = "M D H h m s w W".split(" "),
        formatTokenFunctions = {
            M: function() {
                return this.month() + 1
            },
            MMM: function(format) {
                return this.localeData().monthsShort(this, format)
            },
            MMMM: function(format) {
                return this.localeData().months(this, format)
            },
            D: function() {
                return this.date()
            },
            DDD: function() {
                return this.dayOfYear()
            },
            d: function() {
                return this.day()
            },
            dd: function(format) {
                return this.localeData().weekdaysMin(this, format)
            },
            ddd: function(format) {
                return this.localeData().weekdaysShort(this,
                    format)
            },
            dddd: function(format) {
                return this.localeData().weekdays(this, format)
            },
            w: function() {
                return this.week()
            },
            W: function() {
                return this.isoWeek()
            },
            YY: function() {
                return leftZeroFill(this.year() % 100, 2)
            },
            YYYY: function() {
                return leftZeroFill(this.year(), 4)
            },
            YYYYY: function() {
                return leftZeroFill(this.year(), 5)
            },
            YYYYYY: function() {
                var y = this.year(),
                    sign = y >= 0 ? "+" : "-";
                return sign + leftZeroFill(Math.abs(y), 6)
            },
            gg: function() {
                return leftZeroFill(this.weekYear() % 100, 2)
            },
            gggg: function() {
                return leftZeroFill(this.weekYear(),
                    4)
            },
            ggggg: function() {
                return leftZeroFill(this.weekYear(), 5)
            },
            GG: function() {
                return leftZeroFill(this.isoWeekYear() % 100, 2)
            },
            GGGG: function() {
                return leftZeroFill(this.isoWeekYear(), 4)
            },
            GGGGG: function() {
                return leftZeroFill(this.isoWeekYear(), 5)
            },
            e: function() {
                return this.weekday()
            },
            E: function() {
                return this.isoWeekday()
            },
            a: function() {
                return this.localeData().meridiem(this.hours(), this.minutes(), true)
            },
            A: function() {
                return this.localeData().meridiem(this.hours(), this.minutes(), false)
            },
            H: function() {
                return this.hours()
            },
            h: function() {
                return this.hours() % 12 || 12
            },
            m: function() {
                return this.minutes()
            },
            s: function() {
                return this.seconds()
            },
            S: function() {
                return toInt(this.milliseconds() / 100)
            },
            SS: function() {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2)
            },
            SSS: function() {
                return leftZeroFill(this.milliseconds(), 3)
            },
            SSSS: function() {
                return leftZeroFill(this.milliseconds(), 3)
            },
            Z: function() {
                var a = this.utcOffset(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-"
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2)
            },
            ZZ: function() {
                var a =
                    this.utcOffset(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-"
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2)
            },
            z: function() {
                return this.zoneAbbr()
            },
            zz: function() {
                return this.zoneName()
            },
            x: function() {
                return this.valueOf()
            },
            X: function() {
                return this.unix()
            },
            Q: function() {
                return this.quarter()
            }
        },
        deprecations = {},
        lists = ["months", "monthsShort", "weekdays", "weekdaysShort", "weekdaysMin"],
        updateInProgress = false;

    function dfl(a, b, c) {
        switch (arguments.length) {
            case 2:
                return a != null ? a : b;
            case 3:
                return a != null ? a : b != null ?
                    b : c;
            default:
                throw new Error("Implement me");
        }
    }

    function hasOwnProp(a, b) {
        return hasOwnProperty.call(a, b)
    }

    function defaultParsingFlags() {
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false
        }
    }

    function printMsg(msg) {
        if (moment.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) console.warn("Deprecation warning: " + msg)
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
            if (firstTime) {
                printMsg(msg);
                firstTime = false
            }
            return fn.apply(this, arguments)
        }, fn)
    }

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            printMsg(msg);
            deprecations[name] = true
        }
    }

    function padToken(func, count) {
        return function(a) {
            return leftZeroFill(func.call(this, a), count)
        }
    }

    function ordinalizeToken(func, period) {
        return function(a) {
            return this.localeData().ordinal(func.call(this, a), period)
        }
    }

    function monthDiff(a, b) {
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            anchor = a.clone().add(wholeMonthDiff, "months"),
            anchor2,
            adjust;
        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
            adjust = (b - anchor) / (anchor - anchor2)
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
            adjust = (b - anchor) / (anchor2 - anchor)
        }
        return -(wholeMonthDiff + adjust)
    }
    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + "o"] = ordinalizeToken(formatTokenFunctions[i], i)
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2)
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD,
        3);

    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        if (meridiem == null) return hour;
        if (locale.meridiemHour != null) return locale.meridiemHour(hour, meridiem);
        else if (locale.isPM != null) {
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) hour += 12;
            if (!isPm && hour === 12) hour = 0;
            return hour
        } else return hour
    }

    function Locale() {}

    function Moment(config, skipOverflow) {
        if (skipOverflow !== false) checkOverflow(config);
        copyConfig(this, config);
        this._d = new Date(+config._d);
        if (updateInProgress === false) {
            updateInProgress = true;
            moment.updateOffset(this);
            updateInProgress = false
        }
    }

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;
        this._milliseconds = +milliseconds + seconds * 1E3 + minutes * 6E4 + hours * 36E5;
        this._days = +days + weeks * 7;
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = moment.localeData();
        this._bubble()
    }

    function extend(a, b) {
        for (var i in b)
            if (hasOwnProp(b, i)) a[i] = b[i];
        if (hasOwnProp(b, "toString")) a.toString = b.toString;
        if (hasOwnProp(b, "valueOf")) a.valueOf = b.valueOf;
        return a
    }

    function copyConfig(to, from) {
        var i, prop, val;
        if (typeof from._isAMomentObject !== "undefined") to._isAMomentObject = from._isAMomentObject;
        if (typeof from._i !== "undefined") to._i = from._i;
        if (typeof from._f !== "undefined") to._f =
            from._f;
        if (typeof from._l !== "undefined") to._l = from._l;
        if (typeof from._strict !== "undefined") to._strict = from._strict;
        if (typeof from._tzm !== "undefined") to._tzm = from._tzm;
        if (typeof from._isUTC !== "undefined") to._isUTC = from._isUTC;
        if (typeof from._offset !== "undefined") to._offset = from._offset;
        if (typeof from._pf !== "undefined") to._pf = from._pf;
        if (typeof from._locale !== "undefined") to._locale = from._locale;
        if (momentProperties.length > 0)
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !==
                    "undefined") to[prop] = val
            }
        return to
    }

    function absRound(number) {
        if (number < 0) return Math.ceil(number);
        else return Math.floor(number)
    }

    function leftZeroFill(number, targetLength, forceSign) {
        var output = "" + Math.abs(number),
            sign = number >= 0;
        while (output.length < targetLength) output = "0" + output;
        return (sign ? forceSign ? "+" : "" : "-") + output
    }

    function positiveMomentsDifference(base, other) {
        var res = {
            milliseconds: 0,
            months: 0
        };
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) --res.months;
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res
    }

    function momentsDifference(base, other) {
        var res;
        other = makeAs(other, base);
        if (base.isBefore(other)) res = positiveMomentsDifference(base, other);
        else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months
        }
        return res
    }

    function createAdder(direction, name) {
        return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." +
                    name + "(number, period).");
                tmp = val;
                val = period;
                period = tmp
            }
            val = typeof val === "string" ? +val : val;
            dur = moment.duration(val, period);
            addOrSubtractDurationFromMoment(this, dur, direction);
            return this
        }
    }

    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;
        if (milliseconds) mom._d.setTime(+mom._d + milliseconds * isAdding);
        if (days) rawSetter(mom, "Date", rawGetter(mom,
            "Date") + days * isAdding);
        if (months) rawMonthSetter(mom, rawGetter(mom, "Month") + months * isAdding);
        if (updateOffset) moment.updateOffset(mom, days || months)
    }

    function isArray(input) {
        return Object.prototype.toString.call(input) === "[object Array]"
    }

    function isDate(input) {
        return Object.prototype.toString.call(input) === "[object Date]" || input instanceof Date
    }

    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i =
            0; i < len; i++)
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) diffs++;
        return diffs + lengthDiff
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, "$1");
            units = unitAliases[units] || camelFunctions[lowered] || lowered
        }
        return units
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp, prop;
        for (prop in inputObject)
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) normalizedInput[normalizedProp] =
                    inputObject[prop]
            }
        return normalizedInput
    }

    function makeList(field) {
        var count, setter;
        if (field.indexOf("week") === 0) {
            count = 7;
            setter = "day"
        } else if (field.indexOf("month") === 0) {
            count = 12;
            setter = "month"
        } else return;
        moment[field] = function(format, index) {
            var i, getter, method = moment._locale[field],
                results = [];
            if (typeof format === "number") {
                index = format;
                format = undefined
            }
            getter = function(i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment._locale, m, format || "")
            };
            if (index != null) return getter(index);
            else {
                for (i =
                    0; i < count; i++) results.push(getter(i));
                return results
            }
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber))
            if (coercedNumber >= 0) value = Math.floor(coercedNumber);
            else value = Math.ceil(coercedNumber);
        return value
    }

    function daysInMonth(year, month) {
        return (new Date(Date.UTC(year, month + 1, 0))).getUTCDate()
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week
    }

    function daysInYear(year) {
        return isLeapYear(year) ?
            366 : 365
    }

    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow = m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH : m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE : m._a[HOUR] < 0 || m._a[HOUR] > 24 || m._a[HOUR] === 24 && (m._a[MINUTE] !== 0 || m._a[SECOND] !== 0 || m._a[MILLISECOND] !== 0) ? HOUR : m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE : m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND : m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;
            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) overflow = DATE;
            m._pf.overflow = overflow
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) && m._pf.overflow < 0 && !m._pf.empty && !m._pf.invalidMonth && !m._pf.nullInput && !m._pf.invalidFormat && !m._pf.userInvalidated;
            if (m._strict) m._isValid = m._isValid && m._pf.charsLeftOver === 0 && m._pf.unusedTokens.length === 0 && m._pf.bigHour === undefined
        }
        return m._isValid
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_",
            "-") : key
    }

    function chooseLocale(names) {
        var i = 0,
            j, next, locale, split;
        while (i < names.length) {
            split = normalizeLocale(names[i]).split("-");
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join("-"));
                if (locale) return locale;
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) break;
                j--
            }
            i++
        }
        return null
    }

    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && hasModule) try {
            oldLocale = moment.locale();
            require("./locale/" +
                name);
            moment.locale(oldLocale)
        } catch (e) {}
        return locales[name]
    }

    function makeAs(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (moment.isMoment(input) || isDate(input) ? +input : +moment(input)) - +res;
            res._d.setTime(+res._d + diff);
            moment.updateOffset(res, false);
            return res
        } else return moment(input).local()
    }
    extend(Locale.prototype, {
        set: function(config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === "function") this[i] = prop;
                else this["_" + i] = prop
            }
            this._ordinalParseLenient = new RegExp(this._ordinalParse.source +
                "|" + /\d{1,2}/.source)
        },
        _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months: function(m) {
            return this._months[m.month()]
        },
        _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort: function(m) {
            return this._monthsShort[m.month()]
        },
        monthsParse: function(monthName, format, strict) {
            var i, mom, regex;
            if (!this._monthsParse) {
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = []
            }
            for (i = 0; i < 12; i++) {
                mom = moment.utc([2E3,
                    i
                ]);
                if (strict && !this._longMonthsParse[i]) {
                    this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
                    this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i")
                }
                if (!strict && !this._monthsParse[i]) {
                    regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                    this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i")
                }
                if (strict && format === "MMMM" && this._longMonthsParse[i].test(monthName)) return i;
                else if (strict && format === "MMM" && this._shortMonthsParse[i].test(monthName)) return i;
                else if (!strict && this._monthsParse[i].test(monthName)) return i
            }
        },
        _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays: function(m) {
            return this._weekdays[m.day()]
        },
        _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort: function(m) {
            return this._weekdaysShort[m.day()]
        },
        _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin: function(m) {
            return this._weekdaysMin[m.day()]
        },
        weekdaysParse: function(weekdayName) {
            var i, mom, regex;
            if (!this._weekdaysParse) this._weekdaysParse = [];
            for (i = 0; i < 7; i++) {
                if (!this._weekdaysParse[i]) {
                    mom = moment([2E3, 1]).day(i);
                    regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
                    this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i")
                }
                if (this._weekdaysParse[i].test(weekdayName)) return i
            }
        },
        _longDateFormat: {
            LTS: "h:mm:ss A",
            LT: "h:mm A",
            L: "MM/DD/YYYY",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY LT",
            LLLL: "dddd, MMMM D, YYYY LT"
        },
        longDateFormat: function(key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output =
                    this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function(val) {
                        return val.slice(1)
                    });
                this._longDateFormat[key] = output
            }
            return output
        },
        isPM: function(input) {
            return (input + "").toLowerCase().charAt(0) === "p"
        },
        _meridiemParse: /[ap]\.?m?\.?/i,
        meridiem: function(hours, minutes, isLower) {
            if (hours > 11) return isLower ? "pm" : "PM";
            else return isLower ? "am" : "AM"
        },
        _calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        calendar: function(key, mom, now) {
            var output = this._calendar[key];
            return typeof output === "function" ? output.apply(mom, [now]) : output
        },
        _relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        relativeTime: function(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return typeof output === "function" ? output(number, withoutSuffix, string,
                isFuture) : output.replace(/%d/i, number)
        },
        pastFuture: function(diff, output) {
            var format = this._relativeTime[diff > 0 ? "future" : "past"];
            return typeof format === "function" ? format(output) : format.replace(/%s/i, output)
        },
        ordinal: function(number) {
            return this._ordinal.replace("%d", number)
        },
        _ordinal: "%d",
        _ordinalParse: /\d{1,2}/,
        preparse: function(string) {
            return string
        },
        postformat: function(string) {
            return string
        },
        week: function(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week
        },
        _week: {
            dow: 0,
            doy: 6
        },
        firstDayOfWeek: function() {
            return this._week.dow
        },
        firstDayOfYear: function() {
            return this._week.doy
        },
        _invalidDate: "Invalid date",
        invalidDate: function() {
            return this._invalidDate
        }
    });

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) return input.replace(/^\[|\]$/g, "");
        return input.replace(/\\/g, "")
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i, length;
        for (i = 0, length = array.length; i < length; i++)
            if (formatTokenFunctions[array[i]]) array[i] = formatTokenFunctions[array[i]];
            else array[i] = removeFormattingTokens(array[i]);
        return function(mom) {
            var output = "";
            for (i = 0; i < length; i++) output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            return output
        }
    }

    function formatMoment(m, format) {
        if (!m.isValid()) return m.localeData().invalidDate();
        format = expandFormat(format, m.localeData());
        if (!formatFunctions[format]) formatFunctions[format] = makeFormatFunction(format);
        return formatFunctions[format](m)
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) ||
                input
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1
        }
        return format
    }

    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
            case "Q":
                return parseTokenOneDigit;
            case "DDDD":
                return parseTokenThreeDigits;
            case "YYYY":
            case "GGGG":
            case "gggg":
                return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
            case "Y":
            case "G":
            case "g":
                return parseTokenSignedNumber;
            case "YYYYYY":
            case "YYYYY":
            case "GGGGG":
            case "ggggg":
                return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
            case "S":
                if (strict) return parseTokenOneDigit;
            case "SS":
                if (strict) return parseTokenTwoDigits;
            case "SSS":
                if (strict) return parseTokenThreeDigits;
            case "DDD":
                return parseTokenOneToThreeDigits;
            case "MMM":
            case "MMMM":
            case "dd":
            case "ddd":
            case "dddd":
                return parseTokenWord;
            case "a":
            case "A":
                return config._locale._meridiemParse;
            case "x":
                return parseTokenOffsetMs;
            case "X":
                return parseTokenTimestampMs;
            case "Z":
            case "ZZ":
                return parseTokenTimezone;
            case "T":
                return parseTokenT;
            case "SSSS":
                return parseTokenDigits;
            case "MM":
            case "DD":
            case "YY":
            case "GG":
            case "gg":
            case "HH":
            case "hh":
            case "mm":
            case "ss":
            case "ww":
            case "WW":
                return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
            case "M":
            case "D":
            case "d":
            case "H":
            case "h":
            case "m":
            case "s":
            case "w":
            case "W":
            case "e":
            case "E":
                return parseTokenOneOrTwoDigits;
            case "Do":
                return strict ? config._locale._ordinalParse : config._locale._ordinalParseLenient;
            default:
                a =
                    new RegExp(regexpEscape(unescapeFormat(token.replace("\\", "")), "i"));
                return a
        }
    }

    function utcOffsetFromString(string) {
        string = string || "";
        var possibleTzMatches = string.match(parseTokenTimezone) || [],
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + "").match(parseTimezoneChunker) || ["-", 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);
        return parts[0] === "+" ? minutes : -minutes
    }

    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;
        switch (token) {
            case "Q":
                if (input !=
                    null) datePartArray[MONTH] = (toInt(input) - 1) * 3;
                break;
            case "M":
            case "MM":
                if (input != null) datePartArray[MONTH] = toInt(input) - 1;
                break;
            case "MMM":
            case "MMMM":
                a = config._locale.monthsParse(input, token, config._strict);
                if (a != null) datePartArray[MONTH] = a;
                else config._pf.invalidMonth = input;
                break;
            case "D":
            case "DD":
                if (input != null) datePartArray[DATE] = toInt(input);
                break;
            case "Do":
                if (input != null) datePartArray[DATE] = toInt(parseInt(input.match(/\d{1,2}/)[0], 10));
                break;
            case "DDD":
            case "DDDD":
                if (input != null) config._dayOfYear =
                    toInt(input);
                break;
            case "YY":
                datePartArray[YEAR] = moment.parseTwoDigitYear(input);
                break;
            case "YYYY":
            case "YYYYY":
            case "YYYYYY":
                datePartArray[YEAR] = toInt(input);
                break;
            case "a":
            case "A":
                config._meridiem = input;
                break;
            case "h":
            case "hh":
                config._pf.bigHour = true;
            case "H":
            case "HH":
                datePartArray[HOUR] = toInt(input);
                break;
            case "m":
            case "mm":
                datePartArray[MINUTE] = toInt(input);
                break;
            case "s":
            case "ss":
                datePartArray[SECOND] = toInt(input);
                break;
            case "S":
            case "SS":
            case "SSS":
            case "SSSS":
                datePartArray[MILLISECOND] =
                    toInt(("0." + input) * 1E3);
                break;
            case "x":
                config._d = new Date(toInt(input));
                break;
            case "X":
                config._d = new Date(parseFloat(input) * 1E3);
                break;
            case "Z":
            case "ZZ":
                config._useUTC = true;
                config._tzm = utcOffsetFromString(input);
                break;
            case "dd":
            case "ddd":
            case "dddd":
                a = config._locale.weekdaysParse(input);
                if (a != null) {
                    config._w = config._w || {};
                    config._w["d"] = a
                } else config._pf.invalidWeekday = input;
                break;
            case "w":
            case "ww":
            case "W":
            case "WW":
            case "d":
            case "e":
            case "E":
                token = token.substr(0, 1);
            case "gggg":
            case "GGGG":
            case "GGGGG":
                token =
                    token.substr(0, 2);
                if (input) {
                    config._w = config._w || {};
                    config._w[token] = toInt(input)
                }
                break;
            case "gg":
            case "GG":
                config._w = config._w || {};
                config._w[token] = moment.parseTwoDigitYear(input)
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
            week = dfl(w.W, 1);
            weekday = dfl(w.E, 1)
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            weekYear = dfl(w.gg,
                config._a[YEAR], weekOfYear(moment(), dow, doy).year);
            week = dfl(w.w, 1);
            if (w.d != null) {
                weekday = w.d;
                if (weekday < dow) ++week
            } else if (w.e != null) weekday = w.e + dow;
            else weekday = dow
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear
    }

    function dateFromConfig(config) {
        var i, date, input = [],
            currentDate, yearToUse;
        if (config._d) return;
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) dayOfYearFromWeekInfo(config);
        if (config._dayOfYear) {
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse)) config._pf._overflowDayOfYear = true;
            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate()
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) config._a[i] = input[i] = currentDate[i];
        for (; i < 7; i++) config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] ===
            0) {
            config._nextDay = true;
            config._a[HOUR] = 0
        }
        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
        if (config._tzm != null) config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        if (config._nextDay) config._a[HOUR] = 24
    }

    function dateFromObject(config) {
        var normalizedInput;
        if (config._d) return;
        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [normalizedInput.year, normalizedInput.month, normalizedInput.day || normalizedInput.date, normalizedInput.hour, normalizedInput.minute, normalizedInput.second,
            normalizedInput.millisecond
        ];
        dateFromConfig(config)
    }

    function currentDateArray(config) {
        var now = new Date;
        if (config._useUTC) return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
        else return [now.getFullYear(), now.getMonth(), now.getDate()]
    }

    function makeDateFromStringAndFormat(config) {
        if (config._f === moment.ISO_8601) {
            parseISO(config);
            return
        }
        config._a = [];
        config._pf.empty = true;
        var string = "" + config._i,
            i, parsedInput, tokens, token, skipped, stringLength = string.length,
            totalParsedInputLength = 0;
        tokens = expandFormat(config._f,
            config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) config._pf.unusedInput.push(skipped);
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length
            }
            if (formatTokenFunctions[token]) {
                if (parsedInput) config._pf.empty = false;
                else config._pf.unusedTokens.push(token);
                addTimeToArrayFromToken(token, parsedInput, config)
            } else if (config._strict && !parsedInput) config._pf.unusedTokens.push(token)
        }
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) config._pf.unusedInput.push(string);
        if (config._pf.bigHour === true && config._a[HOUR] <= 12) config._pf.bigHour = undefined;
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        dateFromConfig(config);
        checkOverflow(config)
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
                return p1 || p2 || p3 || p4
            })
    }

    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
    }

    function makeDateFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return
        }
        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) tempConfig._useUTC = config._useUTC;
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f =
                config._f[i];
            makeDateFromStringAndFormat(tempConfig);
            if (!isValid(tempConfig)) continue;
            currentScore += tempConfig._pf.charsLeftOver;
            currentScore += tempConfig._pf.unusedTokens.length * 10;
            tempConfig._pf.score = currentScore;
            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig
            }
        }
        extend(config, bestMoment || tempConfig)
    }

    function parseISO(config) {
        var i, l, string = config._i,
            match = isoRegex.exec(string);
        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++)
                if (isoDates[i][1].exec(string)) {
                    config._f =
                        isoDates[i][0] + (match[6] || " ");
                    break
                }
            for (i = 0, l = isoTimes.length; i < l; i++)
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break
                }
            if (string.match(parseTokenTimezone)) config._f += "Z";
            makeDateFromStringAndFormat(config)
        } else config._isValid = false
    }

    function makeDateFromString(config) {
        parseISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            moment.createFromInputFallback(config)
        }
    }

    function map(arr, fn) {
        var res = [],
            i;
        for (i = 0; i < arr.length; ++i) res.push(fn(arr[i], i));
        return res
    }

    function makeDateFromInput(config) {
        var input =
            config._i,
            matched;
        if (input === undefined) config._d = new Date;
        else if (isDate(input)) config._d = new Date(+input);
        else if ((matched = aspNetJsonRegex.exec(input)) !== null) config._d = new Date(+matched[1]);
        else if (typeof input === "string") makeDateFromString(config);
        else if (isArray(input)) {
            config._a = map(input.slice(0), function(obj) {
                return parseInt(obj, 10)
            });
            dateFromConfig(config)
        } else if (typeof input === "object") dateFromObject(config);
        else if (typeof input === "number") config._d = new Date(input);
        else moment.createFromInputFallback(config)
    }

    function makeDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms);
        if (y < 1970) date.setFullYear(y);
        return date
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) date.setUTCFullYear(y);
        return date
    }

    function parseWeekday(input, locale) {
        if (typeof input === "string")
            if (!isNaN(input)) input = parseInt(input, 10);
            else {
                input = locale.weekdaysParse(input);
                if (typeof input !== "number") return null
            }
        return input
    }

    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number ||
            1, !!withoutSuffix, string, isFuture)
    }

    function relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = moment.duration(posNegDuration).abs(),
            seconds = round(duration.as("s")),
            minutes = round(duration.as("m")),
            hours = round(duration.as("h")),
            days = round(duration.as("d")),
            months = round(duration.as("M")),
            years = round(duration.as("y")),
            args = seconds < relativeTimeThresholds.s && ["s", seconds] || minutes === 1 && ["m"] || minutes < relativeTimeThresholds.m && ["mm", minutes] || hours === 1 && ["h"] || hours < relativeTimeThresholds.h && ["hh", hours] || days === 1 && ["d"] || days < relativeTimeThresholds.d && ["dd", days] || months === 1 && ["M"] || months < relativeTimeThresholds.M && ["MM", months] || years === 1 && ["y"] || ["yy", years];
        args[2] = withoutSuffix;
        args[3] = +posNegDuration > 0;
        args[4] = locale;
        return substituteTimeAgo.apply({}, args)
    }

    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;
        if (daysToDayOfWeek > end) daysToDayOfWeek -= 7;
        if (daysToDayOfWeek <
            end - 7) daysToDayOfWeek += 7;
        adjustedMoment = moment(mom).add(daysToDayOfWeek, "d");
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        }
    }

    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(),
            daysToAdd, dayOfYear;
        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
        return {
            year: dayOfYear >
                0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        }
    }

    function makeMoment(config) {
        var input = config._i,
            format = config._f,
            res;
        config._locale = config._locale || moment.localeData(config._l);
        if (input === null || format === undefined && input === "") return moment.invalid({
            nullInput: true
        });
        if (typeof input === "string") config._i = input = config._locale.preparse(input);
        if (moment.isMoment(input)) return new Moment(input, true);
        else if (format)
            if (isArray(format)) makeDateFromStringAndArray(config);
            else makeDateFromStringAndFormat(config);
        else makeDateFromInput(config);
        res = new Moment(config);
        if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = undefined
        }
        return res
    }
    moment = function(input, format, locale, strict) {
        var c;
        if (typeof locale === "boolean") {
            strict = locale;
            locale = undefined
        }
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = locale;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();
        return makeMoment(c)
    };
    moment.suppressDeprecationWarnings = false;
    moment.createFromInputFallback = deprecate("moment construction falls back to js Date. This is " +
        "discouraged and will be removed in upcoming major " + "release. Please refer to " + "https://github.com/moment/moment/issues/1407 for more info.",
        function(config) {
            config._d = new Date(config._i + (config._useUTC ? " UTC" : ""))
        });

    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) moments = moments[0];
        if (!moments.length) return moment();
        res = moments[0];
        for (i = 1; i < moments.length; ++i)
            if (moments[i][fn](res)) res = moments[i];
        return res
    }
    moment.min = function() {
        var args = [].slice.call(arguments,
            0);
        return pickBy("isBefore", args)
    };
    moment.max = function() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args)
    };
    moment.utc = function(input, format, locale, strict) {
        var c;
        if (typeof locale === "boolean") {
            strict = locale;
            locale = undefined
        }
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();
        return makeMoment(c).utc()
    };
    moment.unix = function(input) {
        return moment(input * 1E3)
    };
    moment.duration = function(input, key) {
        var duration =
            input,
            match = null,
            sign, ret, parseIso, diffRes;
        if (moment.isDuration(input)) duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
        };
        else if (typeof input === "number") {
            duration = {};
            if (key) duration[key] = input;
            else duration.milliseconds = input
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            }
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign =
                match[1] === "-" ? -1 : 1;
            parseIso = function(inp) {
                var res = inp && parseFloat(inp.replace(",", "."));
                return (isNaN(res) ? 0 : res) * sign
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            }
        } else if (duration == null) duration = {};
        else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(moment(duration.from), moment(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months
        }
        ret = new Duration(duration);
        if (moment.isDuration(input) && hasOwnProp(input, "_locale")) ret._locale = input._locale;
        return ret
    };
    moment.version = VERSION;
    moment.defaultFormat = isoFormat;
    moment.ISO_8601 = function() {};
    moment.momentProperties = momentProperties;
    moment.updateOffset = function() {};
    moment.relativeTimeThreshold = function(threshold, limit) {
        if (relativeTimeThresholds[threshold] === undefined) return false;
        if (limit === undefined) return relativeTimeThresholds[threshold];
        relativeTimeThresholds[threshold] =
            limit;
        return true
    };
    moment.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", function(key, value) {
        return moment.locale(key, value)
    });
    moment.locale = function(key, values) {
        var data;
        if (key) {
            if (typeof values !== "undefined") data = moment.defineLocale(key, values);
            else data = moment.localeData(key);
            if (data) moment.duration._locale = moment._locale = data
        }
        return moment._locale._abbr
    };
    moment.defineLocale = function(name, values) {
        if (values !== null) {
            values.abbr = name;
            if (!locales[name]) locales[name] = new Locale;
            locales[name].set(values);
            moment.locale(name);
            return locales[name]
        } else {
            delete locales[name];
            return null
        }
    };
    moment.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", function(key) {
        return moment.localeData(key)
    });
    moment.localeData = function(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) key = key._locale._abbr;
        if (!key) return moment._locale;
        if (!isArray(key)) {
            locale = loadLocale(key);
            if (locale) return locale;
            key = [key]
        }
        return chooseLocale(key)
    };
    moment.isMoment = function(obj) {
        return obj instanceof
        Moment || obj != null && hasOwnProp(obj, "_isAMomentObject")
    };
    moment.isDuration = function(obj) {
        return obj instanceof Duration
    };
    for (i = lists.length - 1; i >= 0; --i) makeList(lists[i]);
    moment.normalizeUnits = function(units) {
        return normalizeUnits(units)
    };
    moment.invalid = function(flags) {
        var m = moment.utc(NaN);
        if (flags != null) extend(m._pf, flags);
        else m._pf.userInvalidated = true;
        return m
    };
    moment.parseZone = function() {
        return moment.apply(null, arguments).parseZone()
    };
    moment.parseTwoDigitYear = function(input) {
        return toInt(input) +
            (toInt(input) > 68 ? 1900 : 2E3)
    };
    moment.isDate = isDate;
    extend(moment.fn = Moment.prototype, {
        clone: function() {
            return moment(this)
        },
        valueOf: function() {
            return +this._d - (this._offset || 0) * 6E4
        },
        unix: function() {
            return Math.floor(+this / 1E3)
        },
        toString: function() {
            return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
        },
        toDate: function() {
            return this._offset ? new Date(+this) : this._d
        },
        toISOString: function() {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999)
                if ("function" === typeof Date.prototype.toISOString) return this.toDate().toISOString();
                else return formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
            else return formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")
        },
        toArray: function() {
            var m = this;
            return [m.year(), m.month(), m.date(), m.hours(), m.minutes(), m.seconds(), m.milliseconds()]
        },
        isValid: function() {
            return isValid(this)
        },
        isDSTShifted: function() {
            if (this._a) return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            return false
        },
        parsingFlags: function() {
            return extend({}, this._pf)
        },
        invalidAt: function() {
            return this._pf.overflow
        },
        utc: function(keepLocalTime) {
            return this.utcOffset(0, keepLocalTime)
        },
        local: function(keepLocalTime) {
            if (this._isUTC) {
                this.utcOffset(0, keepLocalTime);
                this._isUTC = false;
                if (keepLocalTime) this.subtract(this._dateUtcOffset(), "m")
            }
            return this
        },
        format: function(inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.localeData().postformat(output)
        },
        add: createAdder(1, "add"),
        subtract: createAdder(-1, "subtract"),
        diff: function(input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff =
                (that.utcOffset() - this.utcOffset()) * 6E4,
                anchor, diff, output, daysAdjust;
            units = normalizeUnits(units);
            if (units === "year" || units === "month" || units === "quarter") {
                output = monthDiff(this, that);
                if (units === "quarter") output = output / 3;
                else if (units === "year") output = output / 12
            } else {
                diff = this - that;
                output = units === "second" ? diff / 1E3 : units === "minute" ? diff / 6E4 : units === "hour" ? diff / 36E5 : units === "day" ? (diff - zoneDiff) / 864E5 : units === "week" ? (diff - zoneDiff) / 6048E5 : diff
            }
            return asFloat ? output : absRound(output)
        },
        from: function(time, withoutSuffix) {
            return moment.duration({
                to: this,
                from: time
            }).locale(this.locale()).humanize(!withoutSuffix)
        },
        fromNow: function(withoutSuffix) {
            return this.from(moment(), withoutSuffix)
        },
        calendar: function(time) {
            var now = time || moment(),
                sod = makeAs(now, this).startOf("day"),
                diff = this.diff(sod, "days", true),
                format = diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
            return this.format(this.localeData().calendar(format, this, moment(now)))
        },
        isLeapYear: function() {
            return isLeapYear(this.year())
        },
        isDST: function() {
            return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
        },
        day: function(input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, "d")
            } else return day
        },
        month: makeAccessor("Month", true),
        startOf: function(units) {
            units = normalizeUnits(units);
            switch (units) {
                case "year":
                    this.month(0);
                case "quarter":
                case "month":
                    this.date(1);
                case "week":
                case "isoWeek":
                case "day":
                    this.hours(0);
                case "hour":
                    this.minutes(0);
                case "minute":
                    this.seconds(0);
                case "second":
                    this.milliseconds(0)
            }
            if (units === "week") this.weekday(0);
            else if (units === "isoWeek") this.isoWeekday(1);
            if (units === "quarter") this.month(Math.floor(this.month() / 3) * 3);
            return this
        },
        endOf: function(units) {
            units = normalizeUnits(units);
            if (units === undefined || units === "millisecond") return this;
            return this.startOf(units).add(1, units === "isoWeek" ? "week" : units).subtract(1, "ms")
        },
        isAfter: function(input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !==
                "undefined" ? units : "millisecond");
            if (units === "millisecond") {
                input = moment.isMoment(input) ? input : moment(input);
                return +this > +input
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return inputMs < +this.clone().startOf(units)
            }
        },
        isBefore: function(input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== "undefined" ? units : "millisecond");
            if (units === "millisecond") {
                input = moment.isMoment(input) ? input : moment(input);
                return +this < +input
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return +this.clone().endOf(units) <
                    inputMs
            }
        },
        isBetween: function(from, to, units) {
            return this.isAfter(from, units) && this.isBefore(to, units)
        },
        isSame: function(input, units) {
            var inputMs;
            units = normalizeUnits(units || "millisecond");
            if (units === "millisecond") {
                input = moment.isMoment(input) ? input : moment(input);
                return +this === +input
            } else {
                inputMs = +moment(input);
                return +this.clone().startOf(units) <= inputMs && inputMs <= +this.clone().endOf(units)
            }
        },
        min: deprecate("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548",
            function(other) {
                other = moment.apply(null, arguments);
                return other < this ? this : other
            }),
        max: deprecate("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548", function(other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other
        }),
        zone: deprecate("moment().zone is deprecated, use moment().utcOffset instead. " + "https://github.com/moment/moment/issues/1779", function(input, keepLocalTime) {
            if (input != null) {
                if (typeof input !== "string") input = -input;
                this.utcOffset(input,
                    keepLocalTime);
                return this
            } else return -this.utcOffset()
        }),
        utcOffset: function(input, keepLocalTime) {
            var offset = this._offset || 0,
                localAdjust;
            if (input != null) {
                if (typeof input === "string") input = utcOffsetFromString(input);
                if (Math.abs(input) < 16) input = input * 60;
                if (!this._isUTC && keepLocalTime) localAdjust = this._dateUtcOffset();
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) this.add(localAdjust, "m");
                if (offset !== input)
                    if (!keepLocalTime || this._changeInProgress) addOrSubtractDurationFromMoment(this, moment.duration(input -
                        offset, "m"), 1, false);
                    else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    moment.updateOffset(this, true);
                    this._changeInProgress = null
                }
                return this
            } else return this._isUTC ? offset : this._dateUtcOffset()
        },
        isLocal: function() {
            return !this._isUTC
        },
        isUtcOffset: function() {
            return this._isUTC
        },
        isUtc: function() {
            return this._isUTC && this._offset === 0
        },
        zoneAbbr: function() {
            return this._isUTC ? "UTC" : ""
        },
        zoneName: function() {
            return this._isUTC ? "Coordinated Universal Time" : ""
        },
        parseZone: function() {
            if (this._tzm) this.utcOffset(this._tzm);
            else if (typeof this._i === "string") this.utcOffset(utcOffsetFromString(this._i));
            return this
        },
        hasAlignedHourOffset: function(input) {
            if (!input) input = 0;
            else input = moment(input).utcOffset();
            return (this.utcOffset() - input) % 60 === 0
        },
        daysInMonth: function() {
            return daysInMonth(this.year(), this.month())
        },
        dayOfYear: function(input) {
            var dayOfYear = round((moment(this).startOf("day") - moment(this).startOf("year")) / 864E5) + 1;
            return input == null ? dayOfYear : this.add(input - dayOfYear, "d")
        },
        quarter: function(input) {
            return input ==
                null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3)
        },
        weekYear: function(input) {
            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
            return input == null ? year : this.add(input - year, "y")
        },
        isoWeekYear: function(input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add(input - year, "y")
        },
        week: function(input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, "d")
        },
        isoWeek: function(input) {
            var week = weekOfYear(this,
                1, 4).week;
            return input == null ? week : this.add((input - week) * 7, "d")
        },
        weekday: function(input) {
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, "d")
        },
        isoWeekday: function(input) {
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7)
        },
        isoWeeksInYear: function() {
            return weeksInYear(this.year(), 1, 4)
        },
        weeksInYear: function() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy)
        },
        get: function(units) {
            units =
                normalizeUnits(units);
            return this[units]()
        },
        set: function(units, value) {
            var unit;
            if (typeof units === "object")
                for (unit in units) this.set(unit, units[unit]);
            else {
                units = normalizeUnits(units);
                if (typeof this[units] === "function") this[units](value)
            }
            return this
        },
        locale: function(key) {
            var newLocaleData;
            if (key === undefined) return this._locale._abbr;
            else {
                newLocaleData = moment.localeData(key);
                if (newLocaleData != null) this._locale = newLocaleData;
                return this
            }
        },
        lang: deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
            function(key) {
                if (key === undefined) return this.localeData();
                else return this.locale(key)
            }),
        localeData: function() {
            return this._locale
        },
        _dateUtcOffset: function() {
            return -Math.round(this._d.getTimezoneOffset() / 15) * 15
        }
    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;
        if (typeof value === "string") {
            value = mom.localeData().monthsParse(value);
            if (typeof value !== "number") return mom
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom
    }

    function rawGetter(mom, unit) {
        return mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]()
    }

    function rawSetter(mom, unit, value) {
        if (unit === "Month") return rawMonthSetter(mom, value);
        else return mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value)
    }

    function makeAccessor(unit, keepTime) {
        return function(value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this
            } else return rawGetter(this, unit)
        }
    }
    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor("Milliseconds", false);
    moment.fn.second =
        moment.fn.seconds = makeAccessor("Seconds", false);
    moment.fn.minute = moment.fn.minutes = makeAccessor("Minutes", false);
    moment.fn.hour = moment.fn.hours = makeAccessor("Hours", true);
    moment.fn.date = makeAccessor("Date", true);
    moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor("Date", true));
    moment.fn.year = makeAccessor("FullYear", true);
    moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor("FullYear", true));
    moment.fn.days = moment.fn.day;
    moment.fn.months =
        moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;
    moment.fn.toJSON = moment.fn.toISOString;
    moment.fn.isUTC = moment.fn.isUtc;

    function daysToYears(days) {
        return days * 400 / 146097
    }

    function yearsToDays(years) {
        return years * 146097 / 400
    }
    extend(moment.duration.fn = Duration.prototype, {
        _bubble: function() {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years = 0;
            data.milliseconds = milliseconds %
                1E3;
            seconds = absRound(milliseconds / 1E3);
            data.seconds = seconds % 60;
            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;
            hours = absRound(minutes / 60);
            data.hours = hours % 24;
            days += absRound(hours / 24);
            years = absRound(daysToYears(days));
            days -= absRound(yearsToDays(years));
            months += absRound(days / 30);
            days %= 30;
            years += absRound(months / 12);
            months %= 12;
            data.days = days;
            data.months = months;
            data.years = years
        },
        abs: function() {
            this._milliseconds = Math.abs(this._milliseconds);
            this._days = Math.abs(this._days);
            this._months = Math.abs(this._months);
            this._data.milliseconds = Math.abs(this._data.milliseconds);
            this._data.seconds = Math.abs(this._data.seconds);
            this._data.minutes = Math.abs(this._data.minutes);
            this._data.hours = Math.abs(this._data.hours);
            this._data.months = Math.abs(this._data.months);
            this._data.years = Math.abs(this._data.years);
            return this
        },
        weeks: function() {
            return absRound(this.days() / 7)
        },
        valueOf: function() {
            return this._milliseconds + this._days * 864E5 + this._months % 12 * 2592E6 + toInt(this._months / 12) * 31536E6
        },
        humanize: function(withSuffix) {
            var output =
                relativeTime(this, !withSuffix, this.localeData());
            if (withSuffix) output = this.localeData().pastFuture(+this, output);
            return this.localeData().postformat(output)
        },
        add: function(input, val) {
            var dur = moment.duration(input, val);
            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;
            this._bubble();
            return this
        },
        subtract: function(input, val) {
            var dur = moment.duration(input, val);
            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;
            this._bubble();
            return this
        },
        get: function(units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + "s"]()
        },
        as: function(units) {
            var days, months;
            units = normalizeUnits(units);
            if (units === "month" || units === "year") {
                days = this._days + this._milliseconds / 864E5;
                months = this._months + daysToYears(days) * 12;
                return units === "month" ? months : months / 12
            } else {
                days = this._days + Math.round(yearsToDays(this._months / 12));
                switch (units) {
                    case "week":
                        return days / 7 + this._milliseconds / 6048E5;
                    case "day":
                        return days + this._milliseconds / 864E5;
                    case "hour":
                        return days *
                            24 + this._milliseconds / 36E5;
                    case "minute":
                        return days * 24 * 60 + this._milliseconds / 6E4;
                    case "second":
                        return days * 24 * 60 * 60 + this._milliseconds / 1E3;
                    case "millisecond":
                        return Math.floor(days * 24 * 60 * 60 * 1E3) + this._milliseconds;
                    default:
                        throw new Error("Unknown unit " + units);
                }
            }
        },
        lang: moment.fn.lang,
        locale: moment.fn.locale,
        toIsoString: deprecate("toIsoString() is deprecated. Please use toISOString() instead " + "(notice the capitals)", function() {
            return this.toISOString()
        }),
        toISOString: function() {
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1E3);
            if (!this.asSeconds()) return "P0D";
            return (this.asSeconds() < 0 ? "-" : "") + "P" + (years ? years + "Y" : "") + (months ? months + "M" : "") + (days ? days + "D" : "") + (hours || minutes || seconds ? "T" : "") + (hours ? hours + "H" : "") + (minutes ? minutes + "M" : "") + (seconds ? seconds + "S" : "")
        },
        localeData: function() {
            return this._locale
        },
        toJSON: function() {
            return this.toISOString()
        }
    });
    moment.duration.fn.toString = moment.duration.fn.toISOString;

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function() {
            return this._data[name]
        }
    }
    for (i in unitMillisecondFactors)
        if (hasOwnProp(unitMillisecondFactors, i)) makeDurationGetter(i.toLowerCase());
    moment.duration.fn.asMilliseconds = function() {
        return this.as("ms")
    };
    moment.duration.fn.asSeconds = function() {
        return this.as("s")
    };
    moment.duration.fn.asMinutes = function() {
        return this.as("m")
    };
    moment.duration.fn.asHours = function() {
        return this.as("h")
    };
    moment.duration.fn.asDays = function() {
        return this.as("d")
    };
    moment.duration.fn.asWeeks = function() {
        return this.as("weeks")
    };
    moment.duration.fn.asMonths = function() {
        return this.as("M")
    };
    moment.duration.fn.asYears = function() {
        return this.as("y")
    };
    moment.locale("en", {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10,
                output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output
        }
    });

    function makeGlobal(shouldDeprecate) {
        if (typeof ender !== "undefined") return;
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) globalScope.moment = deprecate("Accessing Moment through the global scope is " + "deprecated, and will be removed in an upcoming " + "release.", moment);
        else globalScope.moment = moment
    }
    if (hasModule) module.exports = moment;
    else if (typeof define === "function" && define.amd) {
        define(function(require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal === true) globalScope.moment = oldGlobalMoment;
            return moment
        });
        makeGlobal(true)
    } else makeGlobal()
}).call(this);
(function(factory) {
    if (typeof define === "function" && define.amd) define(["moment"], factory);
    else if (typeof exports === "object") module.exports = factory(require("../moment"));
    else factory((typeof global !== "undefined" ? global : this).moment)
})(function(moment) {
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            "m": ["eine Minute", "einer Minute"],
            "h": ["eine Stunde", "einer Stunde"],
            "d": ["ein Tag", "einem Tag"],
            "dd": [number + " Tage", number + " Tagen"],
            "M": ["ein Monat", "einem Monat"],
            "MM": [number +
                " Monate", number + " Monaten"
            ],
            "y": ["ein Jahr", "einem Jahr"],
            "yy": [number + " Jahre", number + " Jahren"]
        };
        return withoutSuffix ? format[key][0] : format[key][1]
    }
    return moment.defineLocale("de", {
        months: "Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
        monthsShort: "Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
        weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
        weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
        weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY LT",
            LLLL: "dddd, D. MMMM YYYY LT"
        },
        calendar: {
            sameDay: "[Heute um] LT [Uhr]",
            sameElse: "L",
            nextDay: "[Morgen um] LT [Uhr]",
            nextWeek: "dddd [um] LT [Uhr]",
            lastDay: "[Gestern um] LT [Uhr]",
            lastWeek: "[letzten] dddd [um] LT [Uhr]"
        },
        relativeTime: {
            future: "in %s",
            past: "vor %s",
            s: "ein paar Sekunden",
            m: processRelativeTime,
            mm: "%d Minuten",
            h: processRelativeTime,
            hh: "%d Stunden",
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    })
});
(function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" && typeof require === "function" ? factory(require("../moment")) : typeof define === "function" && define.amd ? define(["moment"], factory) : factory(global.moment)
})(this, function(moment) {
    var en = moment.defineLocale("en", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10,
                output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    return en
});
(function(root, factory) {
    var moment;
    if (typeof exports === "object") {
        try {
            moment = require("moment")
        } catch (e) {}
        module.exports = factory(moment)
    } else if (typeof define === "function" && define.amd) define(function(req) {
        var id = "moment";
        moment = req.defined && req.defined(id) ? req(id) : undefined;
        return factory(moment)
    });
    else root.Pikaday = factory(root.moment)
})(this, function(moment) {
    var hasMoment = typeof moment === "function",
        hasEventListeners = !!window.addEventListener,
        document = window.document,
        sto = window.setTimeout,
        addEvent =
        function(el, e, callback, capture) {
            if (hasEventListeners) el.addEventListener(e, callback, !!capture);
            else el.attachEvent("on" + e, callback)
        },
        removeEvent = function(el, e, callback, capture) {
            if (hasEventListeners) el.removeEventListener(e, callback, !!capture);
            else el.detachEvent("on" + e, callback)
        },
        fireEvent = function(el, eventName, data) {
            var ev;
            if (document.createEvent) {
                ev = document.createEvent("HTMLEvents");
                ev.initEvent(eventName, true, false);
                ev = extend(ev, data);
                el.dispatchEvent(ev)
            } else if (document.createEventObject) {
                ev =
                    document.createEventObject();
                ev = extend(ev, data);
                el.fireEvent("on" + eventName, ev)
            }
        },
        trim = function(str) {
            return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "")
        },
        hasClass = function(el, cn) {
            return (" " + el.className + " ").indexOf(" " + cn + " ") !== -1
        },
        addClass = function(el, cn) {
            if (!hasClass(el, cn)) el.className = el.className === "" ? cn : el.className + " " + cn
        },
        removeClass = function(el, cn) {
            el.className = trim((" " + el.className + " ").replace(" " + cn + " ", " "))
        },
        isArray = function(obj) {
            return /Array/.test(Object.prototype.toString.call(obj))
        },
        isDate = function(obj) {
            return /Date/.test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime())
        },
        isLeapYear = function(year) {
            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0
        },
        getDaysInMonth = function(year, month) {
            return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month]
        },
        setToStartOfDay = function(date) {
            if (isDate(date)) date.setHours(0, 0, 0, 0)
        },
        compareDates = function(a, b) {
            var _a = new Date(a.getTime());
            var _b = new Date(b.getTime());
            setToStartOfDay(_a);
            setToStartOfDay(_b);
            return _a.getTime() === _b.getTime()
        },
        extend = function(to, from, overwrite) {
            var prop, hasProp;
            for (prop in from) {
                hasProp = to[prop] !== undefined;
                if (hasProp && typeof from[prop] === "object" && from[prop].nodeName === undefined)
                    if (isDate(from[prop])) {
                        if (overwrite) to[prop] = new Date(from[prop].getTime())
                    } else if (isArray(from[prop])) {
                    if (overwrite) to[prop] = from[prop].slice(0)
                } else to[prop] = extend({}, from[prop], overwrite);
                else if (overwrite || !hasProp) to[prop] = from[prop]
            }
            return to
        },
        adjustCalendar = function(calendar) {
            if (calendar.month < 0) {
                calendar.year -= Math.ceil(Math.abs(calendar.month) /
                    12);
                calendar.month += 12
            }
            if (calendar.month > 11) {
                calendar.year += Math.floor(Math.abs(calendar.month) / 12);
                calendar.month -= 12
            }
            return calendar
        },
        defaults = {
            field: null,
            bound: undefined,
            position: "bottom left",
            format: null,
            inputFormats: null,
            defaultDate: null,
            setDefaultDate: false,
            firstDay: 0,
            minDate: null,
            maxDate: null,
            yearRange: 10,
            showWeekNumber: false,
            minYear: 0,
            maxYear: 9999,
            minMonth: undefined,
            maxMonth: undefined,
            isRTL: false,
            yearSuffix: "",
            showMonthAfterYear: false,
            numberOfMonths: 1,
            showTime: true,
            showSeconds: false,
            use24hour: false,
            mainCalendar: "left",
            container: undefined,
            i18n: {
                previousMonth: "Previous Month",
                nextMonth: "Next Month",
                months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                midnight: "Midnight",
                noon: "Noon"
            },
            onSelect: null,
            onOpen: null,
            onClose: null,
            onDraw: null
        },
        renderDayName = function(opts, day, abbr) {
            day += opts.firstDay;
            while (day >= 7) day -= 7;
            return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day]
        },
        renderDay = function(d, m, y, isSelected, isToday, isDisabled, isEmpty) {
            if (isEmpty) return '<td class="is-empty"></td>';
            var arr = [];
            if (isDisabled) arr.push("is-disabled");
            if (isToday) arr.push("is-today");
            if (isSelected) arr.push("is-selected");
            return '<td data-day="' + d + '" class="' + arr.join(" ") + '">' + '<button class="pika-button pika-day" type="button" ' + 'data-pika-year="' + y + '" data-pika-month="' + m + '" data-pika-day="' + d + '">' + d + "</button>" +
                "</td>"
        },
        renderWeek = function(d, m, y) {
            var onejan = new Date(y, 0, 1),
                weekNum = Math.ceil(((new Date(y, m, d) - onejan) / 864E5 + onejan.getDay() + 1) / 7);
            return '<td class="pika-week">' + weekNum + "</td>"
        },
        renderRow = function(days, isRTL) {
            return "<tr>" + (isRTL ? days.reverse() : days).join("") + "</tr>"
        },
        renderBody = function(rows) {
            return "<tbody>" + rows.join("") + "</tbody>"
        },
        renderHead = function(opts) {
            var i, arr = [];
            if (opts.showWeekNumber) arr.push("<th></th>");
            for (i = 0; i < 7; i++) arr.push('<th scope="col"><abbr title="' + renderDayName(opts,
                i) + '">' + renderDayName(opts, i, true) + "</abbr></th>");
            return "<thead>" + (opts.isRTL ? arr.reverse() : arr).join("") + "</thead>"
        },
        renderTitle = function(instance, c, year, month, refYear) {
            var i, j, arr, opts = instance._o,
                isMinYear = year === opts.minYear,
                isMaxYear = year === opts.maxYear,
                html = '<div class="pika-title">',
                monthHtml, yearHtml, prev = true,
                next = true;
            for (arr = [], i = 0; i < 12; i++) arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' + (i === month ? " selected" : "") + (isMinYear && i < opts.minMonth || isMaxYear && i > opts.maxMonth ? "disabled" :
                "") + ">" + opts.i18n.months[i] + "</option>");
            monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month">' + arr.join("") + "</select></div>";
            if (isArray(opts.yearRange)) {
                i = opts.yearRange[0];
                j = opts.yearRange[1] + 1
            } else {
                i = year - opts.yearRange;
                j = 1 + year + opts.yearRange
            }
            for (arr = []; i < j && i <= opts.maxYear; i++)
                if (i >= opts.minYear) arr.push('<option value="' + i + '"' + (i === year ? " selected" : "") + ">" + i + "</option>");
            yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year">' +
                arr.join("") + "</select></div>";
            if (opts.showMonthAfterYear) html += yearHtml + monthHtml;
            else html += monthHtml + yearHtml;
            if (isMinYear && (month === 0 || opts.minMonth >= month)) prev = false;
            if (isMaxYear && (month === 11 || opts.maxMonth <= month)) next = false;
            if (c === 0) html += '<button class="pika-prev' + (prev ? "" : " is-disabled") + '" type="button">' + opts.i18n.previousMonth + "</button>";
            if (c === instance._o.numberOfMonths - 1) html += '<button class="pika-next' + (next ? "" : " is-disabled") + '" type="button">' + opts.i18n.nextMonth + "</button>";
            return html +=
                "</div>"
        },
        renderTable = function(opts, data) {
            return '<table cellpadding="0" cellspacing="0" class="pika-table">' + renderHead(opts) + renderBody(data) + "</table>"
        },
        renderTimePicker = function(num_options, selected_val, select_class, display_func) {
            var to_return = '<td><select class="pika-select ' + select_class + '">';
            for (var i = 0; i < num_options; i++) to_return += '<option value="' + i + '" ' + (i == selected_val ? "selected" : "") + ">" + display_func(i) + "</option>";
            to_return += "</select></td>";
            return to_return
        },
        renderTime = function(hh, mm,
            ss, opts) {
            var to_return = '<table cellpadding="0" cellspacing="0" class="pika-time"><tbody><tr>' + renderTimePicker(24, hh, "pika-select-hour", function(i) {
                if (opts.use24hour) return i;
                else {
                    var to_return = i % 12 + (i < 12 ? " AM" : " PM");
                    if (to_return == "0 AM") return opts.i18n.midnight;
                    else if (to_return == "0 PM") return opts.i18n.noon;
                    else return to_return
                }
            }) + "<td>:</td>" + renderTimePicker(60, mm, "pika-select-minute", function(i) {
                if (i < 10) return "0" + i;
                return i
            });
            if (opts.showSeconds) to_return += "<td>:</td>" + renderTimePicker(60,
                ss, "pika-select-second",
                function(i) {
                    if (i < 10) return "0" + i;
                    return i
                });
            return to_return + "</tr></tbody></table>"
        },
        Pikaday = function(options) {
            var self = this,
                opts = self.config(options);
            self._onMouseDown = function(e) {
                if (!self._v) return;
                e = e || window.event;
                var target = e.target || e.srcElement;
                if (!target) return;
                if (!hasClass(target, "is-disabled"))
                    if (hasClass(target, "pika-button") && !hasClass(target, "is-empty")) {
                        var newDate = new Date(target.getAttribute("data-pika-year"), target.getAttribute("data-pika-month"), target.getAttribute("data-pika-day"));
                        if (self._d && opts.showTime) {
                            newDate.setHours(self._d.getHours());
                            newDate.setMinutes(self._d.getMinutes())
                        }
                        self.setDate(newDate);
                        if (opts.bound) sto(function() {
                            self.hide();
                            if (opts.field) opts.field.blur()
                        }, 100);
                        return
                    } else if (hasClass(target, "pika-prev")) self.prevMonth();
                else if (hasClass(target, "pika-next")) self.nextMonth();
                if (!hasClass(target, "pika-select"))
                    if (e.preventDefault) e.preventDefault();
                    else {
                        e.returnValue = false;
                        return false
                    } else self._c = true
            };
            self._onChange = function(e) {
                e = e || window.event;
                var target =
                    e.target || e.srcElement;
                if (!target) return;
                if (hasClass(target, "pika-select-month")) self.gotoMonth(target.value);
                else if (hasClass(target, "pika-select-year")) self.gotoYear(target.value);
                else if (hasClass(target, "pika-select-hour")) self.setTime(target.value);
                else if (hasClass(target, "pika-select-minute")) self.setTime(null, target.value);
                else if (hasClass(target, "pika-select-second")) self.setTime(null, null, target.value)
            };
            self._onInputChange = function(e) {
                var date;
                if (e.firedBy === self) return;
                if (hasMoment) {
                    date =
                        moment(opts.field.value, opts.inputFormats);
                    date = date && date.isValid() ? date.toDate() : null
                } else date = new Date(Date.parse(opts.field.value));
                self.setDate(isDate(date) ? date : null);
                if (!self._v) self.show()
            };
            self._onInputFocus = function() {
                self.show()
            };
            self._onInputClick = function() {
                self.show()
            };
            self._onInputBlur = function() {
                if (!self._c) self._b = sto(function() {
                    self.hide()
                }, 50);
                self._c = false
            };
            self._onClick = function(e) {
                e = e || window.event;
                var target = e.target || e.srcElement,
                    pEl = target;
                if (!target) return;
                if (!hasEventListeners &&
                    hasClass(target, "pika-select"))
                    if (!target.onchange) {
                        target.setAttribute("onchange", "return;");
                        addEvent(target, "change", self._onChange)
                    }
                do
                    if (hasClass(pEl, "pika-single")) return;
                while (pEl = pEl.parentNode);
                if (self._v && target !== opts.trigger);
            };
            self.el = document.createElement("div");
            self.el.className = "pika-single" + (opts.isRTL ? " is-rtl" : "");
            addEvent(self.el, "mousedown", self._onMouseDown, true);
            addEvent(self.el, "change", self._onChange);
            if (opts.field) {
                if (opts.container) opts.container.appendChild(self.el);
                else if (opts.bound) document.body.appendChild(self.el);
                else opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling);
                addEvent(opts.field, "change", self._onInputChange);
                if (!opts.defaultDate) {
                    if (hasMoment && opts.field.value) opts.defaultDate = moment(opts.field.value, opts.inputFormats).toDate();
                    else opts.defaultDate = new Date(Date.parse(opts.field.value));
                    opts.setDefaultDate = true
                }
            }
            var defDate = opts.defaultDate;
            if (isDate(defDate))
                if (opts.setDefaultDate) self.setDate(defDate, true);
                else self.gotoDate(defDate);
            else self.gotoDate(new Date);
            if (opts.bound) {
                this.hide();
                self.el.className += " is-bound";
                addEvent(opts.trigger, "click", self._onInputClick);
                addEvent(opts.trigger, "blur", self._onInputBlur)
            } else this.show()
        };
    Pikaday.prototype = {
        config: function(options) {
            if (!this._o) this._o = extend({}, defaults, true);
            var opts = extend(this._o, options, true);
            opts.isRTL = !!opts.isRTL;
            opts.field = opts.field && opts.field.nodeName ? opts.field : null;
            opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);
            opts.trigger = opts.trigger && opts.trigger.nodeName ? opts.trigger : opts.field;
            var nom = parseInt(opts.numberOfMonths, 10) || 1;
            opts.numberOfMonths = nom > 4 ? 4 : nom;
            if (!isDate(opts.minDate)) opts.minDate = false;
            if (!isDate(opts.maxDate)) opts.maxDate = false;
            if (opts.minDate && opts.maxDate && opts.maxDate < opts.minDate) opts.maxDate = opts.minDate = false;
            if (opts.minDate) {
                if (!opts.showTime) setToStartOfDay(opts.minDate);
                opts.minYear = opts.minDate.getFullYear();
                opts.minMonth = opts.minDate.getMonth()
            }
            if (opts.maxDate) {
                if (!opts.showTime) setToStartOfDay(opts.maxDate);
                opts.maxYear = opts.maxDate.getFullYear();
                opts.maxMonth = opts.maxDate.getMonth()
            }
            if (isArray(opts.yearRange)) {
                var fallback = (new Date).getFullYear() - 10;
                opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
                opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback
            } else {
                opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
                if (opts.yearRange > 100) opts.yearRange = 100
            }
            if (opts.format === null) {
                opts.format = "YYYY-MM-DD";
                if (opts.showTime) opts.format += " HH:mm:ss"
            }
            if (!opts.inputFormats) opts.inputFormats = opts.format;
            return opts
        },
        toString: function(format) {
            return !isDate(this._d) ?
                "" : hasMoment ? moment(this._d).format(format || this._o.format) : this._o.showTime ? this._d.toString() : this._d.toDateString()
        },
        getMoment: function() {
            return hasMoment ? moment(this._d) : null
        },
        setMoment: function(date, preventOnSelect) {
            if (hasMoment && moment.isMoment(date)) this.setDate(date.toDate(), preventOnSelect)
        },
        getDate: function() {
            return isDate(this._d) ? new Date(this._d.getTime()) : null
        },
        setTime: function(hours, minutes, seconds) {
            if (!this._d) {
                this._d = new Date;
                this._d.setHours(0, 0, 0, 0)
            }
            if (hours) this._d.setHours(hours);
            if (minutes) this._d.setMinutes(minutes);
            if (seconds) this._d.setSeconds(seconds);
            this.setDate(this._d)
        },
        setDate: function(date, preventOnSelect) {
            if (!date) {
                this._d = null;
                return this.draw()
            }
            if (typeof date === "string") date = new Date(Date.parse(date));
            if (!isDate(date)) return;
            var min = this._o.minDate,
                max = this._o.maxDate;
            if (isDate(min) && date < min) date = min;
            else if (isDate(max) && date > max) date = max;
            this._d = new Date(date.getTime());
            if (this._o.showTime && !this._o.showSeconds) this._d.setSeconds(0);
            else if (!this._o.showTime) setToStartOfDay(this._d);
            this.gotoDate(this._d);
            if (this._o.field) {
                this._o.field.value = this.toString();
                fireEvent(this._o.field, "input", {
                    firedBy: this
                });
                fireEvent(this._o.field, "change", {
                    firedBy: this
                })
            }
            if (!preventOnSelect && typeof this._o.onSelect === "function") this._o.onSelect.call(this, this.getDate())
        },
        gotoDate: function(date) {
            var newCalendar = true;
            if (!isDate(date)) return;
            if (this.calendars) {
                var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
                    lastVisibleDate = new Date(this.calendars[this.calendars.length -
                        1].year, this.calendars[this.calendars.length - 1].month, 1),
                    visibleDate = date.getTime();
                lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);
                lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);
                newCalendar = visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate
            }
            if (newCalendar) {
                this.calendars = [{
                    month: date.getMonth(),
                    year: date.getFullYear(),
                    hour: date.getHours(),
                    minute: date.getMinutes(),
                    second: date.getSeconds()
                }];
                if (this._o.mainCalendar === "right") this.calendars[0].month += 1 - this._o.numberOfMonths
            }
            this.adjustCalendars()
        },
        adjustCalendars: function() {
            this.calendars[0] = adjustCalendar(this.calendars[0]);
            for (var c = 1; c < this._o.numberOfMonths; c++) this.calendars[c] = adjustCalendar({
                month: this.calendars[0].month + c,
                year: this.calendars[0].year
            });
            this.draw()
        },
        gotoToday: function() {
            this.gotoDate(new Date)
        },
        gotoMonth: function(month) {
            if (!isNaN(month)) {
                this.calendars[0].month = parseInt(month, 10);
                this.adjustCalendars()
            }
        },
        nextMonth: function() {
            this.calendars[0].month++;
            this.adjustCalendars()
        },
        prevMonth: function() {
            this.calendars[0].month--;
            this.adjustCalendars()
        },
        gotoYear: function(year) {
            if (!isNaN(year)) {
                this.calendars[0].year = parseInt(year, 10);
                this.adjustCalendars()
            }
        },
        setMinDate: function(value) {
            this._o.minDate = value
        },
        setMaxDate: function(value) {
            this._o.maxDate = value
        },
        draw: function(force) {
            if (!this._v && !force) return;
            var opts = this._o,
                minYear = opts.minYear,
                maxYear = opts.maxYear,
                minMonth = opts.minMonth,
                maxMonth = opts.maxMonth,
                html = "";
            if (this._y <= minYear) {
                this._y = minYear;
                if (!isNaN(minMonth) && this._m < minMonth) this._m = minMonth
            }
            if (this._y >= maxYear) {
                this._y =
                    maxYear;
                if (!isNaN(maxMonth) && this._m > maxMonth) this._m = maxMonth
            }
            for (var c = 0; c < opts.numberOfMonths; c++) html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year) + this.render(this.calendars[c].year, this.calendars[c].month) + (!opts.showTime ? "</div>" : "");
            if (opts.showTime) html += "<div>" + renderTime(this._d ? this._d.getHours() : 0, this._d ? this._d.getMinutes() : 0, this._d ? this._d.getSeconds() : 0, opts) + "</div>" + "</div>";
            this.el.innerHTML = html;
            if (opts.bound)
                if (opts.field.type !==
                    "hidden") sto(function() {
                    opts.trigger.focus()
                }, 1);
            if (typeof this._o.onDraw === "function") {
                var self = this;
                sto(function() {
                    self._o.onDraw.call(self)
                }, 0)
            }
        },
        adjustPosition: function() {
            if (this._o.container) return;
            var field = this._o.trigger,
                pEl = field,
                width = this.el.offsetWidth,
                height = this.el.offsetHeight,
                viewportWidth = window.innerWidth || document.documentElement.clientWidth,
                viewportHeight = window.innerHeight || document.documentElement.clientHeight,
                scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop,
                left, top, clientRect;
            if (typeof field.getBoundingClientRect === "function") {
                clientRect = field.getBoundingClientRect();
                left = clientRect.left + window.pageXOffset;
                top = clientRect.bottom + window.pageYOffset
            } else {
                left = pEl.offsetLeft;
                top = pEl.offsetTop + pEl.offsetHeight;
                while (pEl = pEl.offsetParent) {
                    left += pEl.offsetLeft;
                    top += pEl.offsetTop
                }
            }
            if (left + width > viewportWidth || this._o.position.indexOf("right") > -1 && left - width + field.offsetWidth > 0) left = left - width + field.offsetWidth;
            if (top + height > viewportHeight + scrollTop || this._o.position.indexOf("top") >
                -1 && top - height - field.offsetHeight > 0) top = top - height - field.offsetHeight;
            this.el.style.cssText = ["position: absolute", "left: " + left + "px", "top: " + top + "px"].join(";")
        },
        render: function(year, month) {
            var opts = this._o,
                now = new Date,
                days = getDaysInMonth(year, month),
                before = (new Date(year, month, 1)).getDay(),
                data = [],
                row = [];
            if (!opts.showTime) setToStartOfDay(now);
            if (opts.firstDay > 0) {
                before -= opts.firstDay;
                if (before < 0) before += 7
            }
            var cells = days + before,
                after = cells;
            while (after > 7) after -= 7;
            cells += 7 - after;
            for (var i = 0, r = 0; i <
                cells; i++) {
                var day = new Date(year, month, 1 + (i - before)),
                    isDisabled = opts.minDate && day < opts.minDate || opts.maxDate && day > opts.maxDate,
                    isSelected = isDate(this._d) ? compareDates(day, this._d) : false,
                    isToday = compareDates(day, now),
                    isEmpty = i < before || i >= days + before;
                row.push(renderDay(1 + (i - before), month, year, isSelected, isToday, isDisabled, isEmpty));
                if (++r === 7) {
                    if (opts.showWeekNumber) row.unshift(renderWeek(i - before, month, year));
                    data.push(renderRow(row, opts.isRTL));
                    row = [];
                    r = 0
                }
            }
            return renderTable(opts, data)
        },
        isVisible: function() {
            return this._v
        },
        show: function() {
            if (!this._v) {
                removeClass(this.el, "is-hidden");
                this._v = true;
                this.draw();
                if (this._o.bound) {
                    addEvent(document, "click", this._onClick);
                    this.adjustPosition()
                }
                if (typeof this._o.onOpen === "function") this._o.onOpen.call(this)
            }
        },
        hide: function() {
            var v = this._v;
            if (v !== false) {
                if (this._o.bound) removeEvent(document, "click", this._onClick);
                this.el.style.cssText = "";
                addClass(this.el, "is-hidden");
                this._v = false;
                if (v !== undefined && typeof this._o.onClose === "function") this._o.onClose.call(this)
            }
        },
        destroy: function() {
            this.hide();
            removeEvent(this.el, "mousedown", this._onMouseDown, true);
            removeEvent(this.el, "change", this._onChange);
            if (this._o.field) {
                removeEvent(this._o.field, "change", this._onInputChange);
                if (this._o.bound) {
                    removeEvent(this._o.trigger, "click", this._onInputClick);
                    removeEvent(this._o.trigger, "focus", this._onInputFocus);
                    removeEvent(this._o.trigger, "blur", this._onInputBlur)
                }
            }
            if (this.el.parentNode) this.el.parentNode.removeChild(this.el)
        }
    };
    return Pikaday
});
(function(factory) {
    if (typeof define === "function" && define.amd) define(["jquery", "moment"], factory);
    else if (typeof exports === "object") factory(require("jquery"), require("moment"));
    else {
        if (typeof jQuery === "undefined") throw "bootstrap-datetimepicker requires jQuery to be loaded first";
        if (typeof moment === "undefined") throw "bootstrap-datetimepicker requires Moment.js to be loaded first";
        factory(jQuery, moment)
    }
})(function($, moment) {
    if (!moment) throw new Error("bootstrap-datetimepicker requires Moment.js to be loaded first");
    var dateTimePicker = function(element, options) {
        var picker = {},
            date, viewDate, unset = true,
            input, component = false,
            widget = false,
            use24Hours, minViewModeNumber = 0,
            actualFormat, parseFormats, currentViewMode, datePickerModes = [{
                clsName: "days",
                navFnc: "M",
                navStep: 1
            }, {
                clsName: "months",
                navFnc: "y",
                navStep: 1
            }, {
                clsName: "years",
                navFnc: "y",
                navStep: 10
            }, {
                clsName: "decades",
                navFnc: "y",
                navStep: 100
            }],
            viewModes = ["days", "months", "years", "decades"],
            verticalModes = ["top", "bottom", "auto"],
            horizontalModes = ["left", "right", "auto"],
            toolbarPlacements = ["default", "top", "bottom"],
            keyMap = {
                "up": 38,
                38: "up",
                "down": 40,
                40: "down",
                "left": 37,
                37: "left",
                "right": 39,
                39: "right",
                "tab": 9,
                9: "tab",
                "escape": 27,
                27: "escape",
                "enter": 13,
                13: "enter",
                "pageUp": 33,
                33: "pageUp",
                "pageDown": 34,
                34: "pageDown",
                "shift": 16,
                16: "shift",
                "control": 17,
                17: "control",
                "space": 32,
                32: "space",
                "t": 84,
                84: "t",
                "delete": 46,
                46: "delete"
            },
            keyState = {},
            getMoment = function(d) {
                var tzEnabled = false,
                    returnMoment, currentZoneOffset, incomingZoneOffset, timeZoneIndicator, dateWithTimeZoneInfo;
                if (moment.tz !== undefined &&
                    options.timeZone !== undefined && options.timeZone !== null && options.timeZone !== "") tzEnabled = true;
                if (d === undefined || d === null)
                    if (tzEnabled) returnMoment = moment().tz(options.timeZone).startOf("d");
                    else returnMoment = moment().startOf("d");
                else if (tzEnabled) {
                    currentZoneOffset = moment().tz(options.timeZone).utcOffset();
                    incomingZoneOffset = moment(d, parseFormats, options.useStrict).utcOffset();
                    if (incomingZoneOffset !== currentZoneOffset) {
                        timeZoneIndicator = moment().tz(options.timeZone).format("Z");
                        dateWithTimeZoneInfo =
                            moment(d, parseFormats, options.useStrict).format("YYYY-MM-DD[T]HH:mm:ss") + timeZoneIndicator;
                        returnMoment = moment(dateWithTimeZoneInfo, parseFormats, options.useStrict).tz(options.timeZone)
                    } else returnMoment = moment(d, parseFormats, options.useStrict).tz(options.timeZone)
                } else returnMoment = moment(d, parseFormats, options.useStrict);
                return returnMoment
            },
            isEnabled = function(granularity) {
                if (typeof granularity !== "string" || granularity.length > 1) throw new TypeError("isEnabled expects a single character string parameter");
                var showComponents = options.showComponents;
                switch (granularity) {
                    case "y":
                        return showComponents.indexOf("Y") !== -1;
                    case "M":
                        return showComponents.indexOf("M") !== -1;
                    case "d":
                        return showComponents.toLowerCase().indexOf("d") !== -1;
                    case "h":
                    case "H":
                        return showComponents.toLowerCase().indexOf("h") !== -1;
                    case "m":
                        return showComponents.indexOf("m") !== -1;
                    case "s":
                        return showComponents.indexOf("s") !== -1;
                    default:
                        return false
                }
            },
            hasTime = function() {
                return isEnabled("h") || isEnabled("m") || isEnabled("s")
            },
            hasDate = function() {
                return isEnabled("y") ||
                    isEnabled("M") || isEnabled("d")
            },
            getDatePickerTemplate = function() {
                var headTemplate = $("<thead>").append($("<tr>").append($("<th>").addClass("prev").attr("data-action", "previous").append($("<span>").addClass(options.icons.previous))).append($("<th>").addClass("picker-switch").attr("data-action", "pickerSwitch").attr("colspan", options.calendarWeeks ? "6" : "5")).append($("<th>").addClass("next").attr("data-action", "next").append($("<span>").addClass(options.icons.next)))),
                    contTemplate = $("<tbody>").append($("<tr>").append($("<td>").attr("colspan",
                        options.calendarWeeks ? "8" : "7")));
                return [$("<div>").addClass("datepicker-days").append($("<table>").addClass("table-condensed").append(headTemplate).append($("<tbody>"))), $("<div>").addClass("datepicker-months").append($("<table>").addClass("table-condensed").append(headTemplate.clone()).append(contTemplate.clone())), $("<div>").addClass("datepicker-years").append($("<table>").addClass("table-condensed").append(headTemplate.clone()).append(contTemplate.clone())), $("<div>").addClass("datepicker-decades").append($("<table>").addClass("table-condensed").append(headTemplate.clone()).append(contTemplate.clone()))]
            },
            getTimePickerMainTemplate = function() {
                var topRow = $("<tr>"),
                    middleRow = $("<tr>"),
                    bottomRow = $("<tr>");
                if (isEnabled("h")) {
                    topRow.append($("<td>").append($("<a>").attr({
                        href: "#",
                        tabindex: "-1",
                        "title": options.tooltips.incrementHour
                    }).addClass("btn").attr("data-action", "incrementHours").append($("<span>").addClass(options.icons.up))));
                    middleRow.append($("<td>").append($("<span>").addClass("timepicker-hour").attr({
                        "data-time-component": "hours",
                        "title": options.tooltips.pickHour
                    }).attr("data-action", "showHours")));
                    bottomRow.append($("<td>").append($("<a>").attr({
                        href: "#",
                        tabindex: "-1",
                        "title": options.tooltips.decrementHour
                    }).addClass("btn").attr("data-action", "decrementHours").append($("<span>").addClass(options.icons.down))))
                }
                if (isEnabled("m")) {
                    if (isEnabled("h")) {
                        topRow.append($("<td>").addClass("separator"));
                        middleRow.append($("<td>").addClass("separator").html(":"));
                        bottomRow.append($("<td>").addClass("separator"))
                    }
                    topRow.append($("<td>").append($("<a>").attr({
                        href: "#",
                        tabindex: "-1",
                        "title": options.tooltips.incrementMinute
                    }).addClass("btn").attr("data-action",
                        "incrementMinutes").append($("<span>").addClass(options.icons.up))));
                    middleRow.append($("<td>").append($("<span>").addClass("timepicker-minute").attr({
                        "data-time-component": "minutes",
                        "title": options.tooltips.pickMinute
                    }).attr("data-action", "showMinutes")));
                    bottomRow.append($("<td>").append($("<a>").attr({
                        href: "#",
                        tabindex: "-1",
                        "title": options.tooltips.decrementMinute
                    }).addClass("btn").attr("data-action", "decrementMinutes").append($("<span>").addClass(options.icons.down))))
                }
                if (isEnabled("s")) {
                    if (isEnabled("m")) {
                        topRow.append($("<td>").addClass("separator"));
                        middleRow.append($("<td>").addClass("separator").html(":"));
                        bottomRow.append($("<td>").addClass("separator"))
                    }
                    topRow.append($("<td>").append($("<a>").attr({
                        href: "#",
                        tabindex: "-1",
                        "title": options.tooltips.incrementSecond
                    }).addClass("btn").attr("data-action", "incrementSeconds").append($("<span>").addClass(options.icons.up))));
                    middleRow.append($("<td>").append($("<span>").addClass("timepicker-second").attr({
                        "data-time-component": "seconds",
                        "title": options.tooltips.pickSecond
                    }).attr("data-action", "showSeconds")));
                    bottomRow.append($("<td>").append($("<a>").attr({
                        href: "#",
                        tabindex: "-1",
                        "title": options.tooltips.decrementSecond
                    }).addClass("btn").attr("data-action", "decrementSeconds").append($("<span>").addClass(options.icons.down))))
                }
                if (!use24Hours) {
                    topRow.append($("<td>").addClass("separator"));
                    middleRow.append($("<td>").append($("<button>").addClass("btn btn-primary").attr({
                        "data-action": "togglePeriod",
                        tabindex: "-1",
                        "title": options.tooltips.togglePeriod
                    })));
                    bottomRow.append($("<td>").addClass("separator"))
                }
                return $("<div>").addClass("timepicker-picker").append($("<table>").addClass("table-condensed").append([topRow,
                    middleRow, bottomRow
                ]))
            },
            getTimePickerTemplate = function() {
                var hoursView = $("<div>").addClass("timepicker-hours").append($("<table>").addClass("table-condensed")),
                    minutesView = $("<div>").addClass("timepicker-minutes").append($("<table>").addClass("table-condensed")),
                    secondsView = $("<div>").addClass("timepicker-seconds").append($("<table>").addClass("table-condensed")),
                    ret = [getTimePickerMainTemplate()];
                if (isEnabled("h")) ret.push(hoursView);
                if (isEnabled("m")) ret.push(minutesView);
                if (isEnabled("s")) ret.push(secondsView);
                return ret
            },
            getToolbar = function() {
                var row = [];
                if (options.showTodayButton) row.push($("<td>").append($("<a>").attr({
                    "data-action": "today",
                    "title": options.tooltips.today
                }).append($("<span>").addClass(options.icons.today))));
                if (!options.sideBySide && hasDate() && hasTime()) row.push($("<td>").append($("<a>").attr({
                    "data-action": "togglePicker",
                    "title": options.tooltips.selectTime
                }).append($("<span>").addClass(options.icons.time))));
                if (options.showClear) row.push($("<td>").append($("<a>").attr({
                    "data-action": "clear",
                    "title": options.tooltips.clear
                }).append($("<span>").addClass(options.icons.clear))));
                if (options.showClose) row.push($("<td>").append($("<a>").attr({
                    "data-action": "close",
                    "title": options.tooltips.close
                }).append($("<span>").addClass(options.icons.close))));
                return $("<table>").addClass("table-condensed").append($("<tbody>").append($("<tr>").append(row)))
            },
            getTemplate = function() {
                var template = $("<div>").addClass("bootstrap-datetimepicker-widget dropdown-menu"),
                    dateView = $("<div>").addClass("datepicker").append(getDatePickerTemplate()),
                    timeView = $("<div>").addClass("timepicker").append(getTimePickerTemplate()),
                    content = $("<ul>").addClass("list-unstyled"),
                    toolbar = $("<li>").addClass("picker-switch" + (options.collapse ? " accordion-toggle" : "")).append(getToolbar());
                if (options.inline) template.removeClass("dropdown-menu");
                if (use24Hours) template.addClass("usetwentyfour");
                if (isEnabled("s") && !use24Hours) template.addClass("wider");
                if (options.sideBySide && hasDate() && hasTime()) {
                    template.addClass("timepicker-sbs");
                    if (options.toolbarPlacement === "top") template.append(toolbar);
                    template.append($("<div>").addClass("row").append(dateView.addClass("col-md-6")).append(timeView.addClass("col-md-6")));
                    if (options.toolbarPlacement === "bottom") template.append(toolbar);
                    return template
                }
                if (options.toolbarPlacement === "top") content.append(toolbar);
                if (hasDate()) content.append($("<li>").addClass(options.collapse && hasTime() ? "collapse in" : "").append(dateView));
                if (options.toolbarPlacement === "default") content.append(toolbar);
                if (hasTime()) content.append($("<li>").addClass(options.collapse && hasDate() ?
                    "collapse" : "").append(timeView));
                if (options.toolbarPlacement === "bottom") content.append(toolbar);
                return template.append(content)
            },
            dataToOptions = function() {
                var eData, dataOptions = {};
                if (element.is("input") || options.inline) eData = element.data();
                else eData = element.find("input").data();
                if (eData.dateOptions && eData.dateOptions instanceof Object) dataOptions = $.extend(true, dataOptions, eData.dateOptions);
                $.each(options, function(key) {
                    var attributeName = "date" + key.charAt(0).toUpperCase() + key.slice(1);
                    if (eData[attributeName] !==
                        undefined) dataOptions[key] = eData[attributeName]
                });
                return dataOptions
            },
            place = function() {
                var position = (component || element).position(),
                    offset = (component || element).offset(),
                    vertical = options.widgetPositioning.vertical,
                    horizontal = options.widgetPositioning.horizontal,
                    parent;
                if (options.widgetParent) parent = options.widgetParent.append(widget);
                else if (element.is("input")) parent = element.after(widget).parent();
                else if (options.inline) {
                    parent = element.append(widget);
                    return
                } else {
                    parent = element;
                    element.children().first().after(widget)
                }
                if (vertical ===
                    "auto")
                    if (offset.top + widget.height() * 1.5 >= $(window).height() + $(window).scrollTop() && widget.height() + element.outerHeight() < offset.top) vertical = "top";
                    else vertical = "bottom";
                if (horizontal === "auto")
                    if (parent.width() < offset.left + widget.outerWidth() / 2 && offset.left + widget.outerWidth() > $(window).width()) horizontal = "right";
                    else horizontal = "left";
                if (vertical === "top") widget.addClass("top").removeClass("bottom");
                else widget.addClass("bottom").removeClass("top");
                if (horizontal === "right") widget.addClass("pull-right");
                else widget.removeClass("pull-right");
                if (parent.css("position") !== "relative") parent = parent.parents().filter(function() {
                    return $(this).css("position") === "relative"
                }).first();
                if (parent.length === 0) throw new Error("datetimepicker component should be placed within a relative positioned container");
                widget.css({
                    top: vertical === "top" ? "auto" : position.top + element.outerHeight(),
                    bottom: vertical === "top" ? position.top + element.outerHeight() : "auto",
                    left: horizontal === "left" ? parent === element ? 0 : position.left : "auto",
                    right: horizontal ===
                        "left" ? "auto" : parent.outerWidth() - element.outerWidth() - (parent === element ? 0 : position.left)
                })
            },
            notifyEvent = function(e) {
                if (e.type === "dp.change" && (e.date && e.date.isSame(e.oldDate) || !e.date && !e.oldDate)) return;
                element.trigger(e)
            },
            viewUpdate = function(e) {
                if (e === "y") e = "YYYY";
                notifyEvent({
                    type: "dp.update",
                    change: e,
                    viewDate: viewDate.clone()
                })
            },
            showMode = function(dir) {
                if (!widget) return;
                if (dir) currentViewMode = Math.max(minViewModeNumber, Math.min(3, currentViewMode + dir));
                widget.find(".datepicker > div").hide().filter(".datepicker-" +
                    datePickerModes[currentViewMode].clsName).show()
            },
            fillDow = function() {
                var row = $("<tr>"),
                    currentDate = viewDate.clone().startOf("w").startOf("d");
                if (options.calendarWeeks === true) row.append($("<th>").addClass("cw").text("#"));
                while (currentDate.isBefore(viewDate.clone().endOf("w"))) {
                    row.append($("<th>").addClass("dow").text(currentDate.format("dd")));
                    currentDate.add(1, "d")
                }
                widget.find(".datepicker-days thead").append(row)
            },
            isInDisabledDates = function(testDate) {
                return options.disabledDates[testDate.format("YYYY-MM-DD")] ===
                    true
            },
            isInEnabledDates = function(testDate) {
                return options.enabledDates[testDate.format("YYYY-MM-DD")] === true
            },
            isInDisabledHours = function(testDate) {
                return options.disabledHours[testDate.format("H")] === true
            },
            isInEnabledHours = function(testDate) {
                return options.enabledHours[testDate.format("H")] === true
            },
            isValid = function(targetMoment, granularity) {
                if (!targetMoment.isValid()) return false;
                if (options.disabledDates && granularity === "d" && isInDisabledDates(targetMoment)) return false;
                if (options.enabledDates && granularity ===
                    "d" && !isInEnabledDates(targetMoment)) return false;
                if (options.minDate && targetMoment.isBefore(options.minDate, granularity)) return false;
                if (options.maxDate && targetMoment.isAfter(options.maxDate, granularity)) return false;
                if (options.daysOfWeekDisabled && granularity === "d" && options.daysOfWeekDisabled.indexOf(targetMoment.day()) !== -1) return false;
                if (options.disabledHours && (granularity === "h" || granularity === "m" || granularity === "s") && isInDisabledHours(targetMoment)) return false;
                if (options.enabledHours && (granularity ===
                        "h" || granularity === "m" || granularity === "s") && !isInEnabledHours(targetMoment)) return false;
                if (options.disabledTimeIntervals && (granularity === "h" || granularity === "m" || granularity === "s")) {
                    var found = false;
                    $.each(options.disabledTimeIntervals, function() {
                        if (targetMoment.isBetween(this[0], this[1])) {
                            found = true;
                            return false
                        }
                    });
                    if (found) return false
                }
                return true
            },
            fillMonths = function() {
                var spans = [],
                    monthsShort = viewDate.clone().startOf("y").startOf("d");
                while (monthsShort.isSame(viewDate, "y")) {
                    spans.push($("<span>").attr("data-action",
                        "selectMonth").addClass("month").text(monthsShort.format("MMM")));
                    monthsShort.add(1, "M")
                }
                widget.find(".datepicker-months td").empty().append(spans)
            },
            updateMonths = function() {
                var monthsView = widget.find(".datepicker-months"),
                    monthsViewHeader = monthsView.find("th"),
                    months = monthsView.find("tbody").find("span");
                monthsViewHeader.eq(0).find("span").attr("title", options.tooltips.prevYear);
                monthsViewHeader.eq(1).attr("title", options.tooltips.selectYear);
                monthsViewHeader.eq(2).find("span").attr("title", options.tooltips.nextYear);
                monthsView.find(".disabled").removeClass("disabled");
                if (!isValid(viewDate.clone().subtract(1, "y"), "y")) monthsViewHeader.eq(0).addClass("disabled");
                monthsViewHeader.eq(1).text(viewDate.year());
                if (!isValid(viewDate.clone().add(1, "y"), "y")) monthsViewHeader.eq(2).addClass("disabled");
                months.removeClass("active");
                if (date.isSame(viewDate, "y") && !unset) months.eq(date.month()).addClass("active");
                months.each(function(index) {
                    if (!isValid(viewDate.clone().month(index), "M")) $(this).addClass("disabled")
                })
            },
            updateYears =
            function() {
                var yearsView = widget.find(".datepicker-years"),
                    yearsViewHeader = yearsView.find("th"),
                    startYear = viewDate.clone().subtract(5, "y"),
                    endYear = viewDate.clone().add(6, "y"),
                    html = "";
                yearsViewHeader.eq(0).find("span").attr("title", options.tooltips.prevDecade);
                yearsViewHeader.eq(1).attr("title", options.tooltips.selectDecade);
                yearsViewHeader.eq(2).find("span").attr("title", options.tooltips.nextDecade);
                yearsView.find(".disabled").removeClass("disabled");
                if (options.minDate && options.minDate.isAfter(startYear,
                        "y")) yearsViewHeader.eq(0).addClass("disabled");
                yearsViewHeader.eq(1).text(startYear.year() + "-" + endYear.year());
                if (options.maxDate && options.maxDate.isBefore(endYear, "y")) yearsViewHeader.eq(2).addClass("disabled");
                while (!startYear.isAfter(endYear, "y")) {
                    html += '<span data-action="selectYear" class="year' + (startYear.isSame(date, "y") && !unset ? " active" : "") + (!isValid(startYear, "y") ? " disabled" : "") + '">' + startYear.year() + "</span>";
                    startYear.add(1, "y")
                }
                yearsView.find("td").html(html)
            },
            updateDecades = function() {
                var decadesView =
                    widget.find(".datepicker-decades"),
                    decadesViewHeader = decadesView.find("th"),
                    startDecade = moment({
                        y: viewDate.year() - viewDate.year() % 100 - 1
                    }),
                    endDecade = startDecade.clone().add(100, "y"),
                    startedAt = startDecade.clone(),
                    html = "";
                decadesViewHeader.eq(0).find("span").attr("title", options.tooltips.prevCentury);
                decadesViewHeader.eq(2).find("span").attr("title", options.tooltips.nextCentury);
                decadesView.find(".disabled").removeClass("disabled");
                if (startDecade.isSame(moment({
                        y: 1900
                    })) || options.minDate && options.minDate.isAfter(startDecade,
                        "y")) decadesViewHeader.eq(0).addClass("disabled");
                decadesViewHeader.eq(1).text(startDecade.year() + "-" + endDecade.year());
                if (startDecade.isSame(moment({
                        y: 2E3
                    })) || options.maxDate && options.maxDate.isBefore(endDecade, "y")) decadesViewHeader.eq(2).addClass("disabled");
                while (!startDecade.isAfter(endDecade, "y")) {
                    html += '<span data-action="selectDecade" class="decade' + (startDecade.isSame(date, "y") ? " active" : "") + (!isValid(startDecade, "y") ? " disabled" : "") + '" data-selection="' + (startDecade.year() + 6) + '">' + (startDecade.year() +
                        1) + " - " + (startDecade.year() + 12) + "</span>";
                    startDecade.add(12, "y")
                }
                html += "<span></span><span></span><span></span>";
                decadesView.find("td").html(html);
                decadesViewHeader.eq(1).text(startedAt.year() + 1 + "-" + startDecade.year())
            },
            fillDate = function() {
                var daysView = widget.find(".datepicker-days"),
                    daysViewHeader = daysView.find("th"),
                    currentDate, html = [],
                    row, clsName, i;
                if (!hasDate()) return;
                daysViewHeader.eq(0).find("span").attr("title", options.tooltips.prevMonth);
                daysViewHeader.eq(1).attr("title", options.tooltips.selectMonth);
                daysViewHeader.eq(2).find("span").attr("title", options.tooltips.nextMonth);
                daysView.find(".disabled").removeClass("disabled");
                daysViewHeader.eq(1).text(viewDate.format(options.dayViewHeaderFormat));
                if (!isValid(viewDate.clone().subtract(1, "M"), "M")) daysViewHeader.eq(0).addClass("disabled");
                if (!isValid(viewDate.clone().add(1, "M"), "M")) daysViewHeader.eq(2).addClass("disabled");
                currentDate = viewDate.clone().startOf("M").startOf("w").startOf("d");
                for (i = 0; i < 42; i++) {
                    if (currentDate.weekday() === 0) {
                        row = $("<tr>");
                        if (options.calendarWeeks) row.append('<td class="cw">' + currentDate.week() + "</td>");
                        html.push(row)
                    }
                    clsName = "";
                    if (currentDate.isBefore(viewDate, "M")) clsName += " old";
                    if (currentDate.isAfter(viewDate, "M")) clsName += " new";
                    if (currentDate.isSame(date, "d") && !unset) clsName += " active";
                    if (!isValid(currentDate, "d")) clsName += " disabled";
                    if (currentDate.isSame(getMoment(), "d")) clsName += " today";
                    if (currentDate.day() === 0 || currentDate.day() === 6) clsName += " weekend";
                    row.append('<td data-action="selectDay" data-day="' +
                        currentDate.format("L") + '" class="day' + clsName + '">' + currentDate.date() + "</td>");
                    currentDate.add(1, "d")
                }
                daysView.find("tbody").empty().append(html);
                updateMonths();
                updateYears();
                updateDecades()
            },
            fillHours = function() {
                var table = widget.find(".timepicker-hours table"),
                    currentHour = viewDate.clone().startOf("d"),
                    html = [],
                    row = $("<tr>");
                if (viewDate.hour() > 11 && !use24Hours) currentHour.hour(12);
                while (currentHour.isSame(viewDate, "d") && (use24Hours || viewDate.hour() < 12 && currentHour.hour() < 12 || viewDate.hour() > 11)) {
                    if (currentHour.hour() %
                        4 === 0) {
                        row = $("<tr>");
                        html.push(row)
                    }
                    row.append('<td data-action="selectHour" class="hour' + (!isValid(currentHour, "h") ? " disabled" : "") + '">' + currentHour.format(use24Hours ? "HH" : "hh") + "</td>");
                    currentHour.add(1, "h")
                }
                table.empty().append(html)
            },
            fillMinutes = function() {
                var table = widget.find(".timepicker-minutes table"),
                    currentMinute = viewDate.clone().startOf("h"),
                    html = [],
                    row = $("<tr>"),
                    step = options.stepping === 1 ? 5 : options.stepping;
                while (viewDate.isSame(currentMinute, "h")) {
                    if (currentMinute.minute() % (step * 4) ===
                        0) {
                        row = $("<tr>");
                        html.push(row)
                    }
                    row.append('<td data-action="selectMinute" class="minute' + (!isValid(currentMinute, "m") ? " disabled" : "") + '">' + currentMinute.format("mm") + "</td>");
                    currentMinute.add(step, "m")
                }
                table.empty().append(html)
            },
            fillSeconds = function() {
                var table = widget.find(".timepicker-seconds table"),
                    currentSecond = viewDate.clone().startOf("m"),
                    html = [],
                    row = $("<tr>");
                while (viewDate.isSame(currentSecond, "m")) {
                    if (currentSecond.second() % 20 === 0) {
                        row = $("<tr>");
                        html.push(row)
                    }
                    row.append('<td data-action="selectSecond" class="second' +
                        (!isValid(currentSecond, "s") ? " disabled" : "") + '">' + currentSecond.format("ss") + "</td>");
                    currentSecond.add(5, "s")
                }
                table.empty().append(html)
            },
            fillTime = function() {
                var toggle, newDate, timeComponents = widget.find(".timepicker span[data-time-component]");
                if (!use24Hours) {
                    toggle = widget.find(".timepicker [data-action=togglePeriod]");
                    newDate = date.clone().add(date.hours() >= 12 ? -12 : 12, "h");
                    toggle.text(date.format("A"));
                    if (isValid(newDate, "h")) toggle.removeClass("disabled");
                    else toggle.addClass("disabled")
                }
                timeComponents.filter("[data-time-component=hours]").text(date.format(use24Hours ?
                    "HH" : "hh"));
                timeComponents.filter("[data-time-component=minutes]").text(date.format("mm"));
                timeComponents.filter("[data-time-component=seconds]").text(date.format("ss"));
                fillHours();
                fillMinutes();
                fillSeconds()
            },
            update = function() {
                if (!widget) return;
                fillDate();
                fillTime()
            },
            setValue = function(targetMoment) {
                var oldDate = unset ? null : date;
                if (!targetMoment) {
                    unset = true;
                    input.val("");
                    element.data("date", "");
                    notifyEvent({
                        type: "dp.change",
                        date: false,
                        oldDate: oldDate
                    });
                    update();
                    return
                }
                targetMoment = targetMoment.clone().locale(options.locale);
                if (options.stepping !== 1) targetMoment.minutes(Math.round(targetMoment.minutes() / options.stepping) * options.stepping % 60).seconds(0);
                if (isValid(targetMoment)) {
                    date = targetMoment;
                    viewDate = date.clone();
                    input.val(date.format(actualFormat));
                    element.data("date", date.format(actualFormat));
                    unset = false;
                    update();
                    notifyEvent({
                        type: "dp.change",
                        date: date.clone(),
                        oldDate: oldDate
                    })
                } else {
                    if (!options.keepInvalid) input.val(unset ? "" : date.format(actualFormat));
                    notifyEvent({
                        type: "dp.error",
                        date: targetMoment
                    })
                }
            },
            hide = function() {
                var transitioning =
                    false;
                if (!widget) return picker;
                widget.find(".collapse").each(function() {
                    var collapseData = $(this).data("collapse");
                    if (collapseData && collapseData.transitioning) {
                        transitioning = true;
                        return false
                    }
                    return true
                });
                if (transitioning) return picker;
                if (component && component.hasClass("btn")) component.toggleClass("active");
                widget.hide();
                $(window).off("resize", place);
                widget.off("click", "[data-action]");
                widget.off("mousedown", false);
                widget.remove();
                widget = false;
                notifyEvent({
                    type: "dp.hide",
                    date: date.clone()
                });
                input.blur();
                return picker
            },
            clear = function() {
                setValue(null)
            },
            actions = {
                next: function() {
                    var navFnc = datePickerModes[currentViewMode].navFnc;
                    viewDate.add(datePickerModes[currentViewMode].navStep, navFnc);
                    setValue(date.clone().year(viewDate.year()).month(viewDate.month()));
                    fillDate();
                    viewUpdate(navFnc)
                },
                previous: function() {
                    var navFnc = datePickerModes[currentViewMode].navFnc;
                    viewDate.subtract(datePickerModes[currentViewMode].navStep, navFnc);
                    setValue(date.clone().year(viewDate.year()).month(viewDate.month()));
                    fillDate();
                    viewUpdate(navFnc)
                },
                pickerSwitch: function() {
                    showMode(1)
                },
                selectMonth: function(e) {
                    var month = $(e.target).closest("tbody").find("span").index($(e.target));
                    viewDate.month(month);
                    setValue(date.clone().year(viewDate.year()).month(viewDate.month()));
                    if (currentViewMode === minViewModeNumber) {
                        if (!options.inline) hide()
                    } else {
                        showMode(-1);
                        fillDate()
                    }
                    viewUpdate("M")
                },
                selectYear: function(e) {
                    var year = parseInt($(e.target).text(), 10) || 0;
                    viewDate.year(year);
                    setValue(date.clone().year(viewDate.year()));
                    if (currentViewMode ===
                        minViewModeNumber) {
                        if (!options.inline) hide()
                    } else {
                        showMode(-1);
                        fillDate()
                    }
                    viewUpdate("YYYY")
                },
                selectDecade: function(e) {
                    var year = parseInt($(e.target).data("selection"), 10) || 0;
                    viewDate.year(year);
                    setValue(date.clone().year(viewDate.year()));
                    if (currentViewMode === minViewModeNumber) {
                        if (!options.inline) hide()
                    } else {
                        showMode(-1);
                        fillDate()
                    }
                    viewUpdate("YYYY")
                },
                selectDay: function(e) {
                    var day = viewDate.clone();
                    if ($(e.target).is(".old")) day.subtract(1, "M");
                    if ($(e.target).is(".new")) day.add(1, "M");
                    setValue(day.date(parseInt($(e.target).text(),
                        10)));
                    if (!hasTime() && !options.keepOpen && !options.inline) hide()
                },
                incrementHours: function() {
                    var newDate = date.clone().add(1, "h");
                    if (isValid(newDate, "h")) setValue(newDate)
                },
                incrementMinutes: function() {
                    var newDate = date.clone().add(options.stepping, "m");
                    if (isValid(newDate, "m")) setValue(newDate)
                },
                incrementSeconds: function() {
                    var newDate = date.clone().add(1, "s");
                    if (isValid(newDate, "s")) setValue(newDate)
                },
                decrementHours: function() {
                    var newDate = date.clone().subtract(1, "h");
                    if (isValid(newDate, "h")) setValue(newDate)
                },
                decrementMinutes: function() {
                    var newDate = date.clone().subtract(options.stepping, "m");
                    if (isValid(newDate, "m")) setValue(newDate)
                },
                decrementSeconds: function() {
                    var newDate = date.clone().subtract(1, "s");
                    if (isValid(newDate, "s")) setValue(newDate)
                },
                togglePeriod: function() {
                    setValue(date.clone().add(date.hours() >= 12 ? -12 : 12, "h"))
                },
                togglePicker: function(e) {
                    var $this = $(e.target),
                        $parent = $this.closest("ul"),
                        expanded = $parent.find(".in"),
                        closed = $parent.find(".collapse:not(.in)"),
                        collapseData;
                    if (expanded && expanded.length) {
                        collapseData =
                            expanded.data("collapse");
                        if (collapseData && collapseData.transitioning) return;
                        if (expanded.collapse) {
                            expanded.collapse("hide");
                            closed.collapse("show")
                        } else {
                            expanded.removeClass("in");
                            closed.addClass("in")
                        }
                        if ($this.is("span")) $this.toggleClass(options.icons.time + " " + options.icons.date);
                        else $this.find("span").toggleClass(options.icons.time + " " + options.icons.date)
                    }
                },
                showPicker: function() {
                    widget.find(".timepicker > div:not(.timepicker-picker)").hide();
                    widget.find(".timepicker .timepicker-picker").show()
                },
                showHours: function() {
                    widget.find(".timepicker .timepicker-picker").hide();
                    widget.find(".timepicker .timepicker-hours").show()
                },
                showMinutes: function() {
                    widget.find(".timepicker .timepicker-picker").hide();
                    widget.find(".timepicker .timepicker-minutes").show()
                },
                showSeconds: function() {
                    widget.find(".timepicker .timepicker-picker").hide();
                    widget.find(".timepicker .timepicker-seconds").show()
                },
                selectHour: function(e) {
                    var hour = parseInt($(e.target).text(), 10);
                    if (!use24Hours)
                        if (date.hours() >= 12) {
                            if (hour !== 12) hour +=
                                12
                        } else if (hour === 12) hour = 0;
                    setValue(date.clone().hours(hour));
                    actions.showPicker.call(picker)
                },
                selectMinute: function(e) {
                    setValue(date.clone().minutes(parseInt($(e.target).text(), 10)));
                    actions.showPicker.call(picker)
                },
                selectSecond: function(e) {
                    setValue(date.clone().seconds(parseInt($(e.target).text(), 10)));
                    actions.showPicker.call(picker)
                },
                clear: clear,
                today: function() {
                    var todaysDate = getMoment();
                    if (isValid(todaysDate, "d")) setValue(todaysDate)
                },
                close: hide
            },
            doAction = function(e) {
                if ($(e.currentTarget).is(".disabled")) return false;
                actions[$(e.currentTarget).data("action")].apply(picker, arguments);
                return false
            },
            show = function() {
                var currentMoment, useCurrentGranularity = {
                    "year": function(m) {
                        return m.month(0).date(1).hours(0).seconds(0).minutes(0)
                    },
                    "month": function(m) {
                        return m.date(1).hours(0).seconds(0).minutes(0)
                    },
                    "day": function(m) {
                        return m.hours(0).seconds(0).minutes(0)
                    },
                    "hour": function(m) {
                        return m.seconds(0).minutes(0)
                    },
                    "minute": function(m) {
                        return m.seconds(0)
                    }
                };
                if (input.prop("disabled") || !options.ignoreReadonly && input.prop("readonly") ||
                    widget) return picker;
                if (input.val() !== undefined && input.val().trim().length !== 0) setValue(parseInputDate(input.val().trim()));
                else if (options.useCurrent && unset && (input.is("input") && input.val().trim().length === 0 || options.inline)) {
                    currentMoment = getMoment();
                    if (typeof options.useCurrent === "string") currentMoment = useCurrentGranularity[options.useCurrent](currentMoment);
                    setValue(currentMoment)
                }
                widget = getTemplate();
                fillDow();
                fillMonths();
                widget.find(".timepicker-hours").hide();
                widget.find(".timepicker-minutes").hide();
                widget.find(".timepicker-seconds").hide();
                update();
                showMode();
                $(window).on("resize", place);
                widget.on("click", "[data-action]", doAction);
                widget.on("mousedown", false);
                if (component && component.hasClass("btn")) component.toggleClass("active");
                widget.show();
                place();
                if (options.focusOnShow && !input.is(":focus")) input.focus();
                notifyEvent({
                    type: "dp.show"
                });
                return picker
            },
            toggle = function() {
                return widget ? hide() : show()
            },
            parseInputDate = function(inputDate) {
                if (options.parseInputDate === undefined)
                    if (moment.isMoment(inputDate) ||
                        inputDate instanceof Date) inputDate = moment(inputDate);
                    else inputDate = getMoment(inputDate);
                else inputDate = options.parseInputDate(inputDate);
                inputDate.locale(options.locale);
                return inputDate
            },
            keydown = function(e) {
                var handler = null,
                    index, index2, pressedKeys = [],
                    pressedModifiers = {},
                    currentKey = e.which,
                    keyBindKeys, allModifiersPressed, pressed = "p";
                keyState[currentKey] = pressed;
                for (index in keyState)
                    if (keyState.hasOwnProperty(index) && keyState[index] === pressed) {
                        pressedKeys.push(index);
                        if (parseInt(index, 10) !== currentKey) pressedModifiers[index] =
                            true
                    }
                for (index in options.keyBinds)
                    if (options.keyBinds.hasOwnProperty(index) && typeof options.keyBinds[index] === "function") {
                        keyBindKeys = index.split(" ");
                        if (keyBindKeys.length === pressedKeys.length && keyMap[currentKey] === keyBindKeys[keyBindKeys.length - 1]) {
                            allModifiersPressed = true;
                            for (index2 = keyBindKeys.length - 2; index2 >= 0; index2--)
                                if (!(keyMap[keyBindKeys[index2]] in pressedModifiers)) {
                                    allModifiersPressed = false;
                                    break
                                }
                            if (allModifiersPressed) {
                                handler = options.keyBinds[index];
                                break
                            }
                        }
                    }
                if (handler) {
                    handler.call(picker,
                        widget);
                    e.stopPropagation();
                    e.preventDefault()
                }
            },
            keyup = function(e) {
                keyState[e.which] = "r";
                e.stopPropagation();
                e.preventDefault()
            },
            change = function(e) {
                var val = $(e.target).val().trim(),
                    parsedDate = val ? parseInputDate(val) : null;
                setValue(parsedDate);
                e.stopImmediatePropagation();
                return false
            },
            attachDatePickerElementEvents = function() {
                input.on({
                    "change": change,
                    "blur": options.debug ? "" : hide,
                    "keydown": keydown,
                    "keyup": keyup,
                    "focus": options.allowInputToggle ? show : ""
                });
                if (element.is("input")) input.on({
                    "focus": show
                });
                else if (component) {
                    component.on("click", toggle);
                    component.on("mousedown", false)
                }
            },
            detachDatePickerElementEvents = function() {
                input.off({
                    "change": change,
                    "blur": blur,
                    "keydown": keydown,
                    "keyup": keyup,
                    "focus": options.allowInputToggle ? hide : ""
                });
                if (element.is("input")) input.off({
                    "focus": show
                });
                else if (component) {
                    component.off("click", toggle);
                    component.off("mousedown", false)
                }
            },
            indexGivenDates = function(givenDatesArray) {
                var givenDatesIndexed = {};
                $.each(givenDatesArray, function() {
                    var dDate = parseInputDate(this);
                    if (dDate.isValid()) givenDatesIndexed[dDate.format("YYYY-MM-DD")] = true
                });
                return Object.keys(givenDatesIndexed).length ? givenDatesIndexed : false
            },
            indexGivenHours = function(givenHoursArray) {
                var givenHoursIndexed = {};
                $.each(givenHoursArray, function() {
                    givenHoursIndexed[this] = true
                });
                return Object.keys(givenHoursIndexed).length ? givenHoursIndexed : false
            },
            initFormatting = function() {
                var format = options.format || "L LT";
                actualFormat = format.replace(/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, function(formatInput) {
                    var newinput =
                        date.localeData().longDateFormat(formatInput) || formatInput;
                    return newinput.replace(/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, function(formatInput2) {
                        return date.localeData().longDateFormat(formatInput2) || formatInput2
                    })
                });
                parseFormats = options.extraFormats ? options.extraFormats.slice() : [];
                if (parseFormats.indexOf(format) < 0 && parseFormats.indexOf(actualFormat) < 0) parseFormats.push(actualFormat);
                use24Hours = actualFormat.toLowerCase().indexOf("a") < 1 && actualFormat.replace(/\[.*?\]/g, "").indexOf("h") < 1;
                if (isEnabled("y")) minViewModeNumber =
                    2;
                if (isEnabled("M")) minViewModeNumber = 1;
                if (isEnabled("d")) minViewModeNumber = 0;
                currentViewMode = Math.max(minViewModeNumber, currentViewMode);
                if (!unset) setValue(date)
            };
        picker.destroy = function() {
            hide();
            detachDatePickerElementEvents();
            element.removeData("DateTimePicker");
            element.removeData("date")
        };
        picker.toggle = toggle;
        picker.show = show;
        picker.hide = hide;
        picker.disable = function() {
            hide();
            if (component && component.hasClass("btn")) component.addClass("disabled");
            input.prop("disabled", true);
            return picker
        };
        picker.enable =
            function() {
                if (component && component.hasClass("btn")) component.removeClass("disabled");
                input.prop("disabled", false);
                return picker
            };
        picker.ignoreReadonly = function(ignoreReadonly) {
            if (arguments.length === 0) return options.ignoreReadonly;
            if (typeof ignoreReadonly !== "boolean") throw new TypeError("ignoreReadonly () expects a boolean parameter");
            options.ignoreReadonly = ignoreReadonly;
            return picker
        };
        picker.options = function(newOptions) {
            if (arguments.length === 0) return $.extend(true, {}, options);
            if (!(newOptions instanceof Object)) throw new TypeError("options() options parameter should be an object");
            $.extend(true, options, newOptions);
            $.each(options, function(key, value) {
                if (picker[key] !== undefined) picker[key](value);
                else throw new TypeError("option " + key + " is not recognized!");
            });
            return picker
        };
        picker.date = function(newDate) {
            if (arguments.length === 0) {
                if (unset) return null;
                return date.clone()
            }
            if (newDate !== null && typeof newDate !== "string" && !moment.isMoment(newDate) && !(newDate instanceof Date)) throw new TypeError("date() parameter must be one of [null, string, moment or Date]");
            setValue(newDate === null ? null : parseInputDate(newDate));
            return picker
        };
        picker.format = function(newFormat) {
            if (arguments.length === 0) return options.format;
            if (typeof newFormat !== "string" && (typeof newFormat !== "boolean" || newFormat !== false)) throw new TypeError("format() expects a sting or boolean:false parameter " + newFormat);
            options.format = newFormat;
            if (actualFormat) initFormatting();
            return picker
        };
        picker.showComponents = function(newShowComponents) {
            if (arguments.length === 0) return options.showComponents;
            if (typeof newShowComponents !==
                "string" && (typeof newShowComponents !== "boolean" || newShowComponents !== false)) throw new TypeError("showComponents() expects a sting or boolean:false parameter " + newShowComponents);
            options.showComponents = newShowComponents;
            return picker
        };
        picker.timeZone = function(newZone) {
            if (arguments.length === 0) return options.timeZone;
            options.timeZone = newZone;
            return picker
        };
        picker.dayViewHeaderFormat = function(newFormat) {
            if (arguments.length === 0) return options.dayViewHeaderFormat;
            if (typeof newFormat !== "string") throw new TypeError("dayViewHeaderFormat() expects a string parameter");
            options.dayViewHeaderFormat = newFormat;
            return picker
        };
        picker.extraFormats = function(formats) {
            if (arguments.length === 0) return options.extraFormats;
            if (formats !== false && !(formats instanceof Array)) throw new TypeError("extraFormats() expects an array or false parameter");
            options.extraFormats = formats;
            if (parseFormats) initFormatting();
            return picker
        };
        picker.disabledDates = function(dates) {
            if (arguments.length === 0) return options.disabledDates ? $.extend({}, options.disabledDates) : options.disabledDates;
            if (!dates) {
                options.disabledDates =
                    false;
                update();
                return picker
            }
            if (!(dates instanceof Array)) throw new TypeError("disabledDates() expects an array parameter");
            options.disabledDates = indexGivenDates(dates);
            options.enabledDates = false;
            update();
            return picker
        };
        picker.enabledDates = function(dates) {
            if (arguments.length === 0) return options.enabledDates ? $.extend({}, options.enabledDates) : options.enabledDates;
            if (!dates) {
                options.enabledDates = false;
                update();
                return picker
            }
            if (!(dates instanceof Array)) throw new TypeError("enabledDates() expects an array parameter");
            options.enabledDates = indexGivenDates(dates);
            options.disabledDates = false;
            update();
            return picker
        };
        picker.daysOfWeekDisabled = function(daysOfWeekDisabled) {
            if (arguments.length === 0) return options.daysOfWeekDisabled.splice(0);
            if (typeof daysOfWeekDisabled === "boolean" && !daysOfWeekDisabled) {
                options.daysOfWeekDisabled = false;
                update();
                return picker
            }
            if (!(daysOfWeekDisabled instanceof Array)) throw new TypeError("daysOfWeekDisabled() expects an array parameter");
            options.daysOfWeekDisabled = daysOfWeekDisabled.reduce(function(previousValue,
                currentValue) {
                currentValue = parseInt(currentValue, 10);
                if (currentValue > 6 || currentValue < 0 || isNaN(currentValue)) return previousValue;
                if (previousValue.indexOf(currentValue) === -1) previousValue.push(currentValue);
                return previousValue
            }, []).sort();
            if (options.useCurrent && !options.keepInvalid) {
                var tries = 0;
                while (!isValid(date, "d")) {
                    date.add(1, "d");
                    if (tries === 7) throw "Tried 7 times to find a valid date";
                    tries++
                }
                setValue(date)
            }
            update();
            return picker
        };
        picker.maxDate = function(maxDate) {
            if (arguments.length === 0) return options.maxDate ?
                options.maxDate.clone() : options.maxDate;
            if (typeof maxDate === "boolean" && maxDate === false) {
                options.maxDate = false;
                update();
                return picker
            }
            if (typeof maxDate === "string")
                if (maxDate === "now" || maxDate === "moment") maxDate = getMoment();
            var parsedDate = parseInputDate(maxDate);
            if (!parsedDate.isValid()) throw new TypeError("maxDate() Could not parse date parameter: " + maxDate);
            if (options.minDate && parsedDate.isBefore(options.minDate)) throw new TypeError("maxDate() date parameter is before options.minDate: " + parsedDate.format(actualFormat));
            options.maxDate = parsedDate;
            if (options.useCurrent && !options.keepInvalid && date.isAfter(maxDate)) setValue(options.maxDate);
            if (viewDate.isAfter(parsedDate)) viewDate = parsedDate.clone().subtract(options.stepping, "m");
            update();
            return picker
        };
        picker.minDate = function(minDate) {
            if (arguments.length === 0) return options.minDate ? options.minDate.clone() : options.minDate;
            if (typeof minDate === "boolean" && minDate === false) {
                options.minDate = false;
                update();
                return picker
            }
            if (typeof minDate === "string")
                if (minDate === "now" || minDate ===
                    "moment") minDate = getMoment();
            var parsedDate = parseInputDate(minDate);
            if (!parsedDate.isValid()) throw new TypeError("minDate() Could not parse date parameter: " + minDate);
            if (options.maxDate && parsedDate.isAfter(options.maxDate)) throw new TypeError("minDate() date parameter is after options.maxDate: " + parsedDate.format(actualFormat));
            options.minDate = parsedDate;
            if (options.useCurrent && !options.keepInvalid && date.isBefore(minDate)) setValue(options.minDate);
            if (viewDate.isBefore(parsedDate)) viewDate = parsedDate.clone().add(options.stepping,
                "m");
            update();
            return picker
        };
        picker.defaultDate = function(defaultDate) {
            if (arguments.length === 0) return options.defaultDate ? options.defaultDate.clone() : options.defaultDate;
            if (!defaultDate) {
                options.defaultDate = false;
                return picker
            }
            if (typeof defaultDate === "string")
                if (defaultDate === "now" || defaultDate === "moment") defaultDate = getMoment();
            var parsedDate = parseInputDate(defaultDate);
            if (!parsedDate.isValid()) throw new TypeError("defaultDate() Could not parse date parameter: " + defaultDate);
            if (!isValid(parsedDate)) throw new TypeError("defaultDate() date passed is invalid according to component setup validations");
            options.defaultDate = parsedDate;
            if (options.defaultDate && options.inline || input.val().trim() === "") setValue(options.defaultDate);
            return picker
        };
        picker.locale = function(locale) {
            if (arguments.length === 0) return options.locale;
            if (!moment.localeData(locale)) throw new TypeError("locale() locale " + locale + " is not loaded from moment locales!");
            options.locale = locale;
            date.locale(options.locale);
            viewDate.locale(options.locale);
            if (actualFormat) initFormatting();
            if (widget) {
                hide();
                show()
            }
            return picker
        };
        picker.stepping =
            function(stepping) {
                if (arguments.length === 0) return options.stepping;
                stepping = parseInt(stepping, 10);
                if (isNaN(stepping) || stepping < 1) stepping = 1;
                options.stepping = stepping;
                return picker
            };
        picker.useCurrent = function(useCurrent) {
            var useCurrentOptions = ["year", "month", "day", "hour", "minute"];
            if (arguments.length === 0) return options.useCurrent;
            if (typeof useCurrent !== "boolean" && typeof useCurrent !== "string") throw new TypeError("useCurrent() expects a boolean or string parameter");
            if (typeof useCurrent === "string" &&
                useCurrentOptions.indexOf(useCurrent.toLowerCase()) === -1) throw new TypeError("useCurrent() expects a string parameter of " + useCurrentOptions.join(", "));
            options.useCurrent = useCurrent;
            return picker
        };
        picker.collapse = function(collapse) {
            if (arguments.length === 0) return options.collapse;
            if (typeof collapse !== "boolean") throw new TypeError("collapse() expects a boolean parameter");
            if (options.collapse === collapse) return picker;
            options.collapse = collapse;
            if (widget) {
                hide();
                show()
            }
            return picker
        };
        picker.icons = function(icons) {
            if (arguments.length ===
                0) return $.extend({}, options.icons);
            if (!(icons instanceof Object)) throw new TypeError("icons() expects parameter to be an Object");
            $.extend(options.icons, icons);
            if (widget) {
                hide();
                show()
            }
            return picker
        };
        picker.tooltips = function(tooltips) {
            if (arguments.length === 0) return $.extend({}, options.tooltips);
            if (!(tooltips instanceof Object)) throw new TypeError("tooltips() expects parameter to be an Object");
            $.extend(options.tooltips, tooltips);
            if (widget) {
                hide();
                show()
            }
            return picker
        };
        picker.useStrict = function(useStrict) {
            if (arguments.length ===
                0) return options.useStrict;
            if (typeof useStrict !== "boolean") throw new TypeError("useStrict() expects a boolean parameter");
            options.useStrict = useStrict;
            return picker
        };
        picker.sideBySide = function(sideBySide) {
            if (arguments.length === 0) return options.sideBySide;
            if (typeof sideBySide !== "boolean") throw new TypeError("sideBySide() expects a boolean parameter");
            options.sideBySide = sideBySide;
            if (widget) {
                hide();
                show()
            }
            return picker
        };
        picker.viewMode = function(viewMode) {
            if (arguments.length === 0) return options.viewMode;
            if (typeof viewMode !== "string") throw new TypeError("viewMode() expects a string parameter");
            if (viewModes.indexOf(viewMode) === -1) throw new TypeError("viewMode() parameter must be one of (" + viewModes.join(", ") + ") value");
            options.viewMode = viewMode;
            currentViewMode = Math.max(viewModes.indexOf(viewMode), minViewModeNumber);
            showMode();
            return picker
        };
        picker.toolbarPlacement = function(toolbarPlacement) {
            if (arguments.length === 0) return options.toolbarPlacement;
            if (typeof toolbarPlacement !== "string") throw new TypeError("toolbarPlacement() expects a string parameter");
            if (toolbarPlacements.indexOf(toolbarPlacement) === -1) throw new TypeError("toolbarPlacement() parameter must be one of (" + toolbarPlacements.join(", ") + ") value");
            options.toolbarPlacement = toolbarPlacement;
            if (widget) {
                hide();
                show()
            }
            return picker
        };
        picker.widgetPositioning = function(widgetPositioning) {
            if (arguments.length === 0) return $.extend({}, options.widgetPositioning);
            if ({}.toString.call(widgetPositioning) !== "[object Object]") throw new TypeError("widgetPositioning() expects an object variable");
            if (widgetPositioning.horizontal) {
                if (typeof widgetPositioning.horizontal !==
                    "string") throw new TypeError("widgetPositioning() horizontal variable must be a string");
                widgetPositioning.horizontal = widgetPositioning.horizontal.toLowerCase();
                if (horizontalModes.indexOf(widgetPositioning.horizontal) === -1) throw new TypeError("widgetPositioning() expects horizontal parameter to be one of (" + horizontalModes.join(", ") + ")");
                options.widgetPositioning.horizontal = widgetPositioning.horizontal
            }
            if (widgetPositioning.vertical) {
                if (typeof widgetPositioning.vertical !== "string") throw new TypeError("widgetPositioning() vertical variable must be a string");
                widgetPositioning.vertical = widgetPositioning.vertical.toLowerCase();
                if (verticalModes.indexOf(widgetPositioning.vertical) === -1) throw new TypeError("widgetPositioning() expects vertical parameter to be one of (" + verticalModes.join(", ") + ")");
                options.widgetPositioning.vertical = widgetPositioning.vertical
            }
            update();
            return picker
        };
        picker.calendarWeeks = function(calendarWeeks) {
            if (arguments.length === 0) return options.calendarWeeks;
            if (typeof calendarWeeks !== "boolean") throw new TypeError("calendarWeeks() expects parameter to be a boolean value");
            options.calendarWeeks = calendarWeeks;
            update();
            return picker
        };
        picker.showTodayButton = function(showTodayButton) {
            if (arguments.length === 0) return options.showTodayButton;
            if (typeof showTodayButton !== "boolean") throw new TypeError("showTodayButton() expects a boolean parameter");
            options.showTodayButton = showTodayButton;
            if (widget) {
                hide();
                show()
            }
            return picker
        };
        picker.showClear = function(showClear) {
            if (arguments.length === 0) return options.showClear;
            if (typeof showClear !== "boolean") throw new TypeError("showClear() expects a boolean parameter");
            options.showClear = showClear;
            if (widget) {
                hide();
                show()
            }
            return picker
        };
        picker.widgetParent = function(widgetParent) {
            if (arguments.length === 0) return options.widgetParent;
            if (typeof widgetParent === "string") widgetParent = $(widgetParent);
            if (widgetParent !== null && (typeof widgetParent !== "string" && !(widgetParent instanceof $))) throw new TypeError("widgetParent() expects a string or a jQuery object parameter");
            options.widgetParent = widgetParent;
            if (widget) {
                hide();
                show()
            }
            return picker
        };
        picker.keepOpen = function(keepOpen) {
            if (arguments.length ===
                0) return options.keepOpen;
            if (typeof keepOpen !== "boolean") throw new TypeError("keepOpen() expects a boolean parameter");
            options.keepOpen = keepOpen;
            return picker
        };
        picker.focusOnShow = function(focusOnShow) {
            if (arguments.length === 0) return options.focusOnShow;
            if (typeof focusOnShow !== "boolean") throw new TypeError("focusOnShow() expects a boolean parameter");
            options.focusOnShow = focusOnShow;
            return picker
        };
        picker.inline = function(inline) {
            if (arguments.length === 0) return options.inline;
            if (typeof inline !== "boolean") throw new TypeError("inline() expects a boolean parameter");
            options.inline = inline;
            return picker
        };
        picker.clear = function() {
            clear();
            return picker
        };
        picker.keyBinds = function(keyBinds) {
            options.keyBinds = keyBinds;
            return picker
        };
        picker.getMoment = function(d) {
            return getMoment(d)
        };
        picker.debug = function(debug) {
            if (typeof debug !== "boolean") throw new TypeError("debug() expects a boolean parameter");
            options.debug = debug;
            return picker
        };
        picker.allowInputToggle = function(allowInputToggle) {
            if (arguments.length === 0) return options.allowInputToggle;
            if (typeof allowInputToggle !== "boolean") throw new TypeError("allowInputToggle() expects a boolean parameter");
            options.allowInputToggle = allowInputToggle;
            return picker
        };
        picker.showClose = function(showClose) {
            if (arguments.length === 0) return options.showClose;
            if (typeof showClose !== "boolean") throw new TypeError("showClose() expects a boolean parameter");
            options.showClose = showClose;
            return picker
        };
        picker.keepInvalid = function(keepInvalid) {
            if (arguments.length === 0) return options.keepInvalid;
            if (typeof keepInvalid !== "boolean") throw new TypeError("keepInvalid() expects a boolean parameter");
            options.keepInvalid = keepInvalid;
            return picker
        };
        picker.datepickerInput = function(datepickerInput) {
            if (arguments.length === 0) return options.datepickerInput;
            if (typeof datepickerInput !== "string") throw new TypeError("datepickerInput() expects a string parameter");
            options.datepickerInput = datepickerInput;
            return picker
        };
        picker.parseInputDate = function(parseInputDate) {
            if (arguments.length === 0) return options.parseInputDate;
            if (typeof parseInputDate !== "function") throw new TypeError("parseInputDate() sholud be as function");
            options.parseInputDate =
                parseInputDate;
            return picker
        };
        picker.disabledTimeIntervals = function(disabledTimeIntervals) {
            if (arguments.length === 0) return options.disabledTimeIntervals ? $.extend({}, options.disabledTimeIntervals) : options.disabledTimeIntervals;
            if (!disabledTimeIntervals) {
                options.disabledTimeIntervals = false;
                update();
                return picker
            }
            if (!(disabledTimeIntervals instanceof Array)) throw new TypeError("disabledTimeIntervals() expects an array parameter");
            options.disabledTimeIntervals = disabledTimeIntervals;
            update();
            return picker
        };
        picker.disabledHours = function(hours) {
            if (arguments.length === 0) return options.disabledHours ? $.extend({}, options.disabledHours) : options.disabledHours;
            if (!hours) {
                options.disabledHours = false;
                update();
                return picker
            }
            if (!(hours instanceof Array)) throw new TypeError("disabledHours() expects an array parameter");
            options.disabledHours = indexGivenHours(hours);
            options.enabledHours = false;
            if (options.useCurrent && !options.keepInvalid) {
                var tries = 0;
                while (!isValid(date, "h")) {
                    date.add(1, "h");
                    if (tries === 24) throw "Tried 24 times to find a valid date";
                    tries++
                }
                setValue(date)
            }
            update();
            return picker
        };
        picker.enabledHours = function(hours) {
            if (arguments.length === 0) return options.enabledHours ? $.extend({}, options.enabledHours) : options.enabledHours;
            if (!hours) {
                options.enabledHours = false;
                update();
                return picker
            }
            if (!(hours instanceof Array)) throw new TypeError("enabledHours() expects an array parameter");
            options.enabledHours = indexGivenHours(hours);
            options.disabledHours = false;
            if (options.useCurrent && !options.keepInvalid) {
                var tries = 0;
                while (!isValid(date, "h")) {
                    date.add(1,
                        "h");
                    if (tries === 24) throw "Tried 24 times to find a valid date";
                    tries++
                }
                setValue(date)
            }
            update();
            return picker
        };
        picker.viewDate = function(newDate) {
            if (arguments.length === 0) return viewDate.clone();
            if (!newDate) {
                viewDate = date.clone();
                return picker
            }
            if (typeof newDate !== "string" && !moment.isMoment(newDate) && !(newDate instanceof Date)) throw new TypeError("viewDate() parameter must be one of [string, moment or Date]");
            viewDate = parseInputDate(newDate);
            viewUpdate();
            return picker
        };
        if (element.is("input")) input = element;
        else {
            input = element.find(options.datepickerInput);
            if (input.size() === 0) input = element.find("input");
            else if (!input.is("input")) throw new Error('CSS class "' + options.datepickerInput + '" cannot be applied to non input element');
        }
        if (element.hasClass("input-group"))
            if (element.find(".datepickerbutton").size() === 0) component = element.find(".input-group-addon");
            else component = element.find(".datepickerbutton");
        if (!options.inline && !input.is("input")) throw new Error("Could not initialize DateTimePicker without an input element");
        date = getMoment();
        viewDate = date.clone();
        $.extend(true, options, dataToOptions());
        picker.options(options);
        initFormatting();
        attachDatePickerElementEvents();
        if (input.prop("disabled")) picker.disable();
        if (input.is("input") && input.val().trim().length !== 0) setValue(parseInputDate(input.val().trim()));
        else if (options.defaultDate && input.attr("placeholder") === undefined) setValue(options.defaultDate);
        if (options.inline) show();
        return picker
    };
    $.fn.datetimepicker = function(options) {
        return this.each(function() {
            var $this =
                $(this);
            if (!$this.data("DateTimePicker")) {
                options = $.extend(true, {}, $.fn.datetimepicker.defaults, options);
                $this.data("DateTimePicker", dateTimePicker($this, options))
            }
        })
    };
    $.fn.datetimepicker.defaults = {
        timeZone: "Etc/UTC",
        format: false,
        dayViewHeaderFormat: "MMMM YYYY",
        extraFormats: false,
        stepping: 1,
        minDate: false,
        maxDate: false,
        useCurrent: true,
        collapse: true,
        locale: moment.locale(),
        defaultDate: false,
        disabledDates: false,
        enabledDates: false,
        icons: {
            time: "glyphicon glyphicon-time",
            date: "glyphicon glyphicon-calendar",
            up: "glyphicon glyphicon-chevron-up",
            down: "glyphicon glyphicon-chevron-down",
            previous: "glyphicon glyphicon-chevron-left",
            next: "glyphicon glyphicon-chevron-right",
            today: "glyphicon glyphicon-screenshot",
            clear: "glyphicon glyphicon-trash",
            close: "glyphicon glyphicon-remove"
        },
        tooltips: {
            today: "Go to today",
            clear: "Clear selection",
            close: "Close the picker",
            selectMonth: "Select Month",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            selectYear: "Select Year",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            selectDecade: "Select Decade",
            prevDecade: "Previous Decade",
            nextDecade: "Next Decade",
            prevCentury: "Previous Century",
            nextCentury: "Next Century",
            pickHour: "Pick Hour",
            incrementHour: "Increment Hour",
            decrementHour: "Decrement Hour",
            pickMinute: "Pick Minute",
            incrementMinute: "Increment Minute",
            decrementMinute: "Decrement Minute",
            pickSecond: "Pick Second",
            incrementSecond: "Increment Second",
            decrementSecond: "Decrement Second",
            togglePeriod: "Toggle Period",
            selectTime: "Select Time"
        },
        useStrict: false,
        sideBySide: false,
        daysOfWeekDisabled: false,
        calendarWeeks: false,
        viewMode: "days",
        toolbarPlacement: "default",
        showTodayButton: false,
        showClear: false,
        showClose: false,
        widgetPositioning: {
            horizontal: "auto",
            vertical: "auto"
        },
        widgetParent: null,
        ignoreReadonly: false,
        keepOpen: false,
        focusOnShow: true,
        inline: false,
        keepInvalid: false,
        datepickerInput: ".datepickerinput",
        keyBinds: {
            up: function(widget) {
                if (!widget) return;
                var d = this.date() || this.getMoment();
                if (widget.find(".datepicker").is(":visible")) this.date(d.clone().subtract(7, "d"));
                else this.date(d.clone().add(this.stepping(), "m"))
            },
            down: function(widget) {
                if (!widget) {
                    this.show();
                    return
                }
                var d = this.date() || this.getMoment();
                if (widget.find(".datepicker").is(":visible")) this.date(d.clone().add(7, "d"));
                else this.date(d.clone().subtract(this.stepping(), "m"))
            },
            "control up": function(widget) {
                if (!widget) return;
                var d = this.date() || this.getMoment();
                if (widget.find(".datepicker").is(":visible")) this.date(d.clone().subtract(1, "y"));
                else this.date(d.clone().add(1, "h"))
            },
            "control down": function(widget) {
                if (!widget) return;
                var d = this.date() || this.getMoment();
                if (widget.find(".datepicker").is(":visible")) this.date(d.clone().add(1, "y"));
                else this.date(d.clone().subtract(1, "h"))
            },
            left: function(widget) {
                if (!widget) return;
                var d = this.date() || this.getMoment();
                if (widget.find(".datepicker").is(":visible")) this.date(d.clone().subtract(1, "d"))
            },
            right: function(widget) {
                if (!widget) return;
                var d = this.date() || this.getMoment();
                if (widget.find(".datepicker").is(":visible")) this.date(d.clone().add(1, "d"))
            },
            pageUp: function(widget) {
                if (!widget) return;
                var d = this.date() || this.getMoment();
                if (widget.find(".datepicker").is(":visible")) this.date(d.clone().subtract(1, "M"))
            },
            pageDown: function(widget) {
                if (!widget) return;
                var d = this.date() || this.getMoment();
                if (widget.find(".datepicker").is(":visible")) this.date(d.clone().add(1, "M"))
            },
            enter: function() {
                this.hide()
            },
            escape: function() {
                this.hide()
            },
            "control space": function(widget) {
                if (widget.find(".timepicker").is(":visible")) widget.find('.btn[data-action="togglePeriod"]').click()
            },
            t: function() {
                this.date(this.getMoment())
            },
            "delete": function() {
                this.clear()
            }
        },
        debug: false,
        allowInputToggle: false,
        disabledTimeIntervals: false,
        disabledHours: false,
        enabledHours: false,
        viewDate: false
    }
});
(function($) {
    jQuery.extendext = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false,
            arrayMode = "default";
        if (typeof target === "boolean") {
            deep = target;
            target = arguments[i++] || {}
        }
        if (typeof target === "string") {
            arrayMode = jQuery([target.toLowerCase(), "default"]).filter(["default", "concat", "replace", "extend"])[0];
            target = arguments[i++] || {}
        }
        if (typeof target !== "object" && !jQuery.isFunction(target)) target = {};
        if (i === length) {
            target = this;
            i--
        }
        for (; i < length; i++)
            if ((options =
                    arguments[i]) != null)
                if (jQuery.isArray(options) && arrayMode != "default") {
                    clone = target && jQuery.isArray(target) ? target : [];
                    switch (arrayMode) {
                        case "concat":
                            target = clone.concat(jQuery.extend(deep, [], options));
                            break;
                        case "replace":
                            target = jQuery.extend(deep, [], options);
                            break;
                        case "extend":
                            options.forEach(function(e, i) {
                                if (typeof e === "object") {
                                    var type = jQuery.isArray(e) ? [] : {};
                                    clone[i] = jQuery.extendext(deep, arrayMode, clone[i] || type, e)
                                } else if (clone.indexOf(e) === -1) clone.push(e)
                            });
                            target = clone;
                            break
                    }
                } else
                    for (name in options) {
                        src =
                            target[name];
                        copy = options[name];
                        if (target === copy) continue;
                        if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && jQuery.isArray(src) ? src : []
                            } else clone = src && jQuery.isPlainObject(src) ? src : {};
                            target[name] = jQuery.extendext(deep, arrayMode, clone, copy)
                        } else if (copy !== undefined) target[name] = copy
                    }
                return target
    }
})(jQuery);
(function(root, factory) {
    if (typeof module !== "undefined" && module.exports) module.exports = factory();
    else if (typeof define === "function" && define.amd) define([], factory);
    else root.MicroEvent = factory()
})(this, function() {
    var MicroEvent = function() {};
    MicroEvent.prototype = {
        on: function(events, fct) {
            this._events = this._events || {};
            if (typeof events === "object")
                for (var event in events) {
                    if (events.hasOwnProperty(event)) {
                        this._events[event] = this._events[event] || [];
                        this._events[event].push(events[event])
                    }
                } else events.split(" ").forEach(function(event) {
                    this._events[event] =
                        this._events[event] || [];
                    this._events[event].push(fct)
                }, this);
            return this
        },
        off: function(events, fct) {
            this._events = this._events || {};
            if (typeof events === "object")
                for (var event in events) {
                    if (events.hasOwnProperty(event) && event in this._events) {
                        var index = this._events[event].indexOf(events[event]);
                        if (index !== -1) this._events[event].splice(index, 1)
                    }
                } else if (!!events) events.split(" ").forEach(function(event) {
                    if (event in this._events)
                        if (fct) {
                            var index = this._events[event].indexOf(fct);
                            if (index !== -1) this._events[event].splice(index,
                                1)
                        } else this._events[event] = []
                }, this);
                else this._events = {};
            return this
        },
        once: function(events, fct) {
            this._once = this._once || {};
            if (typeof events === "object")
                for (var event in events) {
                    if (events.hasOwnProperty(event)) {
                        this._once[event] = this._once[event] || [];
                        this._once[event].push(events[event])
                    }
                } else events.split(" ").forEach(function(event) {
                    this._once[event] = this._once[event] || [];
                    this._once[event].push(fct)
                }, this);
            return this
        },
        trigger: function(event) {
            this._events = this._events || {};
            this._once = this._once || {};
            var args = Array.prototype.slice.call(arguments, 1),
                callbacks;
            if (event in this._events) {
                callbacks = this._events[event].slice();
                while (callbacks.length) callbacks.shift().apply(this, args)
            }
            if (event in this._once) {
                callbacks = this._once[event].slice();
                while (callbacks.length) callbacks.shift().apply(this, args);
                delete this._once[event]
            }
            return this
        },
        change: function(event, value) {
            this._events = this._events || {};
            if (event in this._events) {
                var args = Array.prototype.slice.call(arguments, 1);
                for (var i = 0, l = this._events[event].length; i <
                    l; i++) {
                    args[0] = value;
                    value = this._events[event][i].apply(this, args)
                }
            }
            return value
        }
    };
    MicroEvent.mixin = function(obj, names) {
        names = names || {};
        var props = ["on", "off", "once", "trigger", "change"];
        for (var i = 0, l = props.length; i < l; i++) {
            var method = names[props[i]] || props[i];
            if (typeof obj === "function") obj.prototype[method] = MicroEvent.prototype[props[i]];
            else obj[method] = MicroEvent.prototype[props[i]]
        }
    };
    return MicroEvent
});
(function(root, factory) {
    if (typeof define === "function" && define.amd) define(["lodash"], function(_) {
        return factory(_, root)
    });
    else if (typeof module === "object" && module.exports) module.exports = factory(require("lodash"), this);
    else root.postal = factory(root._, root)
})(this, function(_, global, undefined) {
    var prevPostal = global.postal;
    var _defaultConfig = {
        DEFAULT_CHANNEL: "/",
        SYSTEM_CHANNEL: "postal",
        enableSystemMessages: true,
        cacheKeyDelimiter: "|",
        autoCompactResolver: false
    };
    var postal = {
        configuration: _.extend({}, _defaultConfig)
    };
    var _config = postal.configuration;
    var ChannelDefinition = function(channelName, bus) {
        this.bus = bus;
        this.channel = channelName || _config.DEFAULT_CHANNEL
    };
    ChannelDefinition.prototype.subscribe = function() {
        return this.bus.subscribe({
            channel: this.channel,
            topic: arguments.length === 1 ? arguments[0].topic : arguments[0],
            callback: arguments.length === 1 ? arguments[0].callback : arguments[1]
        })
    };
    ChannelDefinition.prototype.publish = function() {
        var envelope = {};
        var callback;
        if (typeof arguments[0] === "string") {
            envelope.topic = arguments[0];
            envelope.data = arguments[1];
            callback = arguments[2]
        } else {
            envelope = arguments[0];
            callback = arguments[1]
        }
        envelope.channel = this.channel;
        this.bus.publish(envelope, callback)
    };
    var SubscriptionDefinition = function(channel, topic, callback) {
        if (arguments.length !== 3) throw new Error("You must provide a channel, topic and callback when creating a SubscriptionDefinition instance.");
        if (topic.length === 0) throw new Error("Topics cannot be empty");
        this.channel = channel;
        this.topic = topic;
        this.callback = callback;
        this.pipeline = [];
        this.cacheKeys = [];
        this._context = undefined
    };
    var ConsecutiveDistinctPredicate = function() {
        var previous;
        return function(data) {
            var eq = false;
            if (typeof data == "string") {
                eq = data === previous;
                previous = data
            } else {
                eq = _.isEqual(data, previous);
                previous = _.extend({}, data)
            }
            return !eq
        }
    };
    var DistinctPredicate = function DistinctPredicateFactory() {
        var previous = [];
        return function DistinctPredicate(data) {
            var isDistinct = !_.any(previous, function(p) {
                return _.isEqual(data, p)
            });
            if (isDistinct) previous.push(data);
            return isDistinct
        }
    };
    SubscriptionDefinition.prototype = {
        "catch": function(errorHandler) {
            var original = this.callback;
            var safeCallback = function() {
                try {
                    original.apply(this, arguments)
                } catch (err) {
                    errorHandler(err, arguments[0])
                }
            };
            this.callback = safeCallback;
            return this
        },
        defer: function defer() {
            return this.delay(0)
        },
        disposeAfter: function disposeAfter(maxCalls) {
            if (typeof maxCalls != "number" || maxCalls <= 0) throw new Error("The value provided to disposeAfter (maxCalls) must be a number greater than zero.");
            var self = this;
            var dispose = _.after(maxCalls,
                _.bind(function() {
                    self.unsubscribe()
                }));
            self.pipeline.push(function(data, env, next) {
                next(data, env);
                dispose()
            });
            return self
        },
        distinct: function distinct() {
            return this.constraint(new DistinctPredicate)
        },
        distinctUntilChanged: function distinctUntilChanged() {
            return this.constraint(new ConsecutiveDistinctPredicate)
        },
        invokeSubscriber: function invokeSubscriber(data, env) {
            if (!this.inactive) {
                var self = this;
                var pipeline = self.pipeline;
                var len = pipeline.length;
                var context = self._context;
                var idx = -1;
                var invoked = false;
                if (!len) {
                    self.callback.call(context, data, env);
                    invoked = true
                } else {
                    pipeline = pipeline.concat([self.callback]);
                    var step = function step(d, e) {
                        idx += 1;
                        if (idx < len) pipeline[idx].call(context, d, e, step);
                        else {
                            self.callback.call(context, d, e);
                            invoked = true
                        }
                    };
                    step(data, env, 0)
                }
                return invoked
            }
        },
        logError: function logError() {
            if (console) {
                var report;
                if (console.warn) report = console.warn;
                else report = console.log;
                this["catch"](report)
            }
            return this
        },
        once: function once() {
            return this.disposeAfter(1)
        },
        subscribe: function subscribe(callback) {
            this.callback =
                callback;
            return this
        },
        unsubscribe: function unsubscribe() {
            if (!this.inactive) postal.unsubscribe(this)
        },
        constraint: function constraint(predicate) {
            if (typeof predicate != "function") throw new Error("Predicate constraint must be a function");
            this.pipeline.push(function(data, env, next) {
                if (predicate.call(this, data, env)) next(data, env)
            });
            return this
        },
        constraints: function constraints(predicates) {
            var self = this;
            _.each(predicates, function(predicate) {
                self.constraint(predicate)
            });
            return self
        },
        context: function contextSetter(context) {
            this._context =
                context;
            return this
        },
        debounce: function debounce(milliseconds, immediate) {
            if (typeof milliseconds != "number") throw new Error("Milliseconds must be a number");
            this.pipeline.push(_.debounce(function(data, env, next) {
                next(data, env)
            }, milliseconds, !!immediate));
            return this
        },
        delay: function delay(milliseconds) {
            if (typeof milliseconds != "number") throw new Error("Milliseconds must be a number");
            var self = this;
            self.pipeline.push(function(data, env, next) {
                setTimeout(function() {
                    next(data, env)
                }, milliseconds)
            });
            return this
        },
        throttle: function throttle(milliseconds) {
            if (typeof milliseconds != "number") throw new Error("Milliseconds must be a number");
            var fn = function(data, env, next) {
                next(data, env)
            };
            this.pipeline.push(_.throttle(fn, milliseconds));
            return this
        }
    };

    function warnOnDeprecation(oldMethod, newMethod) {
        return function() {
            if (console.warn || console.log) {
                var msg = "Warning, the " + oldMethod + " method has been deprecated. Please use " + newMethod + " instead.";
                if (console.warn) console.warn(msg);
                else console.log(msg)
            }
            return SubscriptionDefinition.prototype[newMethod].apply(this,
                arguments)
        }
    }
    var oldMethods = ["withConstraint", "withConstraints", "withContext", "withDebounce", "withDelay", "withThrottle"];
    var newMethods = ["constraint", "constraints", "context", "debounce", "delay", "throttle"];
    for (var i = 0; i < 6; i++) {
        var oldMethod = oldMethods[i];
        SubscriptionDefinition.prototype[oldMethod] = warnOnDeprecation(oldMethod, newMethods[i])
    }
    var bindingsResolver = _config.resolver = {
        cache: {},
        regex: {},
        enableCache: true,
        compare: function compare(binding, topic, headerOptions) {
            var pattern;
            var rgx;
            var prevSegment;
            var cacheKey = topic + _config.cacheKeyDelimiter + binding;
            var result = this.cache[cacheKey];
            var opt = headerOptions || {};
            var saveToCache = this.enableCache && !opt.resolverNoCache;
            if (result === true) return result;
            if (binding.indexOf("#") === -1 && binding.indexOf("*") === -1) {
                result = topic === binding;
                if (saveToCache) this.cache[cacheKey] = result;
                return result
            }
            if (!(rgx = this.regex[binding])) {
                pattern = "^" + _.map(binding.split("."), function mapTopicBinding(segment) {
                    var res = "";
                    if (!!prevSegment) res = prevSegment !== "#" ? "\\.\\b" : "\\b";
                    if (segment === "#") res += "[\\s\\S]*";
                    else if (segment === "*") res += "[^.]+";
                    else res += segment;
                    prevSegment = segment;
                    return res
                }).join("") + "$";
                rgx = this.regex[binding] = new RegExp(pattern)
            }
            result = rgx.test(topic);
            if (saveToCache) this.cache[cacheKey] = result;
            return result
        },
        reset: function reset() {
            this.cache = {};
            this.regex = {}
        },
        purge: function(options) {
            var self = this;
            var keyDelimiter = _config.cacheKeyDelimiter;
            var matchPredicate = function(val, key) {
                var split = key.split(keyDelimiter);
                var topic = split[0];
                var binding = split[1];
                if ((typeof options.topic === "undefined" || options.topic === topic) && (typeof options.binding === "undefined" || options.binding === binding)) delete self.cache[key]
            };
            var compactPredicate = function(val, key) {
                var split = key.split(keyDelimiter);
                if (postal.getSubscribersFor({
                        topic: split[0]
                    }).length === 0) delete self.cache[key]
            };
            if (typeof options === "undefined") this.reset();
            else {
                var handler = options.compact === true ? compactPredicate : matchPredicate;
                _.each(this.cache, handler)
            }
        }
    };
    var pubInProgress = 0;
    var unSubQueue = [];
    var autoCompactIndex =
        0;

    function clearUnSubQueue() {
        while (unSubQueue.length) postal.unsubscribe(unSubQueue.shift())
    }

    function getCachePurger(subDef, key, cache) {
        return function(sub, i, list) {
            if (sub === subDef) list.splice(i, 1);
            if (list.length === 0) delete cache[key]
        }
    }

    function getCacher(topic, cache, cacheKey, done, envelope) {
        var headers = envelope && envelope.headers || {};
        return function(subDef) {
            if (_config.resolver.compare(subDef.topic, topic, headers)) {
                cache.push(subDef);
                subDef.cacheKeys.push(cacheKey);
                if (done) done(subDef)
            }
        }
    }

    function getSystemMessage(kind,
        subDef) {
        return {
            channel: _config.SYSTEM_CHANNEL,
            topic: "subscription." + kind,
            data: {
                event: "subscription." + kind,
                channel: subDef.channel,
                topic: subDef.topic
            }
        }
    }
    var sysCreatedMessage = _.bind(getSystemMessage, this, "created");
    var sysRemovedMessage = _.bind(getSystemMessage, this, "removed");

    function getPredicate(options, resolver) {
        if (typeof options === "function") return options;
        else if (!options) return function() {
            return true
        };
        else return function(sub) {
            var compared = 0,
                matched = 0;
            _.each(options, function(val, prop) {
                compared +=
                    1;
                if (prop === "topic" && resolver.compare(sub.topic, options.topic, {
                        resolverNoCache: true
                    }) || prop === "context" && options.context === sub._context || sub[prop] === options[prop]) matched += 1
            });
            return compared === matched
        }
    }
    _.extend(postal, {
        cache: {},
        subscriptions: {},
        wireTaps: [],
        ChannelDefinition: ChannelDefinition,
        SubscriptionDefinition: SubscriptionDefinition,
        channel: function channel(channelName) {
            return new ChannelDefinition(channelName, this)
        },
        addWireTap: function addWireTap(callback) {
            var self = this;
            self.wireTaps.push(callback);
            return function() {
                var idx = self.wireTaps.indexOf(callback);
                if (idx !== -1) self.wireTaps.splice(idx, 1)
            }
        },
        noConflict: function noConflict() {
            if (typeof window === "undefined" || typeof window !== "undefined" && typeof define === "function" && define.amd) throw new Error("noConflict can only be used in browser clients which aren't using AMD modules");
            global.postal = prevPostal;
            return this
        },
        getSubscribersFor: function getSubscribersFor(options) {
            var result = [];
            var self = this;
            _.each(self.subscriptions, function(channel) {
                _.each(channel,
                    function(subList) {
                        result = result.concat(_.filter(subList, getPredicate(options, _config.resolver)))
                    })
            });
            return result
        },
        publish: function publish(envelope, cb) {
            ++pubInProgress;
            var channel = envelope.channel = envelope.channel || _config.DEFAULT_CHANNEL;
            var topic = envelope.topic;
            envelope.timeStamp = new Date;
            if (this.wireTaps.length) _.each(this.wireTaps, function(tap) {
                tap(envelope.data, envelope, pubInProgress)
            });
            var cacheKey = channel + _config.cacheKeyDelimiter + topic;
            var cache = this.cache[cacheKey];
            var skipped = 0;
            var activated =
                0;
            if (!cache) {
                cache = this.cache[cacheKey] = [];
                var cacherFn = getCacher(topic, cache, cacheKey, function(candidate) {
                    if (candidate.invokeSubscriber(envelope.data, envelope)) activated++;
                    else skipped++
                }, envelope);
                _.each(this.subscriptions[channel], function(candidates) {
                    _.each(candidates, cacherFn)
                })
            } else _.each(cache, function(subDef) {
                if (subDef.invokeSubscriber(envelope.data, envelope)) activated++;
                else skipped++
            });
            if (--pubInProgress === 0) clearUnSubQueue();
            if (cb) cb({
                activated: activated,
                skipped: skipped
            })
        },
        reset: function reset() {
            this.unsubscribeFor();
            _config.resolver.reset();
            this.subscriptions = {}
        },
        subscribe: function subscribe(options) {
            var subscriptions = this.subscriptions;
            var subDef = new SubscriptionDefinition(options.channel || _config.DEFAULT_CHANNEL, options.topic, options.callback);
            var channel = subscriptions[subDef.channel];
            var channelLen = subDef.channel.length;
            var subs;
            if (!channel) channel = subscriptions[subDef.channel] = {};
            subs = subscriptions[subDef.channel][subDef.topic];
            if (!subs) subs = subscriptions[subDef.channel][subDef.topic] = [];
            subs.push(subDef);
            _.each(this.cache, function(list, cacheKey) {
                if (cacheKey.substr(0, channelLen) === subDef.channel) getCacher(cacheKey.split(_config.cacheKeyDelimiter)[1], list, cacheKey)(subDef)
            });
            if (_config.enableSystemMessages) this.publish(sysCreatedMessage(subDef));
            return subDef
        },
        unsubscribe: function unsubscribe() {
            var unSubLen = arguments.length;
            var unSubIdx = 0;
            var subDef;
            var channelSubs;
            var topicSubs;
            var idx;
            for (; unSubIdx < unSubLen; unSubIdx++) {
                subDef = arguments[unSubIdx];
                subDef.inactive = true;
                if (pubInProgress) {
                    unSubQueue.push(subDef);
                    return
                }
                channelSubs = this.subscriptions[subDef.channel];
                topicSubs = channelSubs && channelSubs[subDef.topic];
                if (topicSubs) {
                    var len = topicSubs.length;
                    idx = 0;
                    while (idx < len) {
                        if (topicSubs[idx] === subDef) {
                            topicSubs.splice(idx, 1);
                            break
                        }
                        idx += 1
                    }
                    if (topicSubs.length === 0) {
                        delete channelSubs[subDef.topic];
                        if (!_.keys(channelSubs).length) delete this.subscriptions[subDef.channel]
                    }
                    if (subDef.cacheKeys && subDef.cacheKeys.length) {
                        var key;
                        while (key = subDef.cacheKeys.pop()) _.each(this.cache[key], getCachePurger(subDef, key, this.cache))
                    }
                    if (typeof _config.resolver.purge ===
                        "function") {
                        var autoCompact = _config.autoCompactResolver === true ? 0 : typeof _config.autoCompactResolver === "number" ? _config.autoCompactResolver - 1 : false;
                        if (autoCompact >= 0 && autoCompactIndex === autoCompact) {
                            _config.resolver.purge({
                                compact: true
                            });
                            autoCompactIndex = 0
                        } else if (autoCompact >= 0 && autoCompactIndex < autoCompact) autoCompactIndex += 1
                    }
                }
                if (_config.enableSystemMessages) this.publish(sysRemovedMessage(subDef))
            }
        },
        unsubscribeFor: function unsubscribeFor(options) {
            var toDispose = [];
            if (this.subscriptions) {
                toDispose =
                    this.getSubscribersFor(options);
                this.unsubscribe.apply(this, toDispose)
            }
        }
    });
    if (global && Object.prototype.hasOwnProperty.call(global, "__postalReady__") && _.isArray(global.__postalReady__))
        while (global.__postalReady__.length) global.__postalReady__.shift().onReady(postal);
    return postal
});
(function() {
    function debug(label) {
        return _debug.bind(null, label)
    }

    function _debug(label) {
        var args = [].slice.call(arguments, 1);
        args.unshift("[" + label + "]");
        process.stderr.write(args.join(" ") + "\n")
    }
    var DEBUG = false;
    var TIMER = false;

    function lex(css) {
        var start;
        var buffer = "";
        var ch;
        var column = 0;
        var cursor = -1;
        var depth = 0;
        var line = 1;
        var state = "before-selector";
        var stack = [state];
        var token = {};
        var tokens = [];
        var atRules = ["media", "keyframes", {
            name: "-webkit-keyframes",
            type: "keyframes",
            prefix: "-webkit-"
        }, {
            name: "-moz-keyframes",
            type: "keyframes",
            prefix: "-moz-"
        }, {
            name: "-ms-keyframes",
            type: "keyframes",
            prefix: "-ms-"
        }, {
            name: "-o-keyframes",
            type: "keyframes",
            prefix: "-o-"
        }, "font-face", {
            name: "import",
            state: "before-at-value"
        }, {
            name: "charset",
            state: "before-at-value"
        }, "supports", "viewport", {
            name: "namespace",
            state: "before-at-value"
        }, "document", {
            name: "-moz-document",
            type: "document",
            prefix: "-moz-"
        }, "page"];

        function getCh() {
            skip();
            return css[cursor]
        }

        function getState(index) {
            return index ? stack[stack.length - 1 - index] : state
        }

        function isNextString(str) {
            var start =
                cursor + 1;
            return str === css.slice(start, start + str.length)
        }

        function find(str) {
            var pos = css.slice(cursor).indexOf(str);
            return pos > 0 ? pos : false
        }

        function isNextChar(ch) {
            return ch === peek(1)
        }

        function peek(offset) {
            return css[cursor + (offset || 1)]
        }

        function popState() {
            var removed = stack.pop();
            state = stack[stack.length - 1];
            return removed
        }

        function pushState(newState) {
            state = newState;
            stack.push(state);
            return stack.length
        }

        function replaceState(newState) {
            var previousState = state;
            stack[stack.length - 1] = state = newState;
            return previousState
        }

        function skip(n) {
            cursor = cursor + (n || 1)
        }

        function addToken() {
            token.end = {
                line: line,
                col: column
            };
            DEBUG && debug("addToken:", JSON.stringify(token, null, 2));
            tokens.push(token);
            buffer = "";
            token = {}
        }

        function initializeToken(type) {
            token = {
                type: type,
                start: {
                    line: line,
                    col: column
                }
            }
        }
        TIMER && (start = Date.now());
        while (ch = getCh()) {
            DEBUG && debug(ch, getState());
            column += 1;
            switch (ch) {
                case " ":
                    switch (getState()) {
                        case "selector":
                        case "value":
                        case "value-paren":
                        case "at-group":
                        case "at-value":
                        case "comment":
                        case "double-string":
                        case "single-string":
                            buffer +=
                                ch;
                            break
                    }
                    break;
                case "\n":
                case "\t":
                case "\r":
                case "\f":
                    switch (getState()) {
                        case "comment":
                        case "single-string":
                        case "double-string":
                        case "selector":
                            buffer += ch;
                            break;
                        case "at-value":
                            if ("\n" === ch) {
                                token.value = buffer.trim();
                                addToken();
                                popState()
                            }
                            break
                    }
                    if ("\n" === ch) {
                        column = 0;
                        line += 1
                    }
                    break;
                case ":":
                    switch (getState()) {
                        case "name":
                            token.name = buffer.trim();
                            buffer = "";
                            replaceState("before-value");
                            break;
                        case "before-selector":
                            buffer += ch;
                            initializeToken("selector");
                            pushState("selector");
                            break;
                        default:
                            buffer +=
                                ch;
                            break
                    }
                    break;
                case ";":
                    switch (getState()) {
                        case "name":
                        case "value":
                            token.value = buffer.trim(), addToken();
                            replaceState("before-name");
                            break;
                        case "value-paren":
                            buffer += ch;
                            break;
                        case "at-value":
                            token.value = buffer.trim();
                            addToken();
                            popState();
                            break;
                        case "before-name":
                            break;
                        default:
                            buffer += ch;
                            break
                    }
                    break;
                case "{":
                    switch (getState()) {
                        case "selector":
                            if (peek(-1) === "\\") {
                                buffer += ch;
                                break
                            }
                            token.text = buffer.trim();
                            addToken();
                            replaceState("before-name");
                            break;
                        case "at-group":
                            token.name = buffer.trim();
                            switch (token.type) {
                                case "font-face":
                                case "viewport":
                                case "page":
                                    pushState("before-name");
                                    break;
                                default:
                                    pushState("before-selector")
                            }
                            addToken();
                            break;
                        case "name":
                        case "at-rule":
                            token.name = buffer.trim();
                            addToken();
                            pushState("before-name");
                            break;
                        case "comment":
                        case "double-string":
                        case "single-string":
                            buffer += ch;
                            break
                    }
                    if ("comment" !== getState()) depth = depth + 1;
                    break;
                case "}":
                    switch (getState()) {
                        case "before-name":
                        case "name":
                        case "value":
                            if (buffer) token.value = buffer.trim();
                            if (token.name && token.value) addToken();
                            initializeToken("end");
                            addToken();
                            popState();
                            if ("at-group" === getState()) {
                                initializeToken("at-group-end");
                                addToken();
                                popState()
                            }
                            break;
                        case "at-group":
                        case "before-selector":
                        case "selector":
                            if (peek(-1) === "\\") {
                                buffer += ch;
                                break
                            }
                            if (depth > 0)
                                if ("at-group" === getState(1)) {
                                    initializeToken("at-group-end");
                                    addToken()
                                }
                            if (depth > 1) popState();
                            break;
                        case "double-string":
                        case "single-string":
                        case "comment":
                            buffer += ch;
                            break
                    }
                    if (depth > 0 && "comment" !== getState()) depth = depth - 1;
                    break;
                case '"':
                case "'":
                    switch (getState()) {
                        case "double-string":
                            if ('"' === ch && "\\" !== peek(-1)) popState();
                            break;
                        case "single-string":
                            if ("'" === ch && "\\" !==
                                peek(-1)) popState();
                            break;
                        case "before-at-value":
                            replaceState("at-value");
                            pushState('"' === ch ? "double-string" : "single-string");
                            break;
                        case "before-value":
                            replaceState("value");
                            pushState('"' === ch ? "double-string" : "single-string");
                            break;
                        case "comment":
                            break;
                        default:
                            if ("\\" !== peek(-1)) pushState('"' === ch ? "double-string" : "single-string")
                    }
                    buffer += ch;
                    break;
                case "/":
                    switch (getState()) {
                        case "comment":
                        case "double-string":
                        case "single-string":
                            buffer += ch;
                            break;
                        case "before-value":
                        case "selector":
                        case "name":
                        case "value":
                            if (isNextChar("*")) {
                                var pos =
                                    find("*/");
                                if (pos) skip(pos + 1)
                            } else buffer += ch;
                            break;
                        default:
                            if (isNextChar("*")) {
                                skip();
                                initializeToken("comment");
                                pushState("comment")
                            } else buffer += ch;
                            break
                    }
                    break;
                case "*":
                    switch (getState()) {
                        case "comment":
                            if (isNextChar("/")) {
                                token.text = buffer;
                                skip();
                                addToken();
                                popState()
                            } else buffer += ch;
                            break;
                        case "before-selector":
                            buffer += ch;
                            initializeToken("selector");
                            pushState("selector");
                            break;
                        default:
                            buffer += ch
                    }
                    break;
                case "@":
                    switch (getState()) {
                        case "comment":
                        case "double-string":
                        case "single-string":
                            buffer +=
                                ch;
                            break;
                        default:
                            var tokenized = false;
                            var name;
                            var rule;
                            for (var j = 0, len = atRules.length; !tokenized && j < len; ++j) {
                                rule = atRules[j];
                                name = rule.name || rule;
                                if (!isNextString(name)) continue;
                                tokenized = true;
                                skip(name.length);
                                initializeToken(name);
                                pushState(rule.state || "at-group");
                                if (rule.prefix) token.prefix = rule.prefix;
                                if (rule.type) token.type = rule.type
                            }
                            if (!tokenized) buffer += ch;
                            break
                    }
                    break;
                case "(":
                    switch (getState()) {
                        case "value":
                            pushState("value-paren");
                            break
                    }
                    buffer += ch;
                    break;
                case ")":
                    switch (getState()) {
                        case "value-paren":
                            popState();
                            break
                    }
                    buffer += ch;
                    break;
                default:
                    switch (getState()) {
                        case "before-selector":
                            initializeToken("selector");
                            pushState("selector");
                            break;
                        case "before-name":
                            initializeToken("property");
                            replaceState("name");
                            break;
                        case "before-value":
                            replaceState("value");
                            break;
                        case "before-at-value":
                            replaceState("at-value");
                            break
                    }
                    buffer += ch;
                    break
            }
        }
        TIMER && debug("ran in", Date.now() - start + "ms");
        return tokens
    }
    var DEBUG = false;
    var TIMER = false;
    var _comments;
    var _depth;
    var _position;
    var _tokens;

    function parse(css, options) {
        var start;
        options || (options = {});
        _comments = !!options.comments;
        _position = !!options.position;
        _depth = 0;
        _tokens = Array.isArray(css) ? css.slice() : lex(css);
        var rule;
        var rules = [];
        var token;
        TIMER && (start = Date.now());
        while (token = next()) {
            rule = parseToken(token);
            rule && rules.push(rule)
        }
        TIMER && debug("ran in", Date.now() - start + "ms");
        return {
            type: "stylesheet",
            stylesheet: {
                rules: rules
            }
        }
    }

    function astNode(token, override) {
        override || (override = {});
        var key;
        var keys = ["type", "name", "value"];
        var node = {};
        for (var i = 0; i < keys.length; ++i) {
            key =
                keys[i];
            if (token[key]) node[key] = override[key] || token[key]
        }
        keys = Object.keys(override);
        for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (!node[key]) node[key] = override[key]
        }
        if (_position) node.position = {
            start: token.start,
            end: token.end
        };
        DEBUG && debug("astNode:", JSON.stringify(node, null, 2));
        return node
    }

    function next() {
        var token = _tokens.shift();
        DEBUG && debug("next:", JSON.stringify(token, null, 2));
        return token
    }

    function parseAtGroup(token) {
        _depth = _depth + 1;
        var overrides = {};
        switch (token.type) {
            case "font-face":
            case "viewport":
                overrides.declarations =
                    parseDeclarations();
                break;
            case "page":
                overrides.prefix = token.prefix;
                overrides.declarations = parseDeclarations();
                break;
            default:
                overrides.prefix = token.prefix;
                overrides.rules = parseRules()
        }
        return astNode(token, overrides)
    }

    function parseAtImport(token) {
        return astNode(token)
    }

    function parseCharset(token) {
        return astNode(token)
    }

    function parseComment(token) {
        return astNode(token, {
            text: token.text
        })
    }

    function parseNamespace(token) {
        return astNode(token)
    }

    function parseProperty(token) {
        return astNode(token)
    }

    function parseSelector(token) {
        function trim(str) {
            return str.trim()
        }
        return astNode(token, {
            type: "rule",
            selectors: token.text.split(",").map(trim),
            declarations: parseDeclarations(token)
        })
    }

    function parseToken(token) {
        switch (token.type) {
            case "property":
                return parseProperty(token);
            case "selector":
                return parseSelector(token);
            case "at-group-end":
                _depth = _depth - 1;
                return;
            case "media":
            case "keyframes":
                return parseAtGroup(token);
            case "comment":
                if (_comments) return parseComment(token);
                break;
            case "charset":
                return parseCharset(token);
            case "import":
                return parseAtImport(token);
            case "namespace":
                return parseNamespace(token);
            case "font-face":
            case "supports":
            case "viewport":
            case "document":
            case "page":
                return parseAtGroup(token)
        }
        DEBUG && debug("parseToken: unexpected token:", JSON.stringify(token))
    }

    function parseTokensWhile(conditionFn) {
        var node;
        var nodes = [];
        var token;
        while ((token = next()) && (conditionFn && conditionFn(token))) {
            node = parseToken(token);
            node && nodes.push(node)
        }
        if (token && token.type !== "end") _tokens.unshift(token);
        return nodes
    }

    function parseDeclarations() {
        return parseTokensWhile(function(token) {
            return token.type === "property" ||
                token.type === "comment"
        })
    }

    function parseRules() {
        return parseTokensWhile(function() {
            return _depth
        })
    }
    var DEBUG = false;
    var TIMER = false;
    var _comments;
    var _compress;
    var _indentation;
    var _n;
    var _s;

    function stringify(ast, options) {
        var start;
        options || (options = {});
        _indentation = options.indentation || "";
        _compress = !!options.compress;
        _comments = !!options.comments;
        if (_compress) _n = _s = "";
        else {
            _n = "\n";
            _s = " "
        }
        TIMER && (start = Date.now());
        var css = reduce(ast.stylesheet.rules, stringifyNode).join("\n").trim();
        TIMER && debug("ran in",
            Date.now() - start + "ms");
        return css
    }

    function indent(level) {
        this.level || (this.level = 1);
        if (level) {
            this.level += level;
            return
        }
        if (_compress) return "";
        return Array(this.level).join(_indentation || "")
    }

    function stringifyAtRule(node) {
        return "@" + node.type + " " + node.value + ";" + _n
    }

    function stringifyAtGroup(node) {
        var label = "";
        var prefix = node.prefix || "";
        if (node.name) label = " " + node.name;
        var chomp = node.type !== "page";
        return "@" + prefix + node.type + label + _s + stringifyBlock(node, chomp) + _n
    }

    function stringifyComment(node) {
        if (!_comments) return "";
        return "/*" + (node.text || "") + "*/" + _n
    }

    function stringifyRule(node) {
        var label;
        if (node.selectors) label = node.selectors.join("," + _n);
        else {
            label = "@" + node.type;
            label += node.name ? " " + node.name : ""
        }
        return indent() + label + _s + stringifyBlock(node) + _n
    }

    function reduce(items, fn) {
        return items.reduce(function(results, item) {
            var result = item.type === "comment" ? stringifyComment(item) : fn(item);
            result && results.push(result);
            return results
        }, [])
    }

    function stringifyBlock(node, chomp) {
        var children = node.declarations;
        var fn = stringifyDeclaration;
        if (node.rules) {
            children = node.rules;
            fn = stringifyRule
        }
        children = stringifyChildren(children, fn);
        children && (children = _n + children + (chomp ? "" : _n));
        return "{" + children + indent() + "}"
    }

    function stringifyChildren(children, fn) {
        if (!children) return "";
        indent(1);
        var results = reduce(children, fn);
        indent(-1);
        if (!results.length) return "";
        return results.join(_n)
    }

    function stringifyDeclaration(node) {
        if (node.type === "property") return stringifyProperty(node);
        DEBUG && debug("stringifyDeclaration: unexpected node:", JSON.stringify(node))
    }

    function stringifyNode(node) {
        switch (node.type) {
            case "rule":
                return stringifyRule(node);
            case "media":
            case "keyframes":
                return stringifyAtGroup(node);
            case "comment":
                return stringifyComment(node);
            case "import":
            case "charset":
            case "namespace":
                return stringifyAtRule(node);
            case "font-face":
            case "supports":
            case "viewport":
            case "document":
            case "page":
                return stringifyAtGroup(node)
        }
        DEBUG && debug("stringifyNode: unexpected node: " + JSON.stringify(node))
    }

    function stringifyProperty(node) {
        var name = node.name ? node.name +
            ":" + _s : "";
        return indent() + name + node.value + ";"
    }
    window.mensch = {};
    window.mensch.parse = parse;
    window.mensch.stringify = stringify
})();
var JSON5 = typeof exports === "object" ? exports : {};
JSON5.parse = function() {
    var at, ch, escapee = {
            "'": "'",
            '"': '"',
            "\\": "\\",
            "/": "/",
            "\n": "",
            b: "\b",
            f: "\f",
            n: "\n",
            r: "\r",
            t: "\t"
        },
        ws = [" ", "\t", "\r", "\n", "\v", "\f", " ", "﻿"],
        text, error = function(m) {
            var error = new SyntaxError;
            error.message = m;
            error.at = at;
            error.text = text;
            throw error;
        },
        next = function(c) {
            if (c && c !== ch) error("Expected '" + c + "' instead of '" + ch + "'");
            ch = text.charAt(at);
            at += 1;
            return ch
        },
        peek = function() {
            return text.charAt(at)
        },
        identifier = function() {
            var key = ch;
            if (ch !== "_" && ch !== "$" && (ch < "a" || ch > "z") && (ch < "A" ||
                    ch > "Z")) error("Bad identifier");
            while (next() && (ch === "_" || ch === "$" || ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch >= "0" && ch <= "9")) key += ch;
            return key
        },
        number = function() {
            var number, sign = "",
                string = "",
                base = 10;
            if (ch === "-" || ch === "+") {
                sign = ch;
                next(ch)
            }
            if (ch === "I") {
                number = word();
                if (typeof number !== "number" || isNaN(number)) error("Unexpected word for number");
                return sign === "-" ? -number : number
            }
            if (ch === "N") {
                number = word();
                if (!isNaN(number)) error("expected word to be NaN");
                return number
            }
            if (ch === "0") {
                string += ch;
                next();
                if (ch ===
                    "x" || ch === "X") {
                    string += ch;
                    next();
                    base = 16
                } else if (ch >= "0" && ch <= "9") error("Octal literal")
            }
            switch (base) {
                case 10:
                    while (ch >= "0" && ch <= "9") {
                        string += ch;
                        next()
                    }
                    if (ch === ".") {
                        string += ".";
                        while (next() && ch >= "0" && ch <= "9") string += ch
                    }
                    if (ch === "e" || ch === "E") {
                        string += ch;
                        next();
                        if (ch === "-" || ch === "+") {
                            string += ch;
                            next()
                        }
                        while (ch >= "0" && ch <= "9") {
                            string += ch;
                            next()
                        }
                    }
                    break;
                case 16:
                    while (ch >= "0" && ch <= "9" || ch >= "A" && ch <= "F" || ch >= "a" && ch <= "f") {
                        string += ch;
                        next()
                    }
                    break
            }
            if (sign === "-") number = -string;
            else number = +string;
            if (!isFinite(number)) error("Bad number");
            else return number
        },
        string = function() {
            var hex, i, string = "",
                delim, uffff;
            if (ch === '"' || ch === "'") {
                delim = ch;
                while (next())
                    if (ch === delim) {
                        next();
                        return string
                    } else if (ch === "\\") {
                    next();
                    if (ch === "u") {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) break;
                            uffff = uffff * 16 + hex
                        }
                        string += String.fromCharCode(uffff)
                    } else if (ch === "\r") {
                        if (peek() === "\n") next()
                    } else if (typeof escapee[ch] === "string") string += escapee[ch];
                    else break
                } else if (ch === "\n") break;
                else string += ch
            }
            error("Bad string")
        },
        inlineComment =
        function() {
            if (ch !== "/") error("Not an inline comment");
            do {
                next();
                if (ch === "\n" || ch === "\r") {
                    next();
                    return
                }
            } while (ch)
        },
        blockComment = function() {
            if (ch !== "*") error("Not a block comment");
            do {
                next();
                while (ch === "*") {
                    next("*");
                    if (ch === "/") {
                        next("/");
                        return
                    }
                }
            } while (ch);
            error("Unterminated block comment")
        },
        comment = function() {
            if (ch !== "/") error("Not a comment");
            next("/");
            if (ch === "/") inlineComment();
            else if (ch === "*") blockComment();
            else error("Unrecognized comment")
        },
        white = function() {
            while (ch)
                if (ch === "/") comment();
                else if (ws.indexOf(ch) >= 0) next();
            else return
        },
        word = function() {
            switch (ch) {
                case "t":
                    next("t");
                    next("r");
                    next("u");
                    next("e");
                    return true;
                case "f":
                    next("f");
                    next("a");
                    next("l");
                    next("s");
                    next("e");
                    return false;
                case "n":
                    next("n");
                    next("u");
                    next("l");
                    next("l");
                    return null;
                case "I":
                    next("I");
                    next("n");
                    next("f");
                    next("i");
                    next("n");
                    next("i");
                    next("t");
                    next("y");
                    return Infinity;
                case "N":
                    next("N");
                    next("a");
                    next("N");
                    return NaN
            }
            error("Unexpected '" + ch + "'")
        },
        value, array = function() {
            var array = [];
            if (ch === "[") {
                next("[");
                white();
                while (ch) {
                    if (ch === "]") {
                        next("]");
                        return array
                    }
                    if (ch === ",") error("Missing array element");
                    else array.push(value());
                    white();
                    if (ch !== ",") {
                        next("]");
                        return array
                    }
                    next(",");
                    white()
                }
            }
            error("Bad array")
        },
        object = function() {
            var key, object = {};
            if (ch === "{") {
                next("{");
                white();
                while (ch) {
                    if (ch === "}") {
                        next("}");
                        return object
                    }
                    if (ch === '"' || ch === "'") key = string();
                    else key = identifier();
                    white();
                    next(":");
                    object[key] = value();
                    white();
                    if (ch !== ",") {
                        next("}");
                        return object
                    }
                    next(",");
                    white()
                }
            }
            error("Bad object")
        };
    value =
        function() {
            white();
            switch (ch) {
                case "{":
                    return object();
                case "[":
                    return array();
                case '"':
                case "'":
                    return string();
                case "-":
                case "+":
                case ".":
                    return number();
                default:
                    return ch >= "0" && ch <= "9" ? number() : word()
            }
        };
    return function(source, reviver) {
        var result;
        text = String(source);
        at = 0;
        ch = " ";
        result = value();
        white();
        if (ch) error("Syntax error");
        return typeof reviver === "function" ? function walk(holder, key) {
            var k, v, value = holder[key];
            if (value && typeof value === "object")
                for (k in value)
                    if (Object.prototype.hasOwnProperty.call(value,
                            k)) {
                        v = walk(value, k);
                        if (v !== undefined) value[k] = v;
                        else delete value[k]
                    }
            return reviver.call(holder, key, value)
        }({
            "": result
        }, "") : result
    }
}();
JSON5.stringify = function(obj, replacer, space) {
    if (replacer && (typeof replacer !== "function" && !isArray(replacer))) throw new Error("Replacer must be a function or an array");
    var getReplacedValueOrUndefined = function(holder, key, isTopLevel) {
        var value = holder[key];
        if (value && value.toJSON && typeof value.toJSON === "function") value = value.toJSON();
        if (typeof replacer === "function") return replacer.call(holder, key, value);
        else if (replacer)
            if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) return value;
            else return undefined;
        else return value
    };

    function isWordChar(_char) {
        return _char >= "a" && _char <= "z" || _char >= "A" && _char <= "Z" || _char >= "0" && _char <= "9" || _char === "_" || _char === "$"
    }

    function isWordStart(_char) {
        return _char >= "a" && _char <= "z" || _char >= "A" && _char <= "Z" || _char === "_" || _char === "$"
    }

    function isWord(key) {
        if (typeof key !== "string") return false;
        if (!isWordStart(key[0])) return false;
        var i = 1,
            length = key.length;
        while (i < length) {
            if (!isWordChar(key[i])) return false;
            i++
        }
        return true
    }
    JSON5.isWord = isWord;

    function isArray(obj) {
        if (Array.isArray) return Array.isArray(obj);
        else return Object.prototype.toString.call(obj) === "[object Array]"
    }

    function isDate(obj) {
        return Object.prototype.toString.call(obj) === "[object Date]"
    }
    isNaN = isNaN || function(val) {
        return typeof val === "number" && val !== val
    };
    var objStack = [];

    function checkForCircular(obj) {
        for (var i = 0; i < objStack.length; i++)
            if (objStack[i] === obj) throw new TypeError("Converting circular structure to JSON");
    }

    function makeIndent(str, num, noNewLine) {
        if (!str) return "";
        if (str.length > 10) str = str.substring(0, 10);
        var indent = noNewLine ? "" :
            "\n";
        for (var i = 0; i < num; i++) indent += str;
        return indent
    }
    var indentStr;
    if (space)
        if (typeof space === "string") indentStr = space;
        else if (typeof space === "number" && space >= 0) indentStr = makeIndent(" ", space, true);
    else;
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        meta = {
            "\b": "\\b",
            "\t": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            '"': '\\"',
            "\\": "\\\\"
        };

    function escapeString(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
            var c = meta[a];
            return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
        }) + '"' : '"' + string + '"'
    }

    function internalStringify(holder, key, isTopLevel) {
        var buffer, res;
        var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);
        if (obj_part && !isDate(obj_part)) obj_part = obj_part.valueOf();
        switch (typeof obj_part) {
            case "boolean":
                return obj_part.toString();
            case "number":
                if (isNaN(obj_part) || !isFinite(obj_part)) return "null";
                return obj_part.toString();
            case "string":
                return escapeString(obj_part.toString());
            case "object":
                if (obj_part === null) return "null";
                else if (isArray(obj_part)) {
                    checkForCircular(obj_part);
                    buffer = "[";
                    objStack.push(obj_part);
                    for (var i = 0; i < obj_part.length; i++) {
                        res = internalStringify(obj_part, i, false);
                        buffer += makeIndent(indentStr, objStack.length);
                        if (res === null || typeof res === "undefined") buffer += "null";
                        else buffer += res;
                        if (i < obj_part.length - 1) buffer +=
                            ",";
                        else if (indentStr) buffer += "\n"
                    }
                    objStack.pop();
                    buffer += makeIndent(indentStr, objStack.length, true) + "]"
                } else {
                    checkForCircular(obj_part);
                    buffer = "{";
                    var nonEmpty = false;
                    objStack.push(obj_part);
                    for (var prop in obj_part)
                        if (obj_part.hasOwnProperty(prop)) {
                            var value = internalStringify(obj_part, prop, false);
                            isTopLevel = false;
                            if (typeof value !== "undefined" && value !== null) {
                                buffer += makeIndent(indentStr, objStack.length);
                                nonEmpty = true;
                                var key = isWord(prop) ? prop : escapeString(prop);
                                buffer += key + ":" + (indentStr ? " " : "") +
                                    value + ","
                            }
                        }
                    objStack.pop();
                    if (nonEmpty) buffer = buffer.substring(0, buffer.length - 1) + makeIndent(indentStr, objStack.length) + "}";
                    else buffer = "{}"
                }
                return buffer;
            default:
                return undefined
        }
    }
    var topLevelHolder = {
        "": obj
    };
    if (obj === undefined) return getReplacedValueOrUndefined(topLevelHolder, "", true);
    return internalStringify(topLevelHolder, "", true)
};
(typeof define === "function" ? function(m) {
    define("Wampy", m)
} : typeof exports === "object" ? function(m) {
    module.exports = m()
} : function(m) {
    this.Wampy = m()
})(function() {
    var WAMP_MSG_SPEC = {
            HELLO: 1,
            WELCOME: 2,
            ABORT: 3,
            CHALLENGE: 4,
            AUTHENTICATE: 5,
            GOODBYE: 6,
            HEARTBEAT: 7,
            ERROR: 8,
            PUBLISH: 16,
            PUBLISHED: 17,
            SUBSCRIBE: 32,
            SUBSCRIBED: 33,
            UNSUBSCRIBE: 34,
            UNSUBSCRIBED: 35,
            EVENT: 36,
            CALL: 48,
            CANCEL: 49,
            RESULT: 50,
            REGISTER: 64,
            REGISTERED: 65,
            UNREGISTER: 66,
            UNREGISTERED: 67,
            INVOCATION: 68,
            INTERRUPT: 69,
            YIELD: 70
        },
        WAMP_ERROR_MSG = {
            SUCCESS: {
                code: 0,
                description: "Success!"
            },
            URI_ERROR: {
                code: 1,
                description: "Topic URI doesn't meet requirements!"
            },
            NO_BROKER: {
                code: 2,
                description: "Server doesn't provide broker role!"
            },
            NO_CALLBACK_SPEC: {
                code: 3,
                description: "No required callback function specified!"
            },
            INVALID_PARAM: {
                code: 4,
                description: "Invalid parameter(s) specified!"
            },
            NON_EXIST_SUBSCRIBE_CONFIRM: {
                code: 5,
                description: "Received subscribe confirmation to non existent subscription!"
            },
            NON_EXIST_SUBSCRIBE_ERROR: {
                code: 6,
                description: "Received error for non existent subscription!"
            },
            NON_EXIST_UNSUBSCRIBE: {
                code: 7,
                description: "Trying to unsubscribe from non existent subscription!"
            },
            NON_EXIST_SUBSCRIBE_UNSUBSCRIBED: {
                code: 8,
                description: "Received unsubscribe confirmation to non existent subscription!"
            },
            NON_EXIST_PUBLISH_ERROR: {
                code: 9,
                description: "Received error for non existent publication!"
            },
            NON_EXIST_PUBLISH_PUBLISHED: {
                code: 10,
                description: "Received publish confirmation for non existent publication!"
            },
            NON_EXIST_SUBSCRIBE_EVENT: {
                code: 11,
                description: "Received event for non existent subscription!"
            },
            NO_DEALER: {
                code: 12,
                description: "Server doesn't provide dealer role!"
            },
            NON_EXIST_CALL_RESULT: {
                code: 13,
                description: "Received rpc result for non existent call!"
            },
            NON_EXIST_CALL_ERROR: {
                code: 14,
                description: "Received rpc call error for non existent call!"
            },
            RPC_ALREADY_REGISTERED: {
                code: 15,
                description: "RPC already registered!"
            },
            NON_EXIST_RPC_REG: {
                code: 16,
                description: "Received rpc registration confirmation for non existent rpc!"
            },
            NON_EXIST_RPC_UNREG: {
                code: 17,
                description: "Received rpc unregistration for non existent rpc!"
            },
            NON_EXIST_RPC_ERROR: {
                code: 18,
                description: "Received error for non existent rpc!"
            },
            NON_EXIST_RPC_INVOCATION: {
                code: 19,
                description: "Received invocation for non existent rpc!"
            },
            NON_EXIST_RPC_REQ_ID: {
                code: 20,
                description: "No RPC calls in action with specified request ID!"
            },
            NO_REALM: {
                code: 21,
                description: "No realm specified!"
            },
            NO_WS_URL: {
                code: 22,
                description: "No websocket URL specified or URL is incorrect!"
            }
        },
        isNode = typeof process === "object" && Object.prototype.toString.call(process) === "[object process]";

    function getServerUrlBrowser(url) {
        var scheme,
            port;
        if (!url) {
            scheme = window.location.protocol === "https:" ? "wss://" : "ws://";
            port = window.location.port !== "" ? ":" + window.location.port : "";
            return scheme + window.location.hostname + port + "/ws"
        } else if (/^ws(s)?:\/\//.test(url)) return url;
        else if (/:\d{1,5}/.test(url)) {
            scheme = window.location.protocol === "https:" ? "wss://" : "ws://";
            return scheme + url
        } else if (url[0] === "/") {
            scheme = window.location.protocol === "https:" ? "wss://" : "ws://";
            port = window.location.port !== "" ? ":" + window.location.port : "";
            return scheme + window.location.hostname +
                port + url
        } else {
            scheme = window.location.protocol === "https:" ? "wss://" : "ws://";
            return scheme + url
        }
    }

    function getServerUrlNode(url) {
        if (/^ws(s)?:\/\//.test(url)) return url;
        else return null
    }

    function getWebSocket(url, protocols) {
        var parsedUrl = isNode ? getServerUrlNode(url) : getServerUrlBrowser(url),
            root = isNode ? global : window;
        if (!parsedUrl) return null;
        if ("WebSocket" in root)
            if (protocols) return new root.WebSocket(parsedUrl, protocols);
            else return new root.WebSocket(parsedUrl);
        else if ("MozWebSocket" in root)
            if (protocols) return new root.MozWebSocket(parsedUrl,
                protocols);
            else return new root.MozWebSocket(parsedUrl);
        else return null
    }
    var Wampy = function(url, options) {
        this.version = "v1.0.7";
        this._url = typeof arguments[0] === "string" ? url : undefined;
        this._protocols = ["wamp.2.json"];
        this._wamp_features = {
            agent: "Wampy.js " + this.version,
            roles: {
                publisher: {
                    features: {
                        subscriber_blackwhite_listing: true,
                        publisher_exclusion: true,
                        publisher_identification: true
                    }
                },
                subscriber: {},
                caller: {
                    features: {
                        callee_blackwhite_listing: true,
                        caller_exclusion: true,
                        caller_identification: true,
                        progressive_call_results: true,
                        call_canceling: true
                    }
                },
                callee: {
                    features: {
                        caller_identification: true
                    }
                }
            }
        };
        this._cache = {
            sessionId: null,
            server_wamp_features: {
                roles: {}
            },
            isSayingGoodbye: false,
            opStatus: {
                code: 0,
                description: "Success!",
                reqId: 0
            },
            timer: null,
            reconnectingAttempts: 0
        };
        this._ws = null;
        this._wsQueue = [];
        this._requests = {};
        this._calls = {};
        this._subscriptions = {};
        this._subsTopics = [];
        this._rpcRegs = {};
        this._rpcNames = [];
        this._options = {
            debug: false,
            autoReconnect: true,
            reconnectInterval: 2 * 1E3,
            maxRetries: 25,
            transportEncoding: "json",
            realm: null,
            onConnect: null,
            onClose: null,
            onError: null,
            onReconnect: null
        };
        switch (arguments.length) {
            case 1:
                if (typeof arguments[0] !== "string") this._options = this._merge(this._options, arguments[0]);
                break;
            case 2:
                this._options = this._merge(this._options, options);
                break
        }
        this.connect()
    };
    Wampy.prototype._log = function() {
        if (this._options.debug) console.log(arguments)
    };
    Wampy.prototype._getReqId = function() {
        var reqId;
        do reqId = Math.floor(Math.random() * 1E14); while (reqId in this._requests);
        return reqId
    };
    Wampy.prototype._merge = function() {
        var obj = {},
            i, l = arguments.length,
            attr;
        for (i = 0; i < l; i++)
            for (attr in arguments[i]) obj[attr] = arguments[i][attr];
        return obj
    };
    Wampy.prototype._isArray = function(obj) {
        return !!obj && obj.constructor === Array
    };
    Wampy.prototype._isObject = function(obj) {
        return obj === Object(obj) && Object.prototype.toString.call(obj) !== "[object Array]"
    };
    Wampy.prototype._isPlainObject = function(obj) {
        return !!obj && obj.constructor === Object
    };
    Wampy.prototype._setWsProtocols = function() {
        var root = isNode ? global : window;
        if (root.msgpack !== undefined)
            if (this._options.transportEncoding ===
                "msgpack") this._protocols = ["wamp.2.msgpack", "wamp.2.json"];
            else this._protocols = ["wamp.2.json", "wamp.2.msgpack"]
    };
    Wampy.prototype._validateURI = function(uri) {
        var re = /^([0-9a-zA-Z_|\[\]]{2,}\.)*([0-9a-zA-Z_|\[\]]{2,})$/;
        if (!re.test(uri) || uri.indexOf("wamp") === 0) return false;
        else return true
    };
    Wampy.prototype._encode = function(msg) {
        var bytearray;
        if (this._options.transportEncoding === "msgpack") try {
            bytearray = new Uint8Array(msgpack.encode(msg));
            return bytearray.buffer
        } catch (e) {
            throw new Error("[wampy] no msgpack encoder available!");
        } else return JSON.stringify(msg)
    };
    Wampy.prototype._decode = function(msg) {
        if (this._options.transportEncoding === "msgpack") try {
            return msgpack.decode(msg)
        } catch (e) {
            throw new Error("[wampy] no msgpack encoder available!");
        } else return JSON.parse(msg)
    };
    Wampy.prototype._send = function(msg) {
        if (msg) this._wsQueue.push(this._encode(msg));
        if (this._ws && this._ws.readyState === 1 && this._cache.sessionId)
            while (this._wsQueue.length) this._ws.send(this._wsQueue.shift())
    };
    Wampy.prototype._resetState = function() {
        this._wsQueue = [];
        this._subscriptions = {};
        this._subsTopics = [];
        this._requests = {};
        this._calls = {};
        this._rpcRegs = {};
        this._rpcNames = [];
        this._cache = {
            reconnectingAttempts: 0
        }
    };
    Wampy.prototype._initWsCallbacks = function() {
        var self = this;
        if (this._ws) {
            this._ws.onopen = function() {
                self._wsOnOpen.call(self)
            };
            this._ws.onclose = function(event) {
                self._wsOnClose.call(self, event)
            };
            this._ws.onmessage = function(event) {
                self._wsOnMessage.call(self, event)
            };
            this._ws.onerror = function(error) {
                self._wsOnError.call(self, error)
            }
        }
    };
    Wampy.prototype._wsOnOpen =
        function() {
            var p;
            this._log("[wampy] websocket connected");
            p = this._ws.protocol.split(".");
            this._options.transportEncoding = p[2];
            if (this._options.transportEncoding === "msgpack") this._ws.binaryType = "arraybuffer";
            this._ws.send(this._encode([WAMP_MSG_SPEC.HELLO, this._options.realm, this._wamp_features]))
        };
    Wampy.prototype._wsOnClose = function() {
        var self = this,
            root = isNode ? global : window;
        this._log("[wampy] websocket disconnected");
        if ((this._cache.sessionId || this._cache.reconnectingAttempts) && this._options.autoReconnect &&
            this._cache.reconnectingAttempts < this._options.maxRetries && !this._cache.isSayingGoodbye) {
            this._cache.sessionId = null;
            this._cache.timer = root.setTimeout(function() {
                self._wsReconnect.call(self)
            }, this._options.reconnectInterval)
        } else {
            if (this._options.onClose) this._options.onClose();
            this._resetState();
            this._ws = null
        }
    };
    Wampy.prototype._wsOnMessage = function(event) {
        var self = this,
            data, id, i, d, result, msg;
        this._log("[wampy] websocket message received", event.data);
        data = this._decode(event.data);
        switch (data[0]) {
            case WAMP_MSG_SPEC.WELCOME:
                this._cache.sessionId =
                    data[1];
                this._cache.server_wamp_features = data[2];
                if (this._options.onConnect) this._options.onConnect();
                if (this._cache.reconnectingAttempts) {
                    this._cache.reconnectingAttempts = 0;
                    this._renewSubscriptions();
                    this._renewRegistrations()
                }
                this._send();
                break;
            case WAMP_MSG_SPEC.ABORT:
                if (this._options.onError) this._options.onError(data[1].message ? data[1].message : data[2]);
                this._ws.close();
                break;
            case WAMP_MSG_SPEC.CHALLENGE:
                break;
            case WAMP_MSG_SPEC.GOODBYE:
                if (!this._cache.isSayingGoodbye) {
                    this._cache.isSayingGoodbye =
                        true;
                    this._send([WAMP_MSG_SPEC.GOODBYE, {}, "wamp.error.goodbye_and_out"])
                }
                this._cache.sessionId = null;
                this._ws.close();
                break;
            case WAMP_MSG_SPEC.HEARTBEAT:
                break;
            case WAMP_MSG_SPEC.ERROR:
                switch (data[1]) {
                    case WAMP_MSG_SPEC.SUBSCRIBE:
                    case WAMP_MSG_SPEC.UNSUBSCRIBE:
                        if (this._requests[data[2]]) {
                            if (this._requests[data[2]].callbacks.onError) this._requests[data[2]].callbacks.onError(data[4]);
                            delete this._requests[data[2]]
                        } else this._cache.opStatus = WAMP_ERROR_MSG.NON_EXIST_SUBSCRIBE_ERROR;
                        break;
                    case WAMP_MSG_SPEC.PUBLISH:
                        if (this._requests[data[2]]) {
                            if (this._requests[data[2]].callbacks.onError) this._requests[data[2]].callbacks.onError(data[4]);
                            delete this._requests[data[2]]
                        } else this._cache.opStatus = WAMP_ERROR_MSG.NON_EXIST_PUBLISH_ERROR;
                        break;
                    case WAMP_MSG_SPEC.REGISTER:
                    case WAMP_MSG_SPEC.UNREGISTER:
                        if (this._requests[data[2]]) {
                            if (this._requests[data[2]].callbacks.onError) this._requests[data[2]].callbacks.onError(data[4]);
                            delete this._requests[data[2]]
                        } else this._cache.opStatus = WAMP_ERROR_MSG.NON_EXIST_RPC_ERROR;
                        break;
                    case WAMP_MSG_SPEC.INVOCATION:
                        break;
                    case WAMP_MSG_SPEC.CALL:
                        if (this._calls[data[2]]) {
                            if (this._calls[data[2]].onError) {
                                switch (data.length) {
                                    case 5:
                                        d =
                                            null;
                                        break;
                                    case 6:
                                        d = data[5];
                                        break;
                                    case 7:
                                        d = data[6];
                                        break
                                }
                                this._calls[data[2]].onError(d)
                            }
                            delete this._calls[data[2]]
                        } else this._cache.opStatus = WAMP_ERROR_MSG.NON_EXIST_CALL_ERROR;
                        break
                }
                break;
            case WAMP_MSG_SPEC.SUBSCRIBED:
                if (this._requests[data[1]]) {
                    this._subscriptions[this._requests[data[1]].topic] = this._subscriptions[data[2]] = {
                        id: data[2],
                        callbacks: [this._requests[data[1]].callbacks.onEvent]
                    };
                    this._subsTopics.push(this._requests[data[1]].topic);
                    if (this._requests[data[1]].callbacks.onSuccess) this._requests[data[1]].callbacks.onSuccess();
                    delete this._requests[data[1]]
                } else this._cache.opStatus = WAMP_ERROR_MSG.NON_EXIST_SUBSCRIBE_CONFIRM;
                break;
            case WAMP_MSG_SPEC.UNSUBSCRIBED:
                if (this._requests[data[1]]) {
                    id = this._subscriptions[this._requests[data[1]].topic].id;
                    delete this._subscriptions[this._requests[data[1]].topic];
                    delete this._subscriptions[id];
                    i = this._subsTopics.indexOf(this._requests[data[1]].topic);
                    if (i >= 0) this._subsTopics.splice(i, 1);
                    if (this._requests[data[1]].callbacks.onSuccess) this._requests[data[1]].callbacks.onSuccess();
                    delete this._requests[data[1]]
                } else this._cache.opStatus =
                    WAMP_ERROR_MSG.NON_EXIST_SUBSCRIBE_UNSUBSCRIBED;
                break;
            case WAMP_MSG_SPEC.PUBLISHED:
                if (this._requests[data[1]]) {
                    if (this._requests[data[1]].callbacks.onSuccess) this._requests[data[1]].callbacks.onSuccess();
                    delete this._requests[data[1]]
                } else this._cache.opStatus = WAMP_ERROR_MSG.NON_EXIST_PUBLISH_PUBLISHED;
                break;
            case WAMP_MSG_SPEC.EVENT:
                if (this._subscriptions[data[1]]) {
                    switch (data.length) {
                        case 4:
                            d = null;
                            break;
                        case 5:
                            d = data[4];
                            break;
                        case 6:
                            d = data[5];
                            break
                    }
                    i = this._subscriptions[data[1]].callbacks.length;
                    while (i--) this._subscriptions[data[1]].callbacks[i](d)
                } else this._cache.opStatus = WAMP_ERROR_MSG.NON_EXIST_SUBSCRIBE_EVENT;
                break;
            case WAMP_MSG_SPEC.RESULT:
                if (this._calls[data[1]]) {
                    switch (data.length) {
                        case 3:
                            d = null;
                            break;
                        case 4:
                            d = data[3];
                            break;
                        case 5:
                            d = data[4];
                            break
                    }
                    this._calls[data[1]].onSuccess(d);
                    if (!(data[2].progress && data[2].progress === true)) delete this._calls[data[1]]
                } else this._cache.opStatus = WAMP_ERROR_MSG.NON_EXIST_CALL_RESULT;
                break;
            case WAMP_MSG_SPEC.REGISTER:
                break;
            case WAMP_MSG_SPEC.REGISTERED:
                if (this._requests[data[1]]) {
                    this._rpcRegs[this._requests[data[1]].topic] =
                        this._rpcRegs[data[2]] = {
                            id: data[2],
                            callbacks: [this._requests[data[1]].callbacks.rpc]
                        };
                    this._rpcNames.push(this._requests[data[1]].topic);
                    if (this._requests[data[1]].callbacks.onSuccess) this._requests[data[1]].callbacks.onSuccess();
                    delete this._requests[data[1]]
                } else this._cache.opStatus = WAMP_ERROR_MSG.NON_EXIST_RPC_REG;
                break;
            case WAMP_MSG_SPEC.UNREGISTER:
                break;
            case WAMP_MSG_SPEC.UNREGISTERED:
                if (this._requests[data[1]]) {
                    id = this._rpcRegs[this._requests[data[1]].topic].id;
                    delete this._rpcRegs[this._requests[data[1]].topic];
                    delete this._rpcRegs[id];
                    i = this._rpcNames.indexOf(this._requests[data[1]].topic);
                    if (i >= 0) this._rpcNames.splice(i, 1);
                    if (this._requests[data[1]].callbacks.onSuccess) this._requests[data[1]].callbacks.onSuccess();
                    delete this._requests[data[1]]
                } else this._cache.opStatus = WAMP_ERROR_MSG.NON_EXIST_RPC_UNREG;
                break;
            case WAMP_MSG_SPEC.INVOCATION:
                if (this._rpcRegs[data[2]]) {
                    switch (data.length) {
                        case 4:
                            d = null;
                            break;
                        case 5:
                            d = data[4];
                            break;
                        case 6:
                            d = data[5];
                            break
                    }
                    try {
                        Promise.resolve(this._rpcRegs[data[2]].callbacks[0](d)).then(function(result) {
                            if (self._isArray(result)) msg = [WAMP_MSG_SPEC.YIELD, data[1], {}, result];
                            else if (self._isPlainObject(result)) msg = [WAMP_MSG_SPEC.YIELD, data[1], {},
                                [], result
                            ];
                            else if (result === undefined) msg = [WAMP_MSG_SPEC.YIELD, data[1], {}];
                            else msg = [WAMP_MSG_SPEC.YIELD, data[1], {},
                                [result]
                            ];
                            self._send(msg)
                        })
                    } catch (e) {
                        this._send([WAMP_MSG_SPEC.ERROR, WAMP_MSG_SPEC.INVOCATION, data[1], {}, "wamp.error.invocation_exception"])
                    }
                } else {
                    this._send([WAMP_MSG_SPEC.ERROR, WAMP_MSG_SPEC.INVOCATION, data[1], {}, "wamp.error.no_such_procedure"]);
                    this._cache.opStatus = WAMP_ERROR_MSG.NON_EXIST_RPC_INVOCATION
                }
                break;
            case WAMP_MSG_SPEC.INTERRUPT:
                break;
            case WAMP_MSG_SPEC.YIELD:
                break
        }
    };
    Wampy.prototype._wsOnError = function(error) {
        this._log("[wampy] websocket error");
        if (this._options.onError) this._options.onError(error)
    };
    Wampy.prototype._wsReconnect = function() {
        this._log("[wampy] websocket reconnecting...");
        if (this._options.onReconnect) this._options.onReconnect();
        this._cache.reconnectingAttempts++;
        this._ws = getWebSocket(this._url, this._protocols);
        this._initWsCallbacks()
    };
    Wampy.prototype._renewSubscriptions = function() {
        var subs =
            this._subscriptions,
            st = this._subsTopics,
            s, i;
        this._subscriptions = {};
        this._subsTopics = [];
        s = st.length;
        while (s--) {
            i = subs[st[s]].callbacks.length;
            while (i--) this.subscribe(st[s], subs[st[s]].callbacks[i])
        }
    };
    Wampy.prototype._renewRegistrations = function() {
        var rpcs = this._rpcRegs,
            rn = this._rpcNames,
            r;
        this._rpcRegs = {};
        this._rpcNames = [];
        r = rn.length;
        while (r--) this.register(rn[r], {
            rpc: rpcs[rn[r]].callbacks[0]
        })
    };
    Wampy.prototype.options = function(opts) {
        if (opts === undefined) return this._options;
        else if (this._isPlainObject(opts)) {
            this._options =
                this._merge(this._options, opts);
            return this
        }
    };
    Wampy.prototype.getOpStatus = function() {
        return this._cache.opStatus
    };
    Wampy.prototype.getSessionId = function() {
        return this._cache.sessionId
    };
    Wampy.prototype.connect = function(url) {
        if (url) this._url = url;
        if (this._options.realm) {
            this._setWsProtocols();
            this._ws = getWebSocket(this._url, this._protocols);
            if (this._ws) this._initWsCallbacks();
            else this._cache.opStatus = WAMP_ERROR_MSG.NO_WS_URL
        } else this._cache.opStatus = WAMP_ERROR_MSG.NO_REALM;
        return this
    };
    Wampy.prototype.disconnect =
        function() {
            if (this._cache.sessionId) {
                this._cache.isSayingGoodbye = true;
                this._send([WAMP_MSG_SPEC.GOODBYE, {}, "wamp.error.system_shutdown"])
            } else if (this._ws) this._ws.close();
            this._cache.opStatus = WAMP_ERROR_MSG.SUCCESS;
            return this
        };
    Wampy.prototype.abort = function() {
        if (!this._cache.sessionId && this._ws.readyState === 1) {
            this._send([WAMP_MSG_SPEC.ABORT, {}, "wamp.error.abort"]);
            this._cache.sessionId = null
        }
        this._ws.close();
        this._cache.opStatus = WAMP_ERROR_MSG.SUCCESS;
        return this
    };
    Wampy.prototype.subscribe = function(topicURI,
        callbacks) {
        var reqId;
        if (this._cache.sessionId && !this._cache.server_wamp_features.roles.broker) {
            this._cache.opStatus = WAMP_ERROR_MSG.NO_BROKER;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
            return this
        }
        if (!this._validateURI(topicURI)) {
            this._cache.opStatus = WAMP_ERROR_MSG.URI_ERROR;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
            return this
        }
        if (typeof callbacks === "function") callbacks = {
            onEvent: callbacks
        };
        else if (this._isPlainObject(callbacks) && callbacks.onEvent !== undefined);
        else {
            this._cache.opStatus = WAMP_ERROR_MSG.NO_CALLBACK_SPEC;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
            return this
        }
        if (!this._subscriptions[topicURI] || !this._subscriptions[topicURI].callbacks.length) {
            reqId = this._getReqId();
            this._requests[reqId] = {
                topic: topicURI,
                callbacks: callbacks
            };
            this._send([WAMP_MSG_SPEC.SUBSCRIBE, reqId, {}, topicURI])
        } else {
            if (this._subscriptions[topicURI].callbacks.indexOf(callbacks.onEvent) <
                0) this._subscriptions[topicURI].callbacks.push(callbacks.onEvent);
            if (callbacks.onSuccess) callbacks.onSuccess()
        }
        this._cache.opStatus = WAMP_ERROR_MSG.SUCCESS;
        this._cache.opStatus.reqId = reqId;
        return this
    };
    Wampy.prototype.unsubscribe = function(topicURI, callbacks) {
        var reqId, i = -1;
        if (this._cache.sessionId && !this._cache.server_wamp_features.roles.broker) {
            this._cache.opStatus = WAMP_ERROR_MSG.NO_BROKER;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
            return this
        }
        if (this._subscriptions[topicURI]) {
            reqId =
                this._getReqId();
            if (callbacks === undefined) {
                this._subscriptions[topicURI].callbacks = [];
                callbacks = {}
            } else if (typeof callbacks === "function") {
                i = this._subscriptions[topicURI].callbacks.indexOf(callbacks);
                callbacks = {}
            } else if (callbacks.onEvent && typeof callbacks.onEvent === "function") i = this._subscriptions[topicURI].callbacks.indexOf(callbacks.onEvent);
            else this._subscriptions[topicURI].callbacks = [];
            if (i >= 0) this._subscriptions[topicURI].callbacks.splice(i, 1);
            if (this._subscriptions[topicURI].callbacks.length) {
                this._cache.opStatus =
                    WAMP_ERROR_MSG.SUCCESS;
                return this
            }
            this._requests[reqId] = {
                topic: topicURI,
                callbacks: callbacks
            };
            this._send([WAMP_MSG_SPEC.UNSUBSCRIBE, reqId, this._subscriptions[topicURI].id])
        } else {
            this._cache.opStatus = WAMP_ERROR_MSG.NON_EXIST_UNSUBSCRIBE;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
            return this
        }
        this._cache.opStatus = WAMP_ERROR_MSG.SUCCESS;
        this._cache.opStatus.reqId = reqId;
        return this
    };
    Wampy.prototype.publish = function(topicURI, payload, callbacks,
        advancedOptions) {
        var reqId, msg, options = {},
            err = false;
        if (this._cache.sessionId && !this._cache.server_wamp_features.roles.broker) {
            this._cache.opStatus = WAMP_ERROR_MSG.NO_BROKER;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
            return this
        }
        if (!this._validateURI(topicURI)) {
            this._cache.opStatus = WAMP_ERROR_MSG.URI_ERROR;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
            return this
        }
        if (this._isPlainObject(callbacks)) options.acknowledge =
            true;
        if (advancedOptions !== undefined) {
            if (this._isPlainObject(advancedOptions)) {
                if (advancedOptions.exclude)
                    if (this._isArray(advancedOptions.exclude)) options.exclude = advancedOptions.exclude;
                    else if (typeof advancedOptions.exclude === "number") options.exclude = [advancedOptions.exclude];
                else err = true;
                if (advancedOptions.eligible)
                    if (this._isArray(advancedOptions.eligible)) options.eligible = advancedOptions.eligible;
                    else if (typeof advancedOptions.eligible === "number") options.eligible = [advancedOptions.eligible];
                else err = true;
                if (advancedOptions.hasOwnProperty("exclude_me")) options.exclude_me = advancedOptions.exclude_me !== false;
                if (advancedOptions.hasOwnProperty("disclose_me")) options.disclose_me = advancedOptions.disclose_me === true
            } else err = true;
            if (err) {
                this._cache.opStatus = WAMP_ERROR_MSG.INVALID_PARAM;
                if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
                return this
            }
        }
        reqId = this._getReqId();
        switch (arguments.length) {
            case 1:
                msg = [WAMP_MSG_SPEC.PUBLISH, reqId, options,
                    topicURI
                ];
                break;
            case 2:
                if (this._isArray(payload)) msg = [WAMP_MSG_SPEC.PUBLISH, reqId, options, topicURI, payload];
                else if (this._isPlainObject(payload)) msg = [WAMP_MSG_SPEC.PUBLISH, reqId, options, topicURI, [], payload];
                else msg = [WAMP_MSG_SPEC.PUBLISH, reqId, options, topicURI, [payload]];
                break;
            default:
                this._requests[reqId] = {
                    topic: topicURI,
                    callbacks: callbacks
                };
                if (this._isArray(payload)) msg = [WAMP_MSG_SPEC.PUBLISH, reqId, options, topicURI, payload];
                else if (this._isPlainObject(payload)) msg = [WAMP_MSG_SPEC.PUBLISH, reqId,
                    options, topicURI, [], payload
                ];
                else msg = [WAMP_MSG_SPEC.PUBLISH, reqId, options, topicURI, [payload]];
                break
        }
        this._send(msg);
        this._cache.opStatus = WAMP_ERROR_MSG.SUCCESS;
        this._cache.opStatus.reqId = reqId;
        return this
    };
    Wampy.prototype.call = function(topicURI, payload, callbacks, advancedOptions) {
        var reqId, msg, options = {},
            err = false;
        if (this._cache.sessionId && !this._cache.server_wamp_features.roles.dealer) {
            this._cache.opStatus = WAMP_ERROR_MSG.NO_DEALER;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
            return this
        }
        if (!this._validateURI(topicURI)) {
            this._cache.opStatus = WAMP_ERROR_MSG.URI_ERROR;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
            return this
        }
        if (typeof callbacks === "function") callbacks = {
            onSuccess: callbacks
        };
        else if (this._isPlainObject(callbacks) && callbacks.onSuccess !== undefined);
        else {
            this._cache.opStatus = WAMP_ERROR_MSG.NO_CALLBACK_SPEC;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
            return this
        }
        if (advancedOptions !== undefined) {
            if (this._isPlainObject(advancedOptions)) {
                if (advancedOptions.exclude)
                    if (this._isArray(advancedOptions.exclude)) options.exclude = advancedOptions.exclude;
                    else if (typeof advancedOptions.exclude === "number") options.exclude = [advancedOptions.exclude];
                else err = true;
                if (advancedOptions.eligible)
                    if (this._isArray(advancedOptions.eligible)) options.eligible = advancedOptions.eligible;
                    else if (typeof advancedOptions.eligible === "number") options.eligible = [advancedOptions.eligible];
                else err = true;
                if (advancedOptions.hasOwnProperty("exclude_me")) options.exclude_me = advancedOptions.exclude_me !== false;
                if (advancedOptions.hasOwnProperty("disclose_me")) options.disclose_me = advancedOptions.disclose_me === true;
                if (advancedOptions.hasOwnProperty("receive_progress")) options.receive_progress = advancedOptions.receive_progress === true
            } else err = true;
            if (err) {
                this._cache.opStatus = WAMP_ERROR_MSG.INVALID_PARAM;
                if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
                return this
            }
        }
        do reqId = this._getReqId(); while (reqId in this._calls);
        this._calls[reqId] = callbacks;
        if (payload === null) msg = [WAMP_MSG_SPEC.CALL, reqId, options, topicURI];
        else if (this._isArray(payload)) msg = [WAMP_MSG_SPEC.CALL, reqId, options, topicURI, payload];
        else if (this._isPlainObject(payload)) msg = [WAMP_MSG_SPEC.CALL, reqId, options, topicURI, [], payload];
        else msg = [WAMP_MSG_SPEC.CALL, reqId, options, topicURI, [payload]];
        this._send(msg);
        this._cache.opStatus = WAMP_ERROR_MSG.SUCCESS;
        this._cache.opStatus.reqId = reqId;
        return this
    };
    Wampy.prototype.cancel = function(reqId, callbacks, advancedOptions) {
        var options = {
            mode: "skip"
        };
        if (this._cache.sessionId && !this._cache.server_wamp_features.roles.dealer) {
            this._cache.opStatus = WAMP_ERROR_MSG.NO_DEALER;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
            return this
        }
        if (!reqId || !this._calls[reqId]) {
            this._cache.opStatus = WAMP_ERROR_MSG.NON_EXIST_RPC_REQ_ID;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
            return this
        }
        if (advancedOptions !== undefined)
            if (this._isPlainObject(advancedOptions))
                if (advancedOptions.hasOwnProperty("mode")) options.mode = /skip|kill|killnowait/.test(advancedOptions.mode) ? advancedOptions.mode : "skip";
        this._send([WAMP_MSG_SPEC.CANCEL, reqId, options]);
        if (callbacks.onSuccess) callbacks.onSuccess();
        this._cache.opStatus = WAMP_ERROR_MSG.SUCCESS;
        this._cache.opStatus.reqId = reqId;
        return this
    };
    Wampy.prototype.register = function(topicURI, callbacks) {
        var reqId;
        if (this._cache.sessionId && !this._cache.server_wamp_features.roles.dealer) {
            this._cache.opStatus =
                WAMP_ERROR_MSG.NO_DEALER;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
            return this
        }
        if (!this._validateURI(topicURI)) {
            this._cache.opStatus = WAMP_ERROR_MSG.URI_ERROR;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
            return this
        }
        if (typeof callbacks === "function") callbacks = {
            rpc: callbacks
        };
        else if (this._isPlainObject(callbacks) && callbacks.rpc !== undefined);
        else {
            this._cache.opStatus = WAMP_ERROR_MSG.NO_CALLBACK_SPEC;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
            return this
        }
        if (!this._rpcRegs[topicURI] || !this._rpcRegs[topicURI].callbacks.length) {
            reqId = this._getReqId();
            this._requests[reqId] = {
                topic: topicURI,
                callbacks: callbacks
            };
            this._send([WAMP_MSG_SPEC.REGISTER, reqId, {}, topicURI]);
            this._cache.opStatus = WAMP_ERROR_MSG.SUCCESS;
            this._cache.opStatus.reqId = reqId
        } else {
            this._cache.opStatus = WAMP_ERROR_MSG.RPC_ALREADY_REGISTERED;
            if (this._isPlainObject(callbacks) &&
                callbacks.onError) callbacks.onError(this._cache.opStatus.description)
        }
        return this
    };
    Wampy.prototype.unregister = function(topicURI, callbacks) {
        var reqId;
        if (this._cache.sessionId && !this._cache.server_wamp_features.roles.dealer) {
            this._cache.opStatus = WAMP_ERROR_MSG.NO_DEALER;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
            return this
        }
        if (!this._validateURI(topicURI)) {
            this._cache.opStatus = WAMP_ERROR_MSG.URI_ERROR;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description);
            return this
        }
        if (typeof callbacks === "function") callbacks = {
            onSuccess: callbacks
        };
        if (this._rpcRegs[topicURI]) {
            reqId = this._getReqId();
            this._requests[reqId] = {
                topic: topicURI,
                callbacks: callbacks
            };
            this._send([WAMP_MSG_SPEC.UNREGISTER, reqId, this._rpcRegs[topicURI].id]);
            this._cache.opStatus = WAMP_ERROR_MSG.SUCCESS;
            this._cache.opStatus.reqId = reqId
        } else {
            this._cache.opStatus = WAMP_ERROR_MSG.NON_EXIST_RPC_UNREG;
            if (this._isPlainObject(callbacks) && callbacks.onError) callbacks.onError(this._cache.opStatus.description)
        }
        return this
    };
    return Wampy
});
window.OpenSeadragon = window.OpenSeadragon || function(options) {
    return new OpenSeadragon.Viewer(options)
};
(function($) {
    $.version = {
        versionStr: "2.0.0",
        major: parseInt("2", 10),
        minor: parseInt("0", 10),
        revision: parseInt("0", 10)
    };
    var class2type = {
            "[object Boolean]": "boolean",
            "[object Number]": "number",
            "[object String]": "string",
            "[object Function]": "function",
            "[object Array]": "array",
            "[object Date]": "date",
            "[object RegExp]": "regexp",
            "[object Object]": "object"
        },
        toString = Object.prototype.toString,
        hasOwn = Object.prototype.hasOwnProperty;
    $.isFunction = function(obj) {
        return $.type(obj) === "function"
    };
    $.isArray = Array.isArray ||
        function(obj) {
            return $.type(obj) === "array"
        };
    $.isWindow = function(obj) {
        return obj && typeof obj === "object" && "setInterval" in obj
    };
    $.type = function(obj) {
        return obj === null || obj === undefined ? String(obj) : class2type[toString.call(obj)] || "object"
    };
    $.isPlainObject = function(obj) {
        if (!obj || OpenSeadragon.type(obj) !== "object" || obj.nodeType || $.isWindow(obj)) return false;
        if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) return false;
        var key;
        for (key in obj);
        return key ===
            undefined || hasOwn.call(obj, key)
    };
    $.isEmptyObject = function(obj) {
        for (var name in obj) return false;
        return true
    };
    $.supportsCanvas = function() {
        var canvasElement = document.createElement("canvas");
        return !!($.isFunction(canvasElement.getContext) && canvasElement.getContext("2d"))
    }();
    $.pixelDensityRatio = function() {
        if ($.supportsCanvas) {
            var context = document.createElement("canvas").getContext("2d");
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio ||
                context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
            return devicePixelRatio / backingStoreRatio
        } else return 1
    }()
})(OpenSeadragon);
(function($) {
    $.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},
            length = arguments.length,
            deep = false,
            i = 1;
        if (typeof target === "boolean") {
            deep = target;
            target = arguments[1] || {};
            i = 2
        }
        if (typeof target !== "object" && !OpenSeadragon.isFunction(target)) target = {};
        if (length === i) {
            target = this;
            --i
        }
        for (; i < length; i++) {
            options = arguments[i];
            if (options !== null || options !== undefined)
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) continue;
                    if (deep && copy && (OpenSeadragon.isPlainObject(copy) ||
                            (copyIsArray = OpenSeadragon.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && OpenSeadragon.isArray(src) ? src : []
                        } else clone = src && OpenSeadragon.isPlainObject(src) ? src : {};
                        target[name] = OpenSeadragon.extend(deep, clone, copy)
                    } else if (copy !== undefined) target[name] = copy
                }
        }
        return target
    };
    $.extend($, {
        DEFAULT_SETTINGS: {
            xmlPath: null,
            tileSources: null,
            tileHost: null,
            initialPage: 0,
            crossOriginPolicy: false,
            ajaxWithCredentials: false,
            panHorizontal: true,
            panVertical: true,
            constrainDuringPan: false,
            wrapHorizontal: false,
            wrapVertical: false,
            visibilityRatio: .5,
            minPixelRatio: .5,
            defaultZoomLevel: 0,
            minZoomLevel: null,
            maxZoomLevel: null,
            homeFillsViewer: false,
            clickTimeThreshold: 300,
            clickDistThreshold: 5,
            dblClickTimeThreshold: 300,
            dblClickDistThreshold: 20,
            springStiffness: 6.5,
            animationTime: 1.2,
            gestureSettingsMouse: {
                scrollToZoom: true,
                clickToZoom: true,
                dblClickToZoom: false,
                pinchToZoom: false,
                flickEnabled: false,
                flickMinSpeed: 120,
                flickMomentum: .25,
                pinchRotate: false
            },
            gestureSettingsTouch: {
                scrollToZoom: false,
                clickToZoom: false,
                dblClickToZoom: true,
                pinchToZoom: true,
                flickEnabled: true,
                flickMinSpeed: 120,
                flickMomentum: .25,
                pinchRotate: false
            },
            gestureSettingsPen: {
                scrollToZoom: false,
                clickToZoom: true,
                dblClickToZoom: false,
                pinchToZoom: false,
                flickEnabled: false,
                flickMinSpeed: 120,
                flickMomentum: .25,
                pinchRotate: false
            },
            gestureSettingsUnknown: {
                scrollToZoom: false,
                clickToZoom: false,
                dblClickToZoom: true,
                pinchToZoom: true,
                flickEnabled: true,
                flickMinSpeed: 120,
                flickMomentum: .25,
                pinchRotate: false
            },
            zoomPerClick: 2,
            zoomPerScroll: 1.2,
            zoomPerSecond: 1,
            blendTime: 0,
            alwaysBlend: false,
            autoHideControls: true,
            immediateRender: false,
            minZoomImageRatio: .9,
            maxZoomPixelRatio: 1.1,
            pixelsPerWheelLine: 40,
            autoResize: true,
            preserveImageSizeOnResize: false,
            showSequenceControl: true,
            sequenceControlAnchor: null,
            preserveViewport: false,
            preserveOverlays: false,
            navPrevNextWrap: false,
            showNavigationControl: true,
            navigationControlAnchor: null,
            showZoomControl: true,
            showHomeControl: true,
            showFullPageControl: true,
            showRotationControl: false,
            controlsFadeDelay: 2E3,
            controlsFadeLength: 1500,
            mouseNavEnabled: true,
            showNavigator: false,
            navigatorId: null,
            navigatorPosition: null,
            navigatorSizeRatio: .2,
            navigatorMaintainSizeRatio: false,
            navigatorTop: null,
            navigatorLeft: null,
            navigatorHeight: null,
            navigatorWidth: null,
            navigatorAutoResize: true,
            navigatorRotate: true,
            degrees: 0,
            opacity: 1,
            placeholderFillStyle: null,
            showReferenceStrip: false,
            referenceStripScroll: "horizontal",
            referenceStripElement: null,
            referenceStripHeight: null,
            referenceStripWidth: null,
            referenceStripPosition: "BOTTOM_LEFT",
            referenceStripSizeRatio: .2,
            collectionRows: 3,
            collectionColumns: 0,
            collectionLayout: "horizontal",
            collectionMode: false,
            collectionTileSize: 800,
            collectionTileMargin: 80,
            imageLoaderLimit: 0,
            maxImageCacheCount: 200,
            timeout: 3E4,
            useCanvas: true,
            prefixUrl: "/images/",
            navImages: {
                zoomIn: {
                    REST: "zoomin_rest.png",
                    GROUP: "zoomin_grouphover.png",
                    HOVER: "zoomin_hover.png",
                    DOWN: "zoomin_pressed.png"
                },
                zoomOut: {
                    REST: "zoomout_rest.png",
                    GROUP: "zoomout_grouphover.png",
                    HOVER: "zoomout_hover.png",
                    DOWN: "zoomout_pressed.png"
                },
                home: {
                    REST: "home_rest.png",
                    GROUP: "home_grouphover.png",
                    HOVER: "home_hover.png",
                    DOWN: "home_pressed.png"
                },
                fullpage: {
                    REST: "fullpage_rest.png",
                    GROUP: "fullpage_grouphover.png",
                    HOVER: "fullpage_hover.png",
                    DOWN: "fullpage_pressed.png"
                },
                rotateleft: {
                    REST: "rotateleft_rest.png",
                    GROUP: "rotateleft_grouphover.png",
                    HOVER: "rotateleft_hover.png",
                    DOWN: "rotateleft_pressed.png"
                },
                rotateright: {
                    REST: "rotateright_rest.png",
                    GROUP: "rotateright_grouphover.png",
                    HOVER: "rotateright_hover.png",
                    DOWN: "rotateright_pressed.png"
                },
                previous: {
                    REST: "previous_rest.png",
                    GROUP: "previous_grouphover.png",
                    HOVER: "previous_hover.png",
                    DOWN: "previous_pressed.png"
                },
                next: {
                    REST: "next_rest.png",
                    GROUP: "next_grouphover.png",
                    HOVER: "next_hover.png",
                    DOWN: "next_pressed.png"
                }
            },
            debugMode: false,
            debugGridColor: "#437AB2"
        },
        SIGNAL: "----seadragon----",
        delegate: function(object, method) {
            return function() {
                var args = arguments;
                if (args === undefined) args = [];
                return method.apply(object, args)
            }
        },
        BROWSERS: {
            UNKNOWN: 0,
            IE: 1,
            FIREFOX: 2,
            SAFARI: 3,
            CHROME: 4,
            OPERA: 5
        },
        getElement: function(element) {
            if (typeof element == "string") element = document.getElementById(element);
            return element
        },
        getElementPosition: function(element) {
            var result = new $.Point,
                isFixed, offsetParent;
            element = $.getElement(element);
            isFixed = $.getElementStyle(element).position == "fixed";
            offsetParent = getOffsetParent(element, isFixed);
            while (offsetParent) {
                result.x += element.offsetLeft;
                result.y += element.offsetTop;
                if (isFixed) result = result.plus($.getPageScroll());
                element = offsetParent;
                isFixed = $.getElementStyle(element).position == "fixed";
                offsetParent = getOffsetParent(element, isFixed)
            }
            return result
        },
        getElementOffset: function(element) {
            element =
                $.getElement(element);
            var doc = element && element.ownerDocument,
                docElement, win, boundingRect = {
                    top: 0,
                    left: 0
                };
            if (!doc) return new $.Point;
            docElement = doc.documentElement;
            if (typeof element.getBoundingClientRect !== typeof undefined) boundingRect = element.getBoundingClientRect();
            win = doc == doc.window ? doc : doc.nodeType === 9 ? doc.defaultView || doc.parentWindow : false;
            return new $.Point(boundingRect.left + (win.pageXOffset || docElement.scrollLeft) - (docElement.clientLeft || 0), boundingRect.top + (win.pageYOffset || docElement.scrollTop) -
                (docElement.clientTop || 0))
        },
        getElementSize: function(element) {
            element = $.getElement(element);
            return new $.Point(element.clientWidth, element.clientHeight)
        },
        getElementStyle: document.documentElement.currentStyle ? function(element) {
            element = $.getElement(element);
            return element.currentStyle
        } : function(element) {
            element = $.getElement(element);
            return window.getComputedStyle(element, "")
        },
        pointInElement: function(element, point) {
            element = $.getElement(element);
            var offset = $.getElementOffset(element),
                size = $.getElementSize(element);
            return point.x >= offset.x && point.x < offset.x + size.x && point.y < offset.y + size.y && point.y >= offset.y
        },
        getEvent: function(event) {
            if (event) $.getEvent = function(event) {
                return event
            };
            else $.getEvent = function() {
                return window.event
            };
            return $.getEvent(event)
        },
        getMousePosition: function(event) {
            if (typeof event.pageX == "number") $.getMousePosition = function(event) {
                var result = new $.Point;
                event = $.getEvent(event);
                result.x = event.pageX;
                result.y = event.pageY;
                return result
            };
            else if (typeof event.clientX == "number") $.getMousePosition =
                function(event) {
                    var result = new $.Point;
                    event = $.getEvent(event);
                    result.x = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
                    result.y = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
                    return result
                };
            else throw new Error("Unknown event mouse position, no known technique.");
            return $.getMousePosition(event)
        },
        getPageScroll: function() {
            var docElement = document.documentElement || {},
                body = document.body || {};
            if (typeof window.pageXOffset == "number") $.getPageScroll = function() {
                return new $.Point(window.pageXOffset,
                    window.pageYOffset)
            };
            else if (body.scrollLeft || body.scrollTop) $.getPageScroll = function() {
                return new $.Point(document.body.scrollLeft, document.body.scrollTop)
            };
            else if (docElement.scrollLeft || docElement.scrollTop) $.getPageScroll = function() {
                return new $.Point(document.documentElement.scrollLeft, document.documentElement.scrollTop)
            };
            else return new $.Point(0, 0);
            return $.getPageScroll()
        },
        setPageScroll: function(scroll) {
            if (typeof window.scrollTo !== "undefined") $.setPageScroll = function(scroll) {
                window.scrollTo(scroll.x,
                    scroll.y)
            };
            else {
                var originalScroll = $.getPageScroll();
                if (originalScroll.x === scroll.x && originalScroll.y === scroll.y) return;
                document.body.scrollLeft = scroll.x;
                document.body.scrollTop = scroll.y;
                var currentScroll = $.getPageScroll();
                if (currentScroll.x !== originalScroll.x && currentScroll.y !== originalScroll.y) {
                    $.setPageScroll = function(scroll) {
                        document.body.scrollLeft = scroll.x;
                        document.body.scrollTop = scroll.y
                    };
                    return
                }
                document.documentElement.scrollLeft = scroll.x;
                document.documentElement.scrollTop = scroll.y;
                currentScroll =
                    $.getPageScroll();
                if (currentScroll.x !== originalScroll.x && currentScroll.y !== originalScroll.y) {
                    $.setPageScroll = function(scroll) {
                        document.documentElement.scrollLeft = scroll.x;
                        document.documentElement.scrollTop = scroll.y
                    };
                    return
                }
                $.setPageScroll = function(scroll) {}
            }
            return $.setPageScroll(scroll)
        },
        getWindowSize: function() {
            var docElement = document.documentElement || {},
                body = document.body || {};
            if (typeof window.innerWidth == "number") $.getWindowSize = function() {
                return new $.Point(window.innerWidth, window.innerHeight)
            };
            else if (docElement.clientWidth || docElement.clientHeight) $.getWindowSize = function() {
                return new $.Point(document.documentElement.clientWidth, document.documentElement.clientHeight)
            };
            else if (body.clientWidth || body.clientHeight) $.getWindowSize = function() {
                return new $.Point(document.body.clientWidth, document.body.clientHeight)
            };
            else throw new Error("Unknown window size, no known technique.");
            return $.getWindowSize()
        },
        makeCenteredNode: function(element) {
            element = $.getElement(element);
            var wrappers = [$.makeNeutralElement("div"),
                $.makeNeutralElement("div"), $.makeNeutralElement("div")
            ];
            $.extend(wrappers[0].style, {
                display: "table",
                height: "100%",
                width: "100%"
            });
            $.extend(wrappers[1].style, {
                display: "table-row"
            });
            $.extend(wrappers[2].style, {
                display: "table-cell",
                verticalAlign: "middle",
                textAlign: "center"
            });
            wrappers[0].appendChild(wrappers[1]);
            wrappers[1].appendChild(wrappers[2]);
            wrappers[2].appendChild(element);
            return wrappers[0]
        },
        makeNeutralElement: function(tagName) {
            var element = document.createElement(tagName),
                style = element.style;
            style.background = "transparent none";
            style.border = "none";
            style.margin = "0px";
            style.padding = "0px";
            style.position = "static";
            return element
        },
        now: function() {
            if (Date.now) $.now = Date.now;
            else $.now = function() {
                return (new Date).getTime()
            };
            return $.now()
        },
        makeTransparentImage: function(src) {
            $.makeTransparentImage = function(src) {
                var img = $.makeNeutralElement("img");
                img.src = src;
                return img
            };
            if ($.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 7) $.makeTransparentImage = function(src) {
                var img = $.makeNeutralElement("img"),
                    element = null;
                element = $.makeNeutralElement("span");
                element.style.display = "inline-block";
                img.onload = function() {
                    element.style.width = element.style.width || img.width + "px";
                    element.style.height = element.style.height || img.height + "px";
                    img.onload = null;
                    img = null
                };
                img.src = src;
                element.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + src + "', sizingMethod='scale')";
                return element
            };
            return $.makeTransparentImage(src)
        },
        setElementOpacity: function(element, opacity, usesAlpha) {
            var ieOpacity, ieFilter;
            element = $.getElement(element);
            if (usesAlpha && !$.Browser.alpha) opacity = Math.round(opacity);
            if ($.Browser.opacity) element.style.opacity = opacity < 1 ? opacity : "";
            else if (opacity < 1) {
                ieOpacity = Math.round(100 * opacity);
                ieFilter = "alpha(opacity=" + ieOpacity + ")";
                element.style.filter = ieFilter
            } else element.style.filter = ""
        },
        setElementTouchActionNone: function(element) {
            element = $.getElement(element);
            if (typeof element.style.touchAction !== "undefined") element.style.touchAction = "none";
            else if (typeof element.style.msTouchAction !==
                "undefined") element.style.msTouchAction = "none"
        },
        addClass: function(element, className) {
            element = $.getElement(element);
            if (!element.className) element.className = className;
            else if ((" " + element.className + " ").indexOf(" " + className + " ") === -1) element.className += " " + className
        },
        indexOf: function(array, searchElement, fromIndex) {
            if (Array.prototype.indexOf) this.indexOf = function(array, searchElement, fromIndex) {
                return array.indexOf(searchElement, fromIndex)
            };
            else this.indexOf = function(array, searchElement, fromIndex) {
                var i,
                    pivot = fromIndex ? fromIndex : 0,
                    length;
                if (!array) throw new TypeError;
                length = array.length;
                if (length === 0 || pivot >= length) return -1;
                if (pivot < 0) pivot = length - Math.abs(pivot);
                for (i = pivot; i < length; i++)
                    if (array[i] === searchElement) return i;
                return -1
            };
            return this.indexOf(array, searchElement, fromIndex)
        },
        removeClass: function(element, className) {
            var oldClasses, newClasses = [],
                i;
            element = $.getElement(element);
            oldClasses = element.className.split(/\s+/);
            for (i = 0; i < oldClasses.length; i++)
                if (oldClasses[i] && oldClasses[i] !== className) newClasses.push(oldClasses[i]);
            element.className = newClasses.join(" ")
        },
        addEvent: function() {
            if (window.addEventListener) return function(element, eventName, handler, useCapture) {
                element = $.getElement(element);
                element.addEventListener(eventName, handler, useCapture)
            };
            else if (window.attachEvent) return function(element, eventName, handler, useCapture) {
                element = $.getElement(element);
                element.attachEvent("on" + eventName, handler)
            };
            else throw new Error("No known event model.");
        }(),
        removeEvent: function() {
            if (window.removeEventListener) return function(element,
                eventName, handler, useCapture) {
                element = $.getElement(element);
                element.removeEventListener(eventName, handler, useCapture)
            };
            else if (window.detachEvent) return function(element, eventName, handler, useCapture) {
                element = $.getElement(element);
                element.detachEvent("on" + eventName, handler)
            };
            else throw new Error("No known event model.");
        }(),
        cancelEvent: function(event) {
            event = $.getEvent(event);
            if (event.preventDefault) $.cancelEvent = function(event) {
                event.preventDefault()
            };
            else $.cancelEvent = function(event) {
                event = $.getEvent(event);
                event.cancel = true;
                event.returnValue = false
            };
            $.cancelEvent(event)
        },
        stopEvent: function(event) {
            event = $.getEvent(event);
            if (event.stopPropagation) $.stopEvent = function(event) {
                event.stopPropagation()
            };
            else $.stopEvent = function(event) {
                event = $.getEvent(event);
                event.cancelBubble = true
            };
            $.stopEvent(event)
        },
        createCallback: function(object, method) {
            var initialArgs = [],
                i;
            for (i = 2; i < arguments.length; i++) initialArgs.push(arguments[i]);
            return function() {
                var args = initialArgs.concat([]),
                    i;
                for (i = 0; i < arguments.length; i++) args.push(arguments[i]);
                return method.apply(object, args)
            }
        },
        getUrlParameter: function(key) {
            var value = URLPARAMS[key];
            return value ? value : null
        },
        getUrlProtocol: function(url) {
            var match = url.match(/^([a-z]+:)\/\//i);
            if (match === null) return window.location.protocol;
            return match[1].toLowerCase()
        },
        createAjaxRequest: function(local) {
            var supportActiveX;
            try {
                supportActiveX = !!new ActiveXObject("Microsoft.XMLHTTP")
            } catch (e) {
                supportActiveX = false
            }
            if (supportActiveX)
                if (window.XMLHttpRequest) $.createAjaxRequest = function(local) {
                    if (local) return new ActiveXObject("Microsoft.XMLHTTP");
                    return new XMLHttpRequest
                };
                else $.createAjaxRequest = function() {
                    return new ActiveXObject("Microsoft.XMLHTTP")
                };
            else if (window.XMLHttpRequest) $.createAjaxRequest = function() {
                return new XMLHttpRequest
            };
            else throw new Error("Browser doesn't support XMLHttpRequest.");
            return $.createAjaxRequest(local)
        },
        makeAjaxRequest: function(url, onSuccess, onError) {
            var withCredentials;
            if ($.isPlainObject(url)) {
                onSuccess = url.success;
                onError = url.error;
                withCredentials = url.withCredentials;
                url = url.url
            }
            var protocol = $.getUrlProtocol(url);
            var request = $.createAjaxRequest(protocol === "file:");
            if (!$.isFunction(onSuccess)) throw new Error("makeAjaxRequest requires a success callback");
            request.onreadystatechange = function() {
                if (request.readyState == 4) {
                    request.onreadystatechange = function() {};
                    if (request.status === 200 || request.status === 0 && protocol !== "http:" && protocol !== "https:") onSuccess(request);
                    else {
                        $.console.log("AJAX request returned %d: %s", request.status, url);
                        if ($.isFunction(onError)) onError(request)
                    }
                }
            };
            if (withCredentials) request.withCredentials =
                true;
            try {
                request.open("GET", url, true);
                request.send(null)
            } catch (e) {
                var msg = e.message;
                var oldIE = $.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 10;
                if (oldIE && typeof e.number != "undefined" && e.number == -2147024891) msg += "\nSee http://msdn.microsoft.com/en-us/library/ms537505(v=vs.85).aspx#xdomain";
                $.console.log("%s while making AJAX request: %s", e.name, msg);
                request.onreadystatechange = function() {};
                if ($.isFunction(onError)) onError(request, e)
            }
        },
        jsonp: function(options) {
            var script, url = options.url,
                head = document.head ||
                document.getElementsByTagName("head")[0] || document.documentElement,
                jsonpCallback = options.callbackName || "openseadragon" + $.now(),
                previous = window[jsonpCallback],
                replace = "$1" + jsonpCallback + "$2",
                callbackParam = options.param || "callback",
                callback = options.callback;
            url = url.replace(/(\=)\?(&|$)|\?\?/i, replace);
            url += (/\?/.test(url) ? "&" : "?") + callbackParam + "=" + jsonpCallback;
            window[jsonpCallback] = function(response) {
                if (!previous) try {
                    delete window[jsonpCallback]
                } catch (e) {} else window[jsonpCallback] = previous;
                if (callback &&
                    $.isFunction(callback)) callback(response)
            };
            script = document.createElement("script");
            if (undefined !== options.async || false !== options.async) script.async = "async";
            if (options.scriptCharset) script.charset = options.scriptCharset;
            script.src = url;
            script.onload = script.onreadystatechange = function(_, isAbort) {
                if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
                    script.onload = script.onreadystatechange = null;
                    if (head && script.parentNode) head.removeChild(script);
                    script = undefined
                }
            };
            head.insertBefore(script,
                head.firstChild)
        },
        createFromDZI: function() {
            throw "OpenSeadragon.createFromDZI is deprecated, use Viewer.open.";
        },
        parseXml: function(string) {
            if (window.DOMParser) $.parseXml = function(string) {
                var xmlDoc = null,
                    parser;
                parser = new DOMParser;
                xmlDoc = parser.parseFromString(string, "text/xml");
                return xmlDoc
            };
            else if (window.ActiveXObject) $.parseXml = function(string) {
                var xmlDoc = null;
                xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                xmlDoc.async = false;
                xmlDoc.loadXML(string);
                return xmlDoc
            };
            else throw new Error("Browser doesn't support XML DOM.");
            return $.parseXml(string)
        },
        imageFormatSupported: function(extension) {
            extension = extension ? extension : "";
            return !!FILEFORMATS[extension.toLowerCase()]
        }
    });
    $.Browser = {
        vendor: $.BROWSERS.UNKNOWN,
        version: 0,
        alpha: true
    };
    var FILEFORMATS = {
            "bmp": false,
            "jpeg": true,
            "jpg": true,
            "png": true,
            "tif": false,
            "wdp": false
        },
        URLPARAMS = {};
    (function() {
        var app = navigator.appName,
            ver = navigator.appVersion,
            ua = navigator.userAgent,
            regex;
        switch (navigator.appName) {
            case "Microsoft Internet Explorer":
                if (!!window.attachEvent && !!window.ActiveXObject) {
                    $.Browser.vendor =
                        $.BROWSERS.IE;
                    $.Browser.version = parseFloat(ua.substring(ua.indexOf("MSIE") + 5, ua.indexOf(";", ua.indexOf("MSIE"))))
                }
                break;
            case "Netscape":
                if (!!window.addEventListener)
                    if (ua.indexOf("Firefox") >= 0) {
                        $.Browser.vendor = $.BROWSERS.FIREFOX;
                        $.Browser.version = parseFloat(ua.substring(ua.indexOf("Firefox") + 8))
                    } else if (ua.indexOf("Safari") >= 0) {
                    $.Browser.vendor = ua.indexOf("Chrome") >= 0 ? $.BROWSERS.CHROME : $.BROWSERS.SAFARI;
                    $.Browser.version = parseFloat(ua.substring(ua.substring(0, ua.indexOf("Safari")).lastIndexOf("/") +
                        1, ua.indexOf("Safari")))
                } else {
                    regex = new RegExp("Trident/.*rv:([0-9]{1,}[.0-9]{0,})");
                    if (regex.exec(ua) !== null) {
                        $.Browser.vendor = $.BROWSERS.IE;
                        $.Browser.version = parseFloat(RegExp.$1)
                    }
                }
                break;
            case "Opera":
                $.Browser.vendor = $.BROWSERS.OPERA;
                $.Browser.version = parseFloat(ver);
                break
        }
        var query = window.location.search.substring(1),
            parts = query.split("&"),
            part, sep, i;
        for (i = 0; i < parts.length; i++) {
            part = parts[i];
            sep = part.indexOf("=");
            if (sep > 0) URLPARAMS[part.substring(0, sep)] = decodeURIComponent(part.substring(sep + 1))
        }
        $.Browser.alpha = !($.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 9 || $.Browser.vendor == $.BROWSERS.CHROME && $.Browser.version < 2);
        $.Browser.opacity = !($.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 9)
    })();
    var nullfunction = function(msg) {};
    $.console = window.console || {
        log: nullfunction,
        debug: nullfunction,
        info: nullfunction,
        warn: nullfunction,
        error: nullfunction,
        assert: nullfunction
    };
    (function(w) {
        var requestAnimationFrame = w.requestAnimationFrame || w.mozRequestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame;
        var cancelAnimationFrame = w.cancelAnimationFrame || w.mozCancelAnimationFrame || w.webkitCancelAnimationFrame || w.msCancelAnimationFrame;
        if (requestAnimationFrame && cancelAnimationFrame) {
            $.requestAnimationFrame = function() {
                return requestAnimationFrame.apply(w, arguments)
            };
            $.cancelAnimationFrame = function() {
                return cancelAnimationFrame.apply(w, arguments)
            }
        } else {
            var aAnimQueue = [],
                processing = [],
                iRequestId = 0,
                iIntervalId;
            $.requestAnimationFrame = function(callback) {
                aAnimQueue.push([++iRequestId, callback]);
                if (!iIntervalId) iIntervalId =
                    setInterval(function() {
                        if (aAnimQueue.length) {
                            var time = $.now();
                            var temp = processing;
                            processing = aAnimQueue;
                            aAnimQueue = temp;
                            while (processing.length) processing.shift()[1](time)
                        } else {
                            clearInterval(iIntervalId);
                            iIntervalId = undefined
                        }
                    }, 1E3 / 50);
                return iRequestId
            };
            $.cancelAnimationFrame = function(requestId) {
                var i, j;
                for (i = 0, j = aAnimQueue.length; i < j; i += 1)
                    if (aAnimQueue[i][0] === requestId) {
                        aAnimQueue.splice(i, 1);
                        return
                    }
                for (i = 0, j = processing.length; i < j; i += 1)
                    if (processing[i][0] === requestId) {
                        processing.splice(i, 1);
                        return
                    }
            }
        }
    })(window);

    function getOffsetParent(element, isFixed) {
        if (isFixed && element != document.body) return document.body;
        else return element.offsetParent
    }

    function processDZIResponse(xhr, tilesUrl) {
        var status, statusText, doc = null;
        if (!xhr) throw new Error($.getString("Errors.Security"));
        else if (xhr.status !== 200 && xhr.status !== 0) {
            status = xhr.status;
            statusText = status == 404 ? "Not Found" : xhr.statusText;
            throw new Error($.getString("Errors.Status", status, statusText));
        }
        if (xhr.responseXML && xhr.responseXML.documentElement) doc = xhr.responseXML;
        else if (xhr.responseText) doc = $.parseXml(xhr.responseText);
        return processDZIXml(doc, tilesUrl)
    }

    function processDZIXml(xmlDoc, tilesUrl) {
        if (!xmlDoc || !xmlDoc.documentElement) throw new Error($.getString("Errors.Xml"));
        var root = xmlDoc.documentElement,
            rootName = root.tagName;
        if (rootName == "Image") try {
                return processDZI(root, tilesUrl)
            } catch (e) {
                throw e instanceof Error ? e : new Error($.getString("Errors.Dzi"));
            } else if (rootName == "Collection") throw new Error($.getString("Errors.Dzc"));
            else if (rootName == "Error") return $._processDZIError(root);
        throw new Error($.getString("Errors.Dzi"));
    }

    function processDZI(imageNode, tilesUrl) {
        var fileFormat = imageNode.getAttribute("Format"),
            sizeNode = imageNode.getElementsByTagName("Size")[0],
            dispRectNodes = imageNode.getElementsByTagName("DisplayRect"),
            width = parseInt(sizeNode.getAttribute("Width"), 10),
            height = parseInt(sizeNode.getAttribute("Height"), 10),
            tileSize = parseInt(imageNode.getAttribute("TileSize"), 10),
            tileOverlap = parseInt(imageNode.getAttribute("Overlap"), 10),
            dispRects = [],
            dispRectNode, rectNode, i;
        if (!$.imageFormatSupported(fileFormat)) throw new Error($.getString("Errors.ImageFormat",
            fileFormat.toUpperCase()));
        for (i = 0; i < dispRectNodes.length; i++) {
            dispRectNode = dispRectNodes[i];
            rectNode = dispRectNode.getElementsByTagName("Rect")[0];
            dispRects.push(new $.DisplayRect(parseInt(rectNode.getAttribute("X"), 10), parseInt(rectNode.getAttribute("Y"), 10), parseInt(rectNode.getAttribute("Width"), 10), parseInt(rectNode.getAttribute("Height"), 10), 0, parseInt(dispRectNode.getAttribute("MaxLevel"), 10)))
        }
        return new $.DziTileSource(width, height, tileSize, tileOverlap, tilesUrl, fileFormat, dispRects)
    }

    function processDZIJSON(imageData,
        tilesUrl) {
        var fileFormat = imageData.Format,
            sizeData = imageData.Size,
            dispRectData = imageData.DisplayRect || [],
            width = parseInt(sizeData.Width, 10),
            height = parseInt(sizeData.Height, 10),
            tileSize = parseInt(imageData.TileSize, 10),
            tileOverlap = parseInt(imageData.Overlap, 10),
            dispRects = [],
            rectData, i;
        if (!$.imageFormatSupported(fileFormat)) throw new Error($.getString("Errors.ImageFormat", fileFormat.toUpperCase()));
        for (i = 0; i < dispRectData.length; i++) {
            rectData = dispRectData[i].Rect;
            dispRects.push(new $.DisplayRect(parseInt(rectData.X,
                10), parseInt(rectData.Y, 10), parseInt(rectData.Width, 10), parseInt(rectData.Height, 10), 0, parseInt(rectData.MaxLevel, 10)))
        }
        return new $.DziTileSource(width, height, tileSize, tileOverlap, tilesUrl, fileFormat, dispRects)
    }
    $._processDZIError = function(errorNode) {
        var messageNode = errorNode.getElementsByTagName("Message")[0],
            message = messageNode.firstChild.nodeValue;
        throw new Error(message);
    }
})(OpenSeadragon);
(function($) {
    var fullScreenApi = {
        supportsFullScreen: false,
        isFullScreen: function() {
            return false
        },
        getFullScreenElement: function() {
            return null
        },
        requestFullScreen: function() {},
        exitFullScreen: function() {},
        cancelFullScreen: function() {},
        fullScreenEventName: "",
        fullScreenErrorEventName: ""
    };
    if (document.exitFullscreen) {
        fullScreenApi.supportsFullScreen = true;
        fullScreenApi.getFullScreenElement = function() {
            return document.fullscreenElement
        };
        fullScreenApi.requestFullScreen = function(element) {
            return element.requestFullscreen()
        };
        fullScreenApi.exitFullScreen = function() {
            document.exitFullscreen()
        };
        fullScreenApi.fullScreenEventName = "fullscreenchange";
        fullScreenApi.fullScreenErrorEventName = "fullscreenerror"
    } else if (document.msExitFullscreen) {
        fullScreenApi.supportsFullScreen = true;
        fullScreenApi.getFullScreenElement = function() {
            return document.msFullscreenElement
        };
        fullScreenApi.requestFullScreen = function(element) {
            return element.msRequestFullscreen()
        };
        fullScreenApi.exitFullScreen = function() {
            document.msExitFullscreen()
        };
        fullScreenApi.fullScreenEventName =
            "MSFullscreenChange";
        fullScreenApi.fullScreenErrorEventName = "MSFullscreenError"
    } else if (document.webkitExitFullscreen) {
        fullScreenApi.supportsFullScreen = true;
        fullScreenApi.getFullScreenElement = function() {
            return document.webkitFullscreenElement
        };
        fullScreenApi.requestFullScreen = function(element) {
            return element.webkitRequestFullscreen()
        };
        fullScreenApi.exitFullScreen = function() {
            document.webkitExitFullscreen()
        };
        fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
        fullScreenApi.fullScreenErrorEventName =
            "webkitfullscreenerror"
    } else if (document.webkitCancelFullScreen) {
        fullScreenApi.supportsFullScreen = true;
        fullScreenApi.getFullScreenElement = function() {
            return document.webkitCurrentFullScreenElement
        };
        fullScreenApi.requestFullScreen = function(element) {
            return element.webkitRequestFullScreen()
        };
        fullScreenApi.exitFullScreen = function() {
            document.webkitCancelFullScreen()
        };
        fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
        fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror"
    } else if (document.mozCancelFullScreen) {
        fullScreenApi.supportsFullScreen =
            true;
        fullScreenApi.getFullScreenElement = function() {
            return document.mozFullScreenElement
        };
        fullScreenApi.requestFullScreen = function(element) {
            return element.mozRequestFullScreen()
        };
        fullScreenApi.exitFullScreen = function() {
            document.mozCancelFullScreen()
        };
        fullScreenApi.fullScreenEventName = "mozfullscreenchange";
        fullScreenApi.fullScreenErrorEventName = "mozfullscreenerror"
    }
    fullScreenApi.isFullScreen = function() {
        return fullScreenApi.getFullScreenElement() !== null
    };
    fullScreenApi.cancelFullScreen = function() {
        $.console.error("cancelFullScreen is deprecated. Use exitFullScreen instead.");
        fullScreenApi.exitFullScreen()
    };
    $.extend($, fullScreenApi)
})(OpenSeadragon);
(function($) {
    $.EventSource = function() {
        this.events = {}
    };
    $.EventSource.prototype = {
        addHandler: function(eventName, handler, userData) {
            var events = this.events[eventName];
            if (!events) this.events[eventName] = events = [];
            if (handler && $.isFunction(handler)) events[events.length] = {
                handler: handler,
                userData: userData || null
            }
        },
        removeHandler: function(eventName, handler) {
            var events = this.events[eventName],
                handlers = [],
                i;
            if (!events) return;
            if ($.isArray(events)) {
                for (i = 0; i < events.length; i++)
                    if (events[i].handler !== handler) handlers.push(events[i]);
                this.events[eventName] = handlers
            }
        },
        removeAllHandlers: function(eventName) {
            if (eventName) this.events[eventName] = [];
            else
                for (var eventType in this.events) this.events[eventType] = []
        },
        getHandler: function(eventName) {
            var events = this.events[eventName];
            if (!events || !events.length) return null;
            events = events.length === 1 ? [events[0]] : Array.apply(null, events);
            return function(source, args) {
                var i, length = events.length;
                for (i = 0; i < length; i++)
                    if (events[i]) {
                        args.eventSource = source;
                        args.userData = events[i].userData;
                        events[i].handler(args)
                    }
            }
        },
        raiseEvent: function(eventName, eventArgs) {
            var handler = this.getHandler(eventName);
            if (handler) {
                if (!eventArgs) eventArgs = {};
                handler(this, eventArgs)
            }
        }
    }
})(OpenSeadragon);
(function($) {
    var MOUSETRACKERS = [];
    var THIS = {};
    $.MouseTracker = function(options) {
        MOUSETRACKERS.push(this);
        var args = arguments;
        if (!$.isPlainObject(options)) options = {
            element: args[0],
            clickTimeThreshold: args[1],
            clickDistThreshold: args[2]
        };
        this.hash = Math.random();
        this.element = $.getElement(options.element);
        this.clickTimeThreshold = options.clickTimeThreshold || $.DEFAULT_SETTINGS.clickTimeThreshold;
        this.clickDistThreshold = options.clickDistThreshold || $.DEFAULT_SETTINGS.clickDistThreshold;
        this.dblClickTimeThreshold =
            options.dblClickTimeThreshold || $.DEFAULT_SETTINGS.dblClickTimeThreshold;
        this.dblClickDistThreshold = options.dblClickDistThreshold || $.DEFAULT_SETTINGS.dblClickDistThreshold;
        this.userData = options.userData || null;
        this.stopDelay = options.stopDelay || 50;
        this.enterHandler = options.enterHandler || null;
        this.exitHandler = options.exitHandler || null;
        this.pressHandler = options.pressHandler || null;
        this.nonPrimaryPressHandler = options.nonPrimaryPressHandler || null;
        this.releaseHandler = options.releaseHandler || null;
        this.nonPrimaryReleaseHandler =
            options.nonPrimaryReleaseHandler || null;
        this.moveHandler = options.moveHandler || null;
        this.scrollHandler = options.scrollHandler || null;
        this.clickHandler = options.clickHandler || null;
        this.dblClickHandler = options.dblClickHandler || null;
        this.dragHandler = options.dragHandler || null;
        this.dragEndHandler = options.dragEndHandler || null;
        this.pinchHandler = options.pinchHandler || null;
        this.stopHandler = options.stopHandler || null;
        this.keyDownHandler = options.keyDownHandler || null;
        this.keyUpHandler = options.keyUpHandler || null;
        this.keyHandler =
            options.keyHandler || null;
        this.focusHandler = options.focusHandler || null;
        this.blurHandler = options.blurHandler || null;
        var _this = this;
        THIS[this.hash] = {
            click: function(event) {
                onClick(_this, event)
            },
            dblclick: function(event) {
                onDblClick(_this, event)
            },
            keydown: function(event) {
                onKeyDown(_this, event)
            },
            keyup: function(event) {
                onKeyUp(_this, event)
            },
            keypress: function(event) {
                onKeyPress(_this, event)
            },
            focus: function(event) {
                onFocus(_this, event)
            },
            blur: function(event) {
                onBlur(_this, event)
            },
            wheel: function(event) {
                onWheel(_this,
                    event)
            },
            mousewheel: function(event) {
                onMouseWheel(_this, event)
            },
            DOMMouseScroll: function(event) {
                onMouseWheel(_this, event)
            },
            MozMousePixelScroll: function(event) {
                onMouseWheel(_this, event)
            },
            mouseenter: function(event) {
                onMouseEnter(_this, event)
            },
            mouseleave: function(event) {
                onMouseLeave(_this, event)
            },
            mouseover: function(event) {
                onMouseOver(_this, event)
            },
            mouseout: function(event) {
                onMouseOut(_this, event)
            },
            mousedown: function(event) {
                onMouseDown(_this, event)
            },
            mouseup: function(event) {
                onMouseUp(_this, event)
            },
            mouseupcaptured: function(event) {
                onMouseUpCaptured(_this,
                    event)
            },
            mousemove: function(event) {
                onMouseMove(_this, event)
            },
            mousemovecaptured: function(event) {
                onMouseMoveCaptured(_this, event)
            },
            touchstart: function(event) {
                onTouchStart(_this, event)
            },
            touchend: function(event) {
                onTouchEnd(_this, event)
            },
            touchendcaptured: function(event) {
                onTouchEndCaptured(_this, event)
            },
            touchmove: function(event) {
                onTouchMove(_this, event)
            },
            touchmovecaptured: function(event) {
                onTouchMoveCaptured(_this, event)
            },
            touchcancel: function(event) {
                onTouchCancel(_this, event)
            },
            gesturestart: function(event) {
                onGestureStart(_this,
                    event)
            },
            gesturechange: function(event) {
                onGestureChange(_this, event)
            },
            pointerover: function(event) {
                onPointerOver(_this, event)
            },
            MSPointerOver: function(event) {
                onPointerOver(_this, event)
            },
            pointerout: function(event) {
                onPointerOut(_this, event)
            },
            MSPointerOut: function(event) {
                onPointerOut(_this, event)
            },
            pointerdown: function(event) {
                onPointerDown(_this, event)
            },
            MSPointerDown: function(event) {
                onPointerDown(_this, event)
            },
            pointerup: function(event) {
                onPointerUp(_this, event)
            },
            MSPointerUp: function(event) {
                onPointerUp(_this,
                    event)
            },
            pointermove: function(event) {
                onPointerMove(_this, event)
            },
            MSPointerMove: function(event) {
                onPointerMove(_this, event)
            },
            pointercancel: function(event) {
                onPointerCancel(_this, event)
            },
            MSPointerCancel: function(event) {
                onPointerCancel(_this, event)
            },
            pointerupcaptured: function(event) {
                onPointerUpCaptured(_this, event)
            },
            pointermovecaptured: function(event) {
                onPointerMoveCaptured(_this, event)
            },
            tracking: false,
            activePointersLists: [],
            lastClickPos: null,
            dblClickTimeOut: null,
            pinchGPoints: [],
            lastPinchDist: 0,
            currentPinchDist: 0,
            lastPinchCenter: null,
            currentPinchCenter: null
        };
        if (!options.startDisabled) this.setTracking(true)
    };
    $.MouseTracker.prototype = {
        destroy: function() {
            var i;
            stopTracking(this);
            this.element = null;
            for (i = 0; i < MOUSETRACKERS.length; i++)
                if (MOUSETRACKERS[i] === this) {
                    MOUSETRACKERS.splice(i, 1);
                    break
                }
            THIS[this.hash] = null;
            delete THIS[this.hash]
        },
        isTracking: function() {
            return THIS[this.hash].tracking
        },
        setTracking: function(track) {
            if (track) startTracking(this);
            else stopTracking(this);
            return this
        },
        getActivePointersListByType: function(type) {
            var delegate =
                THIS[this.hash],
                i, len = delegate.activePointersLists.length,
                list;
            for (i = 0; i < len; i++)
                if (delegate.activePointersLists[i].type === type) return delegate.activePointersLists[i];
            list = new $.MouseTracker.GesturePointList(type);
            delegate.activePointersLists.push(list);
            return list
        },
        getActivePointerCount: function() {
            var delegate = THIS[this.hash],
                i, len = delegate.activePointersLists.length,
                count = 0;
            for (i = 0; i < len; i++) count += delegate.activePointersLists[i].getLength();
            return count
        },
        enterHandler: function() {},
        exitHandler: function() {},
        pressHandler: function() {},
        nonPrimaryPressHandler: function() {},
        releaseHandler: function() {},
        nonPrimaryReleaseHandler: function() {},
        moveHandler: function() {},
        scrollHandler: function() {},
        clickHandler: function() {},
        dblClickHandler: function() {},
        dragHandler: function() {},
        dragEndHandler: function() {},
        pinchHandler: function() {},
        stopHandler: function() {},
        keyDownHandler: function() {},
        keyUpHandler: function() {},
        keyHandler: function() {},
        focusHandler: function() {},
        blurHandler: function() {}
    };
    $.MouseTracker.gesturePointVelocityTracker =
        function() {
            var trackerPoints = [],
                intervalId = 0,
                lastTime = 0;
            var _generateGuid = function(tracker, gPoint) {
                return tracker.hash.toString() + gPoint.type + gPoint.id.toString()
            };
            var _doTracking = function() {
                var i, len = trackerPoints.length,
                    trackPoint, gPoint, now = $.now(),
                    elapsedTime, distance, speed;
                elapsedTime = now - lastTime;
                lastTime = now;
                for (i = 0; i < len; i++) {
                    trackPoint = trackerPoints[i];
                    gPoint = trackPoint.gPoint;
                    gPoint.direction = Math.atan2(gPoint.currentPos.y - trackPoint.lastPos.y, gPoint.currentPos.x - trackPoint.lastPos.x);
                    distance =
                        trackPoint.lastPos.distanceTo(gPoint.currentPos);
                    trackPoint.lastPos = gPoint.currentPos;
                    speed = 1E3 * distance / (elapsedTime + 1);
                    gPoint.speed = .75 * speed + .25 * gPoint.speed
                }
            };
            var addPoint = function(tracker, gPoint) {
                var guid = _generateGuid(tracker, gPoint);
                trackerPoints.push({
                    guid: guid,
                    gPoint: gPoint,
                    lastPos: gPoint.currentPos
                });
                if (trackerPoints.length === 1) {
                    lastTime = $.now();
                    intervalId = window.setInterval(_doTracking, 50)
                }
            };
            var removePoint = function(tracker, gPoint) {
                var guid = _generateGuid(tracker, gPoint),
                    i, len = trackerPoints.length;
                for (i = 0; i < len; i++)
                    if (trackerPoints[i].guid === guid) {
                        trackerPoints.splice(i, 1);
                        len--;
                        if (len === 0) window.clearInterval(intervalId);
                        break
                    }
            };
            return {
                addPoint: addPoint,
                removePoint: removePoint
            }
        }();
    $.MouseTracker.captureElement = document;
    $.MouseTracker.wheelEventName = $.Browser.vendor == $.BROWSERS.IE && $.Browser.version > 8 || "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== undefined ? "mousewheel" : "DOMMouseScroll";
    $.MouseTracker.supportsMouseCapture = function() {
        var divElement = document.createElement("div");
        return $.isFunction(divElement.setCapture) && $.isFunction(divElement.releaseCapture)
    }();
    $.MouseTracker.subscribeEvents = ["click", "dblclick", "keydown", "keyup", "keypress", "focus", "blur", $.MouseTracker.wheelEventName];
    if ($.MouseTracker.wheelEventName == "DOMMouseScroll") $.MouseTracker.subscribeEvents.push("MozMousePixelScroll");
    if (window.PointerEvent && (window.navigator.pointerEnabled || $.Browser.vendor !== $.BROWSERS.IE)) {
        $.MouseTracker.havePointerEvents = true;
        $.MouseTracker.subscribeEvents.push("pointerover",
            "pointerout", "pointerdown", "pointerup", "pointermove", "pointercancel");
        $.MouseTracker.unprefixedPointerEvents = true;
        if (navigator.maxTouchPoints) $.MouseTracker.maxTouchPoints = navigator.maxTouchPoints;
        else $.MouseTracker.maxTouchPoints = 0;
        $.MouseTracker.haveMouseEnter = false
    } else if (window.MSPointerEvent && window.navigator.msPointerEnabled) {
        $.MouseTracker.havePointerEvents = true;
        $.MouseTracker.subscribeEvents.push("MSPointerOver", "MSPointerOut", "MSPointerDown", "MSPointerUp", "MSPointerMove", "MSPointerCancel");
        $.MouseTracker.unprefixedPointerEvents = false;
        if (navigator.msMaxTouchPoints) $.MouseTracker.maxTouchPoints = navigator.msMaxTouchPoints;
        else $.MouseTracker.maxTouchPoints = 0;
        $.MouseTracker.haveMouseEnter = false
    } else {
        $.MouseTracker.havePointerEvents = false;
        if ($.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9) {
            $.MouseTracker.subscribeEvents.push("mouseenter", "mouseleave");
            $.MouseTracker.haveMouseEnter = true
        } else {
            $.MouseTracker.subscribeEvents.push("mouseover", "mouseout");
            $.MouseTracker.haveMouseEnter = false
        }
        $.MouseTracker.subscribeEvents.push("mousedown",
            "mouseup", "mousemove");
        if ("ontouchstart" in window) $.MouseTracker.subscribeEvents.push("touchstart", "touchend", "touchmove", "touchcancel");
        if ("ongesturestart" in window) $.MouseTracker.subscribeEvents.push("gesturestart", "gesturechange");
        $.MouseTracker.mousePointerId = "legacy-mouse";
        $.MouseTracker.maxTouchPoints = 10
    }
    $.MouseTracker.GesturePointList = function(type) {
        this._gPoints = [];
        this.type = type;
        this.buttons = 0;
        this.contacts = 0;
        this.clicks = 0;
        this.captureCount = 0
    };
    $.MouseTracker.GesturePointList.prototype = {
        getLength: function() {
            return this._gPoints.length
        },
        asArray: function() {
            return this._gPoints
        },
        add: function(gp) {
            return this._gPoints.push(gp)
        },
        removeById: function(id) {
            var i, len = this._gPoints.length;
            for (i = 0; i < len; i++)
                if (this._gPoints[i].id === id) {
                    this._gPoints.splice(i, 1);
                    break
                }
            return this._gPoints.length
        },
        getByIndex: function(index) {
            if (index < this._gPoints.length) return this._gPoints[index];
            return null
        },
        getById: function(id) {
            var i, len = this._gPoints.length;
            for (i = 0; i < len; i++)
                if (this._gPoints[i].id === id) return this._gPoints[i];
            return null
        },
        getPrimary: function(id) {
            var i,
                len = this._gPoints.length;
            for (i = 0; i < len; i++)
                if (this._gPoints[i].isPrimary) return this._gPoints[i];
            return null
        }
    };

    function clearTrackedPointers(tracker) {
        var delegate = THIS[tracker.hash],
            i, pointerListCount = delegate.activePointersLists.length;
        for (i = 0; i < pointerListCount; i++)
            if (delegate.activePointersLists[i].captureCount > 0) {
                $.removeEvent($.MouseTracker.captureElement, "mousemove", delegate.mousemovecaptured, true);
                $.removeEvent($.MouseTracker.captureElement, "mouseup", delegate.mouseupcaptured, true);
                $.removeEvent($.MouseTracker.captureElement,
                    $.MouseTracker.unprefixedPointerEvents ? "pointermove" : "MSPointerMove", delegate.pointermovecaptured, true);
                $.removeEvent($.MouseTracker.captureElement, $.MouseTracker.unprefixedPointerEvents ? "pointerup" : "MSPointerUp", delegate.pointerupcaptured, true);
                $.removeEvent($.MouseTracker.captureElement, "touchmove", delegate.touchmovecaptured, true);
                $.removeEvent($.MouseTracker.captureElement, "touchend", delegate.touchendcaptured, true);
                delegate.activePointersLists[i].captureCount = 0
            }
        for (i = 0; i < pointerListCount; i++) delegate.activePointersLists.pop()
    }

    function startTracking(tracker) {
        var delegate = THIS[tracker.hash],
            event, i;
        if (!delegate.tracking) {
            for (i = 0; i < $.MouseTracker.subscribeEvents.length; i++) {
                event = $.MouseTracker.subscribeEvents[i];
                $.addEvent(tracker.element, event, delegate[event], false)
            }
            clearTrackedPointers(tracker);
            delegate.tracking = true
        }
    }

    function stopTracking(tracker) {
        var delegate = THIS[tracker.hash],
            event, i;
        if (delegate.tracking) {
            for (i = 0; i < $.MouseTracker.subscribeEvents.length; i++) {
                event = $.MouseTracker.subscribeEvents[i];
                $.removeEvent(tracker.element,
                    event, delegate[event], false)
            }
            clearTrackedPointers(tracker);
            delegate.tracking = false
        }
    }

    function getCaptureEventParams(tracker, pointerType) {
        var delegate = THIS[tracker.hash];
        if (pointerType === "pointerevent") return {
            upName: $.MouseTracker.unprefixedPointerEvents ? "pointerup" : "MSPointerUp",
            upHandler: delegate.pointerupcaptured,
            moveName: $.MouseTracker.unprefixedPointerEvents ? "pointermove" : "MSPointerMove",
            moveHandler: delegate.pointermovecaptured
        };
        else if (pointerType === "mouse") return {
            upName: "mouseup",
            upHandler: delegate.mouseupcaptured,
            moveName: "mousemove",
            moveHandler: delegate.mousemovecaptured
        };
        else if (pointerType === "touch") return {
            upName: "touchend",
            upHandler: delegate.touchendcaptured,
            moveName: "touchmove",
            moveHandler: delegate.touchmovecaptured
        };
        else throw new Error("MouseTracker.getCaptureEventParams: Unknown pointer type.");
    }

    function capturePointer(tracker, pointerType) {
        var pointsList = tracker.getActivePointersListByType(pointerType),
            eventParams;
        pointsList.captureCount++;
        if (pointsList.captureCount === 1)
            if ($.Browser.vendor === $.BROWSERS.IE &&
                $.Browser.version < 9) tracker.element.setCapture(true);
            else {
                eventParams = getCaptureEventParams(tracker, $.MouseTracker.havePointerEvents ? "pointerevent" : pointerType);
                $.addEvent($.MouseTracker.captureElement, eventParams.upName, eventParams.upHandler, true);
                $.addEvent($.MouseTracker.captureElement, eventParams.moveName, eventParams.moveHandler, true)
            }
    }

    function releasePointer(tracker, pointerType) {
        var pointsList = tracker.getActivePointersListByType(pointerType),
            eventParams;
        pointsList.captureCount--;
        if (pointsList.captureCount ===
            0)
            if ($.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9) tracker.element.releaseCapture();
            else {
                eventParams = getCaptureEventParams(tracker, $.MouseTracker.havePointerEvents ? "pointerevent" : pointerType);
                $.removeEvent($.MouseTracker.captureElement, eventParams.moveName, eventParams.moveHandler, true);
                $.removeEvent($.MouseTracker.captureElement, eventParams.upName, eventParams.upHandler, true)
            }
    }

    function getPointerType(event) {
        var pointerTypeStr;
        if ($.MouseTracker.unprefixedPointerEvents) pointerTypeStr = event.pointerType;
        else switch (event.pointerType) {
            case 2:
                pointerTypeStr = "touch";
                break;
            case 3:
                pointerTypeStr = "pen";
                break;
            case 4:
                pointerTypeStr = "mouse";
                break;
            default:
                pointerTypeStr = ""
        }
        return pointerTypeStr
    }

    function getMouseAbsolute(event) {
        return $.getMousePosition(event)
    }

    function getMouseRelative(event, element) {
        return getPointRelativeToAbsolute(getMouseAbsolute(event), element)
    }

    function getPointRelativeToAbsolute(point, element) {
        var offset = $.getElementOffset(element);
        return point.minus(offset)
    }

    function getCenterPoint(point1,
        point2) {
        return new $.Point((point1.x + point2.x) / 2, (point1.y + point2.y) / 2)
    }

    function onClick(tracker, event) {
        if (tracker.clickHandler) $.cancelEvent(event)
    }

    function onDblClick(tracker, event) {
        if (tracker.dblClickHandler) $.cancelEvent(event)
    }

    function onKeyDown(tracker, event) {
        var propagate;
        if (tracker.keyDownHandler) {
            event = $.getEvent(event);
            propagate = tracker.keyDownHandler({
                eventSource: tracker,
                keyCode: event.keyCode ? event.keyCode : event.charCode,
                ctrl: event.ctrlKey,
                shift: event.shiftKey,
                alt: event.altKey,
                meta: event.metaKey,
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
            });
            if (!propagate) $.cancelEvent(event)
        }
    }

    function onKeyUp(tracker, event) {
        var propagate;
        if (tracker.keyUpHandler) {
            event = $.getEvent(event);
            propagate = tracker.keyUpHandler({
                eventSource: tracker,
                keyCode: event.keyCode ? event.keyCode : event.charCode,
                ctrl: event.ctrlKey,
                shift: event.shiftKey,
                alt: event.altKey,
                meta: event.metaKey,
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
            });
            if (!propagate) $.cancelEvent(event)
        }
    }

    function onKeyPress(tracker,
        event) {
        var propagate;
        if (tracker.keyHandler) {
            event = $.getEvent(event);
            propagate = tracker.keyHandler({
                eventSource: tracker,
                keyCode: event.keyCode ? event.keyCode : event.charCode,
                ctrl: event.ctrlKey,
                shift: event.shiftKey,
                alt: event.altKey,
                meta: event.metaKey,
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
            });
            if (!propagate) $.cancelEvent(event)
        }
    }

    function onFocus(tracker, event) {
        var propagate;
        if (tracker.focusHandler) {
            event = $.getEvent(event);
            propagate = tracker.focusHandler({
                eventSource: tracker,
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
            });
            if (propagate === false) $.cancelEvent(event)
        }
    }

    function onBlur(tracker, event) {
        var propagate;
        if (tracker.blurHandler) {
            event = $.getEvent(event);
            propagate = tracker.blurHandler({
                eventSource: tracker,
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
            });
            if (propagate === false) $.cancelEvent(event)
        }
    }

    function onWheel(tracker, event) {
        handleWheelEvent(tracker, event, event)
    }

    function onMouseWheel(tracker, event) {
        event = $.getEvent(event);
        var simulatedEvent = {
            target: event.target || event.srcElement,
            type: "wheel",
            shiftKey: event.shiftKey || false,
            clientX: event.clientX,
            clientY: event.clientY,
            pageX: event.pageX ? event.pageX : event.clientX,
            pageY: event.pageY ? event.pageY : event.clientY,
            deltaMode: event.type == "MozMousePixelScroll" ? 0 : 1,
            deltaX: 0,
            deltaZ: 0
        };
        if ($.MouseTracker.wheelEventName == "mousewheel") simulatedEvent.deltaY = -1 / $.DEFAULT_SETTINGS.pixelsPerWheelLine * event.wheelDelta;
        else simulatedEvent.deltaY = event.detail;
        handleWheelEvent(tracker, simulatedEvent,
            event)
    }

    function handleWheelEvent(tracker, event, originalEvent) {
        var nDelta = 0,
            propagate;
        nDelta = event.deltaY < 0 ? 1 : -1;
        if (tracker.scrollHandler) {
            propagate = tracker.scrollHandler({
                eventSource: tracker,
                pointerType: "mouse",
                position: getMouseRelative(event, tracker.element),
                scroll: nDelta,
                shift: event.shiftKey,
                isTouchEvent: false,
                originalEvent: originalEvent,
                preventDefaultAction: false,
                userData: tracker.userData
            });
            if (propagate === false) $.cancelEvent(originalEvent)
        }
    }

    function isParentChild(parent, child) {
        if (parent === child) return false;
        while (child && child !== parent) child = child.parentNode;
        return child === parent
    }

    function onMouseEnter(tracker, event) {
        event = $.getEvent(event);
        handleMouseEnter(tracker, event)
    }

    function onMouseOver(tracker, event) {
        event = $.getEvent(event);
        if (event.currentTarget === event.relatedTarget || isParentChild(event.currentTarget, event.relatedTarget)) return;
        handleMouseEnter(tracker, event)
    }

    function handleMouseEnter(tracker, event) {
        var gPoint = {
            id: $.MouseTracker.mousePointerId,
            type: "mouse",
            isPrimary: true,
            currentPos: getMouseAbsolute(event),
            currentTime: $.now()
        };
        updatePointersEnter(tracker, event, [gPoint])
    }

    function onMouseLeave(tracker, event) {
        event = $.getEvent(event);
        handleMouseExit(tracker, event)
    }

    function onMouseOut(tracker, event) {
        event = $.getEvent(event);
        if (event.currentTarget === event.relatedTarget || isParentChild(event.currentTarget, event.relatedTarget)) return;
        handleMouseExit(tracker, event)
    }

    function handleMouseExit(tracker, event) {
        var gPoint = {
            id: $.MouseTracker.mousePointerId,
            type: "mouse",
            isPrimary: true,
            currentPos: getMouseAbsolute(event),
            currentTime: $.now()
        };
        updatePointersExit(tracker, event, [gPoint])
    }

    function getStandardizedButton(button) {
        if ($.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9)
            if (button === 1) return 0;
            else if (button === 2) return 2;
        else if (button === 4) return 1;
        else return -1;
        else return button
    }

    function onMouseDown(tracker, event) {
        var gPoint;
        event = $.getEvent(event);
        gPoint = {
            id: $.MouseTracker.mousePointerId,
            type: "mouse",
            isPrimary: true,
            currentPos: getMouseAbsolute(event),
            currentTime: $.now()
        };
        if (updatePointersDown(tracker, event, [gPoint], getStandardizedButton(event.button))) {
            $.stopEvent(event);
            capturePointer(tracker, "mouse")
        }
        if (tracker.clickHandler || tracker.dblClickHandler || tracker.pressHandler || tracker.dragHandler || tracker.dragEndHandler) $.cancelEvent(event)
    }

    function onMouseUp(tracker, event) {
        handleMouseUp(tracker, event)
    }

    function onMouseUpCaptured(tracker, event) {
        handleMouseUp(tracker, event);
        $.stopEvent(event)
    }

    function handleMouseUp(tracker, event) {
        var gPoint;
        event = $.getEvent(event);
        gPoint = {
            id: $.MouseTracker.mousePointerId,
            type: "mouse",
            isPrimary: true,
            currentPos: getMouseAbsolute(event),
            currentTime: $.now()
        };
        if (updatePointersUp(tracker, event, [gPoint], getStandardizedButton(event.button))) releasePointer(tracker, "mouse")
    }

    function onMouseMove(tracker, event) {
        handleMouseMove(tracker, event)
    }

    function onMouseMoveCaptured(tracker, event) {
        handleMouseMove(tracker, event);
        $.stopEvent(event)
    }

    function handleMouseMove(tracker, event) {
        var gPoint;
        event = $.getEvent(event);
        gPoint = {
            id: $.MouseTracker.mousePointerId,
            type: "mouse",
            isPrimary: true,
            currentPos: getMouseAbsolute(event),
            currentTime: $.now()
        };
        updatePointersMove(tracker, event, [gPoint])
    }

    function abortTouchContacts(tracker, event, pointsList) {
        var i, gPointCount = pointsList.getLength(),
            abortGPoints = [];
        for (i = 0; i < gPointCount; i++) abortGPoints.push(pointsList.getByIndex(i));
        if (abortGPoints.length > 0) {
            updatePointersUp(tracker, event, abortGPoints, 0);
            pointsList.captureCount = 1;
            releasePointer(tracker, "touch");
            updatePointersExit(tracker, event, abortGPoints)
        }
    }

    function onTouchStart(tracker, event) {
        var time,
            i, j, touchCount = event.changedTouches.length,
            gPoints = [],
            parentGPoints, pointsList = tracker.getActivePointersListByType("touch");
        time = $.now();
        if (pointsList.getLength() > event.touches.length - touchCount) {
            $.console.warn("Tracked touch contact count doesn't match event.touches.length. Removing all tracked touch pointers.");
            abortTouchContacts(tracker, event, pointsList)
        }
        for (i = 0; i < touchCount; i++) gPoints.push({
            id: event.changedTouches[i].identifier,
            type: "touch",
            currentPos: getMouseAbsolute(event.changedTouches[i]),
            currentTime: time
        });
        updatePointersEnter(tracker, event, gPoints);
        for (i = 0; i < MOUSETRACKERS.length; i++)
            if (MOUSETRACKERS[i] !== tracker && MOUSETRACKERS[i].isTracking() && isParentChild(MOUSETRACKERS[i].element, tracker.element)) {
                parentGPoints = [];
                for (j = 0; j < touchCount; j++) parentGPoints.push({
                    id: event.changedTouches[j].identifier,
                    type: "touch",
                    currentPos: getMouseAbsolute(event.changedTouches[j]),
                    currentTime: time
                });
                updatePointersEnter(MOUSETRACKERS[i], event, parentGPoints)
            }
        if (updatePointersDown(tracker, event, gPoints,
                0)) {
            $.stopEvent(event);
            capturePointer(tracker, "touch")
        }
        $.cancelEvent(event)
    }

    function onTouchEnd(tracker, event) {
        handleTouchEnd(tracker, event)
    }

    function onTouchEndCaptured(tracker, event) {
        handleTouchEnd(tracker, event);
        $.stopEvent(event)
    }

    function handleTouchEnd(tracker, event) {
        var time, i, j, touchCount = event.changedTouches.length,
            gPoints = [],
            parentGPoints;
        time = $.now();
        for (i = 0; i < touchCount; i++) gPoints.push({
            id: event.changedTouches[i].identifier,
            type: "touch",
            currentPos: getMouseAbsolute(event.changedTouches[i]),
            currentTime: time
        });
        if (updatePointersUp(tracker, event, gPoints, 0)) releasePointer(tracker, "touch");
        updatePointersExit(tracker, event, gPoints);
        for (i = 0; i < MOUSETRACKERS.length; i++)
            if (MOUSETRACKERS[i] !== tracker && MOUSETRACKERS[i].isTracking() && isParentChild(MOUSETRACKERS[i].element, tracker.element)) {
                parentGPoints = [];
                for (j = 0; j < touchCount; j++) parentGPoints.push({
                    id: event.changedTouches[j].identifier,
                    type: "touch",
                    currentPos: getMouseAbsolute(event.changedTouches[j]),
                    currentTime: time
                });
                updatePointersExit(MOUSETRACKERS[i],
                    event, parentGPoints)
            }
        $.cancelEvent(event)
    }

    function onTouchMove(tracker, event) {
        handleTouchMove(tracker, event)
    }

    function onTouchMoveCaptured(tracker, event) {
        handleTouchMove(tracker, event);
        $.stopEvent(event)
    }

    function handleTouchMove(tracker, event) {
        var i, touchCount = event.changedTouches.length,
            gPoints = [];
        for (i = 0; i < touchCount; i++) gPoints.push({
            id: event.changedTouches[i].identifier,
            type: "touch",
            currentPos: getMouseAbsolute(event.changedTouches[i]),
            currentTime: $.now()
        });
        updatePointersMove(tracker, event, gPoints);
        $.cancelEvent(event)
    }

    function onTouchCancel(tracker, event) {
        var i, touchCount = event.changedTouches.length,
            gPoints = [];
        for (i = 0; i < touchCount; i++) gPoints.push({
            id: event.changedTouches[i].identifier,
            type: "touch"
        });
        updatePointersCancel(tracker, event, gPoints)
    }

    function onGestureStart(tracker, event) {
        event.stopPropagation();
        event.preventDefault();
        return false
    }

    function onGestureChange(tracker, event) {
        event.stopPropagation();
        event.preventDefault();
        return false
    }

    function onPointerOver(tracker, event) {
        var gPoint;
        if (event.currentTarget ===
            event.relatedTarget || isParentChild(event.currentTarget, event.relatedTarget)) return;
        gPoint = {
            id: event.pointerId,
            type: getPointerType(event),
            isPrimary: event.isPrimary,
            currentPos: getMouseAbsolute(event),
            currentTime: $.now()
        };
        updatePointersEnter(tracker, event, [gPoint])
    }

    function onPointerOut(tracker, event) {
        var gPoint;
        if (event.currentTarget === event.relatedTarget || isParentChild(event.currentTarget, event.relatedTarget)) return;
        gPoint = {
            id: event.pointerId,
            type: getPointerType(event),
            isPrimary: event.isPrimary,
            currentPos: getMouseAbsolute(event),
            currentTime: $.now()
        };
        updatePointersExit(tracker, event, [gPoint])
    }

    function onPointerDown(tracker, event) {
        var gPoint;
        gPoint = {
            id: event.pointerId,
            type: getPointerType(event),
            isPrimary: event.isPrimary,
            currentPos: getMouseAbsolute(event),
            currentTime: $.now()
        };
        if (updatePointersDown(tracker, event, [gPoint], event.button)) {
            $.stopEvent(event);
            capturePointer(tracker, gPoint.type)
        }
        if (tracker.clickHandler || tracker.dblClickHandler || tracker.pressHandler || tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler) $.cancelEvent(event)
    }

    function onPointerUp(tracker, event) {
        handlePointerUp(tracker, event)
    }

    function onPointerUpCaptured(tracker, event) {
        var pointsList = tracker.getActivePointersListByType(getPointerType(event));
        if (pointsList.getById(event.pointerId)) handlePointerUp(tracker, event);
        $.stopEvent(event)
    }

    function handlePointerUp(tracker, event) {
        var gPoint;
        gPoint = {
            id: event.pointerId,
            type: getPointerType(event),
            isPrimary: event.isPrimary,
            currentPos: getMouseAbsolute(event),
            currentTime: $.now()
        };
        if (updatePointersUp(tracker, event, [gPoint],
                event.button)) releasePointer(tracker, gPoint.type)
    }

    function onPointerMove(tracker, event) {
        handlePointerMove(tracker, event)
    }

    function onPointerMoveCaptured(tracker, event) {
        var pointsList = tracker.getActivePointersListByType(getPointerType(event));
        if (pointsList.getById(event.pointerId)) handlePointerMove(tracker, event);
        $.stopEvent(event)
    }

    function handlePointerMove(tracker, event) {
        var gPoint;
        gPoint = {
            id: event.pointerId,
            type: getPointerType(event),
            isPrimary: event.isPrimary,
            currentPos: getMouseAbsolute(event),
            currentTime: $.now()
        };
        updatePointersMove(tracker, event, [gPoint])
    }

    function onPointerCancel(tracker, event) {
        var gPoint;
        gPoint = {
            id: event.pointerId,
            type: getPointerType(event)
        };
        updatePointersCancel(tracker, event, [gPoint])
    }

    function startTrackingPointer(pointsList, gPoint) {
        if (!gPoint.hasOwnProperty("isPrimary"))
            if (pointsList.getLength() === 0) gPoint.isPrimary = true;
            else gPoint.isPrimary = false;
        gPoint.speed = 0;
        gPoint.direction = 0;
        gPoint.contactPos = gPoint.currentPos;
        gPoint.contactTime = gPoint.currentTime;
        gPoint.lastPos = gPoint.currentPos;
        gPoint.lastTime = gPoint.currentTime;
        return pointsList.add(gPoint)
    }

    function stopTrackingPointer(pointsList, gPoint) {
        var listLength, primaryPoint;
        if (pointsList.getById(gPoint.id)) {
            listLength = pointsList.removeById(gPoint.id);
            if (!gPoint.hasOwnProperty("isPrimary")) {
                primaryPoint = pointsList.getPrimary();
                if (!primaryPoint) {
                    primaryPoint = pointsList.getByIndex(0);
                    if (primaryPoint) primaryPoint.isPrimary = true
                }
            }
        } else listLength = pointsList.getLength();
        return listLength
    }

    function updatePointersEnter(tracker, event, gPoints) {
        var pointsList =
            tracker.getActivePointersListByType(gPoints[0].type),
            i, gPointCount = gPoints.length,
            curGPoint, updateGPoint, propagate;
        for (i = 0; i < gPointCount; i++) {
            curGPoint = gPoints[i];
            updateGPoint = pointsList.getById(curGPoint.id);
            if (updateGPoint) {
                updateGPoint.insideElement = true;
                updateGPoint.lastPos = updateGPoint.currentPos;
                updateGPoint.lastTime = updateGPoint.currentTime;
                updateGPoint.currentPos = curGPoint.currentPos;
                updateGPoint.currentTime = curGPoint.currentTime;
                curGPoint = updateGPoint
            } else {
                curGPoint.captured = false;
                curGPoint.insideElementPressed =
                    false;
                curGPoint.insideElement = true;
                startTrackingPointer(pointsList, curGPoint)
            }
            if (tracker.enterHandler) {
                propagate = tracker.enterHandler({
                    eventSource: tracker,
                    pointerType: curGPoint.type,
                    position: getPointRelativeToAbsolute(curGPoint.currentPos, tracker.element),
                    buttons: pointsList.buttons,
                    pointers: tracker.getActivePointerCount(),
                    insideElementPressed: curGPoint.insideElementPressed,
                    buttonDownAny: pointsList.buttons !== 0,
                    isTouchEvent: curGPoint.type === "touch",
                    originalEvent: event,
                    preventDefaultAction: false,
                    userData: tracker.userData
                });
                if (propagate === false) $.cancelEvent(event)
            }
        }
    }

    function updatePointersExit(tracker, event, gPoints) {
        var delegate = THIS[tracker.hash],
            pointsList = tracker.getActivePointersListByType(gPoints[0].type),
            i, gPointCount = gPoints.length,
            curGPoint, updateGPoint, propagate;
        for (i = 0; i < gPointCount; i++) {
            curGPoint = gPoints[i];
            updateGPoint = pointsList.getById(curGPoint.id);
            if (updateGPoint) {
                if (updateGPoint.captured) {
                    updateGPoint.insideElement = false;
                    updateGPoint.lastPos = updateGPoint.currentPos;
                    updateGPoint.lastTime = updateGPoint.currentTime;
                    updateGPoint.currentPos = curGPoint.currentPos;
                    updateGPoint.currentTime = curGPoint.currentTime
                } else stopTrackingPointer(pointsList, updateGPoint);
                curGPoint = updateGPoint
            }
            if (tracker.exitHandler) {
                propagate = tracker.exitHandler({
                    eventSource: tracker,
                    pointerType: curGPoint.type,
                    position: getPointRelativeToAbsolute(curGPoint.currentPos, tracker.element),
                    buttons: pointsList.buttons,
                    pointers: tracker.getActivePointerCount(),
                    insideElementPressed: updateGPoint ? updateGPoint.insideElementPressed : false,
                    buttonDownAny: pointsList.buttons !==
                        0,
                    isTouchEvent: curGPoint.type === "touch",
                    originalEvent: event,
                    preventDefaultAction: false,
                    userData: tracker.userData
                });
                if (propagate === false) $.cancelEvent(event)
            }
        }
    }

    function updatePointersDown(tracker, event, gPoints, buttonChanged) {
        var delegate = THIS[tracker.hash],
            propagate, pointsList = tracker.getActivePointersListByType(gPoints[0].type),
            i, gPointCount = gPoints.length,
            curGPoint, updateGPoint;
        if (typeof event.buttons !== "undefined") pointsList.buttons = event.buttons;
        else if ($.Browser.vendor === $.BROWSERS.IE && $.Browser.version <
            9)
            if (buttonChanged === 0) pointsList.buttons += 1;
            else if (buttonChanged === 1) pointsList.buttons += 4;
        else if (buttonChanged === 2) pointsList.buttons += 2;
        else if (buttonChanged === 3) pointsList.buttons += 8;
        else if (buttonChanged === 4) pointsList.buttons += 16;
        else {
            if (buttonChanged === 5) pointsList.buttons += 32
        } else if (buttonChanged === 0) pointsList.buttons |= 1;
        else if (buttonChanged === 1) pointsList.buttons |= 4;
        else if (buttonChanged === 2) pointsList.buttons |= 2;
        else if (buttonChanged === 3) pointsList.buttons |= 8;
        else if (buttonChanged ===
            4) pointsList.buttons |= 16;
        else if (buttonChanged === 5) pointsList.buttons |= 32;
        if (buttonChanged !== 0) {
            if (tracker.nonPrimaryPressHandler) {
                propagate = tracker.nonPrimaryPressHandler({
                    eventSource: tracker,
                    pointerType: gPoints[0].type,
                    position: getPointRelativeToAbsolute(gPoints[0].currentPos, tracker.element),
                    button: buttonChanged,
                    buttons: pointsList.buttons,
                    isTouchEvent: gPoints[0].type === "touch",
                    originalEvent: event,
                    preventDefaultAction: false,
                    userData: tracker.userData
                });
                if (propagate === false) $.cancelEvent(event)
            }
            return false
        }
        for (i =
            0; i < gPointCount; i++) {
            curGPoint = gPoints[i];
            updateGPoint = pointsList.getById(curGPoint.id);
            if (updateGPoint) {
                updateGPoint.captured = true;
                updateGPoint.insideElementPressed = true;
                updateGPoint.insideElement = true;
                updateGPoint.contactPos = curGPoint.currentPos;
                updateGPoint.contactTime = curGPoint.currentTime;
                updateGPoint.lastPos = updateGPoint.currentPos;
                updateGPoint.lastTime = updateGPoint.currentTime;
                updateGPoint.currentPos = curGPoint.currentPos;
                updateGPoint.currentTime = curGPoint.currentTime;
                curGPoint = updateGPoint
            } else {
                curGPoint.captured =
                    true;
                curGPoint.insideElementPressed = true;
                curGPoint.insideElement = true;
                startTrackingPointer(pointsList, curGPoint)
            }
            pointsList.contacts++;
            if (tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler) $.MouseTracker.gesturePointVelocityTracker.addPoint(tracker, curGPoint);
            if (pointsList.contacts === 1) {
                if (tracker.pressHandler) {
                    propagate = tracker.pressHandler({
                        eventSource: tracker,
                        pointerType: curGPoint.type,
                        position: getPointRelativeToAbsolute(curGPoint.contactPos, tracker.element),
                        buttons: pointsList.buttons,
                        isTouchEvent: curGPoint.type === "touch",
                        originalEvent: event,
                        preventDefaultAction: false,
                        userData: tracker.userData
                    });
                    if (propagate === false) $.cancelEvent(event)
                }
            } else if (pointsList.contacts === 2)
                if (tracker.pinchHandler && curGPoint.type === "touch") {
                    delegate.pinchGPoints = pointsList.asArray();
                    delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
                    delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos,
                        delegate.pinchGPoints[1].currentPos)
                }
        }
        return true
    }

    function updatePointersUp(tracker, event, gPoints, buttonChanged) {
        var delegate = THIS[tracker.hash],
            pointsList = tracker.getActivePointersListByType(gPoints[0].type),
            propagate, insideElementReleased, releasePoint, releaseTime, i, gPointCount = gPoints.length,
            curGPoint, updateGPoint, releaseCapture = false,
            wasCaptured = false,
            quick;
        if (typeof event.buttons !== "undefined") pointsList.buttons = event.buttons;
        else if ($.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9)
            if (buttonChanged ===
                0) pointsList.buttons -= 1;
            else if (buttonChanged === 1) pointsList.buttons -= 4;
        else if (buttonChanged === 2) pointsList.buttons -= 2;
        else if (buttonChanged === 3) pointsList.buttons -= 8;
        else if (buttonChanged === 4) pointsList.buttons -= 16;
        else {
            if (buttonChanged === 5) pointsList.buttons -= 32
        } else if (buttonChanged === 0) pointsList.buttons ^= ~1;
        else if (buttonChanged === 1) pointsList.buttons ^= ~4;
        else if (buttonChanged === 2) pointsList.buttons ^= ~2;
        else if (buttonChanged === 3) pointsList.buttons ^= ~8;
        else if (buttonChanged === 4) pointsList.buttons ^=
            ~16;
        else if (buttonChanged === 5) pointsList.buttons ^= ~32;
        if (buttonChanged !== 0) {
            if (tracker.nonPrimaryReleaseHandler) {
                propagate = tracker.nonPrimaryReleaseHandler({
                    eventSource: tracker,
                    pointerType: gPoints[0].type,
                    position: getPointRelativeToAbsolute(gPoints[0].currentPos, tracker.element),
                    button: buttonChanged,
                    buttons: pointsList.buttons,
                    isTouchEvent: gPoints[0].type === "touch",
                    originalEvent: event,
                    preventDefaultAction: false,
                    userData: tracker.userData
                });
                if (propagate === false) $.cancelEvent(event)
            }
            return false
        }
        for (i =
            0; i < gPointCount; i++) {
            curGPoint = gPoints[i];
            updateGPoint = pointsList.getById(curGPoint.id);
            if (updateGPoint) {
                if (updateGPoint.captured) {
                    updateGPoint.captured = false;
                    releaseCapture = true;
                    wasCaptured = true
                }
                updateGPoint.lastPos = updateGPoint.currentPos;
                updateGPoint.lastTime = updateGPoint.currentTime;
                updateGPoint.currentPos = curGPoint.currentPos;
                updateGPoint.currentTime = curGPoint.currentTime;
                if (!updateGPoint.insideElement) stopTrackingPointer(pointsList, updateGPoint);
                releasePoint = updateGPoint.currentPos;
                releaseTime =
                    updateGPoint.currentTime;
                if (wasCaptured) {
                    pointsList.contacts--;
                    if (tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler) $.MouseTracker.gesturePointVelocityTracker.removePoint(tracker, updateGPoint);
                    if (pointsList.contacts === 0) {
                        if (tracker.releaseHandler) {
                            propagate = tracker.releaseHandler({
                                eventSource: tracker,
                                pointerType: updateGPoint.type,
                                position: getPointRelativeToAbsolute(releasePoint, tracker.element),
                                buttons: pointsList.buttons,
                                insideElementPressed: updateGPoint.insideElementPressed,
                                insideElementReleased: updateGPoint.insideElement,
                                isTouchEvent: updateGPoint.type === "touch",
                                originalEvent: event,
                                preventDefaultAction: false,
                                userData: tracker.userData
                            });
                            if (propagate === false) $.cancelEvent(event)
                        }
                        if (tracker.dragEndHandler && !updateGPoint.currentPos.equals(updateGPoint.contactPos)) {
                            propagate = tracker.dragEndHandler({
                                eventSource: tracker,
                                pointerType: updateGPoint.type,
                                position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                                speed: updateGPoint.speed,
                                direction: updateGPoint.direction,
                                shift: event.shiftKey,
                                isTouchEvent: updateGPoint.type ===
                                    "touch",
                                originalEvent: event,
                                preventDefaultAction: false,
                                userData: tracker.userData
                            });
                            if (propagate === false) $.cancelEvent(event)
                        }
                        if ((tracker.clickHandler || tracker.dblClickHandler) && updateGPoint.insideElement) {
                            quick = releaseTime - updateGPoint.contactTime <= tracker.clickTimeThreshold && updateGPoint.contactPos.distanceTo(releasePoint) <= tracker.clickDistThreshold;
                            if (tracker.clickHandler) {
                                propagate = tracker.clickHandler({
                                    eventSource: tracker,
                                    pointerType: updateGPoint.type,
                                    position: getPointRelativeToAbsolute(updateGPoint.currentPos,
                                        tracker.element),
                                    quick: quick,
                                    shift: event.shiftKey,
                                    isTouchEvent: updateGPoint.type === "touch",
                                    originalEvent: event,
                                    preventDefaultAction: false,
                                    userData: tracker.userData
                                });
                                if (propagate === false) $.cancelEvent(event)
                            }
                            if (tracker.dblClickHandler && quick) {
                                pointsList.clicks++;
                                if (pointsList.clicks === 1) {
                                    delegate.lastClickPos = releasePoint;
                                    delegate.dblClickTimeOut = setTimeout(function() {
                                        pointsList.clicks = 0
                                    }, tracker.dblClickTimeThreshold)
                                } else if (pointsList.clicks === 2) {
                                    clearTimeout(delegate.dblClickTimeOut);
                                    pointsList.clicks =
                                        0;
                                    if (delegate.lastClickPos.distanceTo(releasePoint) <= tracker.dblClickDistThreshold) {
                                        propagate = tracker.dblClickHandler({
                                            eventSource: tracker,
                                            pointerType: updateGPoint.type,
                                            position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                                            shift: event.shiftKey,
                                            isTouchEvent: updateGPoint.type === "touch",
                                            originalEvent: event,
                                            preventDefaultAction: false,
                                            userData: tracker.userData
                                        });
                                        if (propagate === false) $.cancelEvent(event)
                                    }
                                    delegate.lastClickPos = null
                                }
                            }
                        }
                    } else if (pointsList.contacts === 2)
                        if (tracker.pinchHandler &&
                            updateGPoint.type === "touch") {
                            delegate.pinchGPoints = pointsList.asArray();
                            delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
                            delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos, delegate.pinchGPoints[1].currentPos)
                        }
                } else if (tracker.releaseHandler) {
                    propagate = tracker.releaseHandler({
                        eventSource: tracker,
                        pointerType: updateGPoint.type,
                        position: getPointRelativeToAbsolute(releasePoint,
                            tracker.element),
                        buttons: pointsList.buttons,
                        insideElementPressed: updateGPoint.insideElementPressed,
                        insideElementReleased: updateGPoint.insideElement,
                        isTouchEvent: updateGPoint.type === "touch",
                        originalEvent: event,
                        preventDefaultAction: false,
                        userData: tracker.userData
                    });
                    if (propagate === false) $.cancelEvent(event)
                }
            }
        }
        return releaseCapture
    }

    function updatePointersMove(tracker, event, gPoints) {
        var delegate = THIS[tracker.hash],
            pointsList = tracker.getActivePointersListByType(gPoints[0].type),
            i, gPointCount = gPoints.length,
            curGPoint, updateGPoint, gPointArray, delta, propagate;
        if (typeof event.buttons !== "undefined") pointsList.buttons = event.buttons;
        for (i = 0; i < gPointCount; i++) {
            curGPoint = gPoints[i];
            updateGPoint = pointsList.getById(curGPoint.id);
            if (updateGPoint) {
                if (curGPoint.hasOwnProperty("isPrimary")) updateGPoint.isPrimary = curGPoint.isPrimary;
                updateGPoint.lastPos = updateGPoint.currentPos;
                updateGPoint.lastTime = updateGPoint.currentTime;
                updateGPoint.currentPos = curGPoint.currentPos;
                updateGPoint.currentTime = curGPoint.currentTime
            } else {
                curGPoint.captured =
                    false;
                curGPoint.insideElementPressed = false;
                curGPoint.insideElement = true;
                startTrackingPointer(pointsList, curGPoint)
            }
        }
        if (tracker.stopHandler && gPoints[0].type === "mouse") {
            clearTimeout(tracker.stopTimeOut);
            tracker.stopTimeOut = setTimeout(function() {
                handlePointerStop(tracker, event, gPoints[0].type)
            }, tracker.stopDelay)
        }
        if (pointsList.contacts === 0) {
            if (tracker.moveHandler) {
                propagate = tracker.moveHandler({
                    eventSource: tracker,
                    pointerType: gPoints[0].type,
                    position: getPointRelativeToAbsolute(gPoints[0].currentPos,
                        tracker.element),
                    buttons: pointsList.buttons,
                    isTouchEvent: gPoints[0].type === "touch",
                    originalEvent: event,
                    preventDefaultAction: false,
                    userData: tracker.userData
                });
                if (propagate === false) $.cancelEvent(event)
            }
        } else if (pointsList.contacts === 1) {
            if (tracker.moveHandler) {
                updateGPoint = pointsList.asArray()[0];
                propagate = tracker.moveHandler({
                    eventSource: tracker,
                    pointerType: updateGPoint.type,
                    position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                    buttons: pointsList.buttons,
                    isTouchEvent: updateGPoint.type ===
                        "touch",
                    originalEvent: event,
                    preventDefaultAction: false,
                    userData: tracker.userData
                });
                if (propagate === false) $.cancelEvent(event)
            }
            if (tracker.dragHandler) {
                updateGPoint = pointsList.asArray()[0];
                delta = updateGPoint.currentPos.minus(updateGPoint.lastPos);
                propagate = tracker.dragHandler({
                    eventSource: tracker,
                    pointerType: updateGPoint.type,
                    position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                    buttons: pointsList.buttons,
                    delta: delta,
                    speed: updateGPoint.speed,
                    direction: updateGPoint.direction,
                    shift: event.shiftKey,
                    isTouchEvent: updateGPoint.type === "touch",
                    originalEvent: event,
                    preventDefaultAction: false,
                    userData: tracker.userData
                });
                if (propagate === false) $.cancelEvent(event)
            }
        } else if (pointsList.contacts === 2) {
            if (tracker.moveHandler) {
                gPointArray = pointsList.asArray();
                propagate = tracker.moveHandler({
                    eventSource: tracker,
                    pointerType: gPointArray[0].type,
                    position: getPointRelativeToAbsolute(getCenterPoint(gPointArray[0].currentPos, gPointArray[1].currentPos), tracker.element),
                    buttons: pointsList.buttons,
                    isTouchEvent: gPointArray[0].type ===
                        "touch",
                    originalEvent: event,
                    preventDefaultAction: false,
                    userData: tracker.userData
                });
                if (propagate === false) $.cancelEvent(event)
            }
            if (tracker.pinchHandler && gPoints[0].type === "touch") {
                delta = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
                if (delta != delegate.currentPinchDist) {
                    delegate.lastPinchDist = delegate.currentPinchDist;
                    delegate.currentPinchDist = delta;
                    delegate.lastPinchCenter = delegate.currentPinchCenter;
                    delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos,
                        delegate.pinchGPoints[1].currentPos);
                    propagate = tracker.pinchHandler({
                        eventSource: tracker,
                        pointerType: "touch",
                        gesturePoints: delegate.pinchGPoints,
                        lastCenter: getPointRelativeToAbsolute(delegate.lastPinchCenter, tracker.element),
                        center: getPointRelativeToAbsolute(delegate.currentPinchCenter, tracker.element),
                        lastDistance: delegate.lastPinchDist,
                        distance: delegate.currentPinchDist,
                        shift: event.shiftKey,
                        originalEvent: event,
                        preventDefaultAction: false,
                        userData: tracker.userData
                    });
                    if (propagate === false) $.cancelEvent(event)
                }
            }
        }
    }

    function updatePointersCancel(tracker, event, gPoints) {
        updatePointersUp(tracker, event, gPoints, 0);
        updatePointersExit(tracker, event, gPoints)
    }

    function handlePointerStop(tracker, originalMoveEvent, pointerType) {
        if (tracker.stopHandler) tracker.stopHandler({
            eventSource: tracker,
            pointerType: pointerType,
            position: getMouseRelative(originalMoveEvent, tracker.element),
            buttons: tracker.getActivePointersListByType(pointerType).buttons,
            isTouchEvent: pointerType === "touch",
            originalEvent: originalMoveEvent,
            preventDefaultAction: false,
            userData: tracker.userData
        })
    }
})(OpenSeadragon);
(function($) {
    $.ControlAnchor = {
        NONE: 0,
        TOP_LEFT: 1,
        TOP_RIGHT: 2,
        BOTTOM_RIGHT: 3,
        BOTTOM_LEFT: 4,
        ABSOLUTE: 5
    };
    $.Control = function(element, options, container) {
        var parent = element.parentNode;
        if (typeof options === "number") {
            $.console.error("Passing an anchor directly into the OpenSeadragon.Control constructor is deprecated; " + "please use an options object instead.  " + "Support for this deprecated variant is scheduled for removal in December 2013");
            options = {
                anchor: options
            }
        }
        options.attachToViewer = typeof options.attachToViewer ===
            "undefined" ? true : options.attachToViewer;
        this.autoFade = typeof options.autoFade === "undefined" ? true : options.autoFade;
        this.element = element;
        this.anchor = options.anchor;
        this.container = container;
        if (this.anchor == $.ControlAnchor.ABSOLUTE) {
            this.wrapper = $.makeNeutralElement("div");
            this.wrapper.style.position = "absolute";
            this.wrapper.style.top = typeof options.top == "number" ? options.top + "px" : options.top;
            this.wrapper.style.left = typeof options.left == "number" ? options.left + "px" : options.left;
            this.wrapper.style.height =
                typeof options.height == "number" ? options.height + "px" : options.height;
            this.wrapper.style.width = typeof options.width == "number" ? options.width + "px" : options.width;
            this.wrapper.style.margin = "0px";
            this.wrapper.style.padding = "0px";
            this.element.style.position = "relative";
            this.element.style.top = "0px";
            this.element.style.left = "0px";
            this.element.style.height = "100%";
            this.element.style.width = "100%"
        } else {
            this.wrapper = $.makeNeutralElement("div");
            this.wrapper.style.display = "inline-block";
            if (this.anchor == $.ControlAnchor.NONE) this.wrapper.style.width =
                this.wrapper.style.height = "100%"
        }
        this.wrapper.appendChild(this.element);
        if (options.attachToViewer)
            if (this.anchor == $.ControlAnchor.TOP_RIGHT || this.anchor == $.ControlAnchor.BOTTOM_RIGHT) this.container.insertBefore(this.wrapper, this.container.firstChild);
            else this.container.appendChild(this.wrapper);
        else parent.appendChild(this.wrapper)
    };
    $.Control.prototype = {
        destroy: function() {
            this.wrapper.removeChild(this.element);
            this.container.removeChild(this.wrapper)
        },
        isVisible: function() {
            return this.wrapper.style.display !=
                "none"
        },
        setVisible: function(visible) {
            this.wrapper.style.display = visible ? this.anchor == $.ControlAnchor.ABSOLUTE ? "block" : "inline-block" : "none"
        },
        setOpacity: function(opacity) {
            if (this.element[$.SIGNAL] && $.Browser.vendor == $.BROWSERS.IE) $.setElementOpacity(this.element, opacity, true);
            else $.setElementOpacity(this.wrapper, opacity, true)
        }
    }
})(OpenSeadragon);
(function($) {
    $.ControlDock = function(options) {
        var layouts = ["topleft", "topright", "bottomright", "bottomleft"],
            layout, i;
        $.extend(true, this, {
            id: "controldock-" + $.now() + "-" + Math.floor(Math.random() * 1E6),
            container: $.makeNeutralElement("div"),
            controls: []
        }, options);
        this.container.onsubmit = function() {
            return false
        };
        if (this.element) {
            this.element = $.getElement(this.element);
            this.element.appendChild(this.container);
            this.element.style.position = "relative";
            this.container.style.width = "100%";
            this.container.style.height =
                "100%"
        }
        for (i = 0; i < layouts.length; i++) {
            layout = layouts[i];
            this.controls[layout] = $.makeNeutralElement("div");
            this.controls[layout].style.position = "absolute";
            if (layout.match("left")) this.controls[layout].style.left = "0px";
            if (layout.match("right")) this.controls[layout].style.right = "0px";
            if (layout.match("top")) this.controls[layout].style.top = "0px";
            if (layout.match("bottom")) this.controls[layout].style.bottom = "0px"
        }
        this.container.appendChild(this.controls.topleft);
        this.container.appendChild(this.controls.topright);
        this.container.appendChild(this.controls.bottomright);
        this.container.appendChild(this.controls.bottomleft)
    };
    $.ControlDock.prototype = {
        addControl: function(element, controlOptions) {
            element = $.getElement(element);
            var div = null;
            if (getControlIndex(this, element) >= 0) return;
            switch (controlOptions.anchor) {
                case $.ControlAnchor.TOP_RIGHT:
                    div = this.controls.topright;
                    element.style.position = "relative";
                    element.style.paddingRight = "0px";
                    element.style.paddingTop = "0px";
                    break;
                case $.ControlAnchor.BOTTOM_RIGHT:
                    div = this.controls.bottomright;
                    element.style.position = "relative";
                    element.style.paddingRight = "0px";
                    element.style.paddingBottom = "0px";
                    break;
                case $.ControlAnchor.BOTTOM_LEFT:
                    div = this.controls.bottomleft;
                    element.style.position = "relative";
                    element.style.paddingLeft = "0px";
                    element.style.paddingBottom = "0px";
                    break;
                case $.ControlAnchor.TOP_LEFT:
                    div = this.controls.topleft;
                    element.style.position = "relative";
                    element.style.paddingLeft = "0px";
                    element.style.paddingTop = "0px";
                    break;
                case $.ControlAnchor.ABSOLUTE:
                    div = this.container;
                    element.style.margin =
                        "0px";
                    element.style.padding = "0px";
                    break;
                default:
                case $.ControlAnchor.NONE:
                    div = this.container;
                    element.style.margin = "0px";
                    element.style.padding = "0px";
                    break
            }
            this.controls.push(new $.Control(element, controlOptions, div));
            element.style.display = "inline-block"
        },
        removeControl: function(element) {
            element = $.getElement(element);
            var i = getControlIndex(this, element);
            if (i >= 0) {
                this.controls[i].destroy();
                this.controls.splice(i, 1)
            }
            return this
        },
        clearControls: function() {
            while (this.controls.length > 0) this.controls.pop().destroy();
            return this
        },
        areControlsEnabled: function() {
            var i;
            for (i = this.controls.length - 1; i >= 0; i--)
                if (this.controls[i].isVisible()) return true;
            return false
        },
        setControlsEnabled: function(enabled) {
            var i;
            for (i = this.controls.length - 1; i >= 0; i--) this.controls[i].setVisible(enabled);
            return this
        }
    };

    function getControlIndex(dock, element) {
        var controls = dock.controls,
            i;
        for (i = controls.length - 1; i >= 0; i--)
            if (controls[i].element == element) return i;
        return -1
    }
})(OpenSeadragon);
(function($) {
    var THIS = {};
    var nextHash = 1;
    $.Viewer = function(options) {
        var args = arguments,
            _this = this,
            i;
        if (!$.isPlainObject(options)) options = {
            id: args[0],
            xmlPath: args.length > 1 ? args[1] : undefined,
            prefixUrl: args.length > 2 ? args[2] : undefined,
            controls: args.length > 3 ? args[3] : undefined,
            overlays: args.length > 4 ? args[4] : undefined
        };
        if (options.config) {
            $.extend(true, options, options.config);
            delete options.config
        }
        $.extend(true, this, {
            id: options.id,
            hash: options.hash || nextHash++,
            element: null,
            container: null,
            canvas: null,
            overlays: [],
            overlaysContainer: null,
            previousBody: [],
            customControls: [],
            source: null,
            drawer: null,
            world: null,
            viewport: null,
            navigator: null,
            collectionViewport: null,
            collectionDrawer: null,
            navImages: null,
            buttons: null,
            profiler: null
        }, $.DEFAULT_SETTINGS, options);
        if (typeof this.hash === "undefined") throw new Error("A hash must be defined, either by specifying options.id or options.hash.");
        if (typeof THIS[this.hash] !== "undefined") $.console.warn("Hash " + this.hash + " has already been used.");
        THIS[this.hash] = {
            "fsBoundsDelta": new $.Point(1,
                1),
            "prevContainerSize": null,
            "animating": false,
            "forceRedraw": false,
            "mouseInside": false,
            "group": null,
            "zooming": false,
            "zoomFactor": null,
            "lastZoomTime": null,
            "fullPage": false,
            "onfullscreenchange": null
        };
        this._sequenceIndex = 0;
        this._firstOpen = true;
        this._updateRequestId = null;
        this._loadQueue = [];
        this.currentOverlays = [];
        $.EventSource.call(this);
        this.addHandler("open-failed", function(event) {
            var msg = $.getString("Errors.OpenFailed", event.eventSource, event.message);
            _this._showMessage(msg)
        });
        $.ControlDock.call(this,
            options);
        if (this.xmlPath) this.tileSources = [this.xmlPath];
        this.element = this.element || document.getElementById(this.id);
        this.canvas = $.makeNeutralElement("div");
        this.canvas.className = "openseadragon-canvas";
        (function(style) {
            style.width = "100%";
            style.height = "100%";
            style.overflow = "hidden";
            style.position = "absolute";
            style.top = "0px";
            style.left = "0px"
        })(this.canvas.style);
        $.setElementTouchActionNone(this.canvas);
        this.canvas.tabIndex = options.tabIndex || 0;
        this.container.className = "openseadragon-container";
        (function(style) {
            style.width =
                "100%";
            style.height = "100%";
            style.position = "relative";
            style.overflow = "hidden";
            style.left = "0px";
            style.top = "0px";
            style.textAlign = "left"
        })(this.container.style);
        this.container.insertBefore(this.canvas, this.container.firstChild);
        this.element.appendChild(this.container);
        this.bodyWidth = document.body.style.width;
        this.bodyHeight = document.body.style.height;
        this.bodyOverflow = document.body.style.overflow;
        this.docOverflow = document.documentElement.style.overflow;
        this.innerTracker = new $.MouseTracker({
            element: this.canvas,
            startDisabled: this.mouseNavEnabled ? false : true,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            dblClickTimeThreshold: this.dblClickTimeThreshold,
            dblClickDistThreshold: this.dblClickDistThreshold,
            keyDownHandler: $.delegate(this, onCanvasKeyDown),
            keyHandler: $.delegate(this, onCanvasKeyPress),
            clickHandler: $.delegate(this, onCanvasClick),
            dblClickHandler: $.delegate(this, onCanvasDblClick),
            dragHandler: $.delegate(this, onCanvasDrag),
            dragEndHandler: $.delegate(this, onCanvasDragEnd),
            enterHandler: $.delegate(this, onCanvasEnter),
            exitHandler: $.delegate(this, onCanvasExit),
            pressHandler: $.delegate(this, onCanvasPress),
            releaseHandler: $.delegate(this, onCanvasRelease),
            nonPrimaryPressHandler: $.delegate(this, onCanvasNonPrimaryPress),
            nonPrimaryReleaseHandler: $.delegate(this, onCanvasNonPrimaryRelease),
            scrollHandler: $.delegate(this, onCanvasScroll),
            pinchHandler: $.delegate(this, onCanvasPinch)
        });
        this.outerTracker = new $.MouseTracker({
            element: this.container,
            startDisabled: this.mouseNavEnabled ? false : true,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            dblClickTimeThreshold: this.dblClickTimeThreshold,
            dblClickDistThreshold: this.dblClickDistThreshold,
            enterHandler: $.delegate(this, onContainerEnter),
            exitHandler: $.delegate(this, onContainerExit)
        });
        if (this.toolbar) this.toolbar = new $.ControlDock({
            element: this.toolbar
        });
        this.bindStandardControls();
        THIS[this.hash].prevContainerSize = _getSafeElemSize(this.container);
        this.world = new $.World({
            viewer: this
        });
        this.world.addHandler("add-item",
            function(event) {
                _this.source = _this.world.getItemAt(0).source;
                THIS[_this.hash].forceRedraw = true;
                if (!_this._updateRequestId) _this._updateRequestId = scheduleUpdate(_this, updateMulti)
            });
        this.world.addHandler("remove-item", function(event) {
            if (_this.world.getItemCount()) _this.source = _this.world.getItemAt(0).source;
            else _this.source = null;
            THIS[_this.hash].forceRedraw = true
        });
        this.world.addHandler("metrics-change", function(event) {
            if (_this.viewport) _this.viewport.setHomeBounds(_this.world.getHomeBounds(), _this.world.getContentFactor())
        });
        this.world.addHandler("item-index-change", function(event) {
            _this.source = _this.world.getItemAt(0).source
        });
        this.viewport = new $.Viewport({
            containerSize: THIS[this.hash].prevContainerSize,
            springStiffness: this.springStiffness,
            animationTime: this.animationTime,
            minZoomImageRatio: this.minZoomImageRatio,
            maxZoomPixelRatio: this.maxZoomPixelRatio,
            visibilityRatio: this.visibilityRatio,
            wrapHorizontal: this.wrapHorizontal,
            wrapVertical: this.wrapVertical,
            defaultZoomLevel: this.defaultZoomLevel,
            minZoomLevel: this.minZoomLevel,
            maxZoomLevel: this.maxZoomLevel,
            viewer: this,
            degrees: this.degrees,
            navigatorRotate: this.navigatorRotate,
            homeFillsViewer: this.homeFillsViewer,
            margins: this.viewportMargins
        });
        this.viewport.setHomeBounds(this.world.getHomeBounds(), this.world.getContentFactor());
        this.imageLoader = new $.ImageLoader({
            jobLimit: this.imageLoaderLimit
        });
        this.tileCache = new $.TileCache({
            maxImageCacheCount: this.maxImageCacheCount
        });
        this.drawer = new $.Drawer({
            viewer: this,
            viewport: this.viewport,
            element: this.canvas,
            debugGridColor: this.debugGridColor
        });
        this.overlaysContainer = $.makeNeutralElement("div");
        this.canvas.appendChild(this.overlaysContainer);
        if (!this.drawer.canRotate()) {
            if (this.rotateLeft) {
                i = this.buttons.buttons.indexOf(this.rotateLeft);
                this.buttons.buttons.splice(i, 1);
                this.buttons.element.removeChild(this.rotateLeft.element)
            }
            if (this.rotateRight) {
                i = this.buttons.buttons.indexOf(this.rotateRight);
                this.buttons.buttons.splice(i, 1);
                this.buttons.element.removeChild(this.rotateRight.element)
            }
        }
        if (this.showNavigator) this.navigator = new $.Navigator({
            id: this.navigatorId,
            position: this.navigatorPosition,
            sizeRatio: this.navigatorSizeRatio,
            maintainSizeRatio: this.navigatorMaintainSizeRatio,
            top: this.navigatorTop,
            left: this.navigatorLeft,
            width: this.navigatorWidth,
            height: this.navigatorHeight,
            autoResize: this.navigatorAutoResize,
            prefixUrl: this.prefixUrl,
            viewer: this,
            navigatorRotate: this.navigatorRotate,
            crossOriginPolicy: this.crossOriginPolicy
        });
        if (this.sequenceMode) this.bindSequenceControls();
        if (this.tileSources) this.open(this.tileSources);
        for (i = 0; i < this.customControls.length; i++) this.addControl(this.customControls[i].id, {
            anchor: this.customControls[i].anchor
        });
        $.requestAnimationFrame(function() {
            beginControlsAutoHide(_this)
        })
    };
    $.extend($.Viewer.prototype, $.EventSource.prototype, $.ControlDock.prototype, {
        isOpen: function() {
            return !!this.world.getItemCount()
        },
        openDzi: function(dzi) {
            $.console.error("[Viewer.openDzi] this function is deprecated; use Viewer.open() instead.");
            return this.open(dzi)
        },
        openTileSource: function(tileSource) {
            $.console.error("[Viewer.openTileSource] this function is deprecated; use Viewer.open() instead.");
            return this.open(tileSource)
        },
        open: function(tileSources) {
            var _this = this;
            this.close();
            if (!tileSources) return;
            if (this.sequenceMode && $.isArray(tileSources)) {
                if (this.referenceStrip) {
                    this.referenceStrip.destroy();
                    this.referenceStrip = null
                }
                this.tileSources = tileSources;
                this._sequenceIndex = Math.max(0, Math.min(this.tileSources.length - 1, this.initialPage));
                if (this.tileSources.length) {
                    this.open(this.tileSources[this._sequenceIndex]);
                    if (this.showReferenceStrip) this.referenceStrip = new $.ReferenceStrip({
                        id: this.referenceStripElement,
                        position: this.referenceStripPosition,
                        sizeRatio: this.referenceStripSizeRatio,
                        scroll: this.referenceStripScroll,
                        height: this.referenceStripHeight,
                        width: this.referenceStripWidth,
                        tileSources: this.tileSources,
                        prefixUrl: this.prefixUrl,
                        viewer: this
                    })
                }
                this._updateSequenceButtons(this._sequenceIndex);
                return
            }
            if (!$.isArray(tileSources)) tileSources = [tileSources];
            if (!tileSources.length) return;
            this._opening = true;
            var expected = tileSources.length;
            var successes = 0;
            var failures = 0;
            var failEvent;
            var checkCompletion = function() {
                if (successes +
                    failures === expected)
                    if (successes) {
                        if (_this._firstOpen || !_this.preserveViewport) {
                            _this.viewport.goHome(true);
                            _this.viewport.update()
                        }
                        _this._firstOpen = false;
                        var source = tileSources[0];
                        if (source.tileSource) source = source.tileSource;
                        if (_this.overlays && !_this.preserveOverlays)
                            for (var i = 0; i < _this.overlays.length; i++) _this.currentOverlays[i] = getOverlayObject(_this, _this.overlays[i]);
                        _this._drawOverlays();
                        _this._opening = false;
                        _this.raiseEvent("open", {
                            source: source
                        })
                    } else {
                        _this._opening = false;
                        _this.raiseEvent("open-failed",
                            failEvent)
                    }
            };
            var doOne = function(options) {
                if (!$.isPlainObject(options) || !options.tileSource) options = {
                    tileSource: options
                };
                if (options.index !== undefined) {
                    $.console.error("[Viewer.open] setting indexes here is not supported; use addTiledImage instead");
                    delete options.index
                }
                if (options.collectionImmediately === undefined) options.collectionImmediately = true;
                var originalSuccess = options.success;
                options.success = function(event) {
                    successes++;
                    if (originalSuccess) originalSuccess(event);
                    checkCompletion()
                };
                var originalError =
                    options.error;
                options.error = function(event) {
                    failures++;
                    if (!failEvent) failEvent = event;
                    if (originalError) originalError(event);
                    checkCompletion()
                };
                _this.addTiledImage(options);
                if (options.tileSource.overlays)
                    for (var i = 0; i < options.tileSource.overlays.length; i++) _this.addOverlay(options.tileSource.overlays[i])
            };
            for (var i = 0; i < tileSources.length; i++) doOne(tileSources[i]);
            return this
        },
        close: function() {
            if (!THIS[this.hash]) return this;
            this._opening = false;
            if (this.navigator) this.navigator.close();
            if (!this.preserveOverlays) {
                this.clearOverlays();
                this.overlaysContainer.innerHTML = ""
            }
            THIS[this.hash].animating = false;
            this.world.removeAll();
            this.imageLoader.clear();
            this.raiseEvent("close");
            return this
        },
        destroy: function() {
            if (!THIS[this.hash]) return;
            this.close();
            this.clearOverlays();
            this.overlaysContainer.innerHTML = "";
            if (this.referenceStrip) {
                this.referenceStrip.destroy();
                this.referenceStrip = null
            }
            if (this._updateRequestId !== null) {
                $.cancelAnimationFrame(this._updateRequestId);
                this._updateRequestId = null
            }
            if (this.drawer) this.drawer.destroy();
            this.removeAllHandlers();
            if (this.element)
                while (this.element.firstChild) this.element.removeChild(this.element.firstChild);
            if (this.innerTracker) this.innerTracker.destroy();
            if (this.outerTracker) this.outerTracker.destroy();
            THIS[this.hash] = null;
            delete THIS[this.hash];
            this.canvas = null;
            this.container = null;
            this.element = null
        },
        isMouseNavEnabled: function() {
            return this.innerTracker.isTracking()
        },
        setMouseNavEnabled: function(enabled) {
            this.innerTracker.setTracking(enabled);
            this.raiseEvent("mouse-enabled", {
                enabled: enabled
            });
            return this
        },
        areControlsEnabled: function() {
            var enabled = this.controls.length,
                i;
            for (i = 0; i < this.controls.length; i++) enabled = enabled && this.controls[i].isVisibile();
            return enabled
        },
        setControlsEnabled: function(enabled) {
            if (enabled) abortControlsAutoHide(this);
            else beginControlsAutoHide(this);
            this.raiseEvent("controls-enabled", {
                enabled: enabled
            });
            return this
        },
        isFullPage: function() {
            return THIS[this.hash].fullPage
        },
        setFullPage: function(fullPage) {
            var body = document.body,
                bodyStyle = body.style,
                docStyle = document.documentElement.style,
                _this = this,
                hash, nodes, i;
            if (fullPage == this.isFullPage()) return this;
            var fullPageEventArgs = {
                fullPage: fullPage,
                preventDefaultAction: false
            };
            this.raiseEvent("pre-full-page", fullPageEventArgs);
            if (fullPageEventArgs.preventDefaultAction) return this;
            if (fullPage) {
                this.elementSize = $.getElementSize(this.element);
                this.pageScroll = $.getPageScroll();
                this.elementMargin = this.element.style.margin;
                this.element.style.margin = "0";
                this.elementPadding = this.element.style.padding;
                this.element.style.padding = "0";
                this.bodyMargin =
                    bodyStyle.margin;
                this.docMargin = docStyle.margin;
                bodyStyle.margin = "0";
                docStyle.margin = "0";
                this.bodyPadding = bodyStyle.padding;
                this.docPadding = docStyle.padding;
                bodyStyle.padding = "0";
                docStyle.padding = "0";
                this.bodyWidth = bodyStyle.width;
                this.bodyHeight = bodyStyle.height;
                bodyStyle.width = "100%";
                bodyStyle.height = "100%";
                this.previousBody = [];
                THIS[this.hash].prevElementParent = this.element.parentNode;
                THIS[this.hash].prevNextSibling = this.element.nextSibling;
                THIS[this.hash].prevElementWidth = this.element.style.width;
                THIS[this.hash].prevElementHeight = this.element.style.height;
                nodes = body.childNodes.length;
                for (i = 0; i < nodes; i++) {
                    this.previousBody.push(body.childNodes[0]);
                    body.removeChild(body.childNodes[0])
                }
                if (this.toolbar && this.toolbar.element) {
                    this.toolbar.parentNode = this.toolbar.element.parentNode;
                    this.toolbar.nextSibling = this.toolbar.element.nextSibling;
                    body.appendChild(this.toolbar.element);
                    $.addClass(this.toolbar.element, "fullpage")
                }
                $.addClass(this.element, "fullpage");
                body.appendChild(this.element);
                this.element.style.height =
                    $.getWindowSize().y + "px";
                this.element.style.width = $.getWindowSize().x + "px";
                if (this.toolbar && this.toolbar.element) this.element.style.height = $.getElementSize(this.element).y - $.getElementSize(this.toolbar.element).y + "px";
                THIS[this.hash].fullPage = true;
                $.delegate(this, onContainerEnter)({})
            } else {
                this.element.style.margin = this.elementMargin;
                this.element.style.padding = this.elementPadding;
                bodyStyle.margin = this.bodyMargin;
                docStyle.margin = this.docMargin;
                bodyStyle.padding = this.bodyPadding;
                docStyle.padding = this.docPadding;
                bodyStyle.width = this.bodyWidth;
                bodyStyle.height = this.bodyHeight;
                body.removeChild(this.element);
                nodes = this.previousBody.length;
                for (i = 0; i < nodes; i++) body.appendChild(this.previousBody.shift());
                $.removeClass(this.element, "fullpage");
                THIS[this.hash].prevElementParent.insertBefore(this.element, THIS[this.hash].prevNextSibling);
                if (this.toolbar && this.toolbar.element) {
                    body.removeChild(this.toolbar.element);
                    $.removeClass(this.toolbar.element, "fullpage");
                    this.toolbar.parentNode.insertBefore(this.toolbar.element,
                        this.toolbar.nextSibling);
                    delete this.toolbar.parentNode;
                    delete this.toolbar.nextSibling
                }
                this.element.style.width = THIS[this.hash].prevElementWidth;
                this.element.style.height = THIS[this.hash].prevElementHeight;
                var restoreScrollCounter = 0;
                var restoreScroll = function() {
                    $.setPageScroll(_this.pageScroll);
                    var pageScroll = $.getPageScroll();
                    restoreScrollCounter++;
                    if (restoreScrollCounter < 10 && pageScroll.x !== _this.pageScroll.x || pageScroll.y !== _this.pageScroll.y) $.requestAnimationFrame(restoreScroll)
                };
                $.requestAnimationFrame(restoreScroll);
                THIS[this.hash].fullPage = false;
                $.delegate(this, onContainerExit)({})
            }
            if (this.navigator && this.viewport) this.navigator.update(this.viewport);
            this.raiseEvent("full-page", {
                fullPage: fullPage
            });
            return this
        },
        setFullScreen: function(fullScreen) {
            var _this = this;
            if (!$.supportsFullScreen) return this.setFullPage(fullScreen);
            if ($.isFullScreen() === fullScreen) return this;
            var fullScreeEventArgs = {
                fullScreen: fullScreen,
                preventDefaultAction: false
            };
            this.raiseEvent("pre-full-screen", fullScreeEventArgs);
            if (fullScreeEventArgs.preventDefaultAction) return this;
            if (fullScreen) {
                this.setFullPage(true);
                if (!this.isFullPage()) return this;
                this.fullPageStyleWidth = this.element.style.width;
                this.fullPageStyleHeight = this.element.style.height;
                this.element.style.width = "100%";
                this.element.style.height = "100%";
                var onFullScreenChange = function() {
                    var isFullScreen = $.isFullScreen();
                    if (!isFullScreen) {
                        $.removeEvent(document, $.fullScreenEventName, onFullScreenChange);
                        $.removeEvent(document, $.fullScreenErrorEventName, onFullScreenChange);
                        _this.setFullPage(false);
                        if (_this.isFullPage()) {
                            _this.element.style.width =
                                _this.fullPageStyleWidth;
                            _this.element.style.height = _this.fullPageStyleHeight
                        }
                    }
                    if (_this.navigator && _this.viewport) _this.navigator.update(_this.viewport);
                    _this.raiseEvent("full-screen", {
                        fullScreen: isFullScreen
                    })
                };
                $.addEvent(document, $.fullScreenEventName, onFullScreenChange);
                $.addEvent(document, $.fullScreenErrorEventName, onFullScreenChange);
                $.requestFullScreen(document.body)
            } else $.exitFullScreen();
            return this
        },
        isVisible: function() {
            return this.container.style.visibility != "hidden"
        },
        setVisible: function(visible) {
            this.container.style.visibility =
                visible ? "" : "hidden";
            this.raiseEvent("visible", {
                visible: visible
            });
            return this
        },
        addTiledImage: function(options) {
            $.console.assert(options, "[Viewer.addTiledImage] options is required");
            $.console.assert(options.tileSource, "[Viewer.addTiledImage] options.tileSource is required");
            var _this = this;
            this._hideMessage();
            if (options.placeholderFillStyle === undefined) options.placeholderFillStyle = this.placeholderFillStyle;
            if (options.opacity === undefined) options.opacity = this.opacity;
            var myQueueItem = {
                options: options
            };

            function raiseAddItemFailed(event) {
                for (var i = 0; i < _this._loadQueue; i++)
                    if (_this._loadQueue[i] === myQueueItem) {
                        _this._loadQueue.splice(i, 1);
                        break
                    }
                _this.raiseEvent("add-item-failed", event);
                if (options.error) options.error(event)
            }
            this._loadQueue.push(myQueueItem);
            getTileSourceImplementation(this, options.tileSource, function(tileSource) {
                if (tileSource instanceof Array) {
                    raiseAddItemFailed({
                        message: "[Viewer.addTiledImage] Sequences can not be added; add them one at a time instead.",
                        source: tileSource,
                        options: options
                    });
                    return
                }
                myQueueItem.tileSource = tileSource;
                var queueItem, tiledImage, optionsClone;
                while (_this._loadQueue.length) {
                    queueItem = _this._loadQueue[0];
                    if (!queueItem.tileSource) break;
                    _this._loadQueue.splice(0, 1);
                    tiledImage = new $.TiledImage({
                        viewer: _this,
                        source: queueItem.tileSource,
                        viewport: _this.viewport,
                        drawer: _this.drawer,
                        tileCache: _this.tileCache,
                        imageLoader: _this.imageLoader,
                        x: queueItem.options.x,
                        y: queueItem.options.y,
                        width: queueItem.options.width,
                        height: queueItem.options.height,
                        clip: queueItem.options.clip,
                        placeholderFillStyle: queueItem.options.placeholderFillStyle,
                        opacity: queueItem.options.opacity,
                        springStiffness: _this.springStiffness,
                        animationTime: _this.animationTime,
                        minZoomImageRatio: _this.minZoomImageRatio,
                        wrapHorizontal: _this.wrapHorizontal,
                        wrapVertical: _this.wrapVertical,
                        immediateRender: _this.immediateRender,
                        blendTime: _this.blendTime,
                        alwaysBlend: _this.alwaysBlend,
                        minPixelRatio: _this.minPixelRatio,
                        crossOriginPolicy: _this.crossOriginPolicy,
                        debugMode: _this.debugMode
                    });
                    _this.world.addItem(tiledImage, {
                        index: queueItem.options.index
                    });
                    if (_this.collectionMode) _this.world.arrange({
                        immediately: queueItem.options.collectionImmediately,
                        rows: _this.collectionRows,
                        columns: _this.collectionColumns,
                        layout: _this.collectionLayout,
                        tileSize: _this.collectionTileSize,
                        tileMargin: _this.collectionTileMargin
                    });
                    if (_this.world.getItemCount() === 1 && !_this.preserveViewport) _this.viewport.goHome(true);
                    if (_this.navigator) {
                        optionsClone = $.extend({}, queueItem.options, {
                            originalTiledImage: tiledImage,
                            tileSource: queueItem.tileSource
                        });
                        _this.navigator.addTiledImage(optionsClone)
                    }
                    if (queueItem.options.success) queueItem.options.success({
                        item: tiledImage
                    })
                }
            }, function(event) {
                event.options = options;
                raiseAddItemFailed(event)
            })
        },
        addLayer: function(options) {
            var _this = this;
            $.console.error("[Viewer.addLayer] this function is deprecated; use Viewer.addTiledImage() instead.");
            var optionsClone = $.extend({}, options, {
                success: function(event) {
                    _this.raiseEvent("add-layer", {
                        options: options,
                        drawer: event.item
                    })
                },
                error: function(event) {
                    _this.raiseEvent("add-layer-failed",
                        event)
                }
            });
            this.addTiledImage(optionsClone);
            return this
        },
        getLayerAtLevel: function(level) {
            $.console.error("[Viewer.getLayerAtLevel] this function is deprecated; use World.getItemAt() instead.");
            return this.world.getItemAt(level)
        },
        getLevelOfLayer: function(drawer) {
            $.console.error("[Viewer.getLevelOfLayer] this function is deprecated; use World.getIndexOfItem() instead.");
            return this.world.getIndexOfItem(drawer)
        },
        getLayersCount: function() {
            $.console.error("[Viewer.getLayersCount] this function is deprecated; use World.getItemCount() instead.");
            return this.world.getItemCount()
        },
        setLayerLevel: function(drawer, level) {
            $.console.error("[Viewer.setLayerLevel] this function is deprecated; use World.setItemIndex() instead.");
            return this.world.setItemIndex(drawer, level)
        },
        removeLayer: function(drawer) {
            $.console.error("[Viewer.removeLayer] this function is deprecated; use World.removeItem() instead.");
            return this.world.removeItem(drawer)
        },
        forceRedraw: function() {
            THIS[this.hash].forceRedraw = true;
            return this
        },
        bindSequenceControls: function() {
            var onFocusHandler =
                $.delegate(this, onFocus),
                onBlurHandler = $.delegate(this, onBlur),
                onNextHandler = $.delegate(this, onNext),
                onPreviousHandler = $.delegate(this, onPrevious),
                navImages = this.navImages,
                useGroup = true;
            if (this.showSequenceControl) {
                if (this.previousButton || this.nextButton) useGroup = false;
                this.previousButton = new $.Button({
                    element: this.previousButton ? $.getElement(this.previousButton) : null,
                    clickTimeThreshold: this.clickTimeThreshold,
                    clickDistThreshold: this.clickDistThreshold,
                    tooltip: $.getString("Tooltips.PreviousPage"),
                    srcRest: resolveUrl(this.prefixUrl, navImages.previous.REST),
                    srcGroup: resolveUrl(this.prefixUrl, navImages.previous.GROUP),
                    srcHover: resolveUrl(this.prefixUrl, navImages.previous.HOVER),
                    srcDown: resolveUrl(this.prefixUrl, navImages.previous.DOWN),
                    onRelease: onPreviousHandler,
                    onFocus: onFocusHandler,
                    onBlur: onBlurHandler
                });
                this.nextButton = new $.Button({
                    element: this.nextButton ? $.getElement(this.nextButton) : null,
                    clickTimeThreshold: this.clickTimeThreshold,
                    clickDistThreshold: this.clickDistThreshold,
                    tooltip: $.getString("Tooltips.NextPage"),
                    srcRest: resolveUrl(this.prefixUrl, navImages.next.REST),
                    srcGroup: resolveUrl(this.prefixUrl, navImages.next.GROUP),
                    srcHover: resolveUrl(this.prefixUrl, navImages.next.HOVER),
                    srcDown: resolveUrl(this.prefixUrl, navImages.next.DOWN),
                    onRelease: onNextHandler,
                    onFocus: onFocusHandler,
                    onBlur: onBlurHandler
                });
                if (!this.navPrevNextWrap) this.previousButton.disable();
                if (!this.tileSources || !this.tileSources.length) this.nextButton.disable();
                if (useGroup) {
                    this.paging = new $.ButtonGroup({
                        buttons: [this.previousButton, this.nextButton],
                        clickTimeThreshold: this.clickTimeThreshold,
                        clickDistThreshold: this.clickDistThreshold
                    });
                    this.pagingControl = this.paging.element;
                    if (this.toolbar) this.toolbar.addControl(this.pagingControl, {
                        anchor: $.ControlAnchor.BOTTOM_RIGHT
                    });
                    else this.addControl(this.pagingControl, {
                        anchor: this.sequenceControlAnchor || $.ControlAnchor.TOP_LEFT
                    })
                }
            }
            return this
        },
        bindStandardControls: function() {
            var beginZoomingInHandler = $.delegate(this, beginZoomingIn),
                endZoomingHandler = $.delegate(this, endZooming),
                doSingleZoomInHandler = $.delegate(this,
                    doSingleZoomIn),
                beginZoomingOutHandler = $.delegate(this, beginZoomingOut),
                doSingleZoomOutHandler = $.delegate(this, doSingleZoomOut),
                onHomeHandler = $.delegate(this, onHome),
                onFullScreenHandler = $.delegate(this, onFullScreen),
                onRotateLeftHandler = $.delegate(this, onRotateLeft),
                onRotateRightHandler = $.delegate(this, onRotateRight),
                onFocusHandler = $.delegate(this, onFocus),
                onBlurHandler = $.delegate(this, onBlur),
                navImages = this.navImages,
                buttons = [],
                useGroup = true;
            if (this.showNavigationControl) {
                if (this.zoomInButton || this.zoomOutButton ||
                    this.homeButton || this.fullPageButton || this.rotateLeftButton || this.rotateRightButton) useGroup = false;
                if (this.showZoomControl) {
                    buttons.push(this.zoomInButton = new $.Button({
                        element: this.zoomInButton ? $.getElement(this.zoomInButton) : null,
                        clickTimeThreshold: this.clickTimeThreshold,
                        clickDistThreshold: this.clickDistThreshold,
                        tooltip: $.getString("Tooltips.ZoomIn"),
                        srcRest: resolveUrl(this.prefixUrl, navImages.zoomIn.REST),
                        srcGroup: resolveUrl(this.prefixUrl, navImages.zoomIn.GROUP),
                        srcHover: resolveUrl(this.prefixUrl,
                            navImages.zoomIn.HOVER),
                        srcDown: resolveUrl(this.prefixUrl, navImages.zoomIn.DOWN),
                        onPress: beginZoomingInHandler,
                        onRelease: endZoomingHandler,
                        onClick: doSingleZoomInHandler,
                        onEnter: beginZoomingInHandler,
                        onExit: endZoomingHandler,
                        onFocus: onFocusHandler,
                        onBlur: onBlurHandler
                    }));
                    buttons.push(this.zoomOutButton = new $.Button({
                        element: this.zoomOutButton ? $.getElement(this.zoomOutButton) : null,
                        clickTimeThreshold: this.clickTimeThreshold,
                        clickDistThreshold: this.clickDistThreshold,
                        tooltip: $.getString("Tooltips.ZoomOut"),
                        srcRest: resolveUrl(this.prefixUrl, navImages.zoomOut.REST),
                        srcGroup: resolveUrl(this.prefixUrl, navImages.zoomOut.GROUP),
                        srcHover: resolveUrl(this.prefixUrl, navImages.zoomOut.HOVER),
                        srcDown: resolveUrl(this.prefixUrl, navImages.zoomOut.DOWN),
                        onPress: beginZoomingOutHandler,
                        onRelease: endZoomingHandler,
                        onClick: doSingleZoomOutHandler,
                        onEnter: beginZoomingOutHandler,
                        onExit: endZoomingHandler,
                        onFocus: onFocusHandler,
                        onBlur: onBlurHandler
                    }))
                }
                if (this.showHomeControl) buttons.push(this.homeButton = new $.Button({
                    element: this.homeButton ?
                        $.getElement(this.homeButton) : null,
                    clickTimeThreshold: this.clickTimeThreshold,
                    clickDistThreshold: this.clickDistThreshold,
                    tooltip: $.getString("Tooltips.Home"),
                    srcRest: resolveUrl(this.prefixUrl, navImages.home.REST),
                    srcGroup: resolveUrl(this.prefixUrl, navImages.home.GROUP),
                    srcHover: resolveUrl(this.prefixUrl, navImages.home.HOVER),
                    srcDown: resolveUrl(this.prefixUrl, navImages.home.DOWN),
                    onRelease: onHomeHandler,
                    onFocus: onFocusHandler,
                    onBlur: onBlurHandler
                }));
                if (this.showFullPageControl) buttons.push(this.fullPageButton =
                    new $.Button({
                        element: this.fullPageButton ? $.getElement(this.fullPageButton) : null,
                        clickTimeThreshold: this.clickTimeThreshold,
                        clickDistThreshold: this.clickDistThreshold,
                        tooltip: $.getString("Tooltips.FullPage"),
                        srcRest: resolveUrl(this.prefixUrl, navImages.fullpage.REST),
                        srcGroup: resolveUrl(this.prefixUrl, navImages.fullpage.GROUP),
                        srcHover: resolveUrl(this.prefixUrl, navImages.fullpage.HOVER),
                        srcDown: resolveUrl(this.prefixUrl, navImages.fullpage.DOWN),
                        onRelease: onFullScreenHandler,
                        onFocus: onFocusHandler,
                        onBlur: onBlurHandler
                    }));
                if (this.showRotationControl) {
                    buttons.push(this.rotateLeftButton = new $.Button({
                        element: this.rotateLeftButton ? $.getElement(this.rotateLeftButton) : null,
                        clickTimeThreshold: this.clickTimeThreshold,
                        clickDistThreshold: this.clickDistThreshold,
                        tooltip: $.getString("Tooltips.RotateLeft"),
                        srcRest: resolveUrl(this.prefixUrl, navImages.rotateleft.REST),
                        srcGroup: resolveUrl(this.prefixUrl, navImages.rotateleft.GROUP),
                        srcHover: resolveUrl(this.prefixUrl, navImages.rotateleft.HOVER),
                        srcDown: resolveUrl(this.prefixUrl,
                            navImages.rotateleft.DOWN),
                        onRelease: onRotateLeftHandler,
                        onFocus: onFocusHandler,
                        onBlur: onBlurHandler
                    }));
                    buttons.push(this.rotateRightButton = new $.Button({
                        element: this.rotateRightButton ? $.getElement(this.rotateRightButton) : null,
                        clickTimeThreshold: this.clickTimeThreshold,
                        clickDistThreshold: this.clickDistThreshold,
                        tooltip: $.getString("Tooltips.RotateRight"),
                        srcRest: resolveUrl(this.prefixUrl, navImages.rotateright.REST),
                        srcGroup: resolveUrl(this.prefixUrl, navImages.rotateright.GROUP),
                        srcHover: resolveUrl(this.prefixUrl,
                            navImages.rotateright.HOVER),
                        srcDown: resolveUrl(this.prefixUrl, navImages.rotateright.DOWN),
                        onRelease: onRotateRightHandler,
                        onFocus: onFocusHandler,
                        onBlur: onBlurHandler
                    }))
                }
                if (useGroup) {
                    this.buttons = new $.ButtonGroup({
                        buttons: buttons,
                        clickTimeThreshold: this.clickTimeThreshold,
                        clickDistThreshold: this.clickDistThreshold
                    });
                    this.navControl = this.buttons.element;
                    this.addHandler("open", $.delegate(this, lightUp));
                    if (this.toolbar) this.toolbar.addControl(this.navControl, {
                        anchor: $.ControlAnchor.TOP_LEFT
                    });
                    else this.addControl(this.navControl, {
                        anchor: this.navigationControlAnchor || $.ControlAnchor.TOP_LEFT
                    })
                }
            }
            return this
        },
        currentPage: function() {
            return this._sequenceIndex
        },
        goToPage: function(page) {
            if (this.tileSources && page >= 0 && page < this.tileSources.length) {
                this.raiseEvent("page", {
                    page: page
                });
                this._sequenceIndex = page;
                this._updateSequenceButtons(page);
                this.open(this.tileSources[page]);
                if (this.referenceStrip) this.referenceStrip.setFocus(page)
            }
            return this
        },
        addOverlay: function(element, location, placement, onDraw) {
            var options;
            if ($.isPlainObject(element)) options =
                element;
            else options = {
                element: element,
                location: location,
                placement: placement,
                onDraw: onDraw
            };
            element = $.getElement(options.element);
            if (getOverlayIndex(this.currentOverlays, element) >= 0) return this;
            var overlay = getOverlayObject(this, options);
            this.currentOverlays.push(overlay);
            overlay.drawHTML(this.overlaysContainer, this.viewport);
            this.raiseEvent("add-overlay", {
                element: element,
                location: options.location,
                placement: options.placement
            });
            return this
        },
        updateOverlay: function(element, location, placement) {
            var i;
            element =
                $.getElement(element);
            i = getOverlayIndex(this.currentOverlays, element);
            if (i >= 0) {
                this.currentOverlays[i].update(location, placement);
                THIS[this.hash].forceRedraw = true;
                this.raiseEvent("update-overlay", {
                    element: element,
                    location: location,
                    placement: placement
                })
            }
            return this
        },
        removeOverlay: function(element) {
            var i;
            element = $.getElement(element);
            i = getOverlayIndex(this.currentOverlays, element);
            if (i >= 0) {
                this.currentOverlays[i].destroy();
                this.currentOverlays.splice(i, 1);
                THIS[this.hash].forceRedraw = true;
                this.raiseEvent("remove-overlay", {
                    element: element
                })
            }
            return this
        },
        clearOverlays: function() {
            while (this.currentOverlays.length > 0) this.currentOverlays.pop().destroy();
            THIS[this.hash].forceRedraw = true;
            this.raiseEvent("clear-overlay", {});
            return this
        },
        _updateSequenceButtons: function(page) {
            if (this.nextButton)
                if (!this.tileSources || this.tileSources.length - 1 === page) {
                    if (!this.navPrevNextWrap) this.nextButton.disable()
                } else this.nextButton.enable();
            if (this.previousButton)
                if (page > 0) this.previousButton.enable();
                else if (!this.navPrevNextWrap) this.previousButton.disable()
        },
        _showMessage: function(message) {
            this._hideMessage();
            var div = $.makeNeutralElement("div");
            div.appendChild(document.createTextNode(message));
            this.messageDiv = $.makeCenteredNode(div);
            $.addClass(this.messageDiv, "openseadragon-message");
            this.container.appendChild(this.messageDiv)
        },
        _hideMessage: function() {
            var div = this.messageDiv;
            if (div) {
                div.parentNode.removeChild(div);
                delete this.messageDiv
            }
        },
        gestureSettingsByDeviceType: function(type) {
            switch (type) {
                case "mouse":
                    return this.gestureSettingsMouse;
                case "touch":
                    return this.gestureSettingsTouch;
                case "pen":
                    return this.gestureSettingsPen;
                default:
                    return this.gestureSettingsUnknown
            }
        },
        _drawOverlays: function() {
            var i, length = this.currentOverlays.length;
            for (i = 0; i < length; i++) this.currentOverlays[i].drawHTML(this.overlaysContainer, this.viewport)
        }
    });

    function _getSafeElemSize(oElement) {
        oElement = $.getElement(oElement);
        return new $.Point(oElement.clientWidth === 0 ? 1 : oElement.clientWidth, oElement.clientHeight === 0 ? 1 : oElement.clientHeight)
    }

    function getTileSourceImplementation(viewer, tileSource, successCallback,
        failCallback) {
        var _this = viewer;
        if ($.type(tileSource) == "string")
            if (tileSource.match(/\s*<.*/)) tileSource = $.parseXml(tileSource);
            else if (tileSource.match(/\s*[\{\[].*/)) tileSource = eval("(" + tileSource + ")");
        setTimeout(function() {
            if ($.type(tileSource) == "string") {
                tileSource = new $.TileSource({
                    url: tileSource,
                    ajaxWithCredentials: viewer.ajaxWithCredentials,
                    success: function(event) {
                        successCallback(event.tileSource)
                    }
                });
                tileSource.addHandler("open-failed", function(event) {
                    failCallback(event)
                })
            } else if ($.isPlainObject(tileSource) ||
                tileSource.nodeType) {
                if (tileSource.ajaxWithCredentials === undefined) tileSource.ajaxWithCredentials = viewer.ajaxWithCredentials;
                if ($.isFunction(tileSource.getTileUrl)) {
                    var customTileSource = new $.TileSource(tileSource);
                    customTileSource.getTileUrl = tileSource.getTileUrl;
                    successCallback(customTileSource)
                } else {
                    var $TileSource = $.TileSource.determineType(_this, tileSource);
                    if (!$TileSource) {
                        failCallback({
                            message: "Unable to load TileSource",
                            source: tileSource
                        });
                        return
                    }
                    var options = $TileSource.prototype.configure.apply(_this, [tileSource]);
                    var readySource = new $TileSource(options);
                    successCallback(readySource)
                }
            } else successCallback(tileSource)
        }, 1)
    }

    function getOverlayObject(viewer, overlay) {
        if (overlay instanceof $.Overlay) return overlay;
        var element = null;
        if (overlay.element) element = $.getElement(overlay.element);
        else {
            var id = overlay.id ? overlay.id : "openseadragon-overlay-" + Math.floor(Math.random() * 1E7);
            element = $.getElement(overlay.id);
            if (!element) {
                element = document.createElement("a");
                element.href = "#/overlay/" + id
            }
            element.id = id;
            $.addClass(element,
                overlay.className ? overlay.className : "openseadragon-overlay")
        }
        var location = overlay.location;
        if (!location)
            if (overlay.width && overlay.height) location = overlay.px !== undefined ? viewer.viewport.imageToViewportRectangle(new $.Rect(overlay.px, overlay.py, overlay.width, overlay.height)) : new $.Rect(overlay.x, overlay.y, overlay.width, overlay.height);
            else location = overlay.px !== undefined ? viewer.viewport.imageToViewportCoordinates(new $.Point(overlay.px, overlay.py)) : new $.Point(overlay.x, overlay.y);
        var placement = overlay.placement;
        if (placement && $.type(placement) === "string") placement = $.OverlayPlacement[overlay.placement.toUpperCase()];
        return new $.Overlay({
            element: element,
            location: location,
            placement: placement,
            onDraw: overlay.onDraw,
            checkResize: overlay.checkResize
        })
    }

    function getOverlayIndex(overlays, element) {
        var i;
        for (i = overlays.length - 1; i >= 0; i--)
            if (overlays[i].element === element) return i;
        return -1
    }

    function scheduleUpdate(viewer, updateFunc) {
        return $.requestAnimationFrame(function() {
            updateFunc(viewer)
        })
    }

    function scheduleControlsFade(viewer) {
        $.requestAnimationFrame(function() {
            updateControlsFade(viewer)
        })
    }

    function beginControlsAutoHide(viewer) {
        if (!viewer.autoHideControls) return;
        viewer.controlsShouldFade = true;
        viewer.controlsFadeBeginTime = $.now() + viewer.controlsFadeDelay;
        window.setTimeout(function() {
            scheduleControlsFade(viewer)
        }, viewer.controlsFadeDelay)
    }

    function updateControlsFade(viewer) {
        var currentTime, deltaTime, opacity, i;
        if (viewer.controlsShouldFade) {
            currentTime = $.now();
            deltaTime = currentTime - viewer.controlsFadeBeginTime;
            opacity = 1 - deltaTime / viewer.controlsFadeLength;
            opacity = Math.min(1, opacity);
            opacity =
                Math.max(0, opacity);
            for (i = viewer.controls.length - 1; i >= 0; i--)
                if (viewer.controls[i].autoFade) viewer.controls[i].setOpacity(opacity);
            if (opacity > 0) scheduleControlsFade(viewer)
        }
    }

    function abortControlsAutoHide(viewer) {
        var i;
        viewer.controlsShouldFade = false;
        for (i = viewer.controls.length - 1; i >= 0; i--) viewer.controls[i].setOpacity(1)
    }

    function onFocus() {
        abortControlsAutoHide(this)
    }

    function onBlur() {
        beginControlsAutoHide(this)
    }

    function onCanvasKeyDown(event) {
        if (!event.preventDefaultAction && !event.ctrl && !event.alt &&
            !event.meta) switch (event.keyCode) {
            case 38:
                if (event.shift) this.viewport.zoomBy(1.1);
                else this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, -40)));
                this.viewport.applyConstraints();
                return false;
            case 40:
                if (event.shift) this.viewport.zoomBy(.9);
                else this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, 40)));
                this.viewport.applyConstraints();
                return false;
            case 37:
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(-40, 0)));
                this.viewport.applyConstraints();
                return false;
            case 39:
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(40, 0)));
                this.viewport.applyConstraints();
                return false;
            default:
                return true
        } else return true
    }

    function onCanvasKeyPress(event) {
        if (!event.preventDefaultAction && !event.ctrl && !event.alt && !event.meta) switch (event.keyCode) {
            case 61:
                this.viewport.zoomBy(1.1);
                this.viewport.applyConstraints();
                return false;
            case 45:
                this.viewport.zoomBy(.9);
                this.viewport.applyConstraints();
                return false;
            case 48:
                this.viewport.goHome();
                this.viewport.applyConstraints();
                return false;
            case 119:
            case 87:
                if (event.shift) this.viewport.zoomBy(1.1);
                else this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, -40)));
                this.viewport.applyConstraints();
                return false;
            case 115:
            case 83:
                if (event.shift) this.viewport.zoomBy(.9);
                else this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, 40)));
                this.viewport.applyConstraints();
                return false;
            case 97:
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(-40, 0)));
                this.viewport.applyConstraints();
                return false;
            case 100:
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(40, 0)));
                this.viewport.applyConstraints();
                return false;
            default:
                return true
        } else return true
    }

    function onCanvasClick(event) {
        var gestureSettings;
        var haveKeyboardFocus = document.activeElement == this.canvas;
        if (!haveKeyboardFocus) this.canvas.focus();
        if (!event.preventDefaultAction && this.viewport && event.quick) {
            gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
            if (gestureSettings.clickToZoom) {
                this.viewport.zoomBy(event.shift ?
                    1 / this.zoomPerClick : this.zoomPerClick, this.viewport.pointFromPixel(event.position, true));
                this.viewport.applyConstraints()
            }
        }
        this.raiseEvent("canvas-click", {
            tracker: event.eventSource,
            position: event.position,
            quick: event.quick,
            shift: event.shift,
            originalEvent: event.originalEvent
        })
    }

    function onCanvasDblClick(event) {
        var gestureSettings;
        if (!event.preventDefaultAction && this.viewport) {
            gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
            if (gestureSettings.dblClickToZoom) {
                this.viewport.zoomBy(event.shift ?
                    1 / this.zoomPerClick : this.zoomPerClick, this.viewport.pointFromPixel(event.position, true));
                this.viewport.applyConstraints()
            }
        }
        this.raiseEvent("canvas-double-click", {
            tracker: event.eventSource,
            position: event.position,
            shift: event.shift,
            originalEvent: event.originalEvent
        })
    }

    function onCanvasDrag(event) {
        var gestureSettings;
        if (!event.preventDefaultAction && this.viewport) {
            gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
            if (!this.panHorizontal) event.delta.x = 0;
            if (!this.panVertical) event.delta.y =
                0;
            this.viewport.panBy(this.viewport.deltaPointsFromPixels(event.delta.negate()), gestureSettings.flickEnabled);
            if (this.constrainDuringPan) this.viewport.applyConstraints()
        }
        this.raiseEvent("canvas-drag", {
            tracker: event.eventSource,
            position: event.position,
            delta: event.delta,
            speed: event.speed,
            direction: event.direction,
            shift: event.shift,
            originalEvent: event.originalEvent
        })
    }

    function onCanvasDragEnd(event) {
        var gestureSettings;
        if (!event.preventDefaultAction && this.viewport) {
            gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
            if (gestureSettings.flickEnabled && event.speed >= gestureSettings.flickMinSpeed) {
                var amplitudeX = gestureSettings.flickMomentum * (event.speed * Math.cos(event.direction - Math.PI / 180 * this.viewport.degrees)),
                    amplitudeY = gestureSettings.flickMomentum * (event.speed * Math.sin(event.direction - Math.PI / 180 * this.viewport.degrees)),
                    center = this.viewport.pixelFromPoint(this.viewport.getCenter(true)),
                    target = this.viewport.pointFromPixel(new $.Point(center.x - amplitudeX, center.y - amplitudeY));
                if (!this.panHorizontal) target.x = center.x;
                if (!this.panVertical) target.y = center.y;
                this.viewport.panTo(target, false)
            }
            this.viewport.applyConstraints()
        }
        this.raiseEvent("canvas-drag-end", {
            tracker: event.eventSource,
            position: event.position,
            speed: event.speed,
            direction: event.direction,
            shift: event.shift,
            originalEvent: event.originalEvent
        })
    }

    function onCanvasEnter(event) {
        this.raiseEvent("canvas-enter", {
            tracker: event.eventSource,
            pointerType: event.pointerType,
            position: event.position,
            buttons: event.buttons,
            pointers: event.pointers,
            insideElementPressed: event.insideElementPressed,
            buttonDownAny: event.buttonDownAny,
            originalEvent: event.originalEvent
        })
    }

    function onCanvasExit(event) {
        this.raiseEvent("canvas-exit", {
            tracker: event.eventSource,
            pointerType: event.pointerType,
            position: event.position,
            buttons: event.buttons,
            pointers: event.pointers,
            insideElementPressed: event.insideElementPressed,
            buttonDownAny: event.buttonDownAny,
            originalEvent: event.originalEvent
        })
    }

    function onCanvasPress(event) {
        this.raiseEvent("canvas-press", {
            tracker: event.eventSource,
            pointerType: event.pointerType,
            position: event.position,
            insideElementPressed: event.insideElementPressed,
            insideElementReleased: event.insideElementReleased,
            originalEvent: event.originalEvent
        })
    }

    function onCanvasRelease(event) {
        this.raiseEvent("canvas-release", {
            tracker: event.eventSource,
            pointerType: event.pointerType,
            position: event.position,
            insideElementPressed: event.insideElementPressed,
            insideElementReleased: event.insideElementReleased,
            originalEvent: event.originalEvent
        })
    }

    function onCanvasNonPrimaryPress(event) {
        this.raiseEvent("canvas-nonprimary-press", {
            tracker: event.eventSource,
            position: event.position,
            pointerType: event.pointerType,
            button: event.button,
            buttons: event.buttons,
            originalEvent: event.originalEvent
        })
    }

    function onCanvasNonPrimaryRelease(event) {
        this.raiseEvent("canvas-nonprimary-release", {
            tracker: event.eventSource,
            position: event.position,
            pointerType: event.pointerType,
            button: event.button,
            buttons: event.buttons,
            originalEvent: event.originalEvent
        })
    }

    function onCanvasPinch(event) {
        var gestureSettings, centerPt, lastCenterPt, panByPt;
        if (!event.preventDefaultAction && this.viewport) {
            gestureSettings =
                this.gestureSettingsByDeviceType(event.pointerType);
            if (gestureSettings.pinchToZoom) {
                centerPt = this.viewport.pointFromPixel(event.center, true);
                lastCenterPt = this.viewport.pointFromPixel(event.lastCenter, true);
                panByPt = lastCenterPt.minus(centerPt);
                if (!this.panHorizontal) panByPt.x = 0;
                if (!this.panVertical) panByPt.y = 0;
                this.viewport.zoomBy(event.distance / event.lastDistance, centerPt, true);
                this.viewport.panBy(panByPt, true);
                this.viewport.applyConstraints()
            }
            if (gestureSettings.pinchRotate) {
                var angle1 = Math.atan2(event.gesturePoints[0].currentPos.y -
                    event.gesturePoints[1].currentPos.y, event.gesturePoints[0].currentPos.x - event.gesturePoints[1].currentPos.x);
                var angle2 = Math.atan2(event.gesturePoints[0].lastPos.y - event.gesturePoints[1].lastPos.y, event.gesturePoints[0].lastPos.x - event.gesturePoints[1].lastPos.x);
                this.viewport.setRotation(this.viewport.getRotation() + (angle1 - angle2) * (180 / Math.PI))
            }
        }
        this.raiseEvent("canvas-pinch", {
            tracker: event.eventSource,
            gesturePoints: event.gesturePoints,
            lastCenter: event.lastCenter,
            center: event.center,
            lastDistance: event.lastDistance,
            distance: event.distance,
            shift: event.shift,
            originalEvent: event.originalEvent
        });
        return false
    }

    function onCanvasScroll(event) {
        var gestureSettings, factor;
        if (!event.preventDefaultAction && this.viewport) {
            gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
            if (gestureSettings.scrollToZoom) {
                factor = Math.pow(this.zoomPerScroll, event.scroll);
                this.viewport.zoomBy(factor, this.viewport.pointFromPixel(event.position, true));
                this.viewport.applyConstraints()
            }
        }
        this.raiseEvent("canvas-scroll", {
            tracker: event.eventSource,
            position: event.position,
            scroll: event.scroll,
            shift: event.shift,
            originalEvent: event.originalEvent
        });
        if (gestureSettings && gestureSettings.scrollToZoom) return false
    }

    function onContainerEnter(event) {
        THIS[this.hash].mouseInside = true;
        abortControlsAutoHide(this);
        this.raiseEvent("container-enter", {
            tracker: event.eventSource,
            position: event.position,
            buttons: event.buttons,
            pointers: event.pointers,
            insideElementPressed: event.insideElementPressed,
            buttonDownAny: event.buttonDownAny,
            originalEvent: event.originalEvent
        })
    }

    function onContainerExit(event) {
        if (event.pointers < 1) {
            THIS[this.hash].mouseInside = false;
            if (!THIS[this.hash].animating) beginControlsAutoHide(this)
        }
        this.raiseEvent("container-exit", {
            tracker: event.eventSource,
            position: event.position,
            buttons: event.buttons,
            pointers: event.pointers,
            insideElementPressed: event.insideElementPressed,
            buttonDownAny: event.buttonDownAny,
            originalEvent: event.originalEvent
        })
    }

    function updateMulti(viewer) {
        updateOnce(viewer);
        if (viewer.isOpen()) viewer._updateRequestId = scheduleUpdate(viewer,
            updateMulti);
        else viewer._updateRequestId = false
    }

    function updateOnce(viewer) {
        if (viewer._opening) return;
        var containerSize;
        if (viewer.autoResize) {
            containerSize = _getSafeElemSize(viewer.container);
            if (!containerSize.equals(THIS[viewer.hash].prevContainerSize)) {
                if (viewer.preserveImageSizeOnResize) {
                    var prevContainerSize = THIS[viewer.hash].prevContainerSize;
                    var bounds = viewer.viewport.getBounds(true);
                    var deltaX = containerSize.x - prevContainerSize.x;
                    var deltaY = containerSize.y - prevContainerSize.y;
                    var viewportDiff =
                        viewer.viewport.deltaPointsFromPixels(new OpenSeadragon.Point(deltaX, deltaY), true);
                    viewer.viewport.resize(new OpenSeadragon.Point(containerSize.x, containerSize.y), false);
                    bounds.width += viewportDiff.x;
                    bounds.height += viewportDiff.y;
                    bounds.x -= viewportDiff.x / 2;
                    bounds.y -= viewportDiff.y / 2;
                    viewer.viewport.fitBoundsWithConstraints(bounds, true)
                } else {
                    var oldBounds = viewer.viewport.getBounds();
                    var oldCenter = viewer.viewport.getCenter();
                    resizeViewportAndRecenter(viewer, containerSize, oldBounds, oldCenter)
                }
                THIS[viewer.hash].prevContainerSize =
                    containerSize;
                THIS[viewer.hash].forceRedraw = true
            }
        }
        var viewportChange = viewer.viewport.update();
        var animated = viewer.world.update() || viewportChange;
        if (viewportChange) viewer.raiseEvent("viewport-change");
        if (viewer.referenceStrip) animated = viewer.referenceStrip.update(viewer.viewport) || animated;
        if (!THIS[viewer.hash].animating && animated) {
            viewer.raiseEvent("animation-start");
            abortControlsAutoHide(viewer)
        }
        if (animated || THIS[viewer.hash].forceRedraw || viewer.world.needsDraw()) {
            drawWorld(viewer);
            viewer._drawOverlays();
            if (viewer.navigator) viewer.navigator.update(viewer.viewport);
            THIS[viewer.hash].forceRedraw = false;
            if (animated) viewer.raiseEvent("animation")
        }
        if (THIS[viewer.hash].animating && !animated) {
            viewer.raiseEvent("animation-finish");
            if (!THIS[viewer.hash].mouseInside) beginControlsAutoHide(viewer)
        }
        THIS[viewer.hash].animating = animated
    }

    function resizeViewportAndRecenter(viewer, containerSize, oldBounds, oldCenter) {
        var viewport = viewer.viewport;
        viewport.resize(containerSize, true);
        var worldBounds = viewer.world.getHomeBounds();
        var newWidth = oldBounds.width <= worldBounds.width ? oldBounds.width : worldBounds.width;
        var newHeight = oldBounds.height <= worldBounds.height ? oldBounds.height : worldBounds.height;
        var newBounds = new $.Rect(oldCenter.x - newWidth / 2, oldCenter.y - newHeight / 2, newWidth, newHeight);
        viewport.fitBounds(newBounds, true)
    }

    function drawWorld(viewer) {
        viewer.imageLoader.clear();
        viewer.drawer.clear();
        viewer.world.draw();
        viewer.raiseEvent("update-viewport", {})
    }

    function resolveUrl(prefix, url) {
        return prefix ? prefix + url : url
    }

    function beginZoomingIn() {
        THIS[this.hash].lastZoomTime =
            $.now();
        THIS[this.hash].zoomFactor = this.zoomPerSecond;
        THIS[this.hash].zooming = true;
        scheduleZoom(this)
    }

    function beginZoomingOut() {
        THIS[this.hash].lastZoomTime = $.now();
        THIS[this.hash].zoomFactor = 1 / this.zoomPerSecond;
        THIS[this.hash].zooming = true;
        scheduleZoom(this)
    }

    function endZooming() {
        THIS[this.hash].zooming = false
    }

    function scheduleZoom(viewer) {
        $.requestAnimationFrame($.delegate(viewer, doZoom))
    }

    function doZoom() {
        var currentTime, deltaTime, adjustedFactor;
        if (THIS[this.hash].zooming && this.viewport) {
            currentTime =
                $.now();
            deltaTime = currentTime - THIS[this.hash].lastZoomTime;
            adjustedFactor = Math.pow(THIS[this.hash].zoomFactor, deltaTime / 1E3);
            this.viewport.zoomBy(adjustedFactor);
            this.viewport.applyConstraints();
            THIS[this.hash].lastZoomTime = currentTime;
            scheduleZoom(this)
        }
    }

    function doSingleZoomIn() {
        if (this.viewport) {
            THIS[this.hash].zooming = false;
            this.viewport.zoomBy(this.zoomPerClick / 1);
            this.viewport.applyConstraints()
        }
    }

    function doSingleZoomOut() {
        if (this.viewport) {
            THIS[this.hash].zooming = false;
            this.viewport.zoomBy(1 /
                this.zoomPerClick);
            this.viewport.applyConstraints()
        }
    }

    function lightUp() {
        this.buttons.emulateEnter();
        this.buttons.emulateExit()
    }

    function onHome() {
        if (this.viewport) this.viewport.goHome()
    }

    function onFullScreen() {
        if (this.isFullPage() && !$.isFullScreen()) this.setFullPage(false);
        else this.setFullScreen(!this.isFullPage());
        if (this.buttons) this.buttons.emulateExit();
        this.fullPageButton.element.focus();
        if (this.viewport) this.viewport.applyConstraints()
    }

    function onRotateLeft() {
        if (this.viewport) {
            var currRotation =
                this.viewport.getRotation();
            if (currRotation === 0) currRotation = 270;
            else currRotation -= 90;
            this.viewport.setRotation(currRotation)
        }
    }

    function onRotateRight() {
        if (this.viewport) {
            var currRotation = this.viewport.getRotation();
            if (currRotation === 270) currRotation = 0;
            else currRotation += 90;
            this.viewport.setRotation(currRotation)
        }
    }

    function onPrevious() {
        var previous = this._sequenceIndex - 1;
        if (this.navPrevNextWrap && previous < 0) previous += this.tileSources.length;
        this.goToPage(previous)
    }

    function onNext() {
        var next = this._sequenceIndex +
            1;
        if (this.navPrevNextWrap && next >= this.tileSources.length) next = 0;
        this.goToPage(next)
    }
})(OpenSeadragon);
(function($) {
    $.Navigator = function(options) {
        var viewer = options.viewer,
            _this = this,
            viewerSize, navigatorSize;
        if (!options.id) {
            options.id = "navigator-" + $.now();
            this.element = $.makeNeutralElement("div");
            options.controlOptions = {
                anchor: $.ControlAnchor.TOP_RIGHT,
                attachToViewer: true,
                autoFade: true
            };
            if (options.position)
                if ("BOTTOM_RIGHT" == options.position) options.controlOptions.anchor = $.ControlAnchor.BOTTOM_RIGHT;
                else if ("BOTTOM_LEFT" == options.position) options.controlOptions.anchor = $.ControlAnchor.BOTTOM_LEFT;
            else if ("TOP_RIGHT" ==
                options.position) options.controlOptions.anchor = $.ControlAnchor.TOP_RIGHT;
            else if ("TOP_LEFT" == options.position) options.controlOptions.anchor = $.ControlAnchor.TOP_LEFT;
            else if ("ABSOLUTE" == options.position) {
                options.controlOptions.anchor = $.ControlAnchor.ABSOLUTE;
                options.controlOptions.top = options.top;
                options.controlOptions.left = options.left;
                options.controlOptions.height = options.height;
                options.controlOptions.width = options.width
            }
        } else {
            this.element = document.getElementById(options.id);
            options.controlOptions = {
                anchor: $.ControlAnchor.NONE,
                attachToViewer: false,
                autoFade: false
            }
        }
        this.element.id = options.id;
        this.element.className += " navigator";
        options = $.extend(true, {
            sizeRatio: $.DEFAULT_SETTINGS.navigatorSizeRatio
        }, options, {
            element: this.element,
            tabIndex: -1,
            showNavigator: false,
            mouseNavEnabled: false,
            showNavigationControl: false,
            showSequenceControl: false,
            immediateRender: true,
            blendTime: 0,
            animationTime: 0,
            autoResize: options.autoResize
        });
        options.minPixelRatio = this.minPixelRatio = viewer.minPixelRatio;
        $.setElementTouchActionNone(this.element);
        this.borderWidth = 2;
        this.fudge = new $.Point(1, 1);
        this.totalBorderWidths = (new $.Point(this.borderWidth * 2, this.borderWidth * 2)).minus(this.fudge);
        if (options.controlOptions.anchor != $.ControlAnchor.NONE)(function(style, borderWidth) {
            style.margin = "0px";
            style.border = borderWidth + "px solid #555";
            style.padding = "0px";
            style.background = "#000";
            style.opacity = .8;
            style.overflow = "hidden"
        })(this.element.style, this.borderWidth);
        this.displayRegion = $.makeNeutralElement("div");
        this.displayRegion.id = this.element.id + "-displayregion";
        this.displayRegion.className = "displayregion";
        (function(style, borderWidth) {
            style.position = "relative";
            style.top = "0px";
            style.left = "0px";
            style.fontSize = "0px";
            style.overflow = "hidden";
            style.border = borderWidth + "px solid #900";
            style.margin = "0px";
            style.padding = "0px";
            style.background = "transparent";
            style["float"] = "left";
            style.cssFloat = "left";
            style.styleFloat = "left";
            style.zIndex = 999999999;
            style.cursor = "default"
        })(this.displayRegion.style, this.borderWidth);
        this.displayRegionContainer = $.makeNeutralElement("div");
        this.displayRegionContainer.id = this.element.id + "-displayregioncontainer";
        this.displayRegionContainer.className = "displayregioncontainer";
        this.displayRegionContainer.style.width = "100%";
        this.displayRegionContainer.style.height = "100%";
        viewer.addControl(this.element, options.controlOptions);
        this._resizeWithViewer = options.controlOptions.anchor != $.ControlAnchor.ABSOLUTE && options.controlOptions.anchor != $.ControlAnchor.NONE;
        if (this._resizeWithViewer) {
            if (options.width && options.height) {
                this.element.style.height =
                    typeof options.height == "number" ? options.height + "px" : options.height;
                this.element.style.width = typeof options.width == "number" ? options.width + "px" : options.width
            } else {
                viewerSize = $.getElementSize(viewer.element);
                this.element.style.height = Math.round(viewerSize.y * options.sizeRatio) + "px";
                this.element.style.width = Math.round(viewerSize.x * options.sizeRatio) + "px";
                this.oldViewerSize = viewerSize
            }
            navigatorSize = $.getElementSize(this.element);
            this.elementArea = navigatorSize.x * navigatorSize.y
        }
        this.oldContainerSize = new $.Point(0,
            0);
        $.Viewer.apply(this, [options]);
        this.displayRegionContainer.appendChild(this.displayRegion);
        this.element.getElementsByTagName("div")[0].appendChild(this.displayRegionContainer);
        if (options.navigatorRotate) options.viewer.addHandler("rotate", function(args) {
            _setTransformRotate(_this.displayRegionContainer, args.degrees);
            _setTransformRotate(_this.displayRegion, -args.degrees);
            _this.viewport.setRotation(args.degrees)
        });
        this.innerTracker.destroy();
        this.innerTracker = new $.MouseTracker({
            element: this.element,
            dragHandler: $.delegate(this, onCanvasDrag),
            clickHandler: $.delegate(this, onCanvasClick),
            releaseHandler: $.delegate(this, onCanvasRelease),
            scrollHandler: $.delegate(this, onCanvasScroll)
        });
        this.addHandler("reset-size", function() {
            if (_this.viewport) _this.viewport.goHome(true)
        });
        this.addHandler("reset-size", function() {
            if (_this.viewport) _this.viewport.goHome(true)
        });
        viewer.world.addHandler("item-index-change", function(event) {
            var item = _this.world.getItemAt(event.previousIndex);
            _this.world.setItemIndex(item, event.newIndex)
        });
        viewer.world.addHandler("remove-item", function(event) {
            var theirItem = event.item;
            var myItem = _this._getMatchingItem(theirItem);
            if (myItem) _this.world.removeItem(myItem)
        });
        this.update(viewer.viewport)
    };
    $.extend($.Navigator.prototype, $.EventSource.prototype, $.Viewer.prototype, {
        updateSize: function() {
            if (this.viewport) {
                var containerSize = new $.Point(this.container.clientWidth === 0 ? 1 : this.container.clientWidth, this.container.clientHeight === 0 ? 1 : this.container.clientHeight);
                if (!containerSize.equals(this.oldContainerSize)) {
                    this.viewport.resize(containerSize,
                        true);
                    this.viewport.goHome(true);
                    this.oldContainerSize = containerSize;
                    this.drawer.clear();
                    this.world.draw()
                }
            }
        },
        update: function(viewport) {
            var viewerSize, newWidth, newHeight, bounds, topleft, bottomright;
            viewerSize = $.getElementSize(this.viewer.element);
            if (this._resizeWithViewer && viewerSize.x && viewerSize.y && !viewerSize.equals(this.oldViewerSize)) {
                this.oldViewerSize = viewerSize;
                if (this.maintainSizeRatio || !this.elementArea) {
                    newWidth = viewerSize.x * this.sizeRatio;
                    newHeight = viewerSize.y * this.sizeRatio
                } else {
                    newWidth =
                        Math.sqrt(this.elementArea * (viewerSize.x / viewerSize.y));
                    newHeight = this.elementArea / newWidth
                }
                this.element.style.width = Math.round(newWidth) + "px";
                this.element.style.height = Math.round(newHeight) + "px";
                if (!this.elementArea) this.elementArea = newWidth * newHeight;
                this.updateSize()
            }
            if (viewport && this.viewport) {
                bounds = viewport.getBounds(true);
                topleft = this.viewport.pixelFromPoint(bounds.getTopLeft(), false);
                bottomright = this.viewport.pixelFromPoint(bounds.getBottomRight(), false).minus(this.totalBorderWidths);
                var style =
                    this.displayRegion.style;
                style.display = this.world.getItemCount() ? "block" : "none";
                style.top = Math.round(topleft.y) + "px";
                style.left = Math.round(topleft.x) + "px";
                var width = Math.abs(topleft.x - bottomright.x);
                var height = Math.abs(topleft.y - bottomright.y);
                style.width = Math.round(Math.max(width, 0)) + "px";
                style.height = Math.round(Math.max(height, 0)) + "px"
            }
        },
        addTiledImage: function(options) {
            var _this = this;
            var original = options.originalTiledImage;
            delete options.original;
            var optionsClone = $.extend({}, options, {
                success: function(event) {
                    var myItem =
                        event.item;
                    myItem._originalForNavigator = original;
                    _this._matchBounds(myItem, original, true);
                    original.addHandler("bounds-change", function() {
                        _this._matchBounds(myItem, original)
                    })
                }
            });
            return $.Viewer.prototype.addTiledImage.apply(this, [optionsClone])
        },
        _getMatchingItem: function(theirItem) {
            var count = this.world.getItemCount();
            var item;
            for (var i = 0; i < count; i++) {
                item = this.world.getItemAt(i);
                if (item._originalForNavigator === theirItem) return item
            }
            return null
        },
        _matchBounds: function(myItem, theirItem, immediately) {
            var bounds =
                theirItem.getBounds();
            myItem.setPosition(bounds.getTopLeft(), immediately);
            myItem.setWidth(bounds.width, immediately)
        }
    });

    function onCanvasClick(event) {
        if (event.quick && this.viewer.viewport) {
            this.viewer.viewport.panTo(this.viewport.pointFromPixel(event.position).rotate(-this.viewer.viewport.degrees, this.viewer.viewport.getHomeBounds().getCenter()));
            this.viewer.viewport.applyConstraints()
        }
    }

    function onCanvasDrag(event) {
        if (this.viewer.viewport) {
            if (!this.panHorizontal) event.delta.x = 0;
            if (!this.panVertical) event.delta.y =
                0;
            this.viewer.viewport.panBy(this.viewport.deltaPointsFromPixels(event.delta))
        }
    }

    function onCanvasRelease(event) {
        if (event.insideElementPressed && this.viewer.viewport) this.viewer.viewport.applyConstraints()
    }

    function onCanvasScroll(event) {
        this.viewer.raiseEvent("navigator-scroll", {
            tracker: event.eventSource,
            position: event.position,
            scroll: event.scroll,
            shift: event.shift,
            originalEvent: event.originalEvent
        });
        return false
    }

    function _setTransformRotate(element, degrees) {
        element.style.webkitTransform = "rotate(" +
            degrees + "deg)";
        element.style.mozTransform = "rotate(" + degrees + "deg)";
        element.style.msTransform = "rotate(" + degrees + "deg)";
        element.style.oTransform = "rotate(" + degrees + "deg)";
        element.style.transform = "rotate(" + degrees + "deg)"
    }
})(OpenSeadragon);
(function($) {
    var I18N = {
        Errors: {
            Dzc: "Sorry, we don't support Deep Zoom Collections!",
            Dzi: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
            Xml: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
            ImageFormat: "Sorry, we don't support {0}-based Deep Zoom Images.",
            Security: "It looks like a security restriction stopped us from " + "loading this Deep Zoom Image.",
            Status: "This space unintentionally left blank ({0} {1}).",
            OpenFailed: "Unable to open {0}: {1}"
        },
        Tooltips: {
            FullPage: "Toggle full page",
            Home: "Go home",
            ZoomIn: "Zoom in",
            ZoomOut: "Zoom out",
            NextPage: "Next page",
            PreviousPage: "Previous page",
            RotateLeft: "Rotate left",
            RotateRight: "Rotate right"
        }
    };
    $.extend($, {
        getString: function(prop) {
            var props = prop.split("."),
                string = null,
                args = arguments,
                container = I18N,
                i;
            for (i = 0; i < props.length - 1; i++) container = container[props[i]] || {};
            string = container[props[i]];
            if (typeof string != "string") {
                $.console.debug("Untranslated source string:", prop);
                string = ""
            }
            return string.replace(/\{\d+\}/g, function(capture) {
                var i = parseInt(capture.match(/\d+/),
                    10) + 1;
                return i < args.length ? args[i] : ""
            })
        },
        setString: function(prop, value) {
            var props = prop.split("."),
                container = I18N,
                i;
            for (i = 0; i < props.length - 1; i++) {
                if (!container[props[i]]) container[props[i]] = {};
                container = container[props[i]]
            }
            container[props[i]] = value
        }
    })
})(OpenSeadragon);
(function($) {
    $.Point = function(x, y) {
        this.x = typeof x == "number" ? x : 0;
        this.y = typeof y == "number" ? y : 0
    };
    $.Point.prototype = {
        clone: function() {
            return new $.Point(this.x, this.y)
        },
        plus: function(point) {
            return new $.Point(this.x + point.x, this.y + point.y)
        },
        minus: function(point) {
            return new $.Point(this.x - point.x, this.y - point.y)
        },
        times: function(factor) {
            return new $.Point(this.x * factor, this.y * factor)
        },
        divide: function(factor) {
            return new $.Point(this.x / factor, this.y / factor)
        },
        negate: function() {
            return new $.Point(-this.x, -this.y)
        },
        distanceTo: function(point) {
            return Math.sqrt(Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2))
        },
        apply: function(func) {
            return new $.Point(func(this.x), func(this.y))
        },
        equals: function(point) {
            return point instanceof $.Point && this.x === point.x && this.y === point.y
        },
        rotate: function(degrees, pivot) {
            var angle = degrees * Math.PI / 180,
                x = Math.cos(angle) * (this.x - pivot.x) - Math.sin(angle) * (this.y - pivot.y) + pivot.x,
                y = Math.sin(angle) * (this.x - pivot.x) + Math.cos(angle) * (this.y - pivot.y) + pivot.y;
            return new $.Point(x,
                y)
        },
        toString: function() {
            return "(" + Math.round(this.x * 100) / 100 + "," + Math.round(this.y * 100) / 100 + ")"
        }
    }
})(OpenSeadragon);
(function($) {
    $.TileSource = function(width, height, tileSize, tileOverlap, minLevel, maxLevel) {
        var _this = this;
        var args = arguments,
            options, i;
        if ($.isPlainObject(width)) options = width;
        else options = {
            width: args[0],
            height: args[1],
            tileSize: args[2],
            tileOverlap: args[3],
            minLevel: args[4],
            maxLevel: args[5]
        };
        $.EventSource.call(this);
        $.extend(true, this, options);
        if (!this.success)
            for (i = 0; i < arguments.length; i++)
                if ($.isFunction(arguments[i])) {
                    this.success = arguments[i];
                    break
                }
        if (this.success) this.addHandler("ready", function(event) {
            _this.success(event)
        });
        if ("string" == $.type(arguments[0])) this.url = arguments[0];
        if (this.url) {
            this.aspectRatio = 1;
            this.dimensions = new $.Point(10, 10);
            this._tileWidth = 0;
            this._tileHeight = 0;
            this.tileOverlap = 0;
            this.minLevel = 0;
            this.maxLevel = 0;
            this.ready = false;
            this.getImageInfo(this.url)
        } else {
            this.ready = true;
            this.aspectRatio = options.width && options.height ? options.width / options.height : 1;
            this.dimensions = new $.Point(options.width, options.height);
            if (this.tileSize) {
                this._tileWidth = this._tileHeight = this.tileSize;
                delete this.tileSize
            } else {
                if (this.tileWidth) {
                    this._tileWidth =
                        this.tileWidth;
                    delete this.tileWidth
                } else this._tileWidth = 0;
                if (this.tileHeight) {
                    this._tileHeight = this.tileHeight;
                    delete this.tileHeight
                } else this._tileHeight = 0
            }
            this.tileOverlap = options.tileOverlap ? options.tileOverlap : 0;
            this.minLevel = options.minLevel ? options.minLevel : 0;
            this.maxLevel = undefined !== options.maxLevel && null !== options.maxLevel ? options.maxLevel : options.width && options.height ? Math.ceil(Math.log(Math.max(options.width, options.height)) / Math.log(2)) : 0;
            if (this.success && $.isFunction(this.success)) this.success(this)
        }
    };
    $.TileSource.prototype = {
        getTileSize: function(level) {
            $.console.error("[TileSource.getTileSize] is deprecated." + "Use TileSource.getTileWidth() and TileSource.getTileHeight() instead");
            return this._tileWidth
        },
        getTileWidth: function(level) {
            if (!this._tileWidth) return this.getTileSize(level);
            return this._tileWidth
        },
        getTileHeight: function(level) {
            if (!this._tileHeight) return this.getTileSize(level);
            return this._tileHeight
        },
        getLevelScale: function(level) {
            var levelScaleCache = {},
                i;
            for (i = 0; i <= this.maxLevel; i++) levelScaleCache[i] =
                1 / Math.pow(2, this.maxLevel - i);
            this.getLevelScale = function(_level) {
                return levelScaleCache[_level]
            };
            return this.getLevelScale(level)
        },
        getNumTiles: function(level) {
            var scale = this.getLevelScale(level),
                x = Math.ceil(scale * this.dimensions.x / this.getTileWidth(level)),
                y = Math.ceil(scale * this.dimensions.y / this.getTileHeight(level));
            return new $.Point(x, y)
        },
        getPixelRatio: function(level) {
            var imageSizeScaled = this.dimensions.times(this.getLevelScale(level)),
                rx = 1 / imageSizeScaled.x,
                ry = 1 / imageSizeScaled.y;
            return new $.Point(rx,
                ry)
        },
        getClosestLevel: function(rect) {
            var i, tilesPerSide, tiles;
            for (i = this.minLevel; i < this.maxLevel; i++) {
                tiles = this.getNumTiles(i);
                tilesPerSide = new $.Point(Math.floor(rect.x / this.getTileWidth(i)), Math.floor(rect.y / this.getTileHeight(i)));
                if (tiles.x + 1 >= tilesPerSide.x || tiles.y + 1 >= tilesPerSide.y) break
            }
            return Math.max(0, i - 1)
        },
        getTileAtPoint: function(level, point) {
            var pixel = point.times(this.dimensions.x).times(this.getLevelScale(level)),
                tx = Math.floor(pixel.x / this.getTileWidth(level)),
                ty = Math.floor(pixel.y /
                    this.getTileHeight(level));
            return new $.Point(tx, ty)
        },
        getTileBounds: function(level, x, y) {
            var dimensionsScaled = this.dimensions.times(this.getLevelScale(level)),
                tileWidth = this.getTileWidth(level),
                tileHeight = this.getTileHeight(level),
                px = x === 0 ? 0 : tileWidth * x - this.tileOverlap,
                py = y === 0 ? 0 : tileHeight * y - this.tileOverlap,
                sx = tileWidth + (x === 0 ? 1 : 2) * this.tileOverlap,
                sy = tileHeight + (y === 0 ? 1 : 2) * this.tileOverlap,
                scale = 1 / dimensionsScaled.x;
            sx = Math.min(sx, dimensionsScaled.x - px);
            sy = Math.min(sy, dimensionsScaled.y - py);
            return new $.Rect(px *
                scale, py * scale, sx * scale, sy * scale)
        },
        getImageInfo: function(url) {
            var _this = this,
                callbackName, callback, readySource, options, urlParts, filename, lastDot;
            if (url) {
                urlParts = url.split("/");
                filename = urlParts[urlParts.length - 1];
                lastDot = filename.lastIndexOf(".");
                if (lastDot > -1) urlParts[urlParts.length - 1] = filename.slice(0, lastDot)
            }
            callback = function(data) {
                if (typeof data === "string") data = $.parseXml(data);
                var $TileSource = $.TileSource.determineType(_this, data, url);
                if (!$TileSource) {
                    _this.raiseEvent("open-failed", {
                        message: "Unable to load TileSource",
                        source: url
                    });
                    return
                }
                options = $TileSource.prototype.configure.apply(_this, [data, url]);
                if (options.ajaxWithCredentials === undefined) options.ajaxWithCredentials = _this.ajaxWithCredentials;
                readySource = new $TileSource(options);
                _this.ready = true;
                _this.raiseEvent("ready", {
                    tileSource: readySource
                })
            };
            if (url.match(/\.js$/)) {
                callbackName = url.split("/").pop().replace(".js", "");
                $.jsonp({
                    url: url,
                    async: false,
                    callbackName: callbackName,
                    callback: callback
                })
            } else $.makeAjaxRequest({
                url: url,
                withCredentials: this.ajaxWithCredentials,
                success: function(xhr) {
                    var data = processResponse(xhr);
                    callback(data)
                },
                error: function(xhr, exc) {
                    var msg;
                    try {
                        msg = "HTTP " + xhr.status + " attempting to load TileSource"
                    } catch (e) {
                        var formattedExc;
                        if (typeof exc == "undefined" || !exc.toString) formattedExc = "Unknown error";
                        else formattedExc = exc.toString();
                        msg = formattedExc + " attempting to load TileSource"
                    }
                    _this.raiseEvent("open-failed", {
                        message: msg,
                        source: url
                    })
                }
            })
        },
        supports: function(data, url) {
            return false
        },
        configure: function(data, url) {
            throw new Error("Method not implemented.");
        },
        getTileUrl: function(level, x, y) {
            throw new Error("Method not implemented.");
        },
        tileExists: function(level, x, y) {
            var numTiles = this.getNumTiles(level);
            return level >= this.minLevel && level <= this.maxLevel && x >= 0 && y >= 0 && x < numTiles.x && y < numTiles.y
        }
    };
    $.extend(true, $.TileSource.prototype, $.EventSource.prototype);

    function processResponse(xhr) {
        var responseText = xhr.responseText,
            status = xhr.status,
            statusText, data;
        if (!xhr) throw new Error($.getString("Errors.Security"));
        else if (xhr.status !== 200 && xhr.status !== 0) {
            status =
                xhr.status;
            statusText = status == 404 ? "Not Found" : xhr.statusText;
            throw new Error($.getString("Errors.Status", status, statusText));
        }
        if (responseText.match(/\s*<.*/)) try {
                data = xhr.responseXML && xhr.responseXML.documentElement ? xhr.responseXML : $.parseXml(responseText)
            } catch (e) {
                data = xhr.responseText
            } else if (responseText.match(/\s*[\{\[].*/)) data = eval("(" + responseText + ")");
            else data = responseText;
        return data
    }
    $.TileSource.determineType = function(tileSource, data, url) {
        var property;
        for (property in OpenSeadragon)
            if (property.match(/.+TileSource$/) &&
                $.isFunction(OpenSeadragon[property]) && $.isFunction(OpenSeadragon[property].prototype.supports) && OpenSeadragon[property].prototype.supports.call(tileSource, data, url)) return OpenSeadragon[property];
        $.console.error("No TileSource was able to open %s %s", url, data)
    }
})(OpenSeadragon);
(function($) {
    $.DziTileSource = function(width, height, tileSize, tileOverlap, tilesUrl, fileFormat, displayRects, minLevel, maxLevel) {
        var i, rect, level, options;
        if ($.isPlainObject(width)) options = width;
        else options = {
            width: arguments[0],
            height: arguments[1],
            tileSize: arguments[2],
            tileOverlap: arguments[3],
            tilesUrl: arguments[4],
            fileFormat: arguments[5],
            displayRects: arguments[6],
            minLevel: arguments[7],
            maxLevel: arguments[8]
        };
        this._levelRects = {};
        this.tilesUrl = options.tilesUrl;
        this.fileFormat = options.fileFormat;
        this.displayRects =
            options.displayRects;
        if (this.displayRects)
            for (i = this.displayRects.length - 1; i >= 0; i--) {
                rect = this.displayRects[i];
                for (level = rect.minLevel; level <= rect.maxLevel; level++) {
                    if (!this._levelRects[level]) this._levelRects[level] = [];
                    this._levelRects[level].push(rect)
                }
            }
        $.TileSource.apply(this, [options])
    };
    $.extend($.DziTileSource.prototype, $.TileSource.prototype, {
        supports: function(data, url) {
            var ns;
            if (data.Image) ns = data.Image.xmlns;
            else if (data.documentElement)
                if ("Image" == data.documentElement.localName || "Image" ==
                    data.documentElement.tagName) ns = data.documentElement.namespaceURI;
            return "http://schemas.microsoft.com/deepzoom/2008" == ns || "http://schemas.microsoft.com/deepzoom/2009" == ns
        },
        configure: function(data, url) {
            var options;
            if (!$.isPlainObject(data)) options = configureFromXML(this, data);
            else options = configureFromObject(this, data);
            if (url && !options.tilesUrl) {
                options.tilesUrl = url.replace(/([^\/]+)\.(dzi|xml|js)(\?.*|$)/, "$1_files/");
                if (url.search(/\.(dzi|xml|js)\?/) != -1) options.queryParams = url.match(/\?.*/);
                else options.queryParams =
                    ""
            }
            return options
        },
        getTileUrl: function(level, x, y) {
            return [this.tilesUrl, level, "/", x, "_", y, ".", this.fileFormat, this.queryParams].join("")
        },
        tileExists: function(level, x, y) {
            var rects = this._levelRects[level],
                rect, scale, xMin, yMin, xMax, yMax, i;
            if (!rects || !rects.length) return true;
            for (i = rects.length - 1; i >= 0; i--) {
                rect = rects[i];
                if (level < rect.minLevel || level > rect.maxLevel) continue;
                scale = this.getLevelScale(level);
                xMin = rect.x * scale;
                yMin = rect.y * scale;
                xMax = xMin + rect.width * scale;
                yMax = yMin + rect.height * scale;
                xMin = Math.floor(xMin /
                    this.tileSize);
                yMin = Math.floor(yMin / this.tileSize);
                xMax = Math.ceil(xMax / this.tileSize);
                yMax = Math.ceil(yMax / this.tileSize);
                if (xMin <= x && x < xMax && yMin <= y && y < yMax) return true
            }
            return false
        }
    });

    function configureFromXML(tileSource, xmlDoc) {
        if (!xmlDoc || !xmlDoc.documentElement) throw new Error($.getString("Errors.Xml"));
        var root = xmlDoc.documentElement,
            rootName = root.localName || root.tagName,
            ns = xmlDoc.documentElement.namespaceURI,
            configuration = null,
            displayRects = [],
            dispRectNodes, dispRectNode, rectNode, sizeNode, i;
        if (rootName ==
            "Image") try {
                sizeNode = root.getElementsByTagName("Size")[0];
                if (sizeNode === undefined) sizeNode = root.getElementsByTagNameNS(ns, "Size")[0];
                configuration = {
                    Image: {
                        xmlns: "http://schemas.microsoft.com/deepzoom/2008",
                        Url: root.getAttribute("Url"),
                        Format: root.getAttribute("Format"),
                        DisplayRect: null,
                        Overlap: parseInt(root.getAttribute("Overlap"), 10),
                        TileSize: parseInt(root.getAttribute("TileSize"), 10),
                        Size: {
                            Height: parseInt(sizeNode.getAttribute("Height"), 10),
                            Width: parseInt(sizeNode.getAttribute("Width"), 10)
                        }
                    }
                };
                if (!$.imageFormatSupported(configuration.Image.Format)) throw new Error($.getString("Errors.ImageFormat",
                    configuration.Image.Format.toUpperCase()));
                dispRectNodes = root.getElementsByTagName("DisplayRect");
                if (dispRectNodes === undefined) dispRectNodes = root.getElementsByTagNameNS(ns, "DisplayRect")[0];
                for (i = 0; i < dispRectNodes.length; i++) {
                    dispRectNode = dispRectNodes[i];
                    rectNode = dispRectNode.getElementsByTagName("Rect")[0];
                    if (rectNode === undefined) rectNode = dispRectNode.getElementsByTagNameNS(ns, "Rect")[0];
                    displayRects.push({
                        Rect: {
                            X: parseInt(rectNode.getAttribute("X"), 10),
                            Y: parseInt(rectNode.getAttribute("Y"), 10),
                            Width: parseInt(rectNode.getAttribute("Width"), 10),
                            Height: parseInt(rectNode.getAttribute("Height"), 10),
                            MinLevel: parseInt(dispRectNode.getAttribute("MinLevel"), 10),
                            MaxLevel: parseInt(dispRectNode.getAttribute("MaxLevel"), 10)
                        }
                    })
                }
                if (displayRects.length) configuration.Image.DisplayRect = displayRects;
                return configureFromObject(tileSource, configuration)
            } catch (e) {
                throw e instanceof Error ? e : new Error($.getString("Errors.Dzi"));
            } else if (rootName == "Collection") throw new Error($.getString("Errors.Dzc"));
            else if (rootName ==
            "Error") return $._processDZIError(root);
        throw new Error($.getString("Errors.Dzi"));
    }

    function configureFromObject(tileSource, configuration) {
        var imageData = configuration.Image,
            tilesUrl = imageData.Url,
            fileFormat = imageData.Format,
            sizeData = imageData.Size,
            dispRectData = imageData.DisplayRect || [],
            width = parseInt(sizeData.Width, 10),
            height = parseInt(sizeData.Height, 10),
            tileSize = parseInt(imageData.TileSize, 10),
            tileOverlap = parseInt(imageData.Overlap, 10),
            displayRects = [],
            rectData, i;
        for (i = 0; i < dispRectData.length; i++) {
            rectData =
                dispRectData[i].Rect;
            displayRects.push(new $.DisplayRect(parseInt(rectData.X, 10), parseInt(rectData.Y, 10), parseInt(rectData.Width, 10), parseInt(rectData.Height, 10), parseInt(rectData.MinLevel, 10), parseInt(rectData.MaxLevel, 10)))
        }
        return $.extend(true, {
            width: width,
            height: height,
            tileSize: tileSize,
            tileOverlap: tileOverlap,
            minLevel: null,
            maxLevel: null,
            tilesUrl: tilesUrl,
            fileFormat: fileFormat,
            displayRects: displayRects
        }, configuration)
    }
})(OpenSeadragon);
(function($) {
    $.IIIFTileSource = function(options) {
        $.extend(true, this, options);
        if (!(this.height && this.width && this["@id"])) throw new Error("IIIF required parameters not provided.");
        options.tileSizePerScaleFactor = {};
        if (this.tile_width && this.tile_height) {
            options.tileWidth = this.tile_width;
            options.tileHeight = this.tile_height
        } else if (this.tile_width) options.tileSize = this.tile_width;
        else if (this.tile_height) options.tileSize = this.tile_height;
        else if (this.tiles)
            if (this.tiles.length == 1) {
                options.tileWidth = this.tiles[0].width;
                options.tileHeight = this.tiles[0].height || this.tiles[0].width;
                this.scale_factors = this.tiles[0].scaleFactors
            } else {
                this.scale_factors = [];
                for (var t = 0; t < this.tiles.length; t++)
                    for (var sf = 0; sf < this.tiles[t].scaleFactors.length; sf++) {
                        var scaleFactor = this.tiles[t].scaleFactors[sf];
                        this.scale_factors.push(scaleFactor);
                        options.tileSizePerScaleFactor[scaleFactor] = {
                            width: this.tiles[t].width,
                            height: this.tiles[t].height || this.tiles[t].width
                        }
                    }
            } else {
            var shortDim = Math.min(this.height, this.width),
                tileOptions = [256, 512,
                    1024
                ],
                smallerTiles = [];
            for (var c = 0; c < tileOptions.length; c++)
                if (tileOptions[c] <= shortDim) smallerTiles.push(tileOptions[c]);
            if (smallerTiles.length > 0) options.tileSize = Math.max.apply(null, smallerTiles);
            else options.tileSize = shortDim
        }
        if (!options.maxLevel)
            if (!this.scale_factors) options.maxLevel = Number(Math.ceil(Math.log(Math.max(this.width, this.height), 2)));
            else options.maxLevel = Math.floor(Math.pow(Math.max.apply(null, this.scale_factors), .5));
        $.TileSource.apply(this, [options])
    };
    $.extend($.IIIFTileSource.prototype,
        $.TileSource.prototype, {
            supports: function(data, url) {
                if (data.protocol && data.protocol == "http://iiif.io/api/image") return true;
                else if (data["@context"] && (data["@context"] == "http://library.stanford.edu/iiif/image-api/1.1/context.json" || data["@context"] == "http://iiif.io/api/image/1/context.json")) return true;
                else if (data.profile && data.profile.indexOf("http://library.stanford.edu/iiif/image-api/compliance.html") === 0) return true;
                else if (data.identifier && data.width && data.height) return true;
                else if (data.documentElement &&
                    "info" == data.documentElement.tagName && "http://library.stanford.edu/iiif/image-api/ns/" == data.documentElement.namespaceURI) return true;
                else return false
            },
            configure: function(data, url) {
                if (!$.isPlainObject(data)) {
                    var options = configureFromXml10(data);
                    options["@context"] = "http://iiif.io/api/image/1.0/context.json";
                    options["@id"] = url.replace("/info.xml", "");
                    return options
                } else if (!data["@context"]) {
                    data["@context"] = "http://iiif.io/api/image/1.0/context.json";
                    data["@id"] = url.replace("/info.json", "");
                    return data
                } else return data
            },
            getTileWidth: function(level) {
                var scaleFactor = Math.pow(2, this.maxLevel - level);
                if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) return this.tileSizePerScaleFactor[scaleFactor].width;
                return this._tileWidth
            },
            getTileHeight: function(level) {
                var scaleFactor = Math.pow(2, this.maxLevel - level);
                if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) return this.tileSizePerScaleFactor[scaleFactor].height;
                return this._tileHeight
            },
            getTileUrl: function(level, x, y) {
                var IIIF_ROTATION =
                    "0",
                    scale = Math.pow(.5, this.maxLevel - level),
                    levelWidth = Math.ceil(this.width * scale),
                    levelHeight = Math.ceil(this.height * scale),
                    tileWidth, tileHeight, iiifTileSizeWidth, iiifTileSizeHeight, iiifRegion, iiifTileX, iiifTileY, iiifTileW, iiifTileH, iiifSize, iiifQuality, uri;
                tileWidth = this.getTileWidth(level);
                tileHeight = this.getTileHeight(level);
                iiifTileSizeWidth = Math.ceil(tileWidth / scale);
                iiifTileSizeHeight = Math.ceil(tileHeight / scale);
                if (this["@context"].indexOf("/1.0/context.json") > -1 || this["@context"].indexOf("/1.1/context.json") >
                    -1 || this["@context"].indexOf("/1/context.json") > -1) iiifQuality = "native.jpg";
                else iiifQuality = "default.jpg";
                if (levelWidth < tileWidth && levelHeight < tileHeight) {
                    iiifSize = levelWidth + ",";
                    iiifRegion = "full"
                } else {
                    iiifTileX = x * iiifTileSizeWidth;
                    iiifTileY = y * iiifTileSizeHeight;
                    iiifTileW = Math.min(iiifTileSizeWidth, this.width - iiifTileX);
                    iiifTileH = Math.min(iiifTileSizeHeight, this.height - iiifTileY);
                    iiifSize = Math.ceil(iiifTileW * scale) + ",";
                    iiifRegion = [iiifTileX, iiifTileY, iiifTileW, iiifTileH].join(",")
                }
                uri = [this["@id"],
                    iiifRegion, iiifSize, IIIF_ROTATION, iiifQuality
                ].join("/");
                return uri
            }
        });

    function configureFromXml10(xmlDoc) {
        if (!xmlDoc || !xmlDoc.documentElement) throw new Error($.getString("Errors.Xml"));
        var root = xmlDoc.documentElement,
            rootName = root.tagName,
            configuration = null;
        if (rootName == "info") try {
            configuration = {};
            parseXML10(root, configuration);
            return configuration
        } catch (e) {
            throw e instanceof Error ? e : new Error($.getString("Errors.IIIF"));
        }
        throw new Error($.getString("Errors.IIIF"));
    }

    function parseXML10(node, configuration,
        property) {
        var i, value;
        if (node.nodeType == 3 && property) {
            value = node.nodeValue.trim();
            if (value.match(/^\d*$/)) value = Number(value);
            if (!configuration[property]) configuration[property] = value;
            else {
                if (!$.isArray(configuration[property])) configuration[property] = [configuration[property]];
                configuration[property].push(value)
            }
        } else if (node.nodeType == 1)
            for (i = 0; i < node.childNodes.length; i++) parseXML10(node.childNodes[i], configuration, node.nodeName)
    }
})(OpenSeadragon);
(function($) {
    $.OsmTileSource = function(width, height, tileSize, tileOverlap, tilesUrl) {
        var options;
        if ($.isPlainObject(width)) options = width;
        else options = {
            width: arguments[0],
            height: arguments[1],
            tileSize: arguments[2],
            tileOverlap: arguments[3],
            tilesUrl: arguments[4]
        };
        if (!options.width || !options.height) {
            options.width = 65572864;
            options.height = 65572864
        }
        if (!options.tileSize) {
            options.tileSize = 256;
            options.tileOverlap = 0
        }
        if (!options.tilesUrl) options.tilesUrl = "http://tile.openstreetmap.org/";
        options.minLevel = 8;
        $.TileSource.apply(this, [options])
    };
    $.extend($.OsmTileSource.prototype, $.TileSource.prototype, {
        supports: function(data, url) {
            return data.type && "openstreetmaps" == data.type
        },
        configure: function(data, url) {
            return data
        },
        getTileUrl: function(level, x, y) {
            return this.tilesUrl + (level - 8) + "/" + x + "/" + y + ".png"
        }
    })
})(OpenSeadragon);
(function($) {
    $.TmsTileSource = function(width, height, tileSize, tileOverlap, tilesUrl) {
        var options;
        if ($.isPlainObject(width)) options = width;
        else options = {
            width: arguments[0],
            height: arguments[1],
            tileSize: arguments[2],
            tileOverlap: arguments[3],
            tilesUrl: arguments[4]
        };
        var bufferedWidth = Math.ceil(options.width / 256) * 256,
            bufferedHeight = Math.ceil(options.height / 256) * 256,
            max;
        if (bufferedWidth > bufferedHeight) max = bufferedWidth / 256;
        else max = bufferedHeight / 256;
        options.maxLevel = Math.ceil(Math.log(max) / Math.log(2)) - 1;
        options.tileSize =
            256;
        options.width = bufferedWidth;
        options.height = bufferedHeight;
        $.TileSource.apply(this, [options])
    };
    $.extend($.TmsTileSource.prototype, $.TileSource.prototype, {
        supports: function(data, url) {
            return data.type && "tiledmapservice" == data.type
        },
        configure: function(data, url) {
            return data
        },
        getTileUrl: function(level, x, y) {
            var yTiles = this.getNumTiles(level).y - 1;
            return this.tilesUrl + level + "/" + x + "/" + (yTiles - y) + ".png"
        }
    })
})(OpenSeadragon);
(function($) {
    $.LegacyTileSource = function(levels) {
        var options, width, height;
        if ($.isArray(levels)) options = {
            type: "legacy-image-pyramid",
            levels: levels
        };
        options.levels = filterFiles(options.levels);
        if (options.levels.length > 0) {
            width = options.levels[options.levels.length - 1].width;
            height = options.levels[options.levels.length - 1].height
        } else {
            width = 0;
            height = 0;
            $.console.error("No supported image formats found")
        }
        $.extend(true, options, {
            width: width,
            height: height,
            tileSize: Math.max(height, width),
            tileOverlap: 0,
            minLevel: 0,
            maxLevel: options.levels.length > 0 ? options.levels.length - 1 : 0
        });
        $.TileSource.apply(this, [options]);
        this.levels = options.levels
    };
    $.extend($.LegacyTileSource.prototype, $.TileSource.prototype, {
        supports: function(data, url) {
            return data.type && "legacy-image-pyramid" == data.type || data.documentElement && "legacy-image-pyramid" == data.documentElement.getAttribute("type")
        },
        configure: function(configuration, dataUrl) {
            var options;
            if (!$.isPlainObject(configuration)) options = configureFromXML(this, configuration);
            else options =
                configureFromObject(this, configuration);
            return options
        },
        getLevelScale: function(level) {
            var levelScale = NaN;
            if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) levelScale = this.levels[level].width / this.levels[this.maxLevel].width;
            return levelScale
        },
        getNumTiles: function(level) {
            var scale = this.getLevelScale(level);
            if (scale) return new $.Point(1, 1);
            else return new $.Point(0, 0)
        },
        getTileAtPoint: function(level, point) {
            return new $.Point(0, 0)
        },
        getTileUrl: function(level, x, y) {
            var url = null;
            if (this.levels.length >
                0 && level >= this.minLevel && level <= this.maxLevel) url = this.levels[level].url;
            return url
        }
    });

    function filterFiles(files) {
        var filtered = [],
            file, i;
        for (i = 0; i < files.length; i++) {
            file = files[i];
            if (file.height && file.width && file.url && (file.url.toLowerCase().match(/^.*\.(png|jpg|jpeg|gif)$/) || file.mimetype && file.mimetype.toLowerCase().match(/^.*\/(png|jpg|jpeg|gif)$/))) filtered.push({
                url: file.url,
                width: Number(file.width),
                height: Number(file.height)
            });
            else $.console.error("Unsupported image format: %s", file.url ? file.url :
                "<no URL>")
        }
        return filtered.sort(function(a, b) {
            return a.height - b.height
        })
    }

    function configureFromXML(tileSource, xmlDoc) {
        if (!xmlDoc || !xmlDoc.documentElement) throw new Error($.getString("Errors.Xml"));
        var root = xmlDoc.documentElement,
            rootName = root.tagName,
            conf = null,
            levels = [],
            level, i;
        if (rootName == "image") try {
                conf = {
                    type: root.getAttribute("type"),
                    levels: []
                };
                levels = root.getElementsByTagName("level");
                for (i = 0; i < levels.length; i++) {
                    level = levels[i];
                    conf.levels.push({
                        url: level.getAttribute("url"),
                        width: parseInt(level.getAttribute("width"),
                            10),
                        height: parseInt(level.getAttribute("height"), 10)
                    })
                }
                return configureFromObject(tileSource, conf)
            } catch (e) {
                throw e instanceof Error ? e : new Error("Unknown error parsing Legacy Image Pyramid XML.");
            } else if (rootName == "collection") throw new Error("Legacy Image Pyramid Collections not yet supported.");
            else if (rootName == "error") throw new Error("Error: " + xmlDoc);
        throw new Error("Unknown element " + rootName);
    }

    function configureFromObject(tileSource, configuration) {
        return configuration.levels
    }
})(OpenSeadragon);
(function($) {
    $.TileSourceCollection = function(tileSize, tileSources, rows, layout) {
        $.console.error("TileSourceCollection is deprecated; use World instead")
    }
})(OpenSeadragon);
(function($) {
    $.ButtonState = {
        REST: 0,
        GROUP: 1,
        HOVER: 2,
        DOWN: 3
    };
    $.Button = function(options) {
        var _this = this;
        $.EventSource.call(this);
        $.extend(true, this, {
            tooltip: null,
            srcRest: null,
            srcGroup: null,
            srcHover: null,
            srcDown: null,
            clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold,
            clickDistThreshold: $.DEFAULT_SETTINGS.clickDistThreshold,
            fadeDelay: 0,
            fadeLength: 2E3,
            onPress: null,
            onRelease: null,
            onClick: null,
            onEnter: null,
            onExit: null,
            onFocus: null,
            onBlur: null
        }, options);
        this.element = options.element || $.makeNeutralElement("div");
        if (!options.element) {
            this.imgRest = $.makeTransparentImage(this.srcRest);
            this.imgGroup = $.makeTransparentImage(this.srcGroup);
            this.imgHover = $.makeTransparentImage(this.srcHover);
            this.imgDown = $.makeTransparentImage(this.srcDown);
            this.imgRest.alt = this.imgGroup.alt = this.imgHover.alt = this.imgDown.alt = this.tooltip;
            this.element.style.position = "relative";
            $.setElementTouchActionNone(this.element);
            this.imgGroup.style.position = this.imgHover.style.position = this.imgDown.style.position = "absolute";
            this.imgGroup.style.top =
                this.imgHover.style.top = this.imgDown.style.top = "0px";
            this.imgGroup.style.left = this.imgHover.style.left = this.imgDown.style.left = "0px";
            this.imgHover.style.visibility = this.imgDown.style.visibility = "hidden";
            if ($.Browser.vendor == $.BROWSERS.FIREFOX && $.Browser.version < 3) this.imgGroup.style.top = this.imgHover.style.top = this.imgDown.style.top = "";
            this.element.appendChild(this.imgRest);
            this.element.appendChild(this.imgGroup);
            this.element.appendChild(this.imgHover);
            this.element.appendChild(this.imgDown)
        }
        this.addHandler("press",
            this.onPress);
        this.addHandler("release", this.onRelease);
        this.addHandler("click", this.onClick);
        this.addHandler("enter", this.onEnter);
        this.addHandler("exit", this.onExit);
        this.addHandler("focus", this.onFocus);
        this.addHandler("blur", this.onBlur);
        this.currentState = $.ButtonState.GROUP;
        this.fadeBeginTime = null;
        this.shouldFade = false;
        this.element.style.display = "inline-block";
        this.element.style.position = "relative";
        this.element.title = this.tooltip;
        this.tracker = new $.MouseTracker({
            element: this.element,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            enterHandler: function(event) {
                if (event.insideElementPressed) {
                    inTo(_this, $.ButtonState.DOWN);
                    _this.raiseEvent("enter", {
                        originalEvent: event.originalEvent
                    })
                } else if (!event.buttonDownAny) inTo(_this, $.ButtonState.HOVER)
            },
            focusHandler: function(event) {
                this.enterHandler(event);
                _this.raiseEvent("focus", {
                    originalEvent: event.originalEvent
                })
            },
            exitHandler: function(event) {
                outTo(_this, $.ButtonState.GROUP);
                if (event.insideElementPressed) _this.raiseEvent("exit", {
                    originalEvent: event.originalEvent
                })
            },
            blurHandler: function(event) {
                this.exitHandler(event);
                _this.raiseEvent("blur", {
                    originalEvent: event.originalEvent
                })
            },
            pressHandler: function(event) {
                inTo(_this, $.ButtonState.DOWN);
                _this.raiseEvent("press", {
                    originalEvent: event.originalEvent
                })
            },
            releaseHandler: function(event) {
                if (event.insideElementPressed && event.insideElementReleased) {
                    outTo(_this, $.ButtonState.HOVER);
                    _this.raiseEvent("release", {
                        originalEvent: event.originalEvent
                    })
                } else if (event.insideElementPressed) outTo(_this, $.ButtonState.GROUP);
                else inTo(_this,
                    $.ButtonState.HOVER)
            },
            clickHandler: function(event) {
                if (event.quick) _this.raiseEvent("click", {
                    originalEvent: event.originalEvent
                })
            },
            keyHandler: function(event) {
                if (13 === event.keyCode) {
                    _this.raiseEvent("click", {
                        originalEvent: event.originalEvent
                    });
                    _this.raiseEvent("release", {
                        originalEvent: event.originalEvent
                    });
                    return false
                }
                return true
            }
        });
        outTo(this, $.ButtonState.REST)
    };
    $.extend($.Button.prototype, $.EventSource.prototype, {
        notifyGroupEnter: function() {
            inTo(this, $.ButtonState.GROUP)
        },
        notifyGroupExit: function() {
            outTo(this,
                $.ButtonState.REST)
        },
        disable: function() {
            this.notifyGroupExit();
            this.element.disabled = true;
            $.setElementOpacity(this.element, .2, true)
        },
        enable: function() {
            this.element.disabled = false;
            $.setElementOpacity(this.element, 1, true);
            this.notifyGroupEnter()
        }
    });

    function scheduleFade(button) {
        $.requestAnimationFrame(function() {
            updateFade(button)
        })
    }

    function updateFade(button) {
        var currentTime, deltaTime, opacity;
        if (button.shouldFade) {
            currentTime = $.now();
            deltaTime = currentTime - button.fadeBeginTime;
            opacity = 1 - deltaTime / button.fadeLength;
            opacity = Math.min(1, opacity);
            opacity = Math.max(0, opacity);
            if (button.imgGroup) $.setElementOpacity(button.imgGroup, opacity, true);
            if (opacity > 0) scheduleFade(button)
        }
    }

    function beginFading(button) {
        button.shouldFade = true;
        button.fadeBeginTime = $.now() + button.fadeDelay;
        window.setTimeout(function() {
            scheduleFade(button)
        }, button.fadeDelay)
    }

    function stopFading(button) {
        button.shouldFade = false;
        if (button.imgGroup) $.setElementOpacity(button.imgGroup, 1, true)
    }

    function inTo(button, newState) {
        if (button.element.disabled) return;
        if (newState >= $.ButtonState.GROUP && button.currentState == $.ButtonState.REST) {
            stopFading(button);
            button.currentState = $.ButtonState.GROUP
        }
        if (newState >= $.ButtonState.HOVER && button.currentState == $.ButtonState.GROUP) {
            if (button.imgHover) button.imgHover.style.visibility = "";
            button.currentState = $.ButtonState.HOVER
        }
        if (newState >= $.ButtonState.DOWN && button.currentState == $.ButtonState.HOVER) {
            if (button.imgDown) button.imgDown.style.visibility = "";
            button.currentState = $.ButtonState.DOWN
        }
    }

    function outTo(button, newState) {
        if (button.element.disabled) return;
        if (newState <= $.ButtonState.HOVER && button.currentState == $.ButtonState.DOWN) {
            if (button.imgDown) button.imgDown.style.visibility = "hidden";
            button.currentState = $.ButtonState.HOVER
        }
        if (newState <= $.ButtonState.GROUP && button.currentState == $.ButtonState.HOVER) {
            if (button.imgHover) button.imgHover.style.visibility = "hidden";
            button.currentState = $.ButtonState.GROUP
        }
        if (newState <= $.ButtonState.REST && button.currentState == $.ButtonState.GROUP) {
            beginFading(button);
            button.currentState = $.ButtonState.REST
        }
    }
})(OpenSeadragon);
(function($) {
    $.ButtonGroup = function(options) {
        $.extend(true, this, {
            buttons: [],
            clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold,
            clickDistThreshold: $.DEFAULT_SETTINGS.clickDistThreshold,
            labelText: ""
        }, options);
        var buttons = this.buttons.concat([]),
            _this = this,
            i;
        this.element = options.element || $.makeNeutralElement("div");
        if (!options.group) {
            this.label = $.makeNeutralElement("label");
            this.element.style.display = "inline-block";
            this.element.appendChild(this.label);
            for (i = 0; i < buttons.length; i++) this.element.appendChild(buttons[i].element)
        }
        $.setElementTouchActionNone(this.element);
        this.tracker = new $.MouseTracker({
            element: this.element,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            enterHandler: function(event) {
                var i;
                for (i = 0; i < _this.buttons.length; i++) _this.buttons[i].notifyGroupEnter()
            },
            exitHandler: function(event) {
                var i;
                if (!event.insideElementPressed)
                    for (i = 0; i < _this.buttons.length; i++) _this.buttons[i].notifyGroupExit()
            }
        })
    };
    $.ButtonGroup.prototype = {
        emulateEnter: function() {
            this.tracker.enterHandler({
                eventSource: this.tracker
            })
        },
        emulateExit: function() {
            this.tracker.exitHandler({
                eventSource: this.tracker
            })
        }
    }
})(OpenSeadragon);
(function($) {
    $.Rect = function(x, y, width, height) {
        this.x = typeof x == "number" ? x : 0;
        this.y = typeof y == "number" ? y : 0;
        this.width = typeof width == "number" ? width : 0;
        this.height = typeof height == "number" ? height : 0
    };
    $.Rect.prototype = {
        clone: function() {
            return new $.Rect(this.x, this.y, this.width, this.height)
        },
        getAspectRatio: function() {
            return this.width / this.height
        },
        getTopLeft: function() {
            return new $.Point(this.x, this.y)
        },
        getBottomRight: function() {
            return new $.Point(this.x + this.width, this.y + this.height)
        },
        getTopRight: function() {
            return new $.Point(this.x +
                this.width, this.y)
        },
        getBottomLeft: function() {
            return new $.Point(this.x, this.y + this.height)
        },
        getCenter: function() {
            return new $.Point(this.x + this.width / 2, this.y + this.height / 2)
        },
        getSize: function() {
            return new $.Point(this.width, this.height)
        },
        equals: function(other) {
            return other instanceof $.Rect && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height
        },
        times: function(factor) {
            return new OpenSeadragon.Rect(this.x * factor, this.y * factor, this.width * factor, this.height * factor)
        },
        union: function(rect) {
            var left = Math.min(this.x, rect.x);
            var top = Math.min(this.y, rect.y);
            var right = Math.max(this.x + this.width, rect.x + rect.width);
            var bottom = Math.max(this.y + this.height, rect.y + rect.height);
            return new OpenSeadragon.Rect(left, top, right - left, bottom - top)
        },
        rotate: function(degrees, pivot) {
            var width = this.width,
                height = this.height,
                newTopLeft;
            degrees = (degrees + 360) % 360;
            if (degrees % 90 !== 0) throw new Error("Currently only 0, 90, 180, and 270 degrees are supported.");
            if (degrees === 0) return new $.Rect(this.x,
                this.y, this.width, this.height);
            pivot = pivot || this.getCenter();
            switch (degrees) {
                case 90:
                    newTopLeft = this.getBottomLeft();
                    width = this.height;
                    height = this.width;
                    break;
                case 180:
                    newTopLeft = this.getBottomRight();
                    break;
                case 270:
                    newTopLeft = this.getTopRight();
                    width = this.height;
                    height = this.width;
                    break;
                default:
                    newTopLeft = this.getTopLeft();
                    break
            }
            newTopLeft = newTopLeft.rotate(degrees, pivot);
            return new $.Rect(newTopLeft.x, newTopLeft.y, width, height)
        },
        toString: function() {
            return "[" + Math.round(this.x * 100) / 100 + "," + Math.round(this.y *
                100) / 100 + "," + Math.round(this.width * 100) / 100 + "x" + Math.round(this.height * 100) / 100 + "]"
        }
    }
})(OpenSeadragon);
(function($) {
    var THIS = {};
    $.ReferenceStrip = function(options) {
        var _this = this,
            viewer = options.viewer,
            viewerSize = $.getElementSize(viewer.element),
            element, style, i;
        if (!options.id) {
            options.id = "referencestrip-" + $.now();
            this.element = $.makeNeutralElement("div");
            this.element.id = options.id;
            this.element.className = "referencestrip"
        }
        options = $.extend(true, {
                sizeRatio: $.DEFAULT_SETTINGS.referenceStripSizeRatio,
                position: $.DEFAULT_SETTINGS.referenceStripPosition,
                scroll: $.DEFAULT_SETTINGS.referenceStripScroll,
                clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold
            },
            options, {
                element: this.element,
                showNavigator: false,
                mouseNavEnabled: false,
                showNavigationControl: false,
                showSequenceControl: false
            });
        $.extend(this, options);
        THIS[this.id] = {
            "animating": false
        };
        this.minPixelRatio = this.viewer.minPixelRatio;
        style = this.element.style;
        style.marginTop = "0px";
        style.marginRight = "0px";
        style.marginBottom = "0px";
        style.marginLeft = "0px";
        style.left = "0px";
        style.bottom = "0px";
        style.border = "0px";
        style.background = "#000";
        style.position = "relative";
        $.setElementTouchActionNone(this.element);
        $.setElementOpacity(this.element,
            .8);
        this.viewer = viewer;
        this.innerTracker = new $.MouseTracker({
            element: this.element,
            dragHandler: $.delegate(this, onStripDrag),
            scrollHandler: $.delegate(this, onStripScroll),
            enterHandler: $.delegate(this, onStripEnter),
            exitHandler: $.delegate(this, onStripExit),
            keyDownHandler: $.delegate(this, onKeyDown),
            keyHandler: $.delegate(this, onKeyPress)
        });
        if (options.width && options.height) {
            this.element.style.width = options.width + "px";
            this.element.style.height = options.height + "px";
            viewer.addControl(this.element, {
                anchor: $.ControlAnchor.BOTTOM_LEFT
            })
        } else if ("horizontal" ==
            options.scroll) {
            this.element.style.width = viewerSize.x * options.sizeRatio * viewer.tileSources.length + 12 * viewer.tileSources.length + "px";
            this.element.style.height = viewerSize.y * options.sizeRatio + "px";
            viewer.addControl(this.element, {
                anchor: $.ControlAnchor.BOTTOM_LEFT
            })
        } else {
            this.element.style.height = viewerSize.y * options.sizeRatio * viewer.tileSources.length + 12 * viewer.tileSources.length + "px";
            this.element.style.width = viewerSize.x * options.sizeRatio + "px";
            viewer.addControl(this.element, {
                anchor: $.ControlAnchor.TOP_LEFT
            })
        }
        this.panelWidth =
            viewerSize.x * this.sizeRatio + 8;
        this.panelHeight = viewerSize.y * this.sizeRatio + 8;
        this.panels = [];
        for (i = 0; i < viewer.tileSources.length; i++) {
            element = $.makeNeutralElement("div");
            element.id = this.element.id + "-" + i;
            element.style.width = _this.panelWidth + "px";
            element.style.height = _this.panelHeight + "px";
            element.style.display = "inline";
            element.style["float"] = "left";
            element.style.cssFloat = "left";
            element.style.styleFloat = "left";
            element.style.padding = "2px";
            $.setElementTouchActionNone(element);
            element.innerTracker = new $.MouseTracker({
                element: element,
                clickTimeThreshold: this.clickTimeThreshold,
                clickDistThreshold: this.clickDistThreshold,
                pressHandler: function(event) {
                    event.eventSource.dragging = $.now()
                },
                releaseHandler: function(event) {
                    var tracker = event.eventSource,
                        id = tracker.element.id,
                        page = Number(id.split("-")[2]),
                        now = $.now();
                    if (event.insideElementPressed && event.insideElementReleased && tracker.dragging && now - tracker.dragging < tracker.clickTimeThreshold) {
                        tracker.dragging = null;
                        viewer.goToPage(page)
                    }
                }
            });
            this.element.appendChild(element);
            element.activePanel =
                false;
            this.panels.push(element)
        }
        loadPanels(this, this.scroll == "vertical" ? viewerSize.y : viewerSize.x, 0);
        this.setFocus(0)
    };
    $.extend($.ReferenceStrip.prototype, $.EventSource.prototype, $.Viewer.prototype, {
        setFocus: function(page) {
            var element = $.getElement(this.element.id + "-" + page),
                viewerSize = $.getElementSize(this.viewer.canvas),
                scrollWidth = Number(this.element.style.width.replace("px", "")),
                scrollHeight = Number(this.element.style.height.replace("px", "")),
                offsetLeft = -Number(this.element.style.marginLeft.replace("px",
                    "")),
                offsetTop = -Number(this.element.style.marginTop.replace("px", "")),
                offset;
            if (this.currentSelected !== element) {
                if (this.currentSelected) this.currentSelected.style.background = "#000";
                this.currentSelected = element;
                this.currentSelected.style.background = "#999";
                if ("horizontal" == this.scroll) {
                    offset = Number(page) * (this.panelWidth + 3);
                    if (offset > offsetLeft + viewerSize.x - this.panelWidth) {
                        offset = Math.min(offset, scrollWidth - viewerSize.x);
                        this.element.style.marginLeft = -offset + "px";
                        loadPanels(this, viewerSize.x, -offset)
                    } else if (offset <
                        offsetLeft) {
                        offset = Math.max(0, offset - viewerSize.x / 2);
                        this.element.style.marginLeft = -offset + "px";
                        loadPanels(this, viewerSize.x, -offset)
                    }
                } else {
                    offset = Number(page) * (this.panelHeight + 3);
                    if (offset > offsetTop + viewerSize.y - this.panelHeight) {
                        offset = Math.min(offset, scrollHeight - viewerSize.y);
                        this.element.style.marginTop = -offset + "px";
                        loadPanels(this, viewerSize.y, -offset)
                    } else if (offset < offsetTop) {
                        offset = Math.max(0, offset - viewerSize.y / 2);
                        this.element.style.marginTop = -offset + "px";
                        loadPanels(this, viewerSize.y, -offset)
                    }
                }
                this.currentPage =
                    page;
                $.getElement(element.id + "-displayregion").focus();
                onStripEnter.call(this, {
                    eventSource: this.innerTracker
                })
            }
        },
        update: function() {
            if (THIS[this.id].animating) {
                $.console.log("image reference strip update");
                return true
            }
            return false
        },
        destroy: function() {
            if (this.element) this.element.parentNode.removeChild(this.element)
        }
    });

    function onStripDrag(event) {
        var offsetLeft = Number(this.element.style.marginLeft.replace("px", "")),
            offsetTop = Number(this.element.style.marginTop.replace("px", "")),
            scrollWidth = Number(this.element.style.width.replace("px",
                "")),
            scrollHeight = Number(this.element.style.height.replace("px", "")),
            viewerSize = $.getElementSize(this.viewer.canvas);
        this.dragging = true;
        if (this.element)
            if ("horizontal" == this.scroll)
                if (-event.delta.x > 0) {
                    if (offsetLeft > -(scrollWidth - viewerSize.x)) {
                        this.element.style.marginLeft = offsetLeft + event.delta.x * 2 + "px";
                        loadPanels(this, viewerSize.x, offsetLeft + event.delta.x * 2)
                    }
                } else {
                    if (-event.delta.x < 0)
                        if (offsetLeft < 0) {
                            this.element.style.marginLeft = offsetLeft + event.delta.x * 2 + "px";
                            loadPanels(this, viewerSize.x, offsetLeft +
                                event.delta.x * 2)
                        }
                } else if (-event.delta.y > 0) {
            if (offsetTop > -(scrollHeight - viewerSize.y)) {
                this.element.style.marginTop = offsetTop + event.delta.y * 2 + "px";
                loadPanels(this, viewerSize.y, offsetTop + event.delta.y * 2)
            }
        } else if (-event.delta.y < 0)
            if (offsetTop < 0) {
                this.element.style.marginTop = offsetTop + event.delta.y * 2 + "px";
                loadPanels(this, viewerSize.y, offsetTop + event.delta.y * 2)
            }
        return false
    }

    function onStripScroll(event) {
        var offsetLeft = Number(this.element.style.marginLeft.replace("px", "")),
            offsetTop = Number(this.element.style.marginTop.replace("px",
                "")),
            scrollWidth = Number(this.element.style.width.replace("px", "")),
            scrollHeight = Number(this.element.style.height.replace("px", "")),
            viewerSize = $.getElementSize(this.viewer.canvas);
        if (this.element)
            if ("horizontal" == this.scroll)
                if (event.scroll > 0) {
                    if (offsetLeft > -(scrollWidth - viewerSize.x)) {
                        this.element.style.marginLeft = offsetLeft - event.scroll * 60 + "px";
                        loadPanels(this, viewerSize.x, offsetLeft - event.scroll * 60)
                    }
                } else {
                    if (event.scroll < 0)
                        if (offsetLeft < 0) {
                            this.element.style.marginLeft = offsetLeft - event.scroll * 60 +
                                "px";
                            loadPanels(this, viewerSize.x, offsetLeft - event.scroll * 60)
                        }
                } else if (event.scroll < 0) {
            if (offsetTop > viewerSize.y - scrollHeight) {
                this.element.style.marginTop = offsetTop + event.scroll * 60 + "px";
                loadPanels(this, viewerSize.y, offsetTop + event.scroll * 60)
            }
        } else if (event.scroll > 0)
            if (offsetTop < 0) {
                this.element.style.marginTop = offsetTop + event.scroll * 60 + "px";
                loadPanels(this, viewerSize.y, offsetTop + event.scroll * 60)
            }
        return false
    }

    function loadPanels(strip, viewerSize, scroll) {
        var panelSize, activePanelsStart, activePanelsEnd,
            miniViewer, style, i, element;
        if ("horizontal" == strip.scroll) panelSize = strip.panelWidth;
        else panelSize = strip.panelHeight;
        activePanelsStart = Math.ceil(viewerSize / panelSize) + 5;
        activePanelsEnd = Math.ceil((Math.abs(scroll) + viewerSize) / panelSize) + 1;
        activePanelsStart = activePanelsEnd - activePanelsStart;
        activePanelsStart = activePanelsStart < 0 ? 0 : activePanelsStart;
        for (i = activePanelsStart; i < activePanelsEnd && i < strip.panels.length; i++) {
            element = strip.panels[i];
            if (!element.activePanel) {
                miniViewer = new $.Viewer({
                    id: element.id,
                    tileSources: [strip.viewer.tileSources[i]],
                    element: element,
                    navigatorSizeRatio: strip.sizeRatio,
                    showNavigator: false,
                    mouseNavEnabled: false,
                    showNavigationControl: false,
                    showSequenceControl: false,
                    immediateRender: true,
                    blendTime: 0,
                    animationTime: 0
                });
                miniViewer.displayRegion = $.makeNeutralElement("textarea");
                miniViewer.displayRegion.id = element.id + "-displayregion";
                miniViewer.displayRegion.className = "displayregion";
                style = miniViewer.displayRegion.style;
                style.position = "relative";
                style.top = "0px";
                style.left = "0px";
                style.fontSize = "0px";
                style.overflow = "hidden";
                style["float"] = "left";
                style.cssFloat = "left";
                style.styleFloat = "left";
                style.zIndex = 999999999;
                style.cursor = "default";
                style.width = strip.panelWidth - 4 + "px";
                style.height = strip.panelHeight - 4 + "px";
                miniViewer.displayRegion.innerTracker = new $.MouseTracker({
                    element: miniViewer.displayRegion,
                    startDisabled: true
                });
                element.getElementsByTagName("div")[0].appendChild(miniViewer.displayRegion);
                element.activePanel = true
            }
        }
    }

    function onStripEnter(event) {
        var element = event.eventSource.element;
        if ("horizontal" == this.scroll) element.style.marginBottom = "0px";
        else element.style.marginLeft = "0px";
        return false
    }

    function onStripExit(event) {
        var element = event.eventSource.element;
        if ("horizontal" == this.scroll) element.style.marginBottom = "-" + $.getElementSize(element).y / 2 + "px";
        else element.style.marginLeft = "-" + $.getElementSize(element).x / 2 + "px";
        return false
    }

    function onKeyDown(event) {
        if (!event.preventDefaultAction && !event.ctrl && !event.alt && !event.meta) switch (event.keyCode) {
            case 38:
                onStripScroll.call(this, {
                    eventSource: this.tracker,
                    position: null,
                    scroll: 1,
                    shift: null
                });
                return false;
            case 40:
                onStripScroll.call(this, {
                    eventSource: this.tracker,
                    position: null,
                    scroll: -1,
                    shift: null
                });
                return false;
            case 37:
                onStripScroll.call(this, {
                    eventSource: this.tracker,
                    position: null,
                    scroll: -1,
                    shift: null
                });
                return false;
            case 39:
                onStripScroll.call(this, {
                    eventSource: this.tracker,
                    position: null,
                    scroll: 1,
                    shift: null
                });
                return false;
            default:
                return true
        } else return true
    }

    function onKeyPress(event) {
        if (!event.preventDefaultAction && !event.ctrl &&
            !event.alt && !event.meta) switch (event.keyCode) {
            case 61:
                onStripScroll.call(this, {
                    eventSource: this.tracker,
                    position: null,
                    scroll: 1,
                    shift: null
                });
                return false;
            case 45:
                onStripScroll.call(this, {
                    eventSource: this.tracker,
                    position: null,
                    scroll: -1,
                    shift: null
                });
                return false;
            case 48:
            case 119:
            case 87:
                onStripScroll.call(this, {
                    eventSource: this.tracker,
                    position: null,
                    scroll: 1,
                    shift: null
                });
                return false;
            case 115:
            case 83:
                onStripScroll.call(this, {
                    eventSource: this.tracker,
                    position: null,
                    scroll: -1,
                    shift: null
                });
                return false;
            case 97:
                onStripScroll.call(this, {
                    eventSource: this.tracker,
                    position: null,
                    scroll: -1,
                    shift: null
                });
                return false;
            case 100:
                onStripScroll.call(this, {
                    eventSource: this.tracker,
                    position: null,
                    scroll: 1,
                    shift: null
                });
                return false;
            default:
                return true
        } else return true
    }
})(OpenSeadragon);
(function($) {
    $.DisplayRect = function(x, y, width, height, minLevel, maxLevel) {
        $.Rect.apply(this, [x, y, width, height]);
        this.minLevel = minLevel;
        this.maxLevel = maxLevel
    };
    $.extend($.DisplayRect.prototype, $.Rect.prototype)
})(OpenSeadragon);
(function($) {
    $.Spring = function(options) {
        var args = arguments;
        if (typeof options != "object") options = {
            initial: args.length && typeof args[0] == "number" ? args[0] : undefined,
            springStiffness: args.length > 1 ? args[1].springStiffness : 5,
            animationTime: args.length > 1 ? args[1].animationTime : 1.5
        };
        $.console.assert(typeof options.springStiffness === "number" && options.springStiffness !== 0, "[OpenSeadragon.Spring] options.springStiffness must be a non-zero number");
        $.console.assert(typeof options.animationTime === "number" && options.springStiffness !==
            0, "[OpenSeadragon.Spring] options.animationTime must be a non-zero number");
        if (options.exponential) {
            this._exponential = true;
            delete options.exponential
        }
        $.extend(true, this, options);
        this.current = {
            value: typeof this.initial == "number" ? this.initial : this._exponential ? 0 : 1,
            time: $.now()
        };
        $.console.assert(!this._exponential || this.current.value !== 0, "[OpenSeadragon.Spring] value must be non-zero for exponential springs");
        this.start = {
            value: this.current.value,
            time: this.current.time
        };
        this.target = {
            value: this.current.value,
            time: this.current.time
        };
        if (this._exponential) {
            this.start._logValue = Math.log(this.start.value);
            this.target._logValue = Math.log(this.target.value);
            this.current._logValue = Math.log(this.current.value)
        }
    };
    $.Spring.prototype = {
        resetTo: function(target) {
            $.console.assert(!this._exponential || target !== 0, "[OpenSeadragon.Spring.resetTo] target must be non-zero for exponential springs");
            this.start.value = this.target.value = this.current.value = target;
            this.start.time = this.target.time = this.current.time = $.now();
            if (this._exponential) {
                this.start._logValue =
                    Math.log(this.start.value);
                this.target._logValue = Math.log(this.target.value);
                this.current._logValue = Math.log(this.current.value)
            }
        },
        springTo: function(target) {
            $.console.assert(!this._exponential || target !== 0, "[OpenSeadragon.Spring.springTo] target must be non-zero for exponential springs");
            this.start.value = this.current.value;
            this.start.time = this.current.time;
            this.target.value = target;
            this.target.time = this.start.time + 1E3 * this.animationTime;
            if (this._exponential) {
                this.start._logValue = Math.log(this.start.value);
                this.target._logValue = Math.log(this.target.value)
            }
        },
        shiftBy: function(delta) {
            this.start.value += delta;
            this.target.value += delta;
            if (this._exponential) {
                $.console.assert(this.target.value !== 0 && this.start.value !== 0, "[OpenSeadragon.Spring.shiftBy] spring value must be non-zero for exponential springs");
                this.start._logValue = Math.log(this.start.value);
                this.target._logValue = Math.log(this.target.value)
            }
        },
        setExponential: function(value) {
            this._exponential = value;
            if (this._exponential) {
                $.console.assert(this.current.value !==
                    0 && this.target.value !== 0 && this.start.value !== 0, "[OpenSeadragon.Spring.setExponential] spring value must be non-zero for exponential springs");
                this.start._logValue = Math.log(this.start.value);
                this.target._logValue = Math.log(this.target.value);
                this.current._logValue = Math.log(this.current.value)
            }
        },
        update: function() {
            this.current.time = $.now();
            var startValue, targetValue;
            if (this._exponential) {
                startValue = this.start._logValue;
                targetValue = this.target._logValue
            } else {
                startValue = this.start.value;
                targetValue = this.target.value
            }
            var currentValue =
                this.current.time >= this.target.time ? targetValue : startValue + (targetValue - startValue) * transform(this.springStiffness, (this.current.time - this.start.time) / (this.target.time - this.start.time));
            if (this._exponential) this.current.value = Math.exp(currentValue);
            else this.current.value = currentValue
        }
    };

    function transform(stiffness, x) {
        return (1 - Math.exp(stiffness * -x)) / (1 - Math.exp(-stiffness))
    }
})(OpenSeadragon);
(function($) {
    function ImageJob(options) {
        $.extend(true, this, {
            timeout: $.DEFAULT_SETTINGS.timeout,
            jobId: null
        }, options);
        this.image = null
    }
    ImageJob.prototype = {
        errorMsg: null,
        start: function() {
            var _this = this;
            this.image = new Image;
            if (this.crossOriginPolicy !== false) this.image.crossOrigin = this.crossOriginPolicy;
            this.image.onload = function() {
                _this.finish(true)
            };
            this.image.onabort = this.image.onerror = function() {
                _this.errorMsg = "Image load aborted";
                _this.finish(false)
            };
            this.jobId = window.setTimeout(function() {
                _this.errorMsg =
                    "Image load exceeded timeout";
                _this.finish(false)
            }, this.timeout);
            this.image.src = this.src
        },
        finish: function(successful) {
            this.image.onload = this.image.onerror = this.image.onabort = null;
            if (!successful) this.image = null;
            if (this.jobId) window.clearTimeout(this.jobId);
            this.callback(this)
        }
    };
    $.ImageLoader = function(options) {
        $.extend(true, this, {
            jobLimit: $.DEFAULT_SETTINGS.imageLoaderLimit,
            jobQueue: [],
            jobsInProgress: 0
        }, options)
    };
    $.ImageLoader.prototype = {
        addJob: function(options) {
            var _this = this,
                complete = function(job) {
                    completeJob(_this,
                        job, options.callback)
                },
                jobOptions = {
                    src: options.src,
                    crossOriginPolicy: options.crossOriginPolicy,
                    callback: complete,
                    abort: options.abort
                },
                newJob = new ImageJob(jobOptions);
            if (!this.jobLimit || this.jobsInProgress < this.jobLimit) {
                newJob.start();
                this.jobsInProgress++
            } else this.jobQueue.push(newJob)
        },
        clear: function() {
            for (var i = 0; i < this.jobQueue.length; i++) {
                var job = this.jobQueue[i];
                if (typeof job.abort === "function") job.abort()
            }
            this.jobQueue = []
        }
    };

    function completeJob(loader, job, callback) {
        var nextJob;
        loader.jobsInProgress--;
        if ((!loader.jobLimit || loader.jobsInProgress < loader.jobLimit) && loader.jobQueue.length > 0) {
            nextJob = loader.jobQueue.shift();
            nextJob.start();
            loader.jobsInProgress++
        }
        callback(job.image, job.errorMsg)
    }
})(OpenSeadragon);
(function($) {
    $.Tile = function(level, x, y, bounds, exists, url) {
        this.level = level;
        this.x = x;
        this.y = y;
        this.bounds = bounds;
        this.exists = exists;
        this.url = url;
        this.loaded = false;
        this.loading = false;
        this.element = null;
        this.imgElement = null;
        this.image = null;
        this.style = null;
        this.position = null;
        this.size = null;
        this.blendStart = null;
        this.opacity = null;
        this.distance = null;
        this.visibility = null;
        this.beingDrawn = false;
        this.lastTouchTime = 0
    };
    $.Tile.prototype = {
        toString: function() {
            return this.level + "/" + this.x + "_" + this.y
        },
        drawHTML: function(container) {
            if (!this.cacheImageRecord) {
                $.console.warn("[Tile.drawHTML] attempting to draw tile %s when it's not cached",
                    this.toString());
                return
            }
            if (!this.loaded) {
                $.console.warn("Attempting to draw tile %s when it's not yet loaded.", this.toString());
                return
            }
            if (!this.element) {
                this.element = $.makeNeutralElement("div");
                this.imgElement = this.cacheImageRecord.getImage().cloneNode();
                this.imgElement.style.msInterpolationMode = "nearest-neighbor";
                this.imgElement.style.width = "100%";
                this.imgElement.style.height = "100%";
                this.style = this.element.style;
                this.style.position = "absolute"
            }
            if (this.element.parentNode != container) container.appendChild(this.element);
            if (this.imgElement.parentNode != this.element) this.element.appendChild(this.imgElement);
            this.style.top = this.position.y + "px";
            this.style.left = this.position.x + "px";
            this.style.height = this.size.y + "px";
            this.style.width = this.size.x + "px";
            $.setElementOpacity(this.element, this.opacity)
        },
        drawCanvas: function(context, drawingHandler) {
            var position = this.position,
                size = this.size,
                rendered;
            if (!this.cacheImageRecord) {
                $.console.warn("[Tile.drawCanvas] attempting to draw tile %s when it's not cached", this.toString());
                return
            }
            rendered =
                this.cacheImageRecord.getRenderedContext();
            if (!this.loaded || !rendered) {
                $.console.warn("Attempting to draw tile %s when it's not yet loaded.", this.toString());
                return
            }
            context.globalAlpha = this.opacity;
            if (context.globalAlpha == 1 && this.url.match(".png")) context.clearRect(position.x * $.pixelDensityRatio + 1, position.y * $.pixelDensityRatio + 1, size.x * $.pixelDensityRatio - 2, size.y * $.pixelDensityRatio - 2);
            drawingHandler({
                context: context,
                tile: this,
                rendered: rendered
            });
            context.drawImage(rendered.canvas, 0, 0, rendered.canvas.width,
                rendered.canvas.height, position.x * $.pixelDensityRatio, position.y * $.pixelDensityRatio, size.x * $.pixelDensityRatio, size.y * $.pixelDensityRatio)
        },
        unload: function() {
            if (this.imgElement && this.imgElement.parentNode) this.imgElement.parentNode.removeChild(this.imgElement);
            if (this.element && this.element.parentNode) this.element.parentNode.removeChild(this.element);
            this.element = null;
            this.imgElement = null;
            this.loaded = false;
            this.loading = false
        }
    }
})(OpenSeadragon);
(function($) {
    $.OverlayPlacement = {
        CENTER: 0,
        TOP_LEFT: 1,
        TOP: 2,
        TOP_RIGHT: 3,
        RIGHT: 4,
        BOTTOM_RIGHT: 5,
        BOTTOM: 6,
        BOTTOM_LEFT: 7,
        LEFT: 8
    };
    $.Overlay = function(element, location, placement) {
        var options;
        if ($.isPlainObject(element)) options = element;
        else options = {
            element: element,
            location: location,
            placement: placement
        };
        this.element = options.element;
        this.scales = options.location instanceof $.Rect;
        this.bounds = new $.Rect(options.location.x, options.location.y, options.location.width, options.location.height);
        this.position = new $.Point(options.location.x,
            options.location.y);
        this.size = new $.Point(options.location.width, options.location.height);
        this.style = options.element.style;
        this.placement = options.location instanceof $.Point ? options.placement : $.OverlayPlacement.TOP_LEFT;
        this.onDraw = options.onDraw;
        this.checkResize = options.checkResize === undefined ? true : options.checkResize
    };
    $.Overlay.prototype = {
        adjust: function(position, size) {
            switch (this.placement) {
                case $.OverlayPlacement.TOP_LEFT:
                    break;
                case $.OverlayPlacement.TOP:
                    position.x -= size.x / 2;
                    break;
                case $.OverlayPlacement.TOP_RIGHT:
                    position.x -=
                        size.x;
                    break;
                case $.OverlayPlacement.RIGHT:
                    position.x -= size.x;
                    position.y -= size.y / 2;
                    break;
                case $.OverlayPlacement.BOTTOM_RIGHT:
                    position.x -= size.x;
                    position.y -= size.y;
                    break;
                case $.OverlayPlacement.BOTTOM:
                    position.x -= size.x / 2;
                    position.y -= size.y;
                    break;
                case $.OverlayPlacement.BOTTOM_LEFT:
                    position.y -= size.y;
                    break;
                case $.OverlayPlacement.LEFT:
                    position.y -= size.y / 2;
                    break;
                default:
                case $.OverlayPlacement.CENTER:
                    position.x -= size.x / 2;
                    position.y -= size.y / 2;
                    break
            }
        },
        destroy: function() {
            var element = this.element,
                style =
                this.style;
            if (element.parentNode) {
                element.parentNode.removeChild(element);
                if (element.prevElementParent) {
                    style.display = "none";
                    document.body.appendChild(element)
                }
            }
            this.onDraw = null;
            style.top = "";
            style.left = "";
            style.position = "";
            if (this.scales) {
                style.width = "";
                style.height = ""
            }
        },
        drawHTML: function(container, viewport) {
            var element = this.element,
                style = this.style,
                scales = this.scales,
                degrees = viewport.degrees,
                position = viewport.pixelFromPoint(this.bounds.getTopLeft(), true),
                size, overlayCenter;
            if (element.parentNode !=
                container) {
                element.prevElementParent = element.parentNode;
                element.prevNextSibling = element.nextSibling;
                container.appendChild(element);
                this.size = $.getElementSize(element)
            }
            if (scales) size = viewport.deltaPixelsFromPoints(this.bounds.getSize(), true);
            else if (this.checkResize) size = $.getElementSize(element);
            else size = this.size;
            this.position = position;
            this.size = size;
            this.adjust(position, size);
            position = position.apply(Math.floor);
            size = size.apply(Math.ceil);
            if (degrees !== 0 && this.scales) {
                overlayCenter = new $.Point(size.x /
                    2, size.y / 2);
                var drawerCenter = new $.Point(viewport.viewer.drawer.canvas.width / 2, viewport.viewer.drawer.canvas.height / 2);
                position = position.plus(overlayCenter).rotate(degrees, drawerCenter).minus(overlayCenter);
                size = size.rotate(degrees, new $.Point(0, 0));
                size = new $.Point(Math.abs(size.x), Math.abs(size.y))
            }
            if (this.onDraw) this.onDraw(position, size, element);
            else {
                style.left = position.x + "px";
                style.top = position.y + "px";
                style.position = "absolute";
                if (style.display != "none") style.display = "block";
                if (scales) {
                    style.width =
                        size.x + "px";
                    style.height = size.y + "px"
                }
            }
        },
        update: function(location, placement) {
            this.scales = location instanceof $.Rect;
            this.bounds = new $.Rect(location.x, location.y, location.width, location.height);
            this.placement = location instanceof $.Point ? placement : $.OverlayPlacement.TOP_LEFT
        }
    }
})(OpenSeadragon);
(function($) {
    $.Drawer = function(options) {
        $.console.assert(options.viewer, "[Drawer] options.viewer is required");
        var args = arguments;
        if (!$.isPlainObject(options)) options = {
            source: args[0],
            viewport: args[1],
            element: args[2]
        };
        $.console.assert(options.viewport, "[Drawer] options.viewport is required");
        $.console.assert(options.element, "[Drawer] options.element is required");
        if (options.source) $.console.error("[Drawer] options.source is no longer accepted; use TiledImage instead");
        this.viewer = options.viewer;
        this.viewport =
            options.viewport;
        this.debugGridColor = options.debugGridColor || $.DEFAULT_SETTINGS.debugGridColor;
        if (options.opacity) $.console.error("[Drawer] options.opacity is no longer accepted; set the opacity on the TiledImage instead");
        this.useCanvas = $.supportsCanvas && (this.viewer ? this.viewer.useCanvas : true);
        this.container = $.getElement(options.element);
        this.canvas = $.makeNeutralElement(this.useCanvas ? "canvas" : "div");
        this.context = this.useCanvas ? this.canvas.getContext("2d") : null;
        this.sketchCanvas = null;
        this.sketchContext =
            null;
        this.element = this.container;
        this.container.dir = "ltr";
        if (this.useCanvas) {
            var viewportSize = this._calculateCanvasSize();
            this.canvas.width = viewportSize.x;
            this.canvas.height = viewportSize.y
        }
        this.canvas.style.width = "100%";
        this.canvas.style.height = "100%";
        this.canvas.style.position = "absolute";
        $.setElementOpacity(this.canvas, this.opacity, true);
        this.container.style.textAlign = "left";
        this.container.appendChild(this.canvas)
    };
    $.Drawer.prototype = {
        addOverlay: function(element, location, placement, onDraw) {
            $.console.error("drawer.addOverlay is deprecated. Use viewer.addOverlay instead.");
            this.viewer.addOverlay(element, location, placement, onDraw);
            return this
        },
        updateOverlay: function(element, location, placement) {
            $.console.error("drawer.updateOverlay is deprecated. Use viewer.updateOverlay instead.");
            this.viewer.updateOverlay(element, location, placement);
            return this
        },
        removeOverlay: function(element) {
            $.console.error("drawer.removeOverlay is deprecated. Use viewer.removeOverlay instead.");
            this.viewer.removeOverlay(element);
            return this
        },
        clearOverlays: function() {
            $.console.error("drawer.clearOverlays is deprecated. Use viewer.clearOverlays instead.");
            this.viewer.clearOverlays();
            return this
        },
        setOpacity: function(opacity) {
            $.console.error("drawer.setOpacity is deprecated. Use tiledImage.setOpacity instead.");
            var world = this.viewer.world;
            for (var i = 0; i < world.getItemCount(); i++) world.getItemAt(i).setOpacity(opacity);
            return this
        },
        getOpacity: function() {
            $.console.error("drawer.getOpacity is deprecated. Use tiledImage.getOpacity instead.");
            var world = this.viewer.world;
            var maxOpacity = 0;
            for (var i = 0; i < world.getItemCount(); i++) {
                var opacity = world.getItemAt(i).getOpacity();
                if (opacity > maxOpacity) maxOpacity = opacity
            }
            return maxOpacity
        },
        needsUpdate: function() {
            $.console.error("[Drawer.needsUpdate] this function is deprecated. Use World.needsDraw instead.");
            return this.viewer.world.needsDraw()
        },
        numTilesLoaded: function() {
            $.console.error("[Drawer.numTilesLoaded] this function is deprecated. Use TileCache.numTilesLoaded instead.");
            return this.viewer.tileCache.numTilesLoaded()
        },
        reset: function() {
            $.console.error("[Drawer.reset] this function is deprecated. Use World.resetItems instead.");
            this.viewer.world.resetItems();
            return this
        },
        update: function() {
            $.console.error("[Drawer.update] this function is deprecated. Use Drawer.clear and World.draw instead.");
            this.clear();
            this.viewer.world.draw();
            return this
        },
        canRotate: function() {
            return this.useCanvas
        },
        destroy: function() {
            this.canvas.width = 1;
            this.canvas.height = 1;
            this.sketchCanvas = null;
            this.sketchContext = null
        },
        clear: function() {
            this.canvas.innerHTML = "";
            if (this.useCanvas) {
                var viewportSize = this._calculateCanvasSize();
                if (this.canvas.width != viewportSize.x ||
                    this.canvas.height != viewportSize.y) {
                    this.canvas.width = viewportSize.x;
                    this.canvas.height = viewportSize.y;
                    if (this.sketchCanvas !== null) {
                        this.sketchCanvas.width = this.canvas.width;
                        this.sketchCanvas.height = this.canvas.height
                    }
                }
                this._clear()
            }
        },
        _clear: function(useSketch) {
            if (!this.useCanvas) return;
            var context = this._getContext(useSketch);
            var canvas = context.canvas;
            context.clearRect(0, 0, canvas.width, canvas.height)
        },
        viewportToDrawerRectangle: function(rectangle) {
            var topLeft = this.viewport.pixelFromPoint(rectangle.getTopLeft(),
                true);
            var size = this.viewport.deltaPixelsFromPoints(rectangle.getSize(), true);
            return new $.Rect(topLeft.x * $.pixelDensityRatio, topLeft.y * $.pixelDensityRatio, size.x * $.pixelDensityRatio, size.y * $.pixelDensityRatio)
        },
        drawTile: function(tile, drawingHandler, useSketch) {
            $.console.assert(tile, "[Drawer.drawTile] tile is required");
            $.console.assert(drawingHandler, "[Drawer.drawTile] drawingHandler is required");
            if (this.useCanvas) {
                var context = this._getContext(useSketch);
                if (this.viewport.degrees !== 0) {
                    this._offsetForRotation(tile,
                        this.viewport.degrees, useSketch);
                    tile.drawCanvas(context, drawingHandler);
                    this._restoreRotationChanges(tile, useSketch)
                } else tile.drawCanvas(context, drawingHandler)
            } else tile.drawHTML(this.canvas)
        },
        _getContext: function(useSketch) {
            var context = this.context;
            if (useSketch) {
                if (this.sketchCanvas === null) {
                    this.sketchCanvas = document.createElement("canvas");
                    this.sketchCanvas.width = this.canvas.width;
                    this.sketchCanvas.height = this.canvas.height;
                    this.sketchContext = this.sketchCanvas.getContext("2d")
                }
                context = this.sketchContext
            }
            return context
        },
        saveContext: function(useSketch) {
            if (!this.useCanvas) return;
            this._getContext(useSketch).save()
        },
        restoreContext: function(useSketch) {
            if (!this.useCanvas) return;
            this._getContext(useSketch).restore()
        },
        setClip: function(rect, useSketch) {
            if (!this.useCanvas) return;
            var context = this._getContext(useSketch);
            context.beginPath();
            context.rect(rect.x, rect.y, rect.width, rect.height);
            context.clip()
        },
        drawRectangle: function(rect, fillStyle, useSketch) {
            if (!this.useCanvas) return;
            var context = this._getContext(useSketch);
            context.save();
            context.fillStyle = fillStyle;
            context.fillRect(rect.x, rect.y, rect.width, rect.height);
            context.restore()
        },
        blendSketch: function(opacity) {
            if (!this.useCanvas || !this.sketchCanvas) return;
            this.context.save();
            this.context.globalAlpha = opacity;
            this.context.drawImage(this.sketchCanvas, 0, 0);
            this.context.restore()
        },
        drawDebugInfo: function(tile, count, i) {
            if (!this.useCanvas) return;
            var context = this.context;
            context.save();
            context.lineWidth = 2 * $.pixelDensityRatio;
            context.font = "small-caps bold " + 13 * $.pixelDensityRatio + "px arial";
            context.strokeStyle = this.debugGridColor;
            context.fillStyle = this.debugGridColor;
            if (this.viewport.degrees !== 0) this._offsetForRotation(tile, this.viewport.degrees);
            context.strokeRect(tile.position.x * $.pixelDensityRatio, tile.position.y * $.pixelDensityRatio, tile.size.x * $.pixelDensityRatio, tile.size.y * $.pixelDensityRatio);
            var tileCenterX = (tile.position.x + tile.size.x / 2) * $.pixelDensityRatio;
            var tileCenterY = (tile.position.y + tile.size.y / 2) * $.pixelDensityRatio;
            context.translate(tileCenterX, tileCenterY);
            context.rotate(Math.PI /
                180 * -this.viewport.degrees);
            context.translate(-tileCenterX, -tileCenterY);
            if (tile.x === 0 && tile.y === 0) {
                context.fillText("Zoom: " + this.viewport.getZoom(), tile.position.x * $.pixelDensityRatio, (tile.position.y - 30) * $.pixelDensityRatio);
                context.fillText("Pan: " + this.viewport.getBounds().toString(), tile.position.x * $.pixelDensityRatio, (tile.position.y - 20) * $.pixelDensityRatio)
            }
            context.fillText("Level: " + tile.level, (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 20) * $.pixelDensityRatio);
            context.fillText("Column: " +
                tile.x, (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 30) * $.pixelDensityRatio);
            context.fillText("Row: " + tile.y, (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 40) * $.pixelDensityRatio);
            context.fillText("Order: " + i + " of " + count, (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 50) * $.pixelDensityRatio);
            context.fillText("Size: " + tile.size.toString(), (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 60) * $.pixelDensityRatio);
            context.fillText("Position: " + tile.position.toString(), (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 70) * $.pixelDensityRatio);
            if (this.viewport.degrees !== 0) this._restoreRotationChanges(tile);
            context.restore()
        },
        debugRect: function(rect) {
            if (this.useCanvas) {
                var context = this.context;
                context.save();
                context.lineWidth = 2 * $.pixelDensityRatio;
                context.strokeStyle = this.debugGridColor;
                context.fillStyle = this.debugGridColor;
                context.strokeRect(rect.x * $.pixelDensityRatio, rect.y * $.pixelDensityRatio, rect.width * $.pixelDensityRatio, rect.height * $.pixelDensityRatio);
                context.restore()
            }
        },
        _offsetForRotation: function(tile, degrees, useSketch) {
            var cx = this.canvas.width / 2,
                cy = this.canvas.height / 2,
                px = tile.position.x - cx,
                py = tile.position.y - cy;
            var context = this._getContext(useSketch);
            context.save();
            context.translate(cx, cy);
            context.rotate(Math.PI / 180 * degrees);
            tile.position.x = px;
            tile.position.y = py
        },
        _restoreRotationChanges: function(tile, useSketch) {
            var cx = this.canvas.width / 2,
                cy = this.canvas.height / 2,
                px = tile.position.x + cx,
                py = tile.position.y + cy;
            tile.position.x = px;
            tile.position.y =
                py;
            var context = this._getContext(useSketch);
            context.restore()
        },
        _calculateCanvasSize: function() {
            var pixelDensityRatio = $.pixelDensityRatio;
            var viewportSize = this.viewport.getContainerSize();
            return {
                x: viewportSize.x * pixelDensityRatio,
                y: viewportSize.y * pixelDensityRatio
            }
        }
    }
})(OpenSeadragon);
(function($) {
    $.Viewport = function(options) {
        var args = arguments;
        if (args.length && args[0] instanceof $.Point) options = {
            containerSize: args[0],
            contentSize: args[1],
            config: args[2]
        };
        if (options.config) {
            $.extend(true, options, options.config);
            delete options.config
        }
        this._margins = $.extend({
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
        }, options.margins || {});
        delete options.margins;
        $.extend(true, this, {
            containerSize: null,
            contentSize: null,
            zoomPoint: null,
            viewer: null,
            springStiffness: $.DEFAULT_SETTINGS.springStiffness,
            animationTime: $.DEFAULT_SETTINGS.animationTime,
            minZoomImageRatio: $.DEFAULT_SETTINGS.minZoomImageRatio,
            maxZoomPixelRatio: $.DEFAULT_SETTINGS.maxZoomPixelRatio,
            visibilityRatio: $.DEFAULT_SETTINGS.visibilityRatio,
            wrapHorizontal: $.DEFAULT_SETTINGS.wrapHorizontal,
            wrapVertical: $.DEFAULT_SETTINGS.wrapVertical,
            defaultZoomLevel: $.DEFAULT_SETTINGS.defaultZoomLevel,
            minZoomLevel: $.DEFAULT_SETTINGS.minZoomLevel,
            maxZoomLevel: $.DEFAULT_SETTINGS.maxZoomLevel,
            degrees: $.DEFAULT_SETTINGS.degrees,
            homeFillsViewer: $.DEFAULT_SETTINGS.homeFillsViewer
        }, options);
        this._containerInnerSize =
            new $.Point(Math.max(1, this.containerSize.x - (this._margins.left + this._margins.right)), Math.max(1, this.containerSize.y - (this._margins.top + this._margins.bottom)));
        this.centerSpringX = new $.Spring({
            initial: 0,
            springStiffness: this.springStiffness,
            animationTime: this.animationTime
        });
        this.centerSpringY = new $.Spring({
            initial: 0,
            springStiffness: this.springStiffness,
            animationTime: this.animationTime
        });
        this.zoomSpring = new $.Spring({
            exponential: true,
            initial: 1,
            springStiffness: this.springStiffness,
            animationTime: this.animationTime
        });
        this._oldCenterX = this.centerSpringX.current.value;
        this._oldCenterY = this.centerSpringY.current.value;
        this._oldZoom = this.zoomSpring.current.value;
        if (this.contentSize) this.resetContentSize(this.contentSize);
        else this.setHomeBounds(new $.Rect(0, 0, 1, 1), 1);
        this.goHome(true);
        this.update()
    };
    $.Viewport.prototype = {
        resetContentSize: function(contentSize) {
            $.console.assert(contentSize, "[Viewport.resetContentSize] contentSize is required");
            $.console.assert(contentSize instanceof $.Point, "[Viewport.resetContentSize] contentSize must be an OpenSeadragon.Point");
            $.console.assert(contentSize.x > 0, "[Viewport.resetContentSize] contentSize.x must be greater than 0");
            $.console.assert(contentSize.y > 0, "[Viewport.resetContentSize] contentSize.y must be greater than 0");
            this.setHomeBounds(new $.Rect(0, 0, 1, contentSize.y / contentSize.x), contentSize.x);
            return this
        },
        setHomeBounds: function(bounds, contentFactor) {
            $.console.assert(bounds, "[Viewport.setHomeBounds] bounds is required");
            $.console.assert(bounds instanceof $.Rect, "[Viewport.setHomeBounds] bounds must be an OpenSeadragon.Rect");
            $.console.assert(bounds.width > 0, "[Viewport.setHomeBounds] bounds.width must be greater than 0");
            $.console.assert(bounds.height > 0, "[Viewport.setHomeBounds] bounds.height must be greater than 0");
            this.homeBounds = bounds.clone();
            this.contentSize = this.homeBounds.getSize().times(contentFactor);
            this.contentAspectX = this.contentSize.x / this.contentSize.y;
            this.contentAspectY = this.contentSize.y / this.contentSize.x;
            if (this.viewer) this.viewer.raiseEvent("reset-size", {
                contentSize: this.contentSize.clone(),
                contentFactor: contentFactor,
                homeBounds: this.homeBounds.clone()
            })
        },
        getHomeZoom: function() {
            if (this.defaultZoomLevel) return this.defaultZoomLevel;
            else {
                var aspectFactor = this.contentAspectX / this.getAspectRatio();
                var output;
                if (this.homeFillsViewer) output = aspectFactor >= 1 ? aspectFactor : 1;
                else output = aspectFactor >= 1 ? 1 : aspectFactor;
                return output / this.homeBounds.width
            }
        },
        getHomeBounds: function() {
            var center = this.homeBounds.getCenter(),
                width = 1 / this.getHomeZoom(),
                height = width / this.getAspectRatio();
            return new $.Rect(center.x - width / 2, center.y -
                height / 2, width, height)
        },
        goHome: function(immediately) {
            if (this.viewer) this.viewer.raiseEvent("home", {
                immediately: immediately
            });
            return this.fitBounds(this.getHomeBounds(), immediately)
        },
        getMinZoom: function() {
            var homeZoom = this.getHomeZoom(),
                zoom = this.minZoomLevel ? this.minZoomLevel : this.minZoomImageRatio * homeZoom;
            return zoom
        },
        getMaxZoom: function() {
            var zoom = this.maxZoomLevel;
            if (!zoom) {
                zoom = this.contentSize.x * this.maxZoomPixelRatio / this._containerInnerSize.x;
                zoom /= this.homeBounds.width
            }
            return Math.max(zoom,
                this.getHomeZoom())
        },
        getAspectRatio: function() {
            return this._containerInnerSize.x / this._containerInnerSize.y
        },
        getContainerSize: function() {
            return new $.Point(this.containerSize.x, this.containerSize.y)
        },
        getBounds: function(current) {
            var center = this.getCenter(current),
                width = 1 / this.getZoom(current),
                height = width / this.getAspectRatio();
            return new $.Rect(center.x - width / 2, center.y - height / 2, width, height)
        },
        getBoundsWithMargins: function(current) {
            var bounds = this.getBounds(current);
            var factor = this._containerInnerSize.x *
                this.getZoom(current);
            bounds.x -= this._margins.left / factor;
            bounds.y -= this._margins.top / factor;
            bounds.width += (this._margins.left + this._margins.right) / factor;
            bounds.height += (this._margins.top + this._margins.bottom) / factor;
            return bounds
        },
        getCenter: function(current) {
            var centerCurrent = new $.Point(this.centerSpringX.current.value, this.centerSpringY.current.value),
                centerTarget = new $.Point(this.centerSpringX.target.value, this.centerSpringY.target.value),
                oldZoomPixel, zoom, width, height, bounds, newZoomPixel, deltaZoomPixels,
                deltaZoomPoints;
            if (current) return centerCurrent;
            else if (!this.zoomPoint) return centerTarget;
            oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
            zoom = this.getZoom();
            width = 1 / zoom;
            height = width / this.getAspectRatio();
            bounds = new $.Rect(centerCurrent.x - width / 2, centerCurrent.y - height / 2, width, height);
            newZoomPixel = this._pixelFromPoint(this.zoomPoint, bounds);
            deltaZoomPixels = newZoomPixel.minus(oldZoomPixel);
            deltaZoomPoints = deltaZoomPixels.divide(this._containerInnerSize.x * zoom);
            return centerTarget.plus(deltaZoomPoints)
        },
        getZoom: function(current) {
            if (current) return this.zoomSpring.current.value;
            else return this.zoomSpring.target.value
        },
        _applyBoundaryConstraints: function(bounds, immediately) {
            var dx = 0,
                dy = 0,
                newBounds = new $.Rect(bounds.x, bounds.y, bounds.width, bounds.height);
            var horizontalThreshold = this.visibilityRatio * newBounds.width;
            var verticalThreshold = this.visibilityRatio * newBounds.height;
            if (this.wrapHorizontal);
            else {
                var thresholdLeft = newBounds.x + (newBounds.width - horizontalThreshold);
                if (this.homeBounds.x > thresholdLeft) dx =
                    this.homeBounds.x - thresholdLeft;
                var homeRight = this.homeBounds.x + this.homeBounds.width;
                var thresholdRight = newBounds.x + horizontalThreshold;
                if (homeRight < thresholdRight) {
                    var newDx = homeRight - thresholdRight;
                    if (dx) dx = (dx + newDx) / 2;
                    else dx = newDx
                }
            }
            if (this.wrapVertical);
            else {
                var thresholdTop = newBounds.y + (newBounds.height - verticalThreshold);
                if (this.homeBounds.y > thresholdTop) dy = this.homeBounds.y - thresholdTop;
                var homeBottom = this.homeBounds.y + this.homeBounds.height;
                var thresholdBottom = newBounds.y + verticalThreshold;
                if (homeBottom < thresholdBottom) {
                    var newDy = homeBottom - thresholdBottom;
                    if (dy) dy = (dy + newDy) / 2;
                    else dy = newDy
                }
            }
            if (dx || dy) {
                newBounds.x += dx;
                newBounds.y += dy
            }
            if (this.viewer) this.viewer.raiseEvent("constrain", {
                immediately: immediately
            });
            return newBounds
        },
        applyConstraints: function(immediately) {
            var actualZoom = this.getZoom(),
                constrainedZoom = Math.max(Math.min(actualZoom, this.getMaxZoom()), this.getMinZoom()),
                bounds, constrainedBounds;
            if (actualZoom != constrainedZoom) this.zoomTo(constrainedZoom, this.zoomPoint, immediately);
            bounds = this.getBounds();
            constrainedBounds = this._applyBoundaryConstraints(bounds, immediately);
            if (bounds.x !== constrainedBounds.x || bounds.y !== constrainedBounds.y || immediately) this.fitBounds(constrainedBounds, immediately);
            return this
        },
        ensureVisible: function(immediately) {
            return this.applyConstraints(immediately)
        },
        _fitBounds: function(bounds, options) {
            options = options || {};
            var immediately = options.immediately || false;
            var constraints = options.constraints || false;
            var aspect = this.getAspectRatio(),
                center = bounds.getCenter(),
                newBounds = new $.Rect(bounds.x, bounds.y, bounds.width, bounds.height),
                oldBounds, oldZoom, newZoom, referencePoint, newBoundsAspectRatio, newConstrainedZoom;
            if (newBounds.getAspectRatio() >= aspect) {
                newBounds.height = bounds.width / aspect;
                newBounds.y = center.y - newBounds.height / 2
            } else {
                newBounds.width = bounds.height * aspect;
                newBounds.x = center.x - newBounds.width / 2
            }
            if (constraints) newBoundsAspectRatio = newBounds.getAspectRatio();
            this.panTo(this.getCenter(true), true);
            this.zoomTo(this.getZoom(true), null, true);
            oldBounds = this.getBounds();
            oldZoom = this.getZoom();
            newZoom = 1 / newBounds.width;
            if (constraints) {
                newConstrainedZoom = Math.max(Math.min(newZoom, this.getMaxZoom()), this.getMinZoom());
                if (newZoom !== newConstrainedZoom) {
                    newZoom = newConstrainedZoom;
                    newBounds.width = 1 / newZoom;
                    newBounds.x = center.x - newBounds.width / 2;
                    newBounds.height = newBounds.width / newBoundsAspectRatio;
                    newBounds.y = center.y - newBounds.height / 2
                }
                newBounds = this._applyBoundaryConstraints(newBounds, immediately);
                center = newBounds.getCenter()
            }
            if (immediately) {
                this.panTo(center, true);
                return this.zoomTo(newZoom,
                    null, true)
            }
            if (Math.abs(newZoom - oldZoom) < 1E-8 || Math.abs(newBounds.width - oldBounds.width) < 1E-8) return this.panTo(center, immediately);
            referencePoint = oldBounds.getTopLeft().times(this._containerInnerSize.x / oldBounds.width).minus(newBounds.getTopLeft().times(this._containerInnerSize.x / newBounds.width)).divide(this._containerInnerSize.x / oldBounds.width - this._containerInnerSize.x / newBounds.width);
            return this.zoomTo(newZoom, referencePoint, immediately)
        },
        fitBounds: function(bounds, immediately) {
            return this._fitBounds(bounds, {
                immediately: immediately,
                constraints: false
            })
        },
        fitBoundsWithConstraints: function(bounds, immediately) {
            return this._fitBounds(bounds, {
                immediately: immediately,
                constraints: true
            })
        },
        fitVertically: function(immediately) {
            var box = new $.Rect(this.homeBounds.x + this.homeBounds.width / 2, this.homeBounds.y, 0, this.homeBounds.height);
            return this.fitBounds(box, immediately)
        },
        fitHorizontally: function(immediately) {
            var box = new $.Rect(this.homeBounds.x, this.homeBounds.y + this.homeBounds.height / 2, this.homeBounds.width, 0);
            return this.fitBounds(box,
                immediately)
        },
        panBy: function(delta, immediately) {
            var center = new $.Point(this.centerSpringX.target.value, this.centerSpringY.target.value);
            delta = delta.rotate(-this.degrees, new $.Point(0, 0));
            return this.panTo(center.plus(delta), immediately)
        },
        panTo: function(center, immediately) {
            if (immediately) {
                this.centerSpringX.resetTo(center.x);
                this.centerSpringY.resetTo(center.y)
            } else {
                this.centerSpringX.springTo(center.x);
                this.centerSpringY.springTo(center.y)
            }
            if (this.viewer) this.viewer.raiseEvent("pan", {
                center: center,
                immediately: immediately
            });
            return this
        },
        zoomBy: function(factor, refPoint, immediately) {
            if (refPoint instanceof $.Point && !isNaN(refPoint.x) && !isNaN(refPoint.y)) refPoint = refPoint.rotate(-this.degrees, new $.Point(this.centerSpringX.target.value, this.centerSpringY.target.value));
            return this.zoomTo(this.zoomSpring.target.value * factor, refPoint, immediately)
        },
        zoomTo: function(zoom, refPoint, immediately) {
            this.zoomPoint = refPoint instanceof $.Point && !isNaN(refPoint.x) && !isNaN(refPoint.y) ? refPoint : null;
            if (immediately) this.zoomSpring.resetTo(zoom);
            else this.zoomSpring.springTo(zoom);
            if (this.viewer) this.viewer.raiseEvent("zoom", {
                zoom: zoom,
                refPoint: refPoint,
                immediately: immediately
            });
            return this
        },
        setRotation: function(degrees) {
            if (!(this.viewer && this.viewer.drawer.canRotate())) return this;
            degrees = (degrees + 360) % 360;
            this.degrees = degrees;
            this.viewer.forceRedraw();
            if (this.viewer !== null) this.viewer.raiseEvent("rotate", {
                "degrees": degrees
            });
            return this
        },
        getRotation: function() {
            return this.degrees
        },
        resize: function(newContainerSize, maintain) {
            var oldBounds =
                this.getBounds(),
                newBounds = oldBounds,
                widthDeltaFactor;
            this.containerSize.x = newContainerSize.x;
            this.containerSize.y = newContainerSize.y;
            this._containerInnerSize = new $.Point(Math.max(1, newContainerSize.x - (this._margins.left + this._margins.right)), Math.max(1, newContainerSize.y - (this._margins.top + this._margins.bottom)));
            if (maintain) {
                widthDeltaFactor = newContainerSize.x / this.containerSize.x;
                newBounds.width = oldBounds.width * widthDeltaFactor;
                newBounds.height = newBounds.width / this.getAspectRatio()
            }
            if (this.viewer) this.viewer.raiseEvent("resize", {
                newContainerSize: newContainerSize,
                maintain: maintain
            });
            return this.fitBounds(newBounds, true)
        },
        update: function() {
            var oldZoomPixel, newZoomPixel, deltaZoomPixels, deltaZoomPoints;
            if (this.zoomPoint) oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
            this.zoomSpring.update();
            if (this.zoomPoint && this.zoomSpring.current.value != this._oldZoom) {
                newZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
                deltaZoomPixels = newZoomPixel.minus(oldZoomPixel);
                deltaZoomPoints = this.deltaPointsFromPixels(deltaZoomPixels, true);
                this.centerSpringX.shiftBy(deltaZoomPoints.x);
                this.centerSpringY.shiftBy(deltaZoomPoints.y)
            } else this.zoomPoint = null;
            this.centerSpringX.update();
            this.centerSpringY.update();
            var changed = this.centerSpringX.current.value != this._oldCenterX || this.centerSpringY.current.value != this._oldCenterY || this.zoomSpring.current.value != this._oldZoom;
            this._oldCenterX = this.centerSpringX.current.value;
            this._oldCenterY = this.centerSpringY.current.value;
            this._oldZoom = this.zoomSpring.current.value;
            return changed
        },
        deltaPixelsFromPoints: function(deltaPoints,
            current) {
            return deltaPoints.times(this._containerInnerSize.x * this.getZoom(current))
        },
        deltaPointsFromPixels: function(deltaPixels, current) {
            return deltaPixels.divide(this._containerInnerSize.x * this.getZoom(current))
        },
        pixelFromPoint: function(point, current) {
            return this._pixelFromPoint(point, this.getBounds(current))
        },
        _pixelFromPoint: function(point, bounds) {
            return point.minus(bounds.getTopLeft()).times(this._containerInnerSize.x / bounds.width).plus(new $.Point(this._margins.left, this._margins.top))
        },
        pointFromPixel: function(pixel,
            current) {
            var bounds = this.getBounds(current);
            return pixel.minus(new $.Point(this._margins.left, this._margins.top)).divide(this._containerInnerSize.x / bounds.width).plus(bounds.getTopLeft())
        },
        _viewportToImageDelta: function(viewerX, viewerY) {
            var scale = this.homeBounds.width;
            return new $.Point(viewerX * (this.contentSize.x / scale), viewerY * (this.contentSize.y * this.contentAspectX / scale))
        },
        viewportToImageCoordinates: function(viewerX, viewerY) {
            if (arguments.length == 1) return this.viewportToImageCoordinates(viewerX.x,
                viewerX.y);
            if (this.viewer && this.viewer.world.getItemCount() > 1) $.console.error("[Viewport.viewportToImageCoordinates] is not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.");
            return this._viewportToImageDelta(viewerX - this.homeBounds.x, viewerY - this.homeBounds.y)
        },
        _imageToViewportDelta: function(imageX, imageY) {
            var scale = this.homeBounds.width;
            return new $.Point(imageX / this.contentSize.x * scale, imageY / this.contentSize.y / this.contentAspectX * scale)
        },
        imageToViewportCoordinates: function(imageX,
            imageY) {
            if (arguments.length == 1) return this.imageToViewportCoordinates(imageX.x, imageX.y);
            if (this.viewer && this.viewer.world.getItemCount() > 1) $.console.error("[Viewport.imageToViewportCoordinates] is not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.");
            var point = this._imageToViewportDelta(imageX, imageY);
            point.x += this.homeBounds.x;
            point.y += this.homeBounds.y;
            return point
        },
        imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight) {
            var coordA, coordB, rect;
            if (arguments.length ==
                1) {
                rect = imageX;
                return this.imageToViewportRectangle(rect.x, rect.y, rect.width, rect.height)
            }
            coordA = this.imageToViewportCoordinates(imageX, imageY);
            coordB = this._imageToViewportDelta(pixelWidth, pixelHeight);
            return new $.Rect(coordA.x, coordA.y, coordB.x, coordB.y)
        },
        viewportToImageRectangle: function(viewerX, viewerY, pointWidth, pointHeight) {
            var coordA, coordB, rect;
            if (arguments.length == 1) {
                rect = viewerX;
                return this.viewportToImageRectangle(rect.x, rect.y, rect.width, rect.height)
            }
            coordA = this.viewportToImageCoordinates(viewerX,
                viewerY);
            coordB = this._viewportToImageDelta(pointWidth, pointHeight);
            return new $.Rect(coordA.x, coordA.y, coordB.x, coordB.y)
        },
        viewerElementToImageCoordinates: function(pixel) {
            var point = this.pointFromPixel(pixel, true);
            return this.viewportToImageCoordinates(point)
        },
        imageToViewerElementCoordinates: function(pixel) {
            var point = this.imageToViewportCoordinates(pixel);
            return this.pixelFromPoint(point, true)
        },
        windowToImageCoordinates: function(pixel) {
            var viewerCoordinates = pixel.minus(OpenSeadragon.getElementPosition(this.viewer.element));
            return this.viewerElementToImageCoordinates(viewerCoordinates)
        },
        imageToWindowCoordinates: function(pixel) {
            var viewerCoordinates = this.imageToViewerElementCoordinates(pixel);
            return viewerCoordinates.plus(OpenSeadragon.getElementPosition(this.viewer.element))
        },
        viewerElementToViewportCoordinates: function(pixel) {
            return this.pointFromPixel(pixel, true)
        },
        viewportToViewerElementCoordinates: function(point) {
            return this.pixelFromPoint(point, true)
        },
        windowToViewportCoordinates: function(pixel) {
            var viewerCoordinates =
                pixel.minus(OpenSeadragon.getElementPosition(this.viewer.element));
            return this.viewerElementToViewportCoordinates(viewerCoordinates)
        },
        viewportToWindowCoordinates: function(point) {
            var viewerCoordinates = this.viewportToViewerElementCoordinates(point);
            return viewerCoordinates.plus(OpenSeadragon.getElementPosition(this.viewer.element))
        },
        viewportToImageZoom: function(viewportZoom) {
            if (this.viewer && this.viewer.world.getItemCount() > 1) $.console.error("[Viewport.viewportToImageZoom] is not accurate with multi-image.");
            var imageWidth = this.contentSize.x;
            var containerWidth = this._containerInnerSize.x;
            var scale = this.homeBounds.width;
            var viewportToImageZoomRatio = containerWidth / imageWidth * scale;
            return viewportZoom * viewportToImageZoomRatio
        },
        imageToViewportZoom: function(imageZoom) {
            if (this.viewer && this.viewer.world.getItemCount() > 1) $.console.error("[Viewport.imageToViewportZoom] is not accurate with multi-image.");
            var imageWidth = this.contentSize.x;
            var containerWidth = this._containerInnerSize.x;
            var scale = this.homeBounds.width;
            var viewportToImageZoomRatio = imageWidth / containerWidth / scale;
            return imageZoom * viewportToImageZoomRatio
        }
    }
})(OpenSeadragon);
(function($) {
    $.TiledImage = function(options) {
        var _this = this;
        $.console.assert(options.tileCache, "[TiledImage] options.tileCache is required");
        $.console.assert(options.drawer, "[TiledImage] options.drawer is required");
        $.console.assert(options.viewer, "[TiledImage] options.viewer is required");
        $.console.assert(options.imageLoader, "[TiledImage] options.imageLoader is required");
        $.console.assert(options.source, "[TiledImage] options.source is required");
        $.console.assert(!options.clip || options.clip instanceof $.Rect, "[TiledImage] options.clip must be an OpenSeadragon.Rect if present");
        $.EventSource.call(this);
        this._tileCache = options.tileCache;
        delete options.tileCache;
        this._drawer = options.drawer;
        delete options.drawer;
        this._imageLoader = options.imageLoader;
        delete options.imageLoader;
        if (options.clip instanceof $.Rect) this._clip = options.clip.clone();
        delete options.clip;
        var x = options.x || 0;
        delete options.x;
        var y = options.y || 0;
        delete options.y;
        this.normHeight = options.source.dimensions.y / options.source.dimensions.x;
        this.contentAspectX = options.source.dimensions.x / options.source.dimensions.y;
        var scale = 1;
        if (options.width) {
            scale = options.width;
            delete options.width;
            if (options.height) {
                $.console.error("specifying both width and height to a tiledImage is not supported");
                delete options.height
            }
        } else if (options.height) {
            scale = options.height / this.normHeight;
            delete options.height
        }
        $.extend(true, this, {
            viewer: null,
            tilesMatrix: {},
            coverage: {},
            lastDrawn: [],
            lastResetTime: 0,
            _midDraw: false,
            _needsDraw: true,
            springStiffness: $.DEFAULT_SETTINGS.springStiffness,
            animationTime: $.DEFAULT_SETTINGS.animationTime,
            minZoomImageRatio: $.DEFAULT_SETTINGS.minZoomImageRatio,
            wrapHorizontal: $.DEFAULT_SETTINGS.wrapHorizontal,
            wrapVertical: $.DEFAULT_SETTINGS.wrapVertical,
            immediateRender: $.DEFAULT_SETTINGS.immediateRender,
            blendTime: $.DEFAULT_SETTINGS.blendTime,
            alwaysBlend: $.DEFAULT_SETTINGS.alwaysBlend,
            minPixelRatio: $.DEFAULT_SETTINGS.minPixelRatio,
            debugMode: $.DEFAULT_SETTINGS.debugMode,
            crossOriginPolicy: $.DEFAULT_SETTINGS.crossOriginPolicy,
            placeholderFillStyle: $.DEFAULT_SETTINGS.placeholderFillStyle,
            opacity: $.DEFAULT_SETTINGS.opacity
        }, options);
        this._xSpring = new $.Spring({
            initial: x,
            springStiffness: this.springStiffness,
            animationTime: this.animationTime
        });
        this._ySpring = new $.Spring({
            initial: y,
            springStiffness: this.springStiffness,
            animationTime: this.animationTime
        });
        this._scaleSpring = new $.Spring({
            initial: scale,
            springStiffness: this.springStiffness,
            animationTime: this.animationTime
        });
        this._updateForScale();
        this._drawingHandler = function(args) {
            _this.viewer.raiseEvent("tile-drawing", $.extend({
                    tiledImage: _this
                },
                args))
        }
    };
    $.extend($.TiledImage.prototype, $.EventSource.prototype, {
        needsDraw: function() {
            return this._needsDraw
        },
        reset: function() {
            this._tileCache.clearTilesFor(this);
            this.lastResetTime = $.now();
            this._needsDraw = true
        },
        update: function() {
            var oldX = this._xSpring.current.value;
            var oldY = this._ySpring.current.value;
            var oldScale = this._scaleSpring.current.value;
            this._xSpring.update();
            this._ySpring.update();
            this._scaleSpring.update();
            if (this._xSpring.current.value !== oldX || this._ySpring.current.value !== oldY || this._scaleSpring.current.value !==
                oldScale) {
                this._updateForScale();
                this._needsDraw = true;
                return true
            }
            return false
        },
        draw: function() {
            this._midDraw = true;
            updateViewport(this);
            this._midDraw = false
        },
        destroy: function() {
            this.reset()
        },
        getBounds: function(current) {
            if (current) return new $.Rect(this._xSpring.current.value, this._ySpring.current.value, this._worldWidthCurrent, this._worldHeightCurrent);
            return new $.Rect(this._xSpring.target.value, this._ySpring.target.value, this._worldWidthTarget, this._worldHeightTarget)
        },
        getWorldBounds: function() {
            $.console.error("[TiledImage.getWorldBounds] is deprecated; use TiledImage.getBounds instead");
            return this.getBounds()
        },
        getContentSize: function() {
            return new $.Point(this.source.dimensions.x, this.source.dimensions.y)
        },
        _viewportToImageDelta: function(viewerX, viewerY, current) {
            var scale = current ? this._scaleSpring.current.value : this._scaleSpring.target.value;
            return new $.Point(viewerX * (this.source.dimensions.x / scale), viewerY * (this.source.dimensions.y * this.contentAspectX / scale))
        },
        viewportToImageCoordinates: function(viewerX, viewerY, current) {
            if (viewerX instanceof $.Point) {
                current = viewerY;
                viewerY = viewerX.y;
                viewerX = viewerX.x
            }
            if (current) return this._viewportToImageDelta(viewerX - this._xSpring.current.value, viewerY - this._ySpring.current.value);
            return this._viewportToImageDelta(viewerX - this._xSpring.target.value, viewerY - this._ySpring.target.value)
        },
        _imageToViewportDelta: function(imageX, imageY, current) {
            var scale = current ? this._scaleSpring.current.value : this._scaleSpring.target.value;
            return new $.Point(imageX / this.source.dimensions.x * scale, imageY / this.source.dimensions.y / this.contentAspectX * scale)
        },
        imageToViewportCoordinates: function(imageX,
            imageY, current) {
            if (imageX instanceof $.Point) {
                current = imageY;
                imageY = imageX.y;
                imageX = imageX.x
            }
            var point = this._imageToViewportDelta(imageX, imageY);
            if (current) {
                point.x += this._xSpring.current.value;
                point.y += this._ySpring.current.value
            } else {
                point.x += this._xSpring.target.value;
                point.y += this._ySpring.target.value
            }
            return point
        },
        imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight, current) {
            if (imageX instanceof $.Rect) {
                current = imageY;
                pixelWidth = imageX.width;
                pixelHeight = imageX.height;
                imageY =
                    imageX.y;
                imageX = imageX.x
            }
            var coordA = this.imageToViewportCoordinates(imageX, imageY, current);
            var coordB = this._imageToViewportDelta(pixelWidth, pixelHeight, current);
            return new $.Rect(coordA.x, coordA.y, coordB.x, coordB.y)
        },
        viewportToImageRectangle: function(viewerX, viewerY, pointWidth, pointHeight, current) {
            if (viewerX instanceof $.Rect) {
                current = viewerY;
                pointWidth = viewerX.width;
                pointHeight = viewerX.height;
                viewerY = viewerX.y;
                viewerX = viewerX.x
            }
            var coordA = this.viewportToImageCoordinates(viewerX, viewerY, current);
            var coordB = this._viewportToImageDelta(pointWidth, pointHeight, current);
            return new $.Rect(coordA.x, coordA.y, coordB.x, coordB.y)
        },
        viewerElementToImageCoordinates: function(pixel) {
            var point = this.viewport.pointFromPixel(pixel, true);
            return this.viewportToImageCoordinates(point)
        },
        imageToViewerElementCoordinates: function(pixel) {
            var point = this.imageToViewportCoordinates(pixel);
            return this.viewport.pixelFromPoint(point, true)
        },
        windowToImageCoordinates: function(pixel) {
            var viewerCoordinates = pixel.minus(OpenSeadragon.getElementPosition(this.viewer.element));
            return this.viewerElementToImageCoordinates(viewerCoordinates)
        },
        imageToWindowCoordinates: function(pixel) {
            var viewerCoordinates = this.imageToViewerElementCoordinates(pixel);
            return viewerCoordinates.plus(OpenSeadragon.getElementPosition(this.viewer.element))
        },
        viewportToImageZoom: function(viewportZoom) {
            var ratio = this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x;
            return ratio * viewportZoom
        },
        imageToViewportZoom: function(imageZoom) {
            var ratio = this._scaleSpring.current.value *
                this.viewport._containerInnerSize.x / this.source.dimensions.x;
            return imageZoom / ratio
        },
        setPosition: function(position, immediately) {
            var sameTarget = this._xSpring.target.value === position.x && this._ySpring.target.value === position.y;
            if (immediately) {
                if (sameTarget && this._xSpring.current.value === position.x && this._ySpring.current.value === position.y) return;
                this._xSpring.resetTo(position.x);
                this._ySpring.resetTo(position.y)
            } else {
                if (sameTarget) return;
                this._xSpring.springTo(position.x);
                this._ySpring.springTo(position.y)
            }
            if (!sameTarget) this._raiseBoundsChange()
        },
        setWidth: function(width, immediately) {
            this._setScale(width, immediately)
        },
        setHeight: function(height, immediately) {
            this._setScale(height / this.normHeight, immediately)
        },
        getClip: function() {
            if (this._clip) return this._clip.clone();
            return null
        },
        setClip: function(newClip) {
            $.console.assert(!newClip || newClip instanceof $.Rect, "[TiledImage.setClip] newClip must be an OpenSeadragon.Rect or null");
            if (newClip instanceof $.Rect) this._clip = newClip.clone();
            else this._clip = null;
            this._needsDraw = true
        },
        getOpacity: function() {
            return this.opacity
        },
        setOpacity: function(opacity) {
            this.opacity = opacity;
            this._needsDraw = true
        },
        _setScale: function(scale, immediately) {
            var sameTarget = this._scaleSpring.target.value === scale;
            if (immediately) {
                if (sameTarget && this._scaleSpring.current.value === scale) return;
                this._scaleSpring.resetTo(scale);
                this._updateForScale()
            } else {
                if (sameTarget) return;
                this._scaleSpring.springTo(scale);
                this._updateForScale()
            }
            if (!sameTarget) this._raiseBoundsChange()
        },
        _updateForScale: function() {
            this._worldWidthTarget = this._scaleSpring.target.value;
            this._worldHeightTarget = this.normHeight * this._scaleSpring.target.value;
            this._worldWidthCurrent = this._scaleSpring.current.value;
            this._worldHeightCurrent = this.normHeight * this._scaleSpring.current.value
        },
        _raiseBoundsChange: function() {
            this.raiseEvent("bounds-change")
        }
    });

    function updateViewport(tiledImage) {
        tiledImage._needsDraw = false;
        var tile, level, best = null,
            haveDrawn = false,
            currentTime = $.now(),
            viewportBounds = tiledImage.viewport.getBoundsWithMargins(true),
            zeroRatioC = tiledImage.viewport.deltaPixelsFromPoints(tiledImage.source.getPixelRatio(0),
                true).x * tiledImage._scaleSpring.current.value,
            lowestLevel = Math.max(tiledImage.source.minLevel, Math.floor(Math.log(tiledImage.minZoomImageRatio) / Math.log(2))),
            highestLevel = Math.min(Math.abs(tiledImage.source.maxLevel), Math.abs(Math.floor(Math.log(zeroRatioC / tiledImage.minPixelRatio) / Math.log(2)))),
            degrees = tiledImage.viewport.degrees,
            renderPixelRatioC, renderPixelRatioT, zeroRatioT, optimalRatio, levelOpacity, levelVisibility;
        viewportBounds.x -= tiledImage._xSpring.current.value;
        viewportBounds.y -= tiledImage._ySpring.current.value;
        while (tiledImage.lastDrawn.length > 0) {
            tile = tiledImage.lastDrawn.pop();
            tile.beingDrawn = false
        }
        if (degrees === 90 || degrees === 270) viewportBounds = viewportBounds.rotate(degrees);
        else if (degrees !== 0 && degrees !== 180) {
            var orthBounds = viewportBounds.rotate(90);
            viewportBounds.x -= orthBounds.width / 2;
            viewportBounds.y -= orthBounds.height / 2;
            viewportBounds.width += orthBounds.width;
            viewportBounds.height += orthBounds.height
        }
        var viewportTL = viewportBounds.getTopLeft();
        var viewportBR = viewportBounds.getBottomRight();
        if (!tiledImage.wrapHorizontal &&
            (viewportBR.x < 0 || viewportTL.x > tiledImage._worldWidthCurrent)) return;
        if (!tiledImage.wrapVertical && (viewportBR.y < 0 || viewportTL.y > tiledImage._worldHeightCurrent)) return;
        if (!tiledImage.wrapHorizontal) {
            viewportTL.x = Math.max(viewportTL.x, 0);
            viewportBR.x = Math.min(viewportBR.x, tiledImage._worldWidthCurrent)
        }
        if (!tiledImage.wrapVertical) {
            viewportTL.y = Math.max(viewportTL.y, 0);
            viewportBR.y = Math.min(viewportBR.y, tiledImage._worldHeightCurrent)
        }
        lowestLevel = Math.min(lowestLevel, highestLevel);
        var drawLevel;
        for (level =
            highestLevel; level >= lowestLevel; level--) {
            drawLevel = false;
            renderPixelRatioC = tiledImage.viewport.deltaPixelsFromPoints(tiledImage.source.getPixelRatio(level), true).x * tiledImage._scaleSpring.current.value;
            if (!haveDrawn && renderPixelRatioC >= tiledImage.minPixelRatio || level == lowestLevel) {
                drawLevel = true;
                haveDrawn = true
            } else if (!haveDrawn) continue;
            renderPixelRatioT = tiledImage.viewport.deltaPixelsFromPoints(tiledImage.source.getPixelRatio(level), false).x * tiledImage._scaleSpring.current.value;
            zeroRatioT = tiledImage.viewport.deltaPixelsFromPoints(tiledImage.source.getPixelRatio(Math.max(tiledImage.source.getClosestLevel(tiledImage.viewport.containerSize) -
                1, 0)), false).x * tiledImage._scaleSpring.current.value;
            optimalRatio = tiledImage.immediateRender ? 1 : zeroRatioT;
            levelOpacity = Math.min(1, (renderPixelRatioC - .5) / .5);
            levelVisibility = optimalRatio / Math.abs(optimalRatio - renderPixelRatioT);
            best = updateLevel(tiledImage, haveDrawn, drawLevel, level, levelOpacity, levelVisibility, viewportTL, viewportBR, currentTime, best);
            if (providesCoverage(tiledImage.coverage, level)) break
        }
        drawTiles(tiledImage, tiledImage.lastDrawn);
        if (best) loadTile(tiledImage, best, currentTime)
    }

    function updateLevel(tiledImage,
        haveDrawn, drawLevel, level, levelOpacity, levelVisibility, viewportTL, viewportBR, currentTime, best) {
        var x, y, tileTL, tileBR, numberOfTiles, viewportCenter = tiledImage.viewport.pixelFromPoint(tiledImage.viewport.getCenter());
        if (tiledImage.viewer) tiledImage.viewer.raiseEvent("update-level", {
            tiledImage: tiledImage,
            havedrawn: haveDrawn,
            level: level,
            opacity: levelOpacity,
            visibility: levelVisibility,
            topleft: viewportTL,
            bottomright: viewportBR,
            currenttime: currentTime,
            best: best
        });
        tileTL = tiledImage.source.getTileAtPoint(level,
            viewportTL.divide(tiledImage._scaleSpring.current.value));
        tileBR = tiledImage.source.getTileAtPoint(level, viewportBR.divide(tiledImage._scaleSpring.current.value));
        numberOfTiles = tiledImage.source.getNumTiles(level);
        resetCoverage(tiledImage.coverage, level);
        if (!tiledImage.wrapHorizontal) tileBR.x = Math.min(tileBR.x, numberOfTiles.x - 1);
        if (!tiledImage.wrapVertical) tileBR.y = Math.min(tileBR.y, numberOfTiles.y - 1);
        for (x = tileTL.x; x <= tileBR.x; x++)
            for (y = tileTL.y; y <= tileBR.y; y++) best = updateTile(tiledImage, drawLevel,
                haveDrawn, x, y, level, levelOpacity, levelVisibility, viewportCenter, numberOfTiles, currentTime, best);
        return best
    }

    function updateTile(tiledImage, drawLevel, haveDrawn, x, y, level, levelOpacity, levelVisibility, viewportCenter, numberOfTiles, currentTime, best) {
        var tile = getTile(x, y, level, tiledImage.source, tiledImage.tilesMatrix, currentTime, numberOfTiles, tiledImage._worldWidthCurrent, tiledImage._worldHeightCurrent),
            drawTile = drawLevel;
        if (tiledImage.viewer) tiledImage.viewer.raiseEvent("update-tile", {
            tiledImage: tiledImage,
            tile: tile
        });
        setCoverage(tiledImage.coverage, level, x, y, false);
        if (!tile.exists) return best;
        if (haveDrawn && !drawTile)
            if (isCovered(tiledImage.coverage, level, x, y)) setCoverage(tiledImage.coverage, level, x, y, true);
            else drawTile = true;
        if (!drawTile) return best;
        positionTile(tile, tiledImage.source.tileOverlap, tiledImage.viewport, viewportCenter, levelVisibility, tiledImage);
        if (!tile.loaded) {
            var imageRecord = tiledImage._tileCache.getImageRecord(tile.url);
            if (imageRecord) {
                var image = imageRecord.getImage();
                setTileLoaded(tiledImage,
                    tile, image)
            }
        }
        if (tile.loaded) {
            var needsDraw = blendTile(tiledImage, tile, x, y, level, levelOpacity, currentTime);
            if (needsDraw) tiledImage._needsDraw = true
        } else if (tile.loading);
        else best = compareTiles(best, tile);
        return best
    }

    function getTile(x, y, level, tileSource, tilesMatrix, time, numTiles, worldWidth, worldHeight) {
        var xMod, yMod, bounds, exists, url, tile;
        if (!tilesMatrix[level]) tilesMatrix[level] = {};
        if (!tilesMatrix[level][x]) tilesMatrix[level][x] = {};
        if (!tilesMatrix[level][x][y]) {
            xMod = (numTiles.x + x % numTiles.x) % numTiles.x;
            yMod = (numTiles.y + y % numTiles.y) % numTiles.y;
            bounds = tileSource.getTileBounds(level, xMod, yMod);
            exists = tileSource.tileExists(level, xMod, yMod);
            url = tileSource.getTileUrl(level, xMod, yMod);
            bounds.x += (x - xMod) / numTiles.x;
            bounds.y += worldHeight / worldWidth * ((y - yMod) / numTiles.y);
            tilesMatrix[level][x][y] = new $.Tile(level, x, y, bounds, exists, url)
        }
        tile = tilesMatrix[level][x][y];
        tile.lastTouchTime = time;
        return tile
    }

    function loadTile(tiledImage, tile, time) {
        tile.loading = true;
        tiledImage._imageLoader.addJob({
            src: tile.url,
            crossOriginPolicy: tiledImage.crossOriginPolicy,
            callback: function(image, errorMsg) {
                onTileLoad(tiledImage, tile, time, image, errorMsg)
            },
            abort: function() {
                tile.loading = false
            }
        })
    }

    function onTileLoad(tiledImage, tile, time, image, errorMsg) {
        if (!image) {
            $.console.log("Tile %s failed to load: %s - error: %s", tile, tile.url, errorMsg);
            if (!tiledImage.debugMode) {
                tile.loading = false;
                tile.exists = false;
                return
            }
        } else if (time < tiledImage.lastResetTime) {
            $.console.log("Ignoring tile %s loaded before reset: %s", tile, tile.url);
            tile.loading = false;
            return
        }
        var finish = function() {
            var cutoff =
                Math.ceil(Math.log(tiledImage.source.getTileWidth(tile.level)) / Math.log(2));
            setTileLoaded(tiledImage, tile, image, cutoff)
        };
        if (!tiledImage._midDraw) finish();
        else window.setTimeout(finish, 1)
    }

    function setTileLoaded(tiledImage, tile, image, cutoff) {
        var increment = 0;

        function getCompletionCallback() {
            increment++;
            return completionCallback
        }

        function completionCallback() {
            increment--;
            if (increment === 0) {
                tile.loading = false;
                tile.loaded = true;
                tiledImage._tileCache.cacheTile({
                    image: image,
                    tile: tile,
                    cutoff: cutoff,
                    tiledImage: tiledImage
                });
                tiledImage._needsDraw = true
            }
        }
        tiledImage.viewer.raiseEvent("tile-loaded", {
            tile: tile,
            tiledImage: tiledImage,
            image: image,
            getCompletionCallback: getCompletionCallback
        });
        getCompletionCallback()()
    }

    function positionTile(tile, overlap, viewport, viewportCenter, levelVisibility, tiledImage) {
        var boundsTL = tile.bounds.getTopLeft();
        boundsTL.x *= tiledImage._scaleSpring.current.value;
        boundsTL.y *= tiledImage._scaleSpring.current.value;
        boundsTL.x += tiledImage._xSpring.current.value;
        boundsTL.y += tiledImage._ySpring.current.value;
        var boundsSize = tile.bounds.getSize();
        boundsSize.x *= tiledImage._scaleSpring.current.value;
        boundsSize.y *= tiledImage._scaleSpring.current.value;
        var positionC = viewport.pixelFromPoint(boundsTL, true),
            positionT = viewport.pixelFromPoint(boundsTL, false),
            sizeC = viewport.deltaPixelsFromPoints(boundsSize, true),
            sizeT = viewport.deltaPixelsFromPoints(boundsSize, false),
            tileCenter = positionT.plus(sizeT.divide(2)),
            tileDistance = viewportCenter.distanceTo(tileCenter);
        if (!overlap) sizeC = sizeC.plus(new $.Point(1, 1));
        tile.position =
            positionC;
        tile.size = sizeC;
        tile.distance = tileDistance;
        tile.visibility = levelVisibility
    }

    function blendTile(tiledImage, tile, x, y, level, levelOpacity, currentTime) {
        var blendTimeMillis = 1E3 * tiledImage.blendTime,
            deltaTime, opacity;
        if (!tile.blendStart) tile.blendStart = currentTime;
        deltaTime = currentTime - tile.blendStart;
        opacity = blendTimeMillis ? Math.min(1, deltaTime / blendTimeMillis) : 1;
        if (tiledImage.alwaysBlend) opacity *= levelOpacity;
        tile.opacity = opacity;
        tiledImage.lastDrawn.push(tile);
        if (opacity == 1) setCoverage(tiledImage.coverage,
            level, x, y, true);
        else if (deltaTime < blendTimeMillis) return true;
        return false
    }

    function providesCoverage(coverage, level, x, y) {
        var rows, cols, i, j;
        if (!coverage[level]) return false;
        if (x === undefined || y === undefined) {
            rows = coverage[level];
            for (i in rows)
                if (rows.hasOwnProperty(i)) {
                    cols = rows[i];
                    for (j in cols)
                        if (cols.hasOwnProperty(j) && !cols[j]) return false
                }
            return true
        }
        return coverage[level][x] === undefined || coverage[level][x][y] === undefined || coverage[level][x][y] === true
    }

    function isCovered(coverage, level, x, y) {
        if (x ===
            undefined || y === undefined) return providesCoverage(coverage, level + 1);
        else return providesCoverage(coverage, level + 1, 2 * x, 2 * y) && providesCoverage(coverage, level + 1, 2 * x, 2 * y + 1) && providesCoverage(coverage, level + 1, 2 * x + 1, 2 * y) && providesCoverage(coverage, level + 1, 2 * x + 1, 2 * y + 1)
    }

    function setCoverage(coverage, level, x, y, covers) {
        if (!coverage[level]) {
            $.console.warn("Setting coverage for a tile before its level's coverage has been reset: %s", level);
            return
        }
        if (!coverage[level][x]) coverage[level][x] = {};
        coverage[level][x][y] =
            covers
    }

    function resetCoverage(coverage, level) {
        coverage[level] = {}
    }

    function compareTiles(previousBest, tile) {
        if (!previousBest) return tile;
        if (tile.visibility > previousBest.visibility) return tile;
        else if (tile.visibility == previousBest.visibility)
            if (tile.distance < previousBest.distance) return tile;
        return previousBest
    }

    function drawTiles(tiledImage, lastDrawn) {
        var i, tile;
        if (tiledImage.opacity <= 0) {
            drawDebugInfo(tiledImage, lastDrawn);
            return
        }
        var useSketch = tiledImage.opacity < 1;
        if (useSketch) tiledImage._drawer._clear(true);
        var usedClip = false;
        if (tiledImage._clip) {
            tiledImage._drawer.saveContext(useSketch);
            var box = tiledImage.imageToViewportRectangle(tiledImage._clip, true);
            var clipRect = tiledImage._drawer.viewportToDrawerRectangle(box);
            tiledImage._drawer.setClip(clipRect, useSketch);
            usedClip = true
        }
        if (tiledImage.placeholderFillStyle && lastDrawn.length === 0) {
            var placeholderRect = tiledImage._drawer.viewportToDrawerRectangle(tiledImage.getBounds(true));
            var fillStyle = null;
            if (typeof tiledImage.placeholderFillStyle === "function") fillStyle =
                tiledImage.placeholderFillStyle(tiledImage, tiledImage._drawer.context);
            else fillStyle = tiledImage.placeholderFillStyle;
            tiledImage._drawer.drawRectangle(placeholderRect, fillStyle, useSketch)
        }
        for (i = lastDrawn.length - 1; i >= 0; i--) {
            tile = lastDrawn[i];
            tiledImage._drawer.drawTile(tile, tiledImage._drawingHandler, useSketch);
            tile.beingDrawn = true;
            if (tiledImage.viewer) tiledImage.viewer.raiseEvent("tile-drawn", {
                tiledImage: tiledImage,
                tile: tile
            })
        }
        if (usedClip) tiledImage._drawer.restoreContext(useSketch);
        if (useSketch) tiledImage._drawer.blendSketch(tiledImage.opacity);
        drawDebugInfo(tiledImage, lastDrawn)
    }

    function drawDebugInfo(tiledImage, lastDrawn) {
        if (tiledImage.debugMode)
            for (var i = lastDrawn.length - 1; i >= 0; i--) {
                var tile = lastDrawn[i];
                try {
                    tiledImage._drawer.drawDebugInfo(tile, lastDrawn.length, i)
                } catch (e) {
                    $.console.error(e)
                }
            }
    }
})(OpenSeadragon);
(function($) {
    var TileRecord = function(options) {
        $.console.assert(options, "[TileCache.cacheTile] options is required");
        $.console.assert(options.tile, "[TileCache.cacheTile] options.tile is required");
        $.console.assert(options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required");
        this.tile = options.tile;
        this.tiledImage = options.tiledImage
    };
    var ImageRecord = function(options) {
        $.console.assert(options, "[ImageRecord] options is required");
        $.console.assert(options.image, "[ImageRecord] options.image is required");
        this._image = options.image;
        this._tiles = []
    };
    ImageRecord.prototype = {
        destroy: function() {
            this._image = null;
            this._renderedContext = null;
            this._tiles = null
        },
        getImage: function() {
            return this._image
        },
        getRenderedContext: function() {
            if (!this._renderedContext) {
                var canvas = document.createElement("canvas");
                canvas.width = this._image.width;
                canvas.height = this._image.height;
                this._renderedContext = canvas.getContext("2d");
                this._renderedContext.drawImage(this._image, 0, 0);
                this._image = null
            }
            return this._renderedContext
        },
        setRenderedContext: function(renderedContext) {
            $.console.error("ImageRecord.setRenderedContext is deprecated. " +
                "The rendered context should be created by the ImageRecord " + "itself when calling ImageRecord.getRenderedContext.");
            this._renderedContext = renderedContext
        },
        addTile: function(tile) {
            $.console.assert(tile, "[ImageRecord.addTile] tile is required");
            this._tiles.push(tile)
        },
        removeTile: function(tile) {
            for (var i = 0; i < this._tiles.length; i++)
                if (this._tiles[i] === tile) {
                    this._tiles.splice(i, 1);
                    return
                }
            $.console.warn("[ImageRecord.removeTile] trying to remove unknown tile", tile)
        },
        getTileCount: function() {
            return this._tiles.length
        }
    };
    $.TileCache = function(options) {
        options = options || {};
        this._maxImageCacheCount = options.maxImageCacheCount || $.DEFAULT_SETTINGS.maxImageCacheCount;
        this._tilesLoaded = [];
        this._imagesLoaded = [];
        this._imagesLoadedCount = 0
    };
    $.TileCache.prototype = {
        numTilesLoaded: function() {
            return this._tilesLoaded.length
        },
        cacheTile: function(options) {
            $.console.assert(options, "[TileCache.cacheTile] options is required");
            $.console.assert(options.tile, "[TileCache.cacheTile] options.tile is required");
            $.console.assert(options.tile.url,
                "[TileCache.cacheTile] options.tile.url is required");
            $.console.assert(options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required");
            var cutoff = options.cutoff || 0;
            var insertionIndex = this._tilesLoaded.length;
            var imageRecord = this._imagesLoaded[options.tile.url];
            if (!imageRecord) {
                $.console.assert(options.image, "[TileCache.cacheTile] options.image is required to create an ImageRecord");
                imageRecord = this._imagesLoaded[options.tile.url] = new ImageRecord({
                    image: options.image
                });
                this._imagesLoadedCount++
            }
            imageRecord.addTile(options.tile);
            options.tile.cacheImageRecord = imageRecord;
            if (this._imagesLoadedCount > this._maxImageCacheCount) {
                var worstTile = null;
                var worstTileIndex = -1;
                var worstTileRecord = null;
                var prevTile, worstTime, worstLevel, prevTime, prevLevel, prevTileRecord;
                for (var i = this._tilesLoaded.length - 1; i >= 0; i--) {
                    prevTileRecord = this._tilesLoaded[i];
                    prevTile = prevTileRecord.tile;
                    if (prevTile.level <= cutoff || prevTile.beingDrawn) continue;
                    else if (!worstTile) {
                        worstTile = prevTile;
                        worstTileIndex = i;
                        worstTileRecord = prevTileRecord;
                        continue
                    }
                    prevTime =
                        prevTile.lastTouchTime;
                    worstTime = worstTile.lastTouchTime;
                    prevLevel = prevTile.level;
                    worstLevel = worstTile.level;
                    if (prevTime < worstTime || prevTime == worstTime && prevLevel > worstLevel) {
                        worstTile = prevTile;
                        worstTileIndex = i;
                        worstTileRecord = prevTileRecord
                    }
                }
                if (worstTile && worstTileIndex >= 0) {
                    this._unloadTile(worstTileRecord);
                    insertionIndex = worstTileIndex
                }
            }
            this._tilesLoaded[insertionIndex] = new TileRecord({
                tile: options.tile,
                tiledImage: options.tiledImage
            })
        },
        clearTilesFor: function(tiledImage) {
            $.console.assert(tiledImage,
                "[TileCache.clearTilesFor] tiledImage is required");
            var tileRecord;
            for (var i = 0; i < this._tilesLoaded.length; ++i) {
                tileRecord = this._tilesLoaded[i];
                if (tileRecord.tiledImage === tiledImage) {
                    this._unloadTile(tileRecord);
                    this._tilesLoaded.splice(i, 1);
                    i--
                }
            }
        },
        getImageRecord: function(url) {
            $.console.assert(url, "[TileCache.getImageRecord] url is required");
            return this._imagesLoaded[url]
        },
        _unloadTile: function(tileRecord) {
            $.console.assert(tileRecord, "[TileCache._unloadTile] tileRecord is required");
            var tile = tileRecord.tile;
            var tiledImage = tileRecord.tiledImage;
            tile.unload();
            tile.cacheImageRecord = null;
            var imageRecord = this._imagesLoaded[tile.url];
            imageRecord.removeTile(tile);
            if (!imageRecord.getTileCount()) {
                imageRecord.destroy();
                delete this._imagesLoaded[tile.url];
                this._imagesLoadedCount--
            }
            tiledImage.viewer.raiseEvent("tile-unloaded", {
                tile: tile,
                tiledImage: tiledImage
            })
        }
    }
})(OpenSeadragon);
(function($) {
    $.World = function(options) {
        var _this = this;
        $.console.assert(options.viewer, "[World] options.viewer is required");
        $.EventSource.call(this);
        this.viewer = options.viewer;
        this._items = [];
        this._needsDraw = false;
        this._delegatedFigureSizes = function(event) {
            _this._figureSizes()
        };
        this._figureSizes()
    };
    $.extend($.World.prototype, $.EventSource.prototype, {
        addItem: function(item, options) {
            $.console.assert(item, "[World.addItem] item is required");
            $.console.assert(item instanceof $.TiledImage, "[World.addItem] only TiledImages supported at this time");
            options = options || {};
            if (options.index !== undefined) {
                var index = Math.max(0, Math.min(this._items.length, options.index));
                this._items.splice(index, 0, item)
            } else this._items.push(item);
            this._figureSizes();
            this._needsDraw = true;
            item.addHandler("bounds-change", this._delegatedFigureSizes);
            this.raiseEvent("add-item", {
                item: item
            })
        },
        getItemAt: function(index) {
            $.console.assert(index !== undefined, "[World.getItemAt] index is required");
            return this._items[index]
        },
        getIndexOfItem: function(item) {
            $.console.assert(item, "[World.getIndexOfItem] item is required");
            return $.indexOf(this._items, item)
        },
        getItemCount: function() {
            return this._items.length
        },
        setItemIndex: function(item, index) {
            $.console.assert(item, "[World.setItemIndex] item is required");
            $.console.assert(index !== undefined, "[World.setItemIndex] index is required");
            var oldIndex = this.getIndexOfItem(item);
            if (index >= this._items.length) throw new Error("Index bigger than number of layers.");
            if (index === oldIndex || oldIndex === -1) return;
            this._items.splice(oldIndex, 1);
            this._items.splice(index, 0, item);
            this._needsDraw =
                true;
            this.raiseEvent("item-index-change", {
                item: item,
                previousIndex: oldIndex,
                newIndex: index
            })
        },
        removeItem: function(item) {
            $.console.assert(item, "[World.removeItem] item is required");
            var index = $.indexOf(this._items, item);
            if (index === -1) return;
            item.removeHandler("bounds-change", this._delegatedFigureSizes);
            item.destroy();
            this._items.splice(index, 1);
            this._figureSizes();
            this._needsDraw = true;
            this._raiseRemoveItem(item)
        },
        removeAll: function() {
            var item;
            for (var i = 0; i < this._items.length; i++) {
                item = this._items[i];
                item.removeHandler("bounds-change", this._delegatedFigureSizes);
                item.destroy()
            }
            var removedItems = this._items;
            this._items = [];
            this._figureSizes();
            this._needsDraw = true;
            for (i = 0; i < removedItems.length; i++) {
                item = removedItems[i];
                this._raiseRemoveItem(item)
            }
        },
        resetItems: function() {
            for (var i = 0; i < this._items.length; i++) this._items[i].reset()
        },
        update: function() {
            var animated = false;
            for (var i = 0; i < this._items.length; i++) animated = this._items[i].update() || animated;
            return animated
        },
        draw: function() {
            for (var i = 0; i < this._items.length; i++) this._items[i].draw();
            this._needsDraw = false
        },
        needsDraw: function() {
            for (var i = 0; i < this._items.length; i++)
                if (this._items[i].needsDraw()) return true;
            return this._needsDraw
        },
        getHomeBounds: function() {
            return this._homeBounds.clone()
        },
        getContentFactor: function() {
            return this._contentFactor
        },
        arrange: function(options) {
            options = options || {};
            var immediately = options.immediately || false;
            var layout = options.layout || $.DEFAULT_SETTINGS.collectionLayout;
            var rows = options.rows || $.DEFAULT_SETTINGS.collectionRows;
            var columns = options.columns || $.DEFAULT_SETTINGS.collectionColumns;
            var tileSize = options.tileSize || $.DEFAULT_SETTINGS.collectionTileSize;
            var tileMargin = options.tileMargin || $.DEFAULT_SETTINGS.collectionTileMargin;
            var increment = tileSize + tileMargin;
            var wrap;
            if (!options.rows && columns) wrap = columns;
            else wrap = Math.ceil(this._items.length / rows);
            var x = 0;
            var y = 0;
            var item, box, width, height, position;
            for (var i = 0; i < this._items.length; i++) {
                if (i && i % wrap === 0)
                    if (layout === "horizontal") {
                        y += increment;
                        x = 0
                    } else {
                        x += increment;
                        y = 0
                    }
                item = this._items[i];
                box = item.getBounds();
                if (box.width > box.height) width =
                    tileSize;
                else width = tileSize * (box.width / box.height);
                height = width * (box.height / box.width);
                position = new $.Point(x + (tileSize - width) / 2, y + (tileSize - height) / 2);
                item.setPosition(position, immediately);
                item.setWidth(width, immediately);
                if (layout === "horizontal") x += increment;
                else y += increment
            }
        },
        _figureSizes: function() {
            var oldHomeBounds = this._homeBounds ? this._homeBounds.clone() : null;
            var oldContentSize = this._contentSize ? this._contentSize.clone() : null;
            var oldContentFactor = this._contentFactor || 0;
            if (!this._items.length) {
                this._homeBounds =
                    new $.Rect(0, 0, 1, 1);
                this._contentSize = new $.Point(1, 1);
                this._contentFactor = 1
            } else {
                var bounds = this._items[0].getBounds();
                this._contentFactor = this._items[0].getContentSize().x / bounds.width;
                var left = bounds.x;
                var top = bounds.y;
                var right = bounds.x + bounds.width;
                var bottom = bounds.y + bounds.height;
                var box;
                for (var i = 1; i < this._items.length; i++) {
                    box = this._items[i].getBounds();
                    this._contentFactor = Math.max(this._contentFactor, this._items[i].getContentSize().x / box.width);
                    left = Math.min(left, box.x);
                    top = Math.min(top,
                        box.y);
                    right = Math.max(right, box.x + box.width);
                    bottom = Math.max(bottom, box.y + box.height)
                }
                this._homeBounds = new $.Rect(left, top, right - left, bottom - top);
                this._contentSize = new $.Point(this._homeBounds.width * this._contentFactor, this._homeBounds.height * this._contentFactor)
            }
            if (this._contentFactor !== oldContentFactor || !this._homeBounds.equals(oldHomeBounds) || !this._contentSize.equals(oldContentSize)) this.raiseEvent("metrics-change", {})
        },
        _raiseRemoveItem: function(item) {
            this.raiseEvent("remove-item", {
                item: item
            })
        }
    })
})(OpenSeadragon);
(function(OSD, $, undefined) {
    if (!OSD.version || OSD.version.major < 1) throw new Error("OpenSeadragonViewerInputHook requires OpenSeadragon version 1.0.0+");
    OSD.Viewer.prototype.addViewerInputHook = function(options) {
        options = options || {};
        options.viewer = this;
        return new $.ViewerInputHook(options)
    };
    $.ViewerInputHook = function(options) {
        var curHook, curTracker;
        options = options || {};
        options.hooks = options.hooks || [];
        this.viewerTrackers = {};
        if (options.viewer) {
            this.viewerTrackers.viewer = options.viewer.innerTracker;
            this.viewerTrackers.viewer_outer =
                options.viewer.outerTracker
        }
        for (curHook = 0; curHook < options.hooks.length; curHook++) {
            if (typeof options.hooks[curHook].tracker === "string") {
                if (!options.viewer) throw new Error("A viewer must be specified.");
                curTracker = this.viewerTrackers[options.hooks[curHook].tracker];
                if (curTracker === undefined) throw new Error("Unknown tracker specified: " + options.hooks[curHook].tracker);
            } else curTracker = options.hooks[curHook].tracker;
            (function(_this, tracker, handler, hookHandler) {
                var origHandler = tracker[handler];
                tracker[handler] =
                    function(event) {
                        return _this.callHandlers(hookHandler, origHandler, event)
                    }
            })(this, curTracker, options.hooks[curHook].handler, options.hooks[curHook].hookHandler)
        }
    };
    $.ViewerInputHook.version = {
        versionStr: "1.1.0",
        major: 1,
        minor: 1,
        revision: 0
    };
    $.ViewerInputHook.prototype.callHandlers = function(hookHandler, origHandler, event) {
        var ret = hookHandler(event);
        if (origHandler && !event.stopHandlers) ret = origHandler(event);
        return event.stopBubbling ? false : ret
    }
})(OpenSeadragon, window.OpenSeadragonImaging = window.OpenSeadragonImaging || {});
(function(global, factory) {
    if (typeof define === "function" && define.amd) define([], factory);
    else if (typeof module !== "undefined" && module.exports) module.exports = factory();
    else global.ReconnectingWebSocket = factory()
})(this, function() {
    if (!("WebSocket" in window)) return;

    function ReconnectingWebSocket(url, protocols, options) {
        var settings = {
            debug: false,
            automaticOpen: true,
            reconnectInterval: 1E3,
            maxReconnectInterval: 3E4,
            reconnectDecay: 1.5,
            timeoutInterval: 2E3,
            maxReconnectAttempts: null,
            timeoutCallback: null
        };
        if (!options) options = {};
        for (var key in settings)
            if (typeof options[key] !== "undefined") this[key] = options[key];
            else this[key] = settings[key];
        this.url = url;
        this.reconnectAttempts = 0;
        this.readyState = WebSocket.CONNECTING;
        this.protocol = null;
        var self = this;
        var ws;
        var forcedClose = false;
        var timedOut = false;
        var eventTarget = document.createElement("div");
        eventTarget.addEventListener("open", function(event) {
            self.onopen(event)
        });
        eventTarget.addEventListener("close", function(event) {
            self.onclose(event)
        });
        eventTarget.addEventListener("connecting",
            function(event) {
                self.onconnecting(event)
            });
        eventTarget.addEventListener("message", function(event) {
            self.onmessage(event)
        });
        eventTarget.addEventListener("error", function(event) {
            self.onerror(event)
        });
        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);
        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);
        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);

        function generateEvent(s, args) {
            var evt = document.createEvent("CustomEvent");
            evt.initCustomEvent(s,
                false, false, args);
            return evt
        }
        this.open = function(reconnectAttempt) {
            ws = new WebSocket(self.url, protocols || []);
            if (reconnectAttempt) {
                if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) return
            } else {
                eventTarget.dispatchEvent(generateEvent("connecting"));
                this.reconnectAttempts = 0
            }
            if (self.debug || ReconnectingWebSocket.debugAll) console.debug("ReconnectingWebSocket", "attempt-connect", self.url);
            var localWs = ws;
            var timeout = setTimeout(function() {
                if (self.debug || ReconnectingWebSocket.debugAll) console.debug("ReconnectingWebSocket",
                    "connection-timeout", self.url);
                timedOut = true;
                localWs.close();
                timedOut = false
            }, self.timeoutInterval);
            ws.onopen = function(event) {
                clearTimeout(timeout);
                if (self.debug || ReconnectingWebSocket.debugAll) console.debug("ReconnectingWebSocket", "onopen", self.url);
                self.protocol = ws.protocol;
                self.readyState = WebSocket.OPEN;
                self.reconnectAttempts = 0;
                var e = generateEvent("open");
                e.isReconnect = reconnectAttempt;
                reconnectAttempt = false;
                eventTarget.dispatchEvent(e)
            };
            ws.onclose = function(event) {
                console.log("-- ws.onclose:" + event.code +
                    "/" + event.reason + "/forcedClose:" + forcedClose);
                clearTimeout(timeout);
                ws = null;
                if (forcedClose || event.code === 4E3 || event.code === 1006) {
                    self.readyState = WebSocket.CLOSED;
                    var e = generateEvent("close");
                    e.code = event.code;
                    e.reason = event.reason;
                    e.wasClean = event.wasClean;
                    eventTarget.dispatchEvent(e)
                } else {
                    self.readyState = WebSocket.CONNECTING;
                    var timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);
                    setTimeout(function() {
                            self.reconnectAttempts++;
                            self.open(true);
                            if (self.timeoutCallback) self.timeoutCallback()
                        },
                        timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout)
                }
            };
            ws.onmessage = function(event) {
                if (self.debug || ReconnectingWebSocket.debugAll) console.debug("ReconnectingWebSocket", "onmessage", self.url, event.data);
                var e = generateEvent("message");
                e.data = event.data;
                eventTarget.dispatchEvent(e)
            };
            ws.onerror = function(event) {
                if (self.debug || ReconnectingWebSocket.debugAll) console.debug("ReconnectingWebSocket", "onerror", self.url, event);
                eventTarget.dispatchEvent(generateEvent("error"))
            }
        };
        if (this.automaticOpen ==
            true) this.open(false);
        this.send = function(data) {
            if (ws) {
                if (self.debug || ReconnectingWebSocket.debugAll) console.debug("ReconnectingWebSocket", "send", self.url, data);
                return ws.send(data)
            } else throw "INVALID_STATE_ERR : Pausing to reconnect websocket";
        };
        this.close = function(code, reason) {
            if (typeof code == "undefined") code = 1E3;
            forcedClose = true;
            console.log("close:forcedClose:" + forcedClose);
            if (ws) ws.close(code, reason)
        };
        this.refresh = function() {
            if (ws) ws.close()
        }
    }
    ReconnectingWebSocket.prototype.onopen = function(event) {};
    ReconnectingWebSocket.prototype.onclose = function(event) {};
    ReconnectingWebSocket.prototype.onconnecting = function(event) {};
    ReconnectingWebSocket.prototype.onmessage = function(event) {};
    ReconnectingWebSocket.prototype.onerror = function(event) {};
    ReconnectingWebSocket.debugAll = false;
    ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;
    ReconnectingWebSocket.OPEN = WebSocket.OPEN;
    ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;
    ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;
    return ReconnectingWebSocket
});
(function(undefined) {
    var objectTypes = {
        "boolean": false,
        "function": true,
        "object": true,
        "number": false,
        "string": false,
        "undefined": false
    };
    var root = objectTypes[typeof window] && window || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window ===
            freeGlobal)) root = freeGlobal;
    var Rx = {
        internals: {},
        config: {
            Promise: root.Promise
        },
        helpers: {}
    };
    var noop = Rx.helpers.noop = function() {},
        notDefined = Rx.helpers.notDefined = function(x) {
            return typeof x === "undefined"
        },
        identity = Rx.helpers.identity = function(x) {
            return x
        },
        pluck = Rx.helpers.pluck = function(property) {
            return function(x) {
                return x[property]
            }
        },
        just = Rx.helpers.just = function(value) {
            return function() {
                return value
            }
        },
        defaultNow = Rx.helpers.defaultNow = function() {
            return !!Date.now ? Date.now : function() {
                return +new Date
            }
        }(),
        defaultComparer = Rx.helpers.defaultComparer = function(x, y) {
            return isEqual(x, y)
        },
        defaultSubComparer = Rx.helpers.defaultSubComparer = function(x, y) {
            return x > y ? 1 : x < y ? -1 : 0
        },
        defaultKeySerializer = Rx.helpers.defaultKeySerializer = function(x) {
            return x.toString()
        },
        defaultError = Rx.helpers.defaultError = function(err) {
            throw err;
        },
        isPromise = Rx.helpers.isPromise = function(p) {
            return !!p && typeof p.then === "function"
        },
        asArray = Rx.helpers.asArray = function() {
            return Array.prototype.slice.call(arguments)
        },
        not = Rx.helpers.not = function(a) {
            return !a
        },
        isFunction = Rx.helpers.isFunction = function() {
            var isFn = function(value) {
                return typeof value == "function" || false
            };
            if (isFn(/x/)) isFn = function(value) {
                return typeof value == "function" && toString.call(value) == "[object Function]"
            };
            return isFn
        }();

    function cloneArray(arr) {
        var len = arr.length,
            a = new Array(len);
        for (var i = 0; i < len; i++) a[i] = arr[i];
        return a
    }
    Rx.config.longStackSupport = false;
    var hasStacks = false;
    try {
        throw new Error;
    } catch (e) {
        hasStacks = !!e.stack
    }
    var rStartingLine = captureLine(),
        rFileName;
    var STACK_JUMP_SEPARATOR =
        "From previous event:";

    function makeStackTraceLong(error, observable) {
        if (hasStacks && observable.stack && typeof error === "object" && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {
            var stacks = [];
            for (var o = observable; !!o; o = o.source)
                if (o.stack) stacks.unshift(o.stack);
            stacks.unshift(error.stack);
            var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
            error.stack = filterStackString(concatedStacks)
        }
    }

    function filterStackString(stackString) {
        var lines = stackString.split("\n"),
            desiredLines = [];
        for (var i = 0, len = lines.length; i < len; i++) {
            var line = lines[i];
            if (!isInternalFrame(line) && !isNodeFrame(line) && line) desiredLines.push(line)
        }
        return desiredLines.join("\n")
    }

    function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
        if (!fileNameAndLineNumber) return false;
        var fileName = fileNameAndLineNumber[0],
            lineNumber = fileNameAndLineNumber[1];
        return fileName === rFileName && lineNumber >= rStartingLine && lineNumber <= rEndingLine
    }

    function isNodeFrame(stackLine) {
        return stackLine.indexOf("(module.js:") !==
            -1 || stackLine.indexOf("(node.js:") !== -1
    }

    function captureLine() {
        if (!hasStacks) return;
        try {
            throw new Error;
        } catch (e) {
            var lines = e.stack.split("\n");
            var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
            if (!fileNameAndLineNumber) return;
            rFileName = fileNameAndLineNumber[0];
            return fileNameAndLineNumber[1]
        }
    }

    function getFileNameAndLineNumber(stackLine) {
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) return [attempt1[1], Number(attempt1[2])];
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) return [attempt2[1], Number(attempt2[2])];
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) return [attempt3[1], Number(attempt3[2])]
    }
    var EmptyError = Rx.EmptyError = function() {
        this.message = "Sequence contains no elements.";
        Error.call(this)
    };
    EmptyError.prototype = Error.prototype;
    var ObjectDisposedError = Rx.ObjectDisposedError = function() {
        this.message = "Object has been disposed";
        Error.call(this)
    };
    ObjectDisposedError.prototype = Error.prototype;
    var ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError = function() {
        this.message = "Argument out of range";
        Error.call(this)
    };
    ArgumentOutOfRangeError.prototype = Error.prototype;
    var NotSupportedError = Rx.NotSupportedError = function(message) {
        this.message = message || "This operation is not supported";
        Error.call(this)
    };
    NotSupportedError.prototype = Error.prototype;
    var NotImplementedError = Rx.NotImplementedError = function(message) {
        this.message = message || "This operation is not implemented";
        Error.call(this)
    };
    NotImplementedError.prototype =
        Error.prototype;
    var notImplemented = Rx.helpers.notImplemented = function() {
        throw new NotImplementedError;
    };
    var notSupported = Rx.helpers.notSupported = function() {
        throw new NotSupportedError;
    };
    var $iterator$ = typeof Symbol === "function" && Symbol.iterator || "_es6shim_iterator_";
    if (root.Set && typeof(new root.Set)["@@iterator"] === "function") $iterator$ = "@@iterator";
    var doneEnumerator = Rx.doneEnumerator = {
        done: true,
        value: undefined
    };
    var isIterable = Rx.helpers.isIterable = function(o) {
        return o[$iterator$] !== undefined
    };
    var isArrayLike =
        Rx.helpers.isArrayLike = function(o) {
            return o && o.length !== undefined
        };
    Rx.helpers.iterator = $iterator$;
    var bindCallback = Rx.internals.bindCallback = function(func, thisArg, argCount) {
        if (typeof thisArg === "undefined") return func;
        switch (argCount) {
            case 0:
                return function() {
                    return func.call(thisArg)
                };
            case 1:
                return function(arg) {
                    return func.call(thisArg, arg)
                };
            case 2:
                return function(value, index) {
                    return func.call(thisArg, value, index)
                };
            case 3:
                return function(value, index, collection) {
                    return func.call(thisArg, value, index,
                        collection)
                }
        }
        return function() {
            return func.apply(thisArg, arguments)
        }
    };
    var dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
        dontEnumsLength = dontEnums.length;
    var argsClass = "[object Arguments]",
        arrayClass = "[object Array]",
        boolClass = "[object Boolean]",
        dateClass = "[object Date]",
        errorClass = "[object Error]",
        funcClass = "[object Function]",
        numberClass = "[object Number]",
        objectClass = "[object Object]",
        regexpClass = "[object RegExp]",
        stringClass =
        "[object String]";
    var toString = Object.prototype.toString,
        hasOwnProperty = Object.prototype.hasOwnProperty,
        supportsArgsClass = toString.call(arguments) == argsClass,
        supportNodeClass, errorProto = Error.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype,
        propertyIsEnumerable = objectProto.propertyIsEnumerable;
    try {
        supportNodeClass = !(toString.call(document) == objectClass && !({
            "toString": 0
        } + ""))
    } catch (e) {
        supportNodeClass = true
    }
    var nonEnumProps = {};
    nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = {
        "constructor": true,
        "toLocaleString": true,
        "toString": true,
        "valueOf": true
    };
    nonEnumProps[boolClass] = nonEnumProps[stringClass] = {
        "constructor": true,
        "toString": true,
        "valueOf": true
    };
    nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = {
        "constructor": true,
        "toString": true
    };
    nonEnumProps[objectClass] = {
        "constructor": true
    };
    var support = {};
    (function() {
        var ctor = function() {
                this.x = 1
            },
            props = [];
        ctor.prototype = {
            "valueOf": 1,
            "y": 1
        };
        for (var key in new ctor) props.push(key);
        for (key in arguments);
        support.enumErrorProps =
            propertyIsEnumerable.call(errorProto, "message") || propertyIsEnumerable.call(errorProto, "name");
        support.enumPrototypes = propertyIsEnumerable.call(ctor, "prototype");
        support.nonEnumArgs = key != 0;
        support.nonEnumShadows = !/valueOf/.test(props)
    })(1);
    var isObject = Rx.internals.isObject = function(value) {
        var type = typeof value;
        return value && (type == "function" || type == "object") || false
    };

    function keysIn(object) {
        var result = [];
        if (!isObject(object)) return result;
        if (support.nonEnumArgs && object.length && isArguments(object)) object =
            slice.call(object);
        var skipProto = support.enumPrototypes && typeof object == "function",
            skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error);
        for (var key in object)
            if (!(skipProto && key == "prototype") && !(skipErrorProps && (key == "message" || key == "name"))) result.push(key);
        if (support.nonEnumShadows && object !== objectProto) {
            var ctor = object.constructor,
                index = -1,
                length = dontEnumsLength;
            if (object === (ctor && ctor.prototype)) var className = object === stringProto ? stringClass : object === errorProto ?
                errorClass : toString.call(object),
                nonEnum = nonEnumProps[className];
            while (++index < length) {
                key = dontEnums[index];
                if (!(nonEnum && nonEnum[key]) && hasOwnProperty.call(object, key)) result.push(key)
            }
        }
        return result
    }

    function internalFor(object, callback, keysFunc) {
        var index = -1,
            props = keysFunc(object),
            length = props.length;
        while (++index < length) {
            var key = props[index];
            if (callback(object[key], key, object) === false) break
        }
        return object
    }

    function internalForIn(object, callback) {
        return internalFor(object, callback, keysIn)
    }

    function isNode(value) {
        return typeof value.toString !=
            "function" && typeof(value + "") == "string"
    }
    var isArguments = function(value) {
        return value && typeof value == "object" ? toString.call(value) == argsClass : false
    };
    if (!supportsArgsClass) isArguments = function(value) {
        return value && typeof value == "object" ? hasOwnProperty.call(value, "callee") : false
    };
    var isEqual = Rx.internals.isEqual = function(x, y) {
        return deepEquals(x, y, [], [])
    };

    function deepEquals(a, b, stackA, stackB) {
        if (a === b) return a !== 0 || 1 / a == 1 / b;
        var type = typeof a,
            otherType = typeof b;
        if (a === a && (a == null || b == null || type != "function" &&
                type != "object" && otherType != "function" && otherType != "object")) return false;
        var className = toString.call(a),
            otherClass = toString.call(b);
        if (className == argsClass) className = objectClass;
        if (otherClass == argsClass) otherClass = objectClass;
        if (className != otherClass) return false;
        switch (className) {
            case boolClass:
            case dateClass:
                return +a == +b;
            case numberClass:
                return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
            case regexpClass:
            case stringClass:
                return a == String(b)
        }
        var isArr = className == arrayClass;
        if (!isArr) {
            if (className != objectClass ||
                !support.nodeClass && (isNode(a) || isNode(b))) return false;
            var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
                ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
            if (ctorA != ctorB && !(hasOwnProperty.call(a, "constructor") && hasOwnProperty.call(b, "constructor")) && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ("constructor" in a && "constructor" in b)) return false
        }
        var initedStack = !stackA;
        stackA || (stackA = []);
        stackB || (stackB = []);
        var length = stackA.length;
        while (length--)
            if (stackA[length] == a) return stackB[length] == b;
        var size = 0;
        var result = true;
        stackA.push(a);
        stackB.push(b);
        if (isArr) {
            length = a.length;
            size = b.length;
            result = size == length;
            if (result)
                while (size--) {
                    var index = length,
                        value = b[size];
                    if (!(result = deepEquals(a[size], value, stackA, stackB))) break
                }
        } else {
            internalForIn(b, function(value, key, b) {
                if (hasOwnProperty.call(b, key)) {
                    size++;
                    return result = hasOwnProperty.call(a, key) && deepEquals(a[key], value, stackA, stackB)
                }
            });
            if (result) internalForIn(a, function(value, key,
                a) {
                if (hasOwnProperty.call(a, key)) return result = --size > -1
            })
        }
        stackA.pop();
        stackB.pop();
        return result
    }
    var hasProp = {}.hasOwnProperty,
        slice = Array.prototype.slice;
    var inherits = this.inherits = Rx.internals.inherits = function(child, parent) {
        function __() {
            this.constructor = child
        }
        __.prototype = parent.prototype;
        child.prototype = new __
    };
    var addProperties = Rx.internals.addProperties = function(obj) {
        for (var sources = [], i = 1, len = arguments.length; i < len; i++) sources.push(arguments[i]);
        for (var idx = 0, ln = sources.length; idx < ln; idx++) {
            var source =
                sources[idx];
            for (var prop in source) obj[prop] = source[prop]
        }
    };
    var addRef = Rx.internals.addRef = function(xs, r) {
        return new AnonymousObservable(function(observer) {
            return new CompositeDisposable(r.getDisposable(), xs.subscribe(observer))
        })
    };

    function arrayInitialize(count, factory) {
        var a = new Array(count);
        for (var i = 0; i < count; i++) a[i] = factory();
        return a
    }
    var errorObj = {
        e: {}
    };
    var tryCatchTarget;

    function tryCatcher() {
        try {
            return tryCatchTarget.apply(this, arguments)
        } catch (e) {
            errorObj.e = e;
            return errorObj
        }
    }

    function tryCatch(fn) {
        if (!isFunction(fn)) throw new TypeError("fn must be a function");
        tryCatchTarget = fn;
        return tryCatcher
    }

    function thrower(e) {
        throw e;
    }
    if (!Function.prototype.bind) Function.prototype.bind = function(that) {
        var target = this,
            args = slice.call(arguments, 1);
        var bound = function() {
            if (this instanceof bound) {
                function F() {}
                F.prototype = target.prototype;
                var self = new F;
                var result = target.apply(self, args.concat(slice.call(arguments)));
                if (Object(result) === result) return result;
                return self
            } else return target.apply(that, args.concat(slice.call(arguments)))
        };
        return bound
    };
    if (!Array.prototype.forEach) Array.prototype.forEach =
        function(callback, thisArg) {
            var T, k;
            if (this == null) throw new TypeError(" this is null or not defined");
            var O = Object(this);
            var len = O.length >>> 0;
            if (typeof callback !== "function") throw new TypeError(callback + " is not a function");
            if (arguments.length > 1) T = thisArg;
            k = 0;
            while (k < len) {
                var kValue;
                if (k in O) {
                    kValue = O[k];
                    callback.call(T, kValue, k, O)
                }
                k++
            }
        };
    var boxedString = Object("a"),
        splitString = boxedString[0] != "a" || !(0 in boxedString);
    if (!Array.prototype.every) Array.prototype.every = function every(fun) {
        var object =
            Object(this),
            self = splitString && {}.toString.call(this) == stringClass ? this.split("") : object,
            length = self.length >>> 0,
            thisp = arguments[1];
        if ({}.toString.call(fun) != funcClass) throw new TypeError(fun + " is not a function");
        for (var i = 0; i < length; i++)
            if (i in self && !fun.call(thisp, self[i], i, object)) return false;
        return true
    };
    if (!Array.prototype.map) Array.prototype.map = function map(fun) {
        var object = Object(this),
            self = splitString && {}.toString.call(this) == stringClass ? this.split("") : object,
            length = self.length >>> 0,
            result =
            Array(length),
            thisp = arguments[1];
        if ({}.toString.call(fun) != funcClass) throw new TypeError(fun + " is not a function");
        for (var i = 0; i < length; i++)
            if (i in self) result[i] = fun.call(thisp, self[i], i, object);
        return result
    };
    if (!Array.prototype.filter) Array.prototype.filter = function(predicate) {
        var results = [],
            item, t = new Object(this);
        for (var i = 0, len = t.length >>> 0; i < len; i++) {
            item = t[i];
            if (i in t && predicate.call(arguments[1], item, i, t)) results.push(item)
        }
        return results
    };
    if (!Array.isArray) Array.isArray = function(arg) {
        return {}.toString.call(arg) ==
            arrayClass
    };
    if (!Array.prototype.indexOf) Array.prototype.indexOf = function indexOf(searchElement) {
        var t = Object(this);
        var len = t.length >>> 0;
        if (len === 0) return -1;
        var n = 0;
        if (arguments.length > 1) {
            n = Number(arguments[1]);
            if (n !== n) n = 0;
            else if (n !== 0 && n != Infinity && n !== -Infinity) n = (n > 0 || -1) * Math.floor(Math.abs(n))
        }
        if (n >= len) return -1;
        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
        for (; k < len; k++)
            if (k in t && t[k] === searchElement) return k;
        return -1
    };
    if (!Object.prototype.propertyIsEnumerable) Object.prototype.propertyIsEnumerable =
        function(key) {
            for (var k in this)
                if (k === key) return true;
            return false
        };
    if (!Object.keys) Object.keys = function() {
        var hasOwnProperty = Object.prototype.hasOwnProperty,
            hasDontEnumBug = !{
                toString: null
            }.propertyIsEnumerable("toString");
        return function(obj) {
            if (typeof obj !== "object" && (typeof obj !== "function" || obj === null)) throw new TypeError("Object.keys called on non-object");
            var result = [],
                prop, i;
            for (prop in obj)
                if (hasOwnProperty.call(obj, prop)) result.push(prop);
            if (hasDontEnumBug)
                for (i = 0; i < dontEnumsLength; i++)
                    if (hasOwnProperty.call(obj,
                            dontEnums[i])) result.push(dontEnums[i]);
            return result
        }
    }();

    function IndexedItem(id, value) {
        this.id = id;
        this.value = value
    }
    IndexedItem.prototype.compareTo = function(other) {
        var c = this.value.compareTo(other.value);
        c === 0 && (c = this.id - other.id);
        return c
    };
    var PriorityQueue = Rx.internals.PriorityQueue = function(capacity) {
        this.items = new Array(capacity);
        this.length = 0
    };
    var priorityProto = PriorityQueue.prototype;
    priorityProto.isHigherPriority = function(left, right) {
        return this.items[left].compareTo(this.items[right]) < 0
    };
    priorityProto.percolate = function(index) {
        if (index >= this.length || index < 0) return;
        var parent = index - 1 >> 1;
        if (parent < 0 || parent === index) return;
        if (this.isHigherPriority(index, parent)) {
            var temp = this.items[index];
            this.items[index] = this.items[parent];
            this.items[parent] = temp;
            this.percolate(parent)
        }
    };
    priorityProto.heapify = function(index) {
        +index || (index = 0);
        if (index >= this.length || index < 0) return;
        var left = 2 * index + 1,
            right = 2 * index + 2,
            first = index;
        if (left < this.length && this.isHigherPriority(left, first)) first = left;
        if (right <
            this.length && this.isHigherPriority(right, first)) first = right;
        if (first !== index) {
            var temp = this.items[index];
            this.items[index] = this.items[first];
            this.items[first] = temp;
            this.heapify(first)
        }
    };
    priorityProto.peek = function() {
        return this.items[0].value
    };
    priorityProto.removeAt = function(index) {
        this.items[index] = this.items[--this.length];
        this.items[this.length] = undefined;
        this.heapify()
    };
    priorityProto.dequeue = function() {
        var result = this.peek();
        this.removeAt(0);
        return result
    };
    priorityProto.enqueue = function(item) {
        var index =
            this.length++;
        this.items[index] = new IndexedItem(PriorityQueue.count++, item);
        this.percolate(index)
    };
    priorityProto.remove = function(item) {
        for (var i = 0; i < this.length; i++)
            if (this.items[i].value === item) {
                this.removeAt(i);
                return true
            }
        return false
    };
    PriorityQueue.count = 0;
    var CompositeDisposable = Rx.CompositeDisposable = function() {
        var args = [],
            i, len;
        if (Array.isArray(arguments[0])) {
            args = arguments[0];
            len = args.length
        } else {
            len = arguments.length;
            args = new Array(len);
            for (i = 0; i < len; i++) args[i] = arguments[i]
        }
        for (i = 0; i < len; i++)
            if (!isDisposable(args[i])) throw new TypeError("Not a disposable");
        this.disposables = args;
        this.isDisposed = false;
        this.length = args.length
    };
    var CompositeDisposablePrototype = CompositeDisposable.prototype;
    CompositeDisposablePrototype.add = function(item) {
        if (this.isDisposed) item.dispose();
        else {
            this.disposables.push(item);
            this.length++
        }
    };
    CompositeDisposablePrototype.remove = function(item) {
        var shouldDispose = false;
        if (!this.isDisposed) {
            var idx = this.disposables.indexOf(item);
            if (idx !== -1) {
                shouldDispose = true;
                this.disposables.splice(idx, 1);
                this.length--;
                item.dispose()
            }
        }
        return shouldDispose
    };
    CompositeDisposablePrototype.dispose = function() {
        if (!this.isDisposed) {
            this.isDisposed = true;
            var len = this.disposables.length,
                currentDisposables = new Array(len);
            for (var i = 0; i < len; i++) currentDisposables[i] = this.disposables[i];
            this.disposables = [];
            this.length = 0;
            for (i = 0; i < len; i++) currentDisposables[i].dispose()
        }
    };
    var Disposable = Rx.Disposable = function(action) {
        this.isDisposed = false;
        this.action = action || noop
    };
    Disposable.prototype.dispose = function() {
        if (!this.isDisposed) {
            this.action();
            this.isDisposed = true
        }
    };
    var disposableCreate =
        Disposable.create = function(action) {
            return new Disposable(action)
        };
    var disposableEmpty = Disposable.empty = {
        dispose: noop
    };
    var isDisposable = Disposable.isDisposable = function(d) {
        return d && isFunction(d.dispose)
    };
    var checkDisposed = Disposable.checkDisposed = function(disposable) {
        if (disposable.isDisposed) throw new ObjectDisposedError;
    };
    var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = function() {
        this.isDisposed = false;
        this.current = null
    };
    SingleAssignmentDisposable.prototype.getDisposable = function() {
        return this.current
    };
    SingleAssignmentDisposable.prototype.setDisposable = function(value) {
        if (this.current) throw new Error("Disposable has already been assigned");
        var shouldDispose = this.isDisposed;
        !shouldDispose && (this.current = value);
        shouldDispose && value && value.dispose()
    };
    SingleAssignmentDisposable.prototype.dispose = function() {
        if (!this.isDisposed) {
            this.isDisposed = true;
            var old = this.current;
            this.current = null
        }
        old && old.dispose()
    };
    var SerialDisposable = Rx.SerialDisposable = function() {
        this.isDisposed = false;
        this.current = null
    };
    SerialDisposable.prototype.getDisposable =
        function() {
            return this.current
        };
    SerialDisposable.prototype.setDisposable = function(value) {
        var shouldDispose = this.isDisposed;
        if (!shouldDispose) {
            var old = this.current;
            this.current = value
        }
        old && old.dispose();
        shouldDispose && value && value.dispose()
    };
    SerialDisposable.prototype.dispose = function() {
        if (!this.isDisposed) {
            this.isDisposed = true;
            var old = this.current;
            this.current = null
        }
        old && old.dispose()
    };
    var RefCountDisposable = Rx.RefCountDisposable = function() {
        function InnerDisposable(disposable) {
            this.disposable = disposable;
            this.disposable.count++;
            this.isInnerDisposed = false
        }
        InnerDisposable.prototype.dispose = function() {
            if (!this.disposable.isDisposed && !this.isInnerDisposed) {
                this.isInnerDisposed = true;
                this.disposable.count--;
                if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {
                    this.disposable.isDisposed = true;
                    this.disposable.underlyingDisposable.dispose()
                }
            }
        };

        function RefCountDisposable(disposable) {
            this.underlyingDisposable = disposable;
            this.isDisposed = false;
            this.isPrimaryDisposed = false;
            this.count = 0
        }
        RefCountDisposable.prototype.dispose =
            function() {
                if (!this.isDisposed && !this.isPrimaryDisposed) {
                    this.isPrimaryDisposed = true;
                    if (this.count === 0) {
                        this.isDisposed = true;
                        this.underlyingDisposable.dispose()
                    }
                }
            };
        RefCountDisposable.prototype.getDisposable = function() {
            return this.isDisposed ? disposableEmpty : new InnerDisposable(this)
        };
        return RefCountDisposable
    }();

    function ScheduledDisposable(scheduler, disposable) {
        this.scheduler = scheduler;
        this.disposable = disposable;
        this.isDisposed = false
    }

    function scheduleItem(s, self) {
        if (!self.isDisposed) {
            self.isDisposed =
                true;
            self.disposable.dispose()
        }
    }
    ScheduledDisposable.prototype.dispose = function() {
        this.scheduler.scheduleWithState(this, scheduleItem)
    };
    var ScheduledItem = Rx.internals.ScheduledItem = function(scheduler, state, action, dueTime, comparer) {
        this.scheduler = scheduler;
        this.state = state;
        this.action = action;
        this.dueTime = dueTime;
        this.comparer = comparer || defaultSubComparer;
        this.disposable = new SingleAssignmentDisposable
    };
    ScheduledItem.prototype.invoke = function() {
        this.disposable.setDisposable(this.invokeCore())
    };
    ScheduledItem.prototype.compareTo =
        function(other) {
            return this.comparer(this.dueTime, other.dueTime)
        };
    ScheduledItem.prototype.isCancelled = function() {
        return this.disposable.isDisposed
    };
    ScheduledItem.prototype.invokeCore = function() {
        return this.action(this.scheduler, this.state)
    };
    var Scheduler = Rx.Scheduler = function() {
        function Scheduler(now, schedule, scheduleRelative, scheduleAbsolute) {
            this.now = now;
            this._schedule = schedule;
            this._scheduleRelative = scheduleRelative;
            this._scheduleAbsolute = scheduleAbsolute
        }
        Scheduler.isScheduler = function(s) {
            return s instanceof
            Scheduler
        };

        function invokeAction(scheduler, action) {
            action();
            return disposableEmpty
        }
        var schedulerProto = Scheduler.prototype;
        schedulerProto.schedule = function(action) {
            return this._schedule(action, invokeAction)
        };
        schedulerProto.scheduleWithState = function(state, action) {
            return this._schedule(state, action)
        };
        schedulerProto.scheduleWithRelative = function(dueTime, action) {
            return this._scheduleRelative(action, dueTime, invokeAction)
        };
        schedulerProto.scheduleWithRelativeAndState = function(state, dueTime, action) {
            return this._scheduleRelative(state,
                dueTime, action)
        };
        schedulerProto.scheduleWithAbsolute = function(dueTime, action) {
            return this._scheduleAbsolute(action, dueTime, invokeAction)
        };
        schedulerProto.scheduleWithAbsoluteAndState = function(state, dueTime, action) {
            return this._scheduleAbsolute(state, dueTime, action)
        };
        Scheduler.now = defaultNow;
        Scheduler.normalize = function(timeSpan) {
            timeSpan < 0 && (timeSpan = 0);
            return timeSpan
        };
        return Scheduler
    }();
    var normalizeTime = Scheduler.normalize,
        isScheduler = Scheduler.isScheduler;
    (function(schedulerProto) {
        function invokeRecImmediate(scheduler,
            pair) {
            var state = pair[0],
                action = pair[1],
                group = new CompositeDisposable;

            function recursiveAction(state1) {
                action(state1, function(state2) {
                    var isAdded = false,
                        isDone = false,
                        d = scheduler.scheduleWithState(state2, function(scheduler1, state3) {
                            if (isAdded) group.remove(d);
                            else isDone = true;
                            recursiveAction(state3);
                            return disposableEmpty
                        });
                    if (!isDone) {
                        group.add(d);
                        isAdded = true
                    }
                })
            }
            recursiveAction(state);
            return group
        }

        function invokeRecDate(scheduler, pair, method) {
            var state = pair[0],
                action = pair[1],
                group = new CompositeDisposable;

            function recursiveAction(state1) {
                action(state1, function(state2, dueTime1) {
                    var isAdded = false,
                        isDone = false,
                        d = scheduler[method](state2, dueTime1, function(scheduler1, state3) {
                            if (isAdded) group.remove(d);
                            else isDone = true;
                            recursiveAction(state3);
                            return disposableEmpty
                        });
                    if (!isDone) {
                        group.add(d);
                        isAdded = true
                    }
                })
            }
            recursiveAction(state);
            return group
        }

        function scheduleInnerRecursive(action, self) {
            action(function(dt) {
                self(action, dt)
            })
        }
        schedulerProto.scheduleRecursive = function(action) {
            return this.scheduleRecursiveWithState(action,
                function(_action, self) {
                    _action(function() {
                        self(_action)
                    })
                })
        };
        schedulerProto.scheduleRecursiveWithState = function(state, action) {
            return this.scheduleWithState([state, action], invokeRecImmediate)
        };
        schedulerProto.scheduleRecursiveWithRelative = function(dueTime, action) {
            return this.scheduleRecursiveWithRelativeAndState(action, dueTime, scheduleInnerRecursive)
        };
        schedulerProto.scheduleRecursiveWithRelativeAndState = function(state, dueTime, action) {
            return this._scheduleRelative([state, action], dueTime, function(s, p) {
                return invokeRecDate(s,
                    p, "scheduleWithRelativeAndState")
            })
        };
        schedulerProto.scheduleRecursiveWithAbsolute = function(dueTime, action) {
            return this.scheduleRecursiveWithAbsoluteAndState(action, dueTime, scheduleInnerRecursive)
        };
        schedulerProto.scheduleRecursiveWithAbsoluteAndState = function(state, dueTime, action) {
            return this._scheduleAbsolute([state, action], dueTime, function(s, p) {
                return invokeRecDate(s, p, "scheduleWithAbsoluteAndState")
            })
        }
    })(Scheduler.prototype);
    (function(schedulerProto) {
        Scheduler.prototype.schedulePeriodic = function(period,
            action) {
            return this.schedulePeriodicWithState(null, period, action)
        };
        Scheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
            if (typeof root.setInterval === "undefined") throw new NotSupportedError;
            period = normalizeTime(period);
            var s = state,
                id = root.setInterval(function() {
                    s = action(s)
                }, period);
            return disposableCreate(function() {
                root.clearInterval(id)
            })
        }
    })(Scheduler.prototype);
    (function(schedulerProto) {
        schedulerProto.catchError = schedulerProto["catch"] = function(handler) {
            return new CatchScheduler(this,
                handler)
        }
    })(Scheduler.prototype);
    var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = function() {
        function tick(command, recurse) {
            recurse(0, this._period);
            try {
                this._state = this._action(this._state)
            } catch (e) {
                this._cancel.dispose();
                throw e;
            }
        }

        function SchedulePeriodicRecursive(scheduler, state, period, action) {
            this._scheduler = scheduler;
            this._state = state;
            this._period = period;
            this._action = action
        }
        SchedulePeriodicRecursive.prototype.start = function() {
            var d = new SingleAssignmentDisposable;
            this._cancel =
                d;
            d.setDisposable(this._scheduler.scheduleRecursiveWithRelativeAndState(0, this._period, tick.bind(this)));
            return d
        };
        return SchedulePeriodicRecursive
    }();
    var immediateScheduler = Scheduler.immediate = function() {
        function scheduleNow(state, action) {
            return action(this, state)
        }
        return new Scheduler(defaultNow, scheduleNow, notSupported, notSupported)
    }();
    var currentThreadScheduler = Scheduler.currentThread = function() {
        var queue;

        function runTrampoline() {
            while (queue.length > 0) {
                var item = queue.dequeue();
                !item.isCancelled() &&
                    item.invoke()
            }
        }

        function scheduleNow(state, action) {
            var si = new ScheduledItem(this, state, action, this.now());
            if (!queue) {
                queue = new PriorityQueue(4);
                queue.enqueue(si);
                var result = tryCatch(runTrampoline)();
                queue = null;
                if (result === errorObj) return thrower(result.e)
            } else queue.enqueue(si);
            return si.disposable
        }
        var currentScheduler = new Scheduler(defaultNow, scheduleNow, notSupported, notSupported);
        currentScheduler.scheduleRequired = function() {
            return !queue
        };
        return currentScheduler
    }();
    var scheduleMethod, clearMethod;
    var localTimer = function() {
        var localSetTimeout, localClearTimeout = noop;
        if (!!root.setTimeout) {
            localSetTimeout = root.setTimeout;
            localClearTimeout = root.clearTimeout
        } else if (!!root.WScript) localSetTimeout = function(fn, time) {
            root.WScript.Sleep(time);
            fn()
        };
        else throw new NotSupportedError;
        return {
            setTimeout: localSetTimeout,
            clearTimeout: localClearTimeout
        }
    }();
    var localSetTimeout = localTimer.setTimeout,
        localClearTimeout = localTimer.clearTimeout;
    (function() {
        var nextHandle = 1,
            tasksByHandle = {},
            currentlyRunning = false;
        clearMethod = function(handle) {
            delete tasksByHandle[handle]
        };

        function runTask(handle) {
            if (currentlyRunning) localSetTimeout(function() {
                runTask(handle)
            }, 0);
            else {
                var task = tasksByHandle[handle];
                if (task) {
                    currentlyRunning = true;
                    var result = tryCatch(task)();
                    clearMethod(handle);
                    currentlyRunning = false;
                    if (result === errorObj) return thrower(result.e)
                }
            }
        }
        var reNative = RegExp("^" + String(toString).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$");
        var setImmediate = typeof(setImmediate = freeGlobal &&
            moduleExports && freeGlobal.setImmediate) == "function" && !reNative.test(setImmediate) && setImmediate;

        function postMessageSupported() {
            if (!root.postMessage || root.importScripts) return false;
            var isAsync = false,
                oldHandler = root.onmessage;
            root.onmessage = function() {
                isAsync = true
            };
            root.postMessage("", "*");
            root.onmessage = oldHandler;
            return isAsync
        }
        if (isFunction(setImmediate)) scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            setImmediate(function() {
                runTask(id)
            });
            return id
        };
        else if (typeof process !==
            "undefined" && {}.toString.call(process) === "[object process]") scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            process.nextTick(function() {
                runTask(id)
            });
            return id
        };
        else if (postMessageSupported()) {
            var MSG_PREFIX = "ms.rx.schedule" + Math.random();

            function onGlobalPostMessage(event) {
                if (typeof event.data === "string" && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) runTask(event.data.substring(MSG_PREFIX.length))
            }
            if (root.addEventListener) root.addEventListener("message", onGlobalPostMessage,
                false);
            else if (root.attachEvent) root.attachEvent("onmessage", onGlobalPostMessage);
            else root.onmessage = onGlobalPostMessage;
            scheduleMethod = function(action) {
                var id = nextHandle++;
                tasksByHandle[id] = action;
                root.postMessage(MSG_PREFIX + currentId, "*");
                return id
            }
        } else if (!!root.MessageChannel) {
            var channel = new root.MessageChannel;
            channel.port1.onmessage = function(e) {
                runTask(e.data)
            };
            scheduleMethod = function(action) {
                var id = nextHandle++;
                tasksByHandle[id] = action;
                channel.port2.postMessage(id);
                return id
            }
        } else if ("document" in
            root && "onreadystatechange" in root.document.createElement("script")) scheduleMethod = function(action) {
            var scriptElement = root.document.createElement("script");
            var id = nextHandle++;
            tasksByHandle[id] = action;
            scriptElement.onreadystatechange = function() {
                runTask(id);
                scriptElement.onreadystatechange = null;
                scriptElement.parentNode.removeChild(scriptElement);
                scriptElement = null
            };
            root.document.documentElement.appendChild(scriptElement);
            return id
        };
        else scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] =
                action;
            localSetTimeout(function() {
                runTask(id)
            }, 0);
            return id
        }
    })();
    var timeoutScheduler = Scheduler.timeout = Scheduler["default"] = function() {
        function scheduleNow(state, action) {
            var scheduler = this,
                disposable = new SingleAssignmentDisposable;
            var id = scheduleMethod(function() {
                !disposable.isDisposed && disposable.setDisposable(action(scheduler, state))
            });
            return new CompositeDisposable(disposable, disposableCreate(function() {
                clearMethod(id)
            }))
        }

        function scheduleRelative(state, dueTime, action) {
            var scheduler = this,
                dt = Scheduler.normalize(dueTime),
                disposable = new SingleAssignmentDisposable;
            if (dt === 0) return scheduler.scheduleWithState(state, action);
            var id = localSetTimeout(function() {
                !disposable.isDisposed && disposable.setDisposable(action(scheduler, state))
            }, dt);
            return new CompositeDisposable(disposable, disposableCreate(function() {
                localClearTimeout(id)
            }))
        }

        function scheduleAbsolute(state, dueTime, action) {
            return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action)
        }
        return new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute)
    }();
    var CatchScheduler = function(__super__) {
        function scheduleNow(state, action) {
            return this._scheduler.scheduleWithState(state, this._wrap(action))
        }

        function scheduleRelative(state, dueTime, action) {
            return this._scheduler.scheduleWithRelativeAndState(state, dueTime, this._wrap(action))
        }

        function scheduleAbsolute(state, dueTime, action) {
            return this._scheduler.scheduleWithAbsoluteAndState(state, dueTime, this._wrap(action))
        }
        inherits(CatchScheduler, __super__);

        function CatchScheduler(scheduler, handler) {
            this._scheduler =
                scheduler;
            this._handler = handler;
            this._recursiveOriginal = null;
            this._recursiveWrapper = null;
            __super__.call(this, this._scheduler.now.bind(this._scheduler), scheduleNow, scheduleRelative, scheduleAbsolute)
        }
        CatchScheduler.prototype._clone = function(scheduler) {
            return new CatchScheduler(scheduler, this._handler)
        };
        CatchScheduler.prototype._wrap = function(action) {
            var parent = this;
            return function(self, state) {
                try {
                    return action(parent._getRecursiveWrapper(self), state)
                } catch (e) {
                    if (!parent._handler(e)) throw e;
                    return disposableEmpty
                }
            }
        };
        CatchScheduler.prototype._getRecursiveWrapper = function(scheduler) {
            if (this._recursiveOriginal !== scheduler) {
                this._recursiveOriginal = scheduler;
                var wrapper = this._clone(scheduler);
                wrapper._recursiveOriginal = scheduler;
                wrapper._recursiveWrapper = wrapper;
                this._recursiveWrapper = wrapper
            }
            return this._recursiveWrapper
        };
        CatchScheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
            var self = this,
                failed = false,
                d = new SingleAssignmentDisposable;
            d.setDisposable(this._scheduler.schedulePeriodicWithState(state,
                period,
                function(state1) {
                    if (failed) return null;
                    try {
                        return action(state1)
                    } catch (e) {
                        failed = true;
                        if (!self._handler(e)) throw e;
                        d.dispose();
                        return null
                    }
                }));
            return d
        };
        return CatchScheduler
    }(Scheduler);
    var Notification = Rx.Notification = function() {
        function Notification(kind, value, exception, accept, acceptObservable, toString) {
            this.kind = kind;
            this.value = value;
            this.exception = exception;
            this._accept = accept;
            this._acceptObservable = acceptObservable;
            this.toString = toString
        }
        Notification.prototype.accept = function(observerOrOnNext,
            onError, onCompleted) {
            return observerOrOnNext && typeof observerOrOnNext === "object" ? this._acceptObservable(observerOrOnNext) : this._accept(observerOrOnNext, onError, onCompleted)
        };
        Notification.prototype.toObservable = function(scheduler) {
            var self = this;
            isScheduler(scheduler) || (scheduler = immediateScheduler);
            return new AnonymousObservable(function(observer) {
                return scheduler.scheduleWithState(self, function(_, notification) {
                    notification._acceptObservable(observer);
                    notification.kind === "N" && observer.onCompleted()
                })
            })
        };
        return Notification
    }();
    var notificationCreateOnNext = Notification.createOnNext = function() {
        function _accept(onNext) {
            return onNext(this.value)
        }

        function _acceptObservable(observer) {
            return observer.onNext(this.value)
        }

        function toString() {
            return "OnNext(" + this.value + ")"
        }
        return function(value) {
            return new Notification("N", value, null, _accept, _acceptObservable, toString)
        }
    }();
    var notificationCreateOnError = Notification.createOnError = function() {
        function _accept(onNext, onError) {
            return onError(this.exception)
        }

        function _acceptObservable(observer) {
            return observer.onError(this.exception)
        }

        function toString() {
            return "OnError(" + this.exception + ")"
        }
        return function(e) {
            return new Notification("E", null, e, _accept, _acceptObservable, toString)
        }
    }();
    var notificationCreateOnCompleted = Notification.createOnCompleted = function() {
        function _accept(onNext, onError, onCompleted) {
            return onCompleted()
        }

        function _acceptObservable(observer) {
            return observer.onCompleted()
        }

        function toString() {
            return "OnCompleted()"
        }
        return function() {
            return new Notification("C", null, null, _accept, _acceptObservable, toString)
        }
    }();
    var Enumerator =
        Rx.internals.Enumerator = function(next) {
            this._next = next
        };
    Enumerator.prototype.next = function() {
        return this._next()
    };
    Enumerator.prototype[$iterator$] = function() {
        return this
    };
    var Enumerable = Rx.internals.Enumerable = function(iterator) {
        this._iterator = iterator
    };
    Enumerable.prototype[$iterator$] = function() {
        return this._iterator()
    };
    Enumerable.prototype.concat = function() {
        var sources = this;
        return new AnonymousObservable(function(o) {
            var e = sources[$iterator$]();
            var isDisposed, subscription = new SerialDisposable;
            var cancelable =
                immediateScheduler.scheduleRecursive(function(self) {
                    if (isDisposed) return;
                    try {
                        var currentItem = e.next()
                    } catch (ex) {
                        return o.onError(ex)
                    }
                    if (currentItem.done) return o.onCompleted();
                    var currentValue = currentItem.value;
                    isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
                    var d = new SingleAssignmentDisposable;
                    subscription.setDisposable(d);
                    d.setDisposable(currentValue.subscribe(function(x) {
                        o.onNext(x)
                    }, function(err) {
                        o.onError(err)
                    }, self))
                });
            return new CompositeDisposable(subscription,
                cancelable, disposableCreate(function() {
                    isDisposed = true
                }))
        })
    };
    Enumerable.prototype.catchError = function() {
        var sources = this;
        return new AnonymousObservable(function(o) {
            var e = sources[$iterator$]();
            var isDisposed, subscription = new SerialDisposable;
            var cancelable = immediateScheduler.scheduleRecursiveWithState(null, function(lastException, self) {
                if (isDisposed) return;
                try {
                    var currentItem = e.next()
                } catch (ex) {
                    return observer.onError(ex)
                }
                if (currentItem.done) {
                    if (lastException !== null) o.onError(lastException);
                    else o.onCompleted();
                    return
                }
                var currentValue = currentItem.value;
                isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
                var d = new SingleAssignmentDisposable;
                subscription.setDisposable(d);
                d.setDisposable(currentValue.subscribe(function(x) {
                    o.onNext(x)
                }, self, function() {
                    o.onCompleted()
                }))
            });
            return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
                isDisposed = true
            }))
        })
    };
    Enumerable.prototype.catchErrorWhen = function(notificationHandler) {
        var sources = this;
        return new AnonymousObservable(function(o) {
            var exceptions =
                new Subject,
                notifier = new Subject,
                handled = notificationHandler(exceptions),
                notificationDisposable = handled.subscribe(notifier);
            var e = sources[$iterator$]();
            var isDisposed, lastException, subscription = new SerialDisposable;
            var cancelable = immediateScheduler.scheduleRecursive(function(self) {
                if (isDisposed) return;
                try {
                    var currentItem = e.next()
                } catch (ex) {
                    return o.onError(ex)
                }
                if (currentItem.done) {
                    if (lastException) o.onError(lastException);
                    else o.onCompleted();
                    return
                }
                var currentValue = currentItem.value;
                isPromise(currentValue) &&
                    (currentValue = observableFromPromise(currentValue));
                var outer = new SingleAssignmentDisposable;
                var inner = new SingleAssignmentDisposable;
                subscription.setDisposable(new CompositeDisposable(inner, outer));
                outer.setDisposable(currentValue.subscribe(function(x) {
                    o.onNext(x)
                }, function(exn) {
                    inner.setDisposable(notifier.subscribe(self, function(ex) {
                        o.onError(ex)
                    }, function() {
                        o.onCompleted()
                    }));
                    exceptions.onNext(exn)
                }, function() {
                    o.onCompleted()
                }))
            });
            return new CompositeDisposable(notificationDisposable, subscription,
                cancelable, disposableCreate(function() {
                    isDisposed = true
                }))
        })
    };
    var enumerableRepeat = Enumerable.repeat = function(value, repeatCount) {
        if (repeatCount == null) repeatCount = -1;
        return new Enumerable(function() {
            var left = repeatCount;
            return new Enumerator(function() {
                if (left === 0) return doneEnumerator;
                if (left > 0) left--;
                return {
                    done: false,
                    value: value
                }
            })
        })
    };
    var enumerableOf = Enumerable.of = function(source, selector, thisArg) {
        if (selector) var selectorFn = bindCallback(selector, thisArg, 3);
        return new Enumerable(function() {
            var index = -1;
            return new Enumerator(function() {
                return ++index < source.length ? {
                    done: false,
                    value: !selector ? source[index] : selectorFn(source[index], index, source)
                } : doneEnumerator
            })
        })
    };
    var Observer = Rx.Observer = function() {};
    Observer.prototype.toNotifier = function() {
        var observer = this;
        return function(n) {
            return n.accept(observer)
        }
    };
    Observer.prototype.asObserver = function() {
        return new AnonymousObserver(this.onNext.bind(this), this.onError.bind(this), this.onCompleted.bind(this))
    };
    Observer.prototype.checked = function() {
        return new CheckedObserver(this)
    };
    var observerCreate = Observer.create = function(onNext, onError, onCompleted) {
        onNext || (onNext = noop);
        onError || (onError = defaultError);
        onCompleted || (onCompleted = noop);
        return new AnonymousObserver(onNext, onError, onCompleted)
    };
    Observer.fromNotifier = function(handler, thisArg) {
        return new AnonymousObserver(function(x) {
            return handler.call(thisArg, notificationCreateOnNext(x))
        }, function(e) {
            return handler.call(thisArg, notificationCreateOnError(e))
        }, function() {
            return handler.call(thisArg, notificationCreateOnCompleted())
        })
    };
    Observer.prototype.notifyOn = function(scheduler) {
        return new ObserveOnObserver(scheduler, this)
    };
    Observer.prototype.makeSafe = function(disposable) {
        return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable)
    };
    var AbstractObserver = Rx.internals.AbstractObserver = function(__super__) {
        inherits(AbstractObserver, __super__);

        function AbstractObserver() {
            this.isStopped = false;
            __super__.call(this)
        }
        AbstractObserver.prototype.next = notImplemented;
        AbstractObserver.prototype.error = notImplemented;
        AbstractObserver.prototype.completed = notImplemented;
        AbstractObserver.prototype.onNext = function(value) {
            if (!this.isStopped) this.next(value)
        };
        AbstractObserver.prototype.onError = function(error) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.error(error)
            }
        };
        AbstractObserver.prototype.onCompleted = function() {
            if (!this.isStopped) {
                this.isStopped = true;
                this.completed()
            }
        };
        AbstractObserver.prototype.dispose = function() {
            this.isStopped = true
        };
        AbstractObserver.prototype.fail = function(e) {
            if (!this.isStopped) {
                this.isStopped =
                    true;
                this.error(e);
                return true
            }
            return false
        };
        return AbstractObserver
    }(Observer);
    var AnonymousObserver = Rx.AnonymousObserver = function(__super__) {
        inherits(AnonymousObserver, __super__);

        function AnonymousObserver(onNext, onError, onCompleted) {
            __super__.call(this);
            this._onNext = onNext;
            this._onError = onError;
            this._onCompleted = onCompleted
        }
        AnonymousObserver.prototype.next = function(value) {
            this._onNext(value)
        };
        AnonymousObserver.prototype.error = function(error) {
            this._onError(error)
        };
        AnonymousObserver.prototype.completed =
            function() {
                this._onCompleted()
            };
        return AnonymousObserver
    }(AbstractObserver);
    var CheckedObserver = function(__super__) {
        inherits(CheckedObserver, __super__);

        function CheckedObserver(observer) {
            __super__.call(this);
            this._observer = observer;
            this._state = 0
        }
        var CheckedObserverPrototype = CheckedObserver.prototype;
        CheckedObserverPrototype.onNext = function(value) {
            this.checkAccess();
            var res = tryCatch(this._observer.onNext).call(this._observer, value);
            this._state = 0;
            res === errorObj && thrower(res.e)
        };
        CheckedObserverPrototype.onError =
            function(err) {
                this.checkAccess();
                var res = tryCatch(this._observer.onError).call(this._observer, err);
                this._state = 2;
                res === errorObj && thrower(res.e)
            };
        CheckedObserverPrototype.onCompleted = function() {
            this.checkAccess();
            var res = tryCatch(this._observer.onCompleted).call(this._observer);
            this._state = 2;
            res === errorObj && thrower(res.e)
        };
        CheckedObserverPrototype.checkAccess = function() {
            if (this._state === 1) throw new Error("Re-entrancy detected");
            if (this._state === 2) throw new Error("Observer completed");
            if (this._state ===
                0) this._state = 1
        };
        return CheckedObserver
    }(Observer);
    var ScheduledObserver = Rx.internals.ScheduledObserver = function(__super__) {
        inherits(ScheduledObserver, __super__);

        function ScheduledObserver(scheduler, observer) {
            __super__.call(this);
            this.scheduler = scheduler;
            this.observer = observer;
            this.isAcquired = false;
            this.hasFaulted = false;
            this.queue = [];
            this.disposable = new SerialDisposable
        }
        ScheduledObserver.prototype.next = function(value) {
            var self = this;
            this.queue.push(function() {
                self.observer.onNext(value)
            })
        };
        ScheduledObserver.prototype.error =
            function(e) {
                var self = this;
                this.queue.push(function() {
                    self.observer.onError(e)
                })
            };
        ScheduledObserver.prototype.completed = function() {
            var self = this;
            this.queue.push(function() {
                self.observer.onCompleted()
            })
        };
        ScheduledObserver.prototype.ensureActive = function() {
            var isOwner = false,
                parent = this;
            if (!this.hasFaulted && this.queue.length > 0) {
                isOwner = !this.isAcquired;
                this.isAcquired = true
            }
            if (isOwner) this.disposable.setDisposable(this.scheduler.scheduleRecursive(function(self) {
                var work;
                if (parent.queue.length > 0) work = parent.queue.shift();
                else {
                    parent.isAcquired = false;
                    return
                }
                try {
                    work()
                } catch (ex) {
                    parent.queue = [];
                    parent.hasFaulted = true;
                    throw ex;
                }
                self()
            }))
        };
        ScheduledObserver.prototype.dispose = function() {
            __super__.prototype.dispose.call(this);
            this.disposable.dispose()
        };
        return ScheduledObserver
    }(AbstractObserver);
    var ObserveOnObserver = function(__super__) {
        inherits(ObserveOnObserver, __super__);

        function ObserveOnObserver(scheduler, observer, cancel) {
            __super__.call(this, scheduler, observer);
            this._cancel = cancel
        }
        ObserveOnObserver.prototype.next =
            function(value) {
                __super__.prototype.next.call(this, value);
                this.ensureActive()
            };
        ObserveOnObserver.prototype.error = function(e) {
            __super__.prototype.error.call(this, e);
            this.ensureActive()
        };
        ObserveOnObserver.prototype.completed = function() {
            __super__.prototype.completed.call(this);
            this.ensureActive()
        };
        ObserveOnObserver.prototype.dispose = function() {
            __super__.prototype.dispose.call(this);
            this._cancel && this._cancel.dispose();
            this._cancel = null
        };
        return ObserveOnObserver
    }(ScheduledObserver);
    var observableProto;
    var Observable = Rx.Observable = function() {
        function Observable(subscribe) {
            if (Rx.config.longStackSupport && hasStacks) {
                try {
                    throw new Error;
                } catch (e) {
                    this.stack = e.stack.substring(e.stack.indexOf("\n") + 1)
                }
                var self = this;
                this._subscribe = function(observer) {
                    var oldOnError = observer.onError.bind(observer);
                    observer.onError = function(err) {
                        makeStackTraceLong(err, self);
                        oldOnError(err)
                    };
                    return subscribe.call(self, observer)
                }
            } else this._subscribe = subscribe
        }
        observableProto = Observable.prototype;
        observableProto.subscribe =
            observableProto.forEach = function(observerOrOnNext, onError, onCompleted) {
                return this._subscribe(typeof observerOrOnNext === "object" ? observerOrOnNext : observerCreate(observerOrOnNext, onError, onCompleted))
            };
        observableProto.subscribeOnNext = function(onNext, thisArg) {
            return this._subscribe(observerCreate(typeof thisArg !== "undefined" ? function(x) {
                onNext.call(thisArg, x)
            } : onNext))
        };
        observableProto.subscribeOnError = function(onError, thisArg) {
            return this._subscribe(observerCreate(null, typeof thisArg !== "undefined" ?
                function(e) {
                    onError.call(thisArg, e)
                } : onError))
        };
        observableProto.subscribeOnCompleted = function(onCompleted, thisArg) {
            return this._subscribe(observerCreate(null, null, typeof thisArg !== "undefined" ? function() {
                onCompleted.call(thisArg)
            } : onCompleted))
        };
        return Observable
    }();
    var ObservableBase = Rx.ObservableBase = function(__super__) {
        inherits(ObservableBase, __super__);

        function fixSubscriber(subscriber) {
            return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) :
                disposableEmpty
        }

        function setDisposable(s, state) {
            var ado = state[0],
                self = state[1];
            var sub = tryCatch(self.subscribeCore).call(self, ado);
            if (sub === errorObj)
                if (!ado.fail(errorObj.e)) return thrower(errorObj.e);
            ado.setDisposable(fixSubscriber(sub))
        }

        function subscribe(observer) {
            var ado = new AutoDetachObserver(observer),
                state = [ado, this];
            if (currentThreadScheduler.scheduleRequired()) currentThreadScheduler.scheduleWithState(state, setDisposable);
            else setDisposable(null, state);
            return ado
        }

        function ObservableBase() {
            __super__.call(this,
                subscribe)
        }
        ObservableBase.prototype.subscribeCore = notImplemented;
        return ObservableBase
    }(Observable);
    observableProto.observeOn = function(scheduler) {
        var source = this;
        return new AnonymousObservable(function(observer) {
            return source.subscribe(new ObserveOnObserver(scheduler, observer))
        }, source)
    };
    observableProto.subscribeOn = function(scheduler) {
        var source = this;
        return new AnonymousObservable(function(observer) {
            var m = new SingleAssignmentDisposable,
                d = new SerialDisposable;
            d.setDisposable(m);
            m.setDisposable(scheduler.schedule(function() {
                d.setDisposable(new ScheduledDisposable(scheduler,
                    source.subscribe(observer)))
            }));
            return d
        }, source)
    };
    var observableFromPromise = Observable.fromPromise = function(promise) {
        return observableDefer(function() {
            var subject = new Rx.AsyncSubject;
            promise.then(function(value) {
                subject.onNext(value);
                subject.onCompleted()
            }, subject.onError.bind(subject));
            return subject
        })
    };
    observableProto.toPromise = function(promiseCtor) {
        promiseCtor || (promiseCtor = Rx.config.Promise);
        if (!promiseCtor) throw new NotSupportedError("Promise type not provided nor in Rx.config.Promise");
        var source =
            this;
        return new promiseCtor(function(resolve, reject) {
            var value, hasValue = false;
            source.subscribe(function(v) {
                value = v;
                hasValue = true
            }, reject, function() {
                hasValue && resolve(value)
            })
        })
    };
    var ToArrayObservable = function(__super__) {
        inherits(ToArrayObservable, __super__);

        function ToArrayObservable(source) {
            this.source = source;
            __super__.call(this)
        }
        ToArrayObservable.prototype.subscribeCore = function(observer) {
            return this.source.subscribe(new ToArrayObserver(observer))
        };
        return ToArrayObservable
    }(ObservableBase);

    function ToArrayObserver(observer) {
        this.observer =
            observer;
        this.a = [];
        this.isStopped = false
    }
    ToArrayObserver.prototype.onNext = function(x) {
        if (!this.isStopped) this.a.push(x)
    };
    ToArrayObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
            this.isStopped = true;
            this.observer.onError(e)
        }
    };
    ToArrayObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
            this.isStopped = true;
            this.observer.onNext(this.a);
            this.observer.onCompleted()
        }
    };
    ToArrayObserver.prototype.dispose = function() {
        this.isStopped = true
    };
    ToArrayObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
            this.isStopped =
                true;
            this.observer.onError(e);
            return true
        }
        return false
    };
    observableProto.toArray = function() {
        return new ToArrayObservable(this)
    };
    Observable.create = Observable.createWithDisposable = function(subscribe, parent) {
        return new AnonymousObservable(subscribe, parent)
    };
    var observableDefer = Observable.defer = function(observableFactory) {
        return new AnonymousObservable(function(observer) {
            var result;
            try {
                result = observableFactory()
            } catch (e) {
                return observableThrow(e).subscribe(observer)
            }
            isPromise(result) && (result = observableFromPromise(result));
            return result.subscribe(observer)
        })
    };
    var EmptyObservable = function(__super__) {
        inherits(EmptyObservable, __super__);

        function EmptyObservable(scheduler) {
            this.scheduler = scheduler;
            __super__.call(this)
        }
        EmptyObservable.prototype.subscribeCore = function(observer) {
            var sink = new EmptySink(observer, this);
            return sink.run()
        };

        function EmptySink(observer, parent) {
            this.observer = observer;
            this.parent = parent
        }

        function scheduleItem(s, state) {
            state.onCompleted()
        }
        EmptySink.prototype.run = function() {
            return this.parent.scheduler.scheduleWithState(this.observer,
                scheduleItem)
        };
        return EmptyObservable
    }(ObservableBase);
    var observableEmpty = Observable.empty = function(scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new EmptyObservable(scheduler)
    };
    var FromObservable = function(__super__) {
        inherits(FromObservable, __super__);

        function FromObservable(iterable, mapper, scheduler) {
            this.iterable = iterable;
            this.mapper = mapper;
            this.scheduler = scheduler;
            __super__.call(this)
        }
        FromObservable.prototype.subscribeCore = function(observer) {
            var sink = new FromSink(observer,
                this);
            return sink.run()
        };
        return FromObservable
    }(ObservableBase);
    var FromSink = function() {
        function FromSink(observer, parent) {
            this.observer = observer;
            this.parent = parent
        }
        FromSink.prototype.run = function() {
            var list = Object(this.parent.iterable),
                it = getIterable(list),
                observer = this.observer,
                mapper = this.parent.mapper;

            function loopRecursive(i, recurse) {
                try {
                    var next = it.next()
                } catch (e) {
                    return observer.onError(e)
                }
                if (next.done) return observer.onCompleted();
                var result = next.value;
                if (mapper) try {
                    result = mapper(result, i)
                } catch (e) {
                    return observer.onError(e)
                }
                observer.onNext(result);
                recurse(i + 1)
            }
            return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive)
        };
        return FromSink
    }();
    var maxSafeInteger = Math.pow(2, 53) - 1;

    function StringIterable(str) {
        this._s = s
    }
    StringIterable.prototype[$iterator$] = function() {
        return new StringIterator(this._s)
    };

    function StringIterator(str) {
        this._s = s;
        this._l = s.length;
        this._i = 0
    }
    StringIterator.prototype[$iterator$] = function() {
        return this
    };
    StringIterator.prototype.next = function() {
        return this._i < this._l ? {
                done: false,
                value: this._s.charAt(this._i++)
            } :
            doneEnumerator
    };

    function ArrayIterable(a) {
        this._a = a
    }
    ArrayIterable.prototype[$iterator$] = function() {
        return new ArrayIterator(this._a)
    };

    function ArrayIterator(a) {
        this._a = a;
        this._l = toLength(a);
        this._i = 0
    }
    ArrayIterator.prototype[$iterator$] = function() {
        return this
    };
    ArrayIterator.prototype.next = function() {
        return this._i < this._l ? {
            done: false,
            value: this._a[this._i++]
        } : doneEnumerator
    };

    function numberIsFinite(value) {
        return typeof value === "number" && root.isFinite(value)
    }

    function isNan(n) {
        return n !== n
    }

    function getIterable(o) {
        var i =
            o[$iterator$],
            it;
        if (!i && typeof o === "string") {
            it = new StringIterable(o);
            return it[$iterator$]()
        }
        if (!i && o.length !== undefined) {
            it = new ArrayIterable(o);
            return it[$iterator$]()
        }
        if (!i) throw new TypeError("Object is not iterable");
        return o[$iterator$]()
    }

    function sign(value) {
        var number = +value;
        if (number === 0) return number;
        if (isNaN(number)) return number;
        return number < 0 ? -1 : 1
    }

    function toLength(o) {
        var len = +o.length;
        if (isNaN(len)) return 0;
        if (len === 0 || !numberIsFinite(len)) return len;
        len = sign(len) * Math.floor(Math.abs(len));
        if (len <= 0) return 0;
        if (len > maxSafeInteger) return maxSafeInteger;
        return len
    }
    var observableFrom = Observable.from = function(iterable, mapFn, thisArg, scheduler) {
        if (iterable == null) throw new Error("iterable cannot be null.");
        if (mapFn && !isFunction(mapFn)) throw new Error("mapFn when provided must be a function");
        if (mapFn) var mapper = bindCallback(mapFn, thisArg, 2);
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromObservable(iterable, mapper, scheduler)
    };
    var FromArrayObservable = function(__super__) {
        inherits(FromArrayObservable,
            __super__);

        function FromArrayObservable(args, scheduler) {
            this.args = args;
            this.scheduler = scheduler;
            __super__.call(this)
        }
        FromArrayObservable.prototype.subscribeCore = function(observer) {
            var sink = new FromArraySink(observer, this);
            return sink.run()
        };
        return FromArrayObservable
    }(ObservableBase);

    function FromArraySink(observer, parent) {
        this.observer = observer;
        this.parent = parent
    }
    FromArraySink.prototype.run = function() {
        var observer = this.observer,
            args = this.parent.args,
            len = args.length;

        function loopRecursive(i, recurse) {
            if (i <
                len) {
                observer.onNext(args[i]);
                recurse(i + 1)
            } else observer.onCompleted()
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive)
    };
    var observableFromArray = Observable.fromArray = function(array, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromArrayObservable(array, scheduler)
    };
    Observable.generate = function(initialState, condition, iterate, resultSelector, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new AnonymousObservable(function(o) {
            var first =
                true;
            return scheduler.scheduleRecursiveWithState(initialState, function(state, self) {
                var hasResult, result;
                try {
                    if (first) first = false;
                    else state = iterate(state);
                    hasResult = condition(state);
                    hasResult && (result = resultSelector(state))
                } catch (e) {
                    return o.onError(e)
                }
                if (hasResult) {
                    o.onNext(result);
                    self(state)
                } else o.onCompleted()
            })
        })
    };

    function observableOf(scheduler, array) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromArrayObservable(array, scheduler)
    }
    Observable.of = function() {
        var len =
            arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) args[i] = arguments[i];
        return new FromArrayObservable(args, currentThreadScheduler)
    };
    Observable.ofWithScheduler = function(scheduler) {
        var len = arguments.length,
            args = new Array(len - 1);
        for (var i = 1; i < len; i++) args[i - 1] = arguments[i];
        return new FromArrayObservable(args, scheduler)
    };
    var NeverObservable = function(__super__) {
        inherits(NeverObservable, __super__);

        function NeverObservable() {
            __super__.call(this)
        }
        NeverObservable.prototype.subscribeCore = function(observer) {
            return disposableEmpty
        };
        return NeverObservable
    }(ObservableBase);
    var observableNever = Observable.never = function() {
        return new NeverObservable
    };
    var PairsObservable = function(__super__) {
        inherits(PairsObservable, __super__);

        function PairsObservable(obj, scheduler) {
            this.obj = obj;
            this.keys = Object.keys(obj);
            this.scheduler = scheduler;
            __super__.call(this)
        }
        PairsObservable.prototype.subscribeCore = function(observer) {
            var sink = new PairsSink(observer, this);
            return sink.run()
        };
        return PairsObservable
    }(ObservableBase);

    function PairsSink(observer,
        parent) {
        this.observer = observer;
        this.parent = parent
    }
    PairsSink.prototype.run = function() {
        var observer = this.observer,
            obj = this.parent.obj,
            keys = this.parent.keys,
            len = keys.length;

        function loopRecursive(i, recurse) {
            if (i < len) {
                var key = keys[i];
                observer.onNext([key, obj[key]]);
                recurse(i + 1)
            } else observer.onCompleted()
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive)
    };
    Observable.pairs = function(obj, scheduler) {
        scheduler || (scheduler = currentThreadScheduler);
        return new PairsObservable(obj, scheduler)
    };
    var RangeObservable = function(__super__) {
        inherits(RangeObservable, __super__);

        function RangeObservable(start, count, scheduler) {
            this.start = start;
            this.count = count;
            this.scheduler = scheduler;
            __super__.call(this)
        }
        RangeObservable.prototype.subscribeCore = function(observer) {
            var sink = new RangeSink(observer, this);
            return sink.run()
        };
        return RangeObservable
    }(ObservableBase);
    var RangeSink = function() {
        function RangeSink(observer, parent) {
            this.observer = observer;
            this.parent = parent
        }
        RangeSink.prototype.run = function() {
            var start =
                this.parent.start,
                count = this.parent.count,
                observer = this.observer;

            function loopRecursive(i, recurse) {
                if (i < count) {
                    observer.onNext(start + i);
                    recurse(i + 1)
                } else observer.onCompleted()
            }
            return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive)
        };
        return RangeSink
    }();
    Observable.range = function(start, count, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new RangeObservable(start, count, scheduler)
    };
    var RepeatObservable = function(__super__) {
        inherits(RepeatObservable, __super__);

        function RepeatObservable(value, repeatCount, scheduler) {
            this.value = value;
            this.repeatCount = repeatCount == null ? -1 : repeatCount;
            this.scheduler = scheduler;
            __super__.call(this)
        }
        RepeatObservable.prototype.subscribeCore = function(observer) {
            var sink = new RepeatSink(observer, this);
            return sink.run()
        };
        return RepeatObservable
    }(ObservableBase);

    function RepeatSink(observer, parent) {
        this.observer = observer;
        this.parent = parent
    }
    RepeatSink.prototype.run = function() {
        var observer = this.observer,
            value = this.parent.value;

        function loopRecursive(i,
            recurse) {
            if (i === -1 || i > 0) {
                observer.onNext(value);
                i > 0 && i--
            }
            if (i === 0) return observer.onCompleted();
            recurse(i)
        }
        return this.parent.scheduler.scheduleRecursiveWithState(this.parent.repeatCount, loopRecursive)
    };
    Observable.repeat = function(value, repeatCount, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new RepeatObservable(value, repeatCount, scheduler)
    };
    var JustObservable = function(__super__) {
        inherits(JustObservable, __super__);

        function JustObservable(value, scheduler) {
            this.value =
                value;
            this.scheduler = scheduler;
            __super__.call(this)
        }
        JustObservable.prototype.subscribeCore = function(observer) {
            var sink = new JustSink(observer, this);
            return sink.run()
        };

        function JustSink(observer, parent) {
            this.observer = observer;
            this.parent = parent
        }

        function scheduleItem(s, state) {
            var value = state[0],
                observer = state[1];
            observer.onNext(value);
            observer.onCompleted()
        }
        JustSink.prototype.run = function() {
            return this.parent.scheduler.scheduleWithState([this.parent.value, this.observer], scheduleItem)
        };
        return JustObservable
    }(ObservableBase);
    var observableReturn = Observable["return"] = Observable.just = Observable.returnValue = function(value, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new JustObservable(value, scheduler)
    };
    var ThrowObservable = function(__super__) {
        inherits(ThrowObservable, __super__);

        function ThrowObservable(error, scheduler) {
            this.error = error;
            this.scheduler = scheduler;
            __super__.call(this)
        }
        ThrowObservable.prototype.subscribeCore = function(observer) {
            var sink = new ThrowSink(observer, this);
            return sink.run()
        };

        function ThrowSink(observer, parent) {
            this.observer = observer;
            this.parent = parent
        }

        function scheduleItem(s, state) {
            var error = state[0],
                observer = state[1];
            observer.onError(error)
        }
        ThrowSink.prototype.run = function() {
            return this.parent.scheduler.scheduleWithState([this.parent.error, this.observer], scheduleItem)
        };
        return ThrowObservable
    }(ObservableBase);
    var observableThrow = Observable["throw"] = Observable.throwError = Observable.throwException = function(error, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new ThrowObservable(error, scheduler)
    };
    Observable.using = function(resourceFactory, observableFactory) {
        return new AnonymousObservable(function(observer) {
            var disposable = disposableEmpty,
                resource, source;
            try {
                resource = resourceFactory();
                resource && (disposable = resource);
                source = observableFactory(resource)
            } catch (exception) {
                return new CompositeDisposable(observableThrow(exception).subscribe(observer), disposable)
            }
            return new CompositeDisposable(source.subscribe(observer), disposable)
        })
    };
    observableProto.amb =
        function(rightSource) {
            var leftSource = this;
            return new AnonymousObservable(function(observer) {
                var choice, leftChoice = "L",
                    rightChoice = "R",
                    leftSubscription = new SingleAssignmentDisposable,
                    rightSubscription = new SingleAssignmentDisposable;
                isPromise(rightSource) && (rightSource = observableFromPromise(rightSource));

                function choiceL() {
                    if (!choice) {
                        choice = leftChoice;
                        rightSubscription.dispose()
                    }
                }

                function choiceR() {
                    if (!choice) {
                        choice = rightChoice;
                        leftSubscription.dispose()
                    }
                }
                leftSubscription.setDisposable(leftSource.subscribe(function(left) {
                    choiceL();
                    if (choice === leftChoice) observer.onNext(left)
                }, function(err) {
                    choiceL();
                    if (choice === leftChoice) observer.onError(err)
                }, function() {
                    choiceL();
                    if (choice === leftChoice) observer.onCompleted()
                }));
                rightSubscription.setDisposable(rightSource.subscribe(function(right) {
                    choiceR();
                    if (choice === rightChoice) observer.onNext(right)
                }, function(err) {
                    choiceR();
                    if (choice === rightChoice) observer.onError(err)
                }, function() {
                    choiceR();
                    if (choice === rightChoice) observer.onCompleted()
                }));
                return new CompositeDisposable(leftSubscription,
                    rightSubscription)
            })
        };
    Observable.amb = function() {
        var acc = observableNever(),
            items = [];
        if (Array.isArray(arguments[0])) items = arguments[0];
        else
            for (var i = 0, len = arguments.length; i < len; i++) items.push(arguments[i]);

        function func(previous, current) {
            return previous.amb(current)
        }
        for (var i = 0, len = items.length; i < len; i++) acc = func(acc, items[i]);
        return acc
    };

    function observableCatchHandler(source, handler) {
        return new AnonymousObservable(function(o) {
            var d1 = new SingleAssignmentDisposable,
                subscription = new SerialDisposable;
            subscription.setDisposable(d1);
            d1.setDisposable(source.subscribe(function(x) {
                o.onNext(x)
            }, function(e) {
                try {
                    var result = handler(e)
                } catch (ex) {
                    return o.onError(ex)
                }
                isPromise(result) && (result = observableFromPromise(result));
                var d = new SingleAssignmentDisposable;
                subscription.setDisposable(d);
                d.setDisposable(result.subscribe(o))
            }, function(x) {
                o.onCompleted(x)
            }));
            return subscription
        }, source)
    }
    observableProto["catch"] = observableProto.catchError = observableProto.catchException = function(handlerOrSecond) {
        return typeof handlerOrSecond ===
            "function" ? observableCatchHandler(this, handlerOrSecond) : observableCatch([this, handlerOrSecond])
    };
    var observableCatch = Observable.catchError = Observable["catch"] = Observable.catchException = function() {
        var items = [];
        if (Array.isArray(arguments[0])) items = arguments[0];
        else
            for (var i = 0, len = arguments.length; i < len; i++) items.push(arguments[i]);
        return enumerableOf(items).catchError()
    };
    observableProto.combineLatest = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) args[i] = arguments[i];
        if (Array.isArray(args[0])) args[0].unshift(this);
        else args.unshift(this);
        return combineLatest.apply(this, args)
    };
    var combineLatest = Observable.combineLatest = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) args[i] = arguments[i];
        var resultSelector = args.pop();
        Array.isArray(args[0]) && (args = args[0]);
        return new AnonymousObservable(function(o) {
            var n = args.length,
                falseFactory = function() {
                    return false
                },
                hasValue = arrayInitialize(n, falseFactory),
                hasValueAll = false,
                isDone = arrayInitialize(n,
                    falseFactory),
                values = new Array(n);

            function next(i) {
                hasValue[i] = true;
                if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
                    try {
                        var res = resultSelector.apply(null, values)
                    } catch (e) {
                        return o.onError(e)
                    }
                    o.onNext(res)
                } else if (isDone.filter(function(x, j) {
                        return j !== i
                    }).every(identity)) o.onCompleted()
            }

            function done(i) {
                isDone[i] = true;
                isDone.every(identity) && o.onCompleted()
            }
            var subscriptions = new Array(n);
            for (var idx = 0; idx < n; idx++)(function(i) {
                var source = args[i],
                    sad = new SingleAssignmentDisposable;
                isPromise(source) &&
                    (source = observableFromPromise(source));
                sad.setDisposable(source.subscribe(function(x) {
                    values[i] = x;
                    next(i)
                }, function(e) {
                    o.onError(e)
                }, function() {
                    done(i)
                }));
                subscriptions[i] = sad
            })(idx);
            return new CompositeDisposable(subscriptions)
        }, this)
    };
    observableProto.concat = function() {
        for (var args = [], i = 0, len = arguments.length; i < len; i++) args.push(arguments[i]);
        args.unshift(this);
        return observableConcat.apply(null, args)
    };
    var observableConcat = Observable.concat = function() {
        var args;
        if (Array.isArray(arguments[0])) args =
            arguments[0];
        else {
            args = new Array(arguments.length);
            for (var i = 0, len = arguments.length; i < len; i++) args[i] = arguments[i]
        }
        return enumerableOf(args).concat()
    };
    observableProto.concatAll = observableProto.concatObservable = function() {
        return this.merge(1)
    };
    var MergeObservable = function(__super__) {
        inherits(MergeObservable, __super__);

        function MergeObservable(source, maxConcurrent) {
            this.source = source;
            this.maxConcurrent = maxConcurrent;
            __super__.call(this)
        }
        MergeObservable.prototype.subscribeCore = function(observer) {
            var g =
                new CompositeDisposable;
            g.add(this.source.subscribe(new MergeObserver(observer, this.maxConcurrent, g)));
            return g
        };
        return MergeObservable
    }(ObservableBase);
    var MergeObserver = function() {
        function MergeObserver(o, max, g) {
            this.o = o;
            this.max = max;
            this.g = g;
            this.done = false;
            this.q = [];
            this.activeCount = 0;
            this.isStopped = false
        }
        MergeObserver.prototype.handleSubscribe = function(xs) {
            var sad = new SingleAssignmentDisposable;
            this.g.add(sad);
            isPromise(xs) && (xs = observableFromPromise(xs));
            sad.setDisposable(xs.subscribe(new InnerObserver(this,
                sad)))
        };
        MergeObserver.prototype.onNext = function(innerSource) {
            if (this.isStopped) return;
            if (this.activeCount < this.max) {
                this.activeCount++;
                this.handleSubscribe(innerSource)
            } else this.q.push(innerSource)
        };
        MergeObserver.prototype.onError = function(e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e)
            }
        };
        MergeObserver.prototype.onCompleted = function() {
            if (!this.isStopped) {
                this.isStopped = true;
                this.done = true;
                this.activeCount === 0 && this.o.onCompleted()
            }
        };
        MergeObserver.prototype.dispose = function() {
            this.isStopped =
                true
        };
        MergeObserver.prototype.fail = function(e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
                return true
            }
            return false
        };

        function InnerObserver(parent, sad) {
            this.parent = parent;
            this.sad = sad;
            this.isStopped = false
        }
        InnerObserver.prototype.onNext = function(x) {
            if (!this.isStopped) this.parent.o.onNext(x)
        };
        InnerObserver.prototype.onError = function(e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.parent.o.onError(e)
            }
        };
        InnerObserver.prototype.onCompleted = function() {
            if (!this.isStopped) {
                this.isStopped = true;
                var parent = this.parent;
                parent.g.remove(this.sad);
                if (parent.q.length > 0) parent.handleSubscribe(parent.q.shift());
                else {
                    parent.activeCount--;
                    parent.done && parent.activeCount === 0 && parent.o.onCompleted()
                }
            }
        };
        InnerObserver.prototype.dispose = function() {
            this.isStopped = true
        };
        InnerObserver.prototype.fail = function(e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.parent.o.onError(e);
                return true
            }
            return false
        };
        return MergeObserver
    }();
    observableProto.merge = function(maxConcurrentOrOther) {
        return typeof maxConcurrentOrOther !==
            "number" ? observableMerge(this, maxConcurrentOrOther) : new MergeObservable(this, maxConcurrentOrOther)
    };
    var observableMerge = Observable.merge = function() {
        var scheduler, sources = [],
            i, len = arguments.length;
        if (!arguments[0]) {
            scheduler = immediateScheduler;
            for (i = 1; i < len; i++) sources.push(arguments[i])
        } else if (isScheduler(arguments[0])) {
            scheduler = arguments[0];
            for (i = 1; i < len; i++) sources.push(arguments[i])
        } else {
            scheduler = immediateScheduler;
            for (i = 0; i < len; i++) sources.push(arguments[i])
        }
        if (Array.isArray(sources[0])) sources =
            sources[0];
        return observableOf(scheduler, sources).mergeAll()
    };
    var MergeAllObservable = function(__super__) {
        inherits(MergeAllObservable, __super__);

        function MergeAllObservable(source) {
            this.source = source;
            __super__.call(this)
        }
        MergeAllObservable.prototype.subscribeCore = function(observer) {
            var g = new CompositeDisposable,
                m = new SingleAssignmentDisposable;
            g.add(m);
            m.setDisposable(this.source.subscribe(new MergeAllObserver(observer, g)));
            return g
        };
        return MergeAllObservable
    }(ObservableBase);
    var MergeAllObserver =
        function() {
            function MergeAllObserver(o, g) {
                this.o = o;
                this.g = g;
                this.isStopped = false;
                this.done = false
            }
            MergeAllObserver.prototype.onNext = function(innerSource) {
                if (this.isStopped) return;
                var sad = new SingleAssignmentDisposable;
                this.g.add(sad);
                isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
                sad.setDisposable(innerSource.subscribe(new InnerObserver(this, this.g, sad)))
            };
            MergeAllObserver.prototype.onError = function(e) {
                if (!this.isStopped) {
                    this.isStopped = true;
                    this.o.onError(e)
                }
            };
            MergeAllObserver.prototype.onCompleted =
                function() {
                    if (!this.isStopped) {
                        this.isStopped = true;
                        this.done = true;
                        this.g.length === 1 && this.o.onCompleted()
                    }
                };
            MergeAllObserver.prototype.dispose = function() {
                this.isStopped = true
            };
            MergeAllObserver.prototype.fail = function(e) {
                if (!this.isStopped) {
                    this.isStopped = true;
                    this.o.onError(e);
                    return true
                }
                return false
            };

            function InnerObserver(parent, g, sad) {
                this.parent = parent;
                this.g = g;
                this.sad = sad;
                this.isStopped = false
            }
            InnerObserver.prototype.onNext = function(x) {
                if (!this.isStopped) this.parent.o.onNext(x)
            };
            InnerObserver.prototype.onError =
                function(e) {
                    if (!this.isStopped) {
                        this.isStopped = true;
                        this.parent.o.onError(e)
                    }
                };
            InnerObserver.prototype.onCompleted = function() {
                if (!this.isStopped) {
                    var parent = this.parent;
                    this.isStopped = true;
                    parent.g.remove(this.sad);
                    parent.done && parent.g.length === 1 && parent.o.onCompleted()
                }
            };
            InnerObserver.prototype.dispose = function() {
                this.isStopped = true
            };
            InnerObserver.prototype.fail = function(e) {
                if (!this.isStopped) {
                    this.isStopped = true;
                    this.parent.o.onError(e);
                    return true
                }
                return false
            };
            return MergeAllObserver
        }();
    observableProto.mergeAll =
        observableProto.mergeObservable = function() {
            return new MergeAllObservable(this)
        };
    var CompositeError = Rx.CompositeError = function(errors) {
        this.name = "NotImplementedError";
        this.innerErrors = errors;
        this.message = "This contains multiple errors. Check the innerErrors";
        Error.call(this)
    };
    CompositeError.prototype = Error.prototype;
    Observable.mergeDelayError = function() {
        var args;
        if (Array.isArray(arguments[0])) args = arguments[0];
        else {
            var len = arguments.length;
            args = new Array(len);
            for (var i = 0; i < len; i++) args[i] = arguments[i]
        }
        var source =
            observableOf(null, args);
        return new AnonymousObservable(function(o) {
            var group = new CompositeDisposable,
                m = new SingleAssignmentDisposable,
                isStopped = false,
                errors = [];

            function setCompletion() {
                if (errors.length === 0) o.onCompleted();
                else if (errors.length === 1) o.onError(errors[0]);
                else o.onError(new CompositeError(errors))
            }
            group.add(m);
            m.setDisposable(source.subscribe(function(innerSource) {
                var innerSubscription = new SingleAssignmentDisposable;
                group.add(innerSubscription);
                isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
                innerSubscription.setDisposable(innerSource.subscribe(function(x) {
                    o.onNext(x)
                }, function(e) {
                    errors.push(e);
                    group.remove(innerSubscription);
                    isStopped && group.length === 1 && setCompletion()
                }, function() {
                    group.remove(innerSubscription);
                    isStopped && group.length === 1 && setCompletion()
                }))
            }, function(e) {
                errors.push(e);
                isStopped = true;
                group.length === 1 && setCompletion()
            }, function() {
                isStopped = true;
                group.length === 1 && setCompletion()
            }));
            return group
        })
    };
    observableProto.onErrorResumeNext = function(second) {
        if (!second) throw new Error("Second observable is required");
        return onErrorResumeNext([this, second])
    };
    var onErrorResumeNext = Observable.onErrorResumeNext = function() {
        var sources = [];
        if (Array.isArray(arguments[0])) sources = arguments[0];
        else
            for (var i = 0, len = arguments.length; i < len; i++) sources.push(arguments[i]);
        return new AnonymousObservable(function(observer) {
            var pos = 0,
                subscription = new SerialDisposable,
                cancelable = immediateScheduler.scheduleRecursive(function(self) {
                    var current, d;
                    if (pos < sources.length) {
                        current = sources[pos++];
                        isPromise(current) && (current = observableFromPromise(current));
                        d = new SingleAssignmentDisposable;
                        subscription.setDisposable(d);
                        d.setDisposable(current.subscribe(observer.onNext.bind(observer), self, self))
                    } else observer.onCompleted()
                });
            return new CompositeDisposable(subscription, cancelable)
        })
    };
    observableProto.skipUntil = function(other) {
        var source = this;
        return new AnonymousObservable(function(o) {
            var isOpen = false;
            var disposables = new CompositeDisposable(source.subscribe(function(left) {
                isOpen && o.onNext(left)
            }, function(e) {
                o.onError(e)
            }, function() {
                isOpen && o.onCompleted()
            }));
            isPromise(other) && (other = observableFromPromise(other));
            var rightSubscription = new SingleAssignmentDisposable;
            disposables.add(rightSubscription);
            rightSubscription.setDisposable(other.subscribe(function() {
                isOpen = true;
                rightSubscription.dispose()
            }, function(e) {
                o.onError(e)
            }, function() {
                rightSubscription.dispose()
            }));
            return disposables
        }, source)
    };
    observableProto["switch"] = observableProto.switchLatest = function() {
        var sources = this;
        return new AnonymousObservable(function(observer) {
            var hasLatest = false,
                innerSubscription =
                new SerialDisposable,
                isStopped = false,
                latest = 0,
                subscription = sources.subscribe(function(innerSource) {
                        var d = new SingleAssignmentDisposable,
                            id = ++latest;
                        hasLatest = true;
                        innerSubscription.setDisposable(d);
                        isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
                        d.setDisposable(innerSource.subscribe(function(x) {
                            latest === id && observer.onNext(x)
                        }, function(e) {
                            latest === id && observer.onError(e)
                        }, function() {
                            if (latest === id) {
                                hasLatest = false;
                                isStopped && observer.onCompleted()
                            }
                        }))
                    }, function(e) {
                        observer.onError(e)
                    },
                    function() {
                        isStopped = true;
                        !hasLatest && observer.onCompleted()
                    });
            return new CompositeDisposable(subscription, innerSubscription)
        }, sources)
    };
    observableProto.takeUntil = function(other) {
        var source = this;
        return new AnonymousObservable(function(o) {
            isPromise(other) && (other = observableFromPromise(other));
            return new CompositeDisposable(source.subscribe(o), other.subscribe(function() {
                o.onCompleted()
            }, function(e) {
                o.onError(e)
            }, noop))
        }, source)
    };
    observableProto.withLatestFrom = function() {
        var len = arguments.length,
            args =
            new Array(len);
        for (var i = 0; i < len; i++) args[i] = arguments[i];
        var resultSelector = args.pop(),
            source = this;
        if (typeof source === "undefined") throw new Error("Source observable not found for withLatestFrom().");
        if (typeof resultSelector !== "function") throw new Error("withLatestFrom() expects a resultSelector function.");
        if (Array.isArray(args[0])) args = args[0];
        return new AnonymousObservable(function(observer) {
            var falseFactory = function() {
                    return false
                },
                n = args.length,
                hasValue = arrayInitialize(n, falseFactory),
                hasValueAll =
                false,
                values = new Array(n);
            var subscriptions = new Array(n + 1);
            for (var idx = 0; idx < n; idx++)(function(i) {
                var other = args[i],
                    sad = new SingleAssignmentDisposable;
                isPromise(other) && (other = observableFromPromise(other));
                sad.setDisposable(other.subscribe(function(x) {
                    values[i] = x;
                    hasValue[i] = true;
                    hasValueAll = hasValue.every(identity)
                }, observer.onError.bind(observer), function() {}));
                subscriptions[i] = sad
            })(idx);
            var sad = new SingleAssignmentDisposable;
            sad.setDisposable(source.subscribe(function(x) {
                var res;
                var allValues = [x].concat(values);
                if (!hasValueAll) return;
                try {
                    res = resultSelector.apply(null, allValues)
                } catch (ex) {
                    observer.onError(ex);
                    return
                }
                observer.onNext(res)
            }, observer.onError.bind(observer), function() {
                observer.onCompleted()
            }));
            subscriptions[n] = sad;
            return new CompositeDisposable(subscriptions)
        }, this)
    };

    function zipArray(second, resultSelector) {
        var first = this;
        return new AnonymousObservable(function(observer) {
            var index = 0,
                len = second.length;
            return first.subscribe(function(left) {
                if (index < len) {
                    var right = second[index++],
                        result;
                    try {
                        result = resultSelector(left, right)
                    } catch (e) {
                        return observer.onError(e)
                    }
                    observer.onNext(result)
                } else observer.onCompleted()
            }, function(e) {
                observer.onError(e)
            }, function() {
                observer.onCompleted()
            })
        }, first)
    }

    function falseFactory() {
        return false
    }

    function emptyArrayFactory() {
        return []
    }
    observableProto.zip = function() {
        if (Array.isArray(arguments[0])) return zipArray.apply(this, arguments);
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) args[i] = arguments[i];
        var parent = this,
            resultSelector =
            args.pop();
        args.unshift(parent);
        return new AnonymousObservable(function(observer) {
            var n = args.length,
                queues = arrayInitialize(n, emptyArrayFactory),
                isDone = arrayInitialize(n, falseFactory);

            function next(i) {
                var res, queuedValues;
                if (queues.every(function(x) {
                        return x.length > 0
                    })) {
                    try {
                        queuedValues = queues.map(function(x) {
                            return x.shift()
                        });
                        res = resultSelector.apply(parent, queuedValues)
                    } catch (ex) {
                        observer.onError(ex);
                        return
                    }
                    observer.onNext(res)
                } else if (isDone.filter(function(x, j) {
                        return j !== i
                    }).every(identity)) observer.onCompleted()
            }

            function done(i) {
                isDone[i] = true;
                if (isDone.every(function(x) {
                        return x
                    })) observer.onCompleted()
            }
            var subscriptions = new Array(n);
            for (var idx = 0; idx < n; idx++)(function(i) {
                var source = args[i],
                    sad = new SingleAssignmentDisposable;
                isPromise(source) && (source = observableFromPromise(source));
                sad.setDisposable(source.subscribe(function(x) {
                    queues[i].push(x);
                    next(i)
                }, function(e) {
                    observer.onError(e)
                }, function() {
                    done(i)
                }));
                subscriptions[i] = sad
            })(idx);
            return new CompositeDisposable(subscriptions)
        }, parent)
    };
    Observable.zip =
        function() {
            var len = arguments.length,
                args = new Array(len);
            for (var i = 0; i < len; i++) args[i] = arguments[i];
            var first = args.shift();
            return first.zip.apply(first, args)
        };
    Observable.zipArray = function() {
        var sources;
        if (Array.isArray(arguments[0])) sources = arguments[0];
        else {
            var len = arguments.length;
            sources = new Array(len);
            for (var i = 0; i < len; i++) sources[i] = arguments[i]
        }
        return new AnonymousObservable(function(observer) {
            var n = sources.length,
                queues = arrayInitialize(n, function() {
                    return []
                }),
                isDone = arrayInitialize(n, function() {
                    return false
                });

            function next(i) {
                if (queues.every(function(x) {
                        return x.length > 0
                    })) {
                    var res = queues.map(function(x) {
                        return x.shift()
                    });
                    observer.onNext(res)
                } else if (isDone.filter(function(x, j) {
                        return j !== i
                    }).every(identity)) {
                    observer.onCompleted();
                    return
                }
            }

            function done(i) {
                isDone[i] = true;
                if (isDone.every(identity)) {
                    observer.onCompleted();
                    return
                }
            }
            var subscriptions = new Array(n);
            for (var idx = 0; idx < n; idx++)(function(i) {
                subscriptions[i] = new SingleAssignmentDisposable;
                subscriptions[i].setDisposable(sources[i].subscribe(function(x) {
                    queues[i].push(x);
                    next(i)
                }, function(e) {
                    observer.onError(e)
                }, function() {
                    done(i)
                }))
            })(idx);
            return new CompositeDisposable(subscriptions)
        })
    };
    observableProto.asObservable = function() {
        var source = this;
        return new AnonymousObservable(function(o) {
            return source.subscribe(o)
        }, this)
    };
    observableProto.bufferWithCount = function(count, skip) {
        if (typeof skip !== "number") skip = count;
        return this.windowWithCount(count, skip).selectMany(function(x) {
            return x.toArray()
        }).where(function(x) {
            return x.length > 0
        })
    };
    observableProto.dematerialize = function() {
        var source =
            this;
        return new AnonymousObservable(function(o) {
            return source.subscribe(function(x) {
                return x.accept(o)
            }, function(e) {
                o.onError(e)
            }, function() {
                o.onCompleted()
            })
        }, this)
    };
    observableProto.distinctUntilChanged = function(keySelector, comparer) {
        var source = this;
        comparer || (comparer = defaultComparer);
        return new AnonymousObservable(function(o) {
            var hasCurrentKey = false,
                currentKey;
            return source.subscribe(function(value) {
                var key = value;
                if (keySelector) try {
                    key = keySelector(value)
                } catch (e) {
                    o.onError(e);
                    return
                }
                if (hasCurrentKey) try {
                    var comparerEquals =
                        comparer(currentKey, key)
                } catch (e) {
                    o.onError(e);
                    return
                }
                if (!hasCurrentKey || !comparerEquals) {
                    hasCurrentKey = true;
                    currentKey = key;
                    o.onNext(value)
                }
            }, function(e) {
                o.onError(e)
            }, function() {
                o.onCompleted()
            })
        }, this)
    };
    observableProto["do"] = observableProto.tap = observableProto.doAction = function(observerOrOnNext, onError, onCompleted) {
        var source = this;
        return new AnonymousObservable(function(observer) {
            var tapObserver = !observerOrOnNext || isFunction(observerOrOnNext) ? observerCreate(observerOrOnNext || noop, onError || noop,
                onCompleted || noop) : observerOrOnNext;
            return source.subscribe(function(x) {
                try {
                    tapObserver.onNext(x)
                } catch (e) {
                    observer.onError(e)
                }
                observer.onNext(x)
            }, function(err) {
                try {
                    tapObserver.onError(err)
                } catch (e) {
                    observer.onError(e)
                }
                observer.onError(err)
            }, function() {
                try {
                    tapObserver.onCompleted()
                } catch (e) {
                    observer.onError(e)
                }
                observer.onCompleted()
            })
        }, this)
    };
    observableProto.doOnNext = observableProto.tapOnNext = function(onNext, thisArg) {
        return this.tap(typeof thisArg !== "undefined" ? function(x) {
                onNext.call(thisArg, x)
            } :
            onNext)
    };
    observableProto.doOnError = observableProto.tapOnError = function(onError, thisArg) {
        return this.tap(noop, typeof thisArg !== "undefined" ? function(e) {
            onError.call(thisArg, e)
        } : onError)
    };
    observableProto.doOnCompleted = observableProto.tapOnCompleted = function(onCompleted, thisArg) {
        return this.tap(noop, null, typeof thisArg !== "undefined" ? function() {
            onCompleted.call(thisArg)
        } : onCompleted)
    };
    observableProto["finally"] = observableProto.ensure = function(action) {
        var source = this;
        return new AnonymousObservable(function(observer) {
            var subscription;
            try {
                subscription = source.subscribe(observer)
            } catch (e) {
                action();
                throw e;
            }
            return disposableCreate(function() {
                try {
                    subscription.dispose()
                } catch (e) {
                    throw e;
                } finally {
                    action()
                }
            })
        }, this)
    };
    observableProto.finallyAction = function(action) {
        return this.ensure(action)
    };
    observableProto.ignoreElements = function() {
        var source = this;
        return new AnonymousObservable(function(o) {
            return source.subscribe(noop, function(e) {
                o.onError(e)
            }, function() {
                o.onCompleted()
            })
        }, source)
    };
    observableProto.materialize = function() {
        var source = this;
        return new AnonymousObservable(function(observer) {
            return source.subscribe(function(value) {
                observer.onNext(notificationCreateOnNext(value))
            }, function(e) {
                observer.onNext(notificationCreateOnError(e));
                observer.onCompleted()
            }, function() {
                observer.onNext(notificationCreateOnCompleted());
                observer.onCompleted()
            })
        }, source)
    };
    observableProto.repeat = function(repeatCount) {
        return enumerableRepeat(this, repeatCount).concat()
    };
    observableProto.retry = function(retryCount) {
        return enumerableRepeat(this, retryCount).catchError()
    };
    observableProto.retryWhen = function(notifier) {
        return enumerableRepeat(this).catchErrorWhen(notifier)
    };
    observableProto.scan = function() {
        var hasSeed = false,
            seed, accumulator, source = this;
        if (arguments.length === 2) {
            hasSeed = true;
            seed = arguments[0];
            accumulator = arguments[1]
        } else accumulator = arguments[0];
        return new AnonymousObservable(function(o) {
            var hasAccumulation, accumulation, hasValue;
            return source.subscribe(function(x) {
                !hasValue && (hasValue = true);
                try {
                    if (hasAccumulation) accumulation = accumulator(accumulation, x);
                    else {
                        accumulation = hasSeed ? accumulator(seed, x) : x;
                        hasAccumulation = true
                    }
                } catch (e) {
                    o.onError(e);
                    return
                }
                o.onNext(accumulation)
            }, function(e) {
                o.onError(e)
            }, function() {
                !hasValue && hasSeed && o.onNext(seed);
                o.onCompleted()
            })
        }, source)
    };
    observableProto.skipLast = function(count) {
        if (count < 0) throw new ArgumentOutOfRangeError;
        var source = this;
        return new AnonymousObservable(function(o) {
                var q = [];
                return source.subscribe(function(x) {
                    q.push(x);
                    q.length > count && o.onNext(q.shift())
                }, function(e) {
                    o.onError(e)
                }, function() {
                    o.onCompleted()
                })
            },
            source)
    };
    observableProto.startWith = function() {
        var values, scheduler, start = 0;
        if (!!arguments.length && isScheduler(arguments[0])) {
            scheduler = arguments[0];
            start = 1
        } else scheduler = immediateScheduler;
        for (var args = [], i = start, len = arguments.length; i < len; i++) args.push(arguments[i]);
        return enumerableOf([observableFromArray(args, scheduler), this]).concat()
    };
    observableProto.takeLast = function(count) {
        if (count < 0) throw new ArgumentOutOfRangeError;
        var source = this;
        return new AnonymousObservable(function(o) {
            var q = [];
            return source.subscribe(function(x) {
                q.push(x);
                q.length > count && q.shift()
            }, function(e) {
                o.onError(e)
            }, function() {
                while (q.length > 0) o.onNext(q.shift());
                o.onCompleted()
            })
        }, source)
    };
    observableProto.takeLastBuffer = function(count) {
        var source = this;
        return new AnonymousObservable(function(o) {
            var q = [];
            return source.subscribe(function(x) {
                q.push(x);
                q.length > count && q.shift()
            }, function(e) {
                o.onError(e)
            }, function() {
                o.onNext(q);
                o.onCompleted()
            })
        }, source)
    };
    observableProto.windowWithCount = function(count, skip) {
        var source = this; + count || (count = 0);
        Math.abs(count) === Infinity &&
            (count = 0);
        if (count <= 0) throw new ArgumentOutOfRangeError;
        skip == null && (skip = count); + skip || (skip = 0);
        Math.abs(skip) === Infinity && (skip = 0);
        if (skip <= 0) throw new ArgumentOutOfRangeError;
        return new AnonymousObservable(function(observer) {
            var m = new SingleAssignmentDisposable,
                refCountDisposable = new RefCountDisposable(m),
                n = 0,
                q = [];

            function createWindow() {
                var s = new Subject;
                q.push(s);
                observer.onNext(addRef(s, refCountDisposable))
            }
            createWindow();
            m.setDisposable(source.subscribe(function(x) {
                for (var i = 0, len = q.length; i <
                    len; i++) q[i].onNext(x);
                var c = n - count + 1;
                c >= 0 && c % skip === 0 && q.shift().onCompleted();
                ++n % skip === 0 && createWindow()
            }, function(e) {
                while (q.length > 0) q.shift().onError(e);
                observer.onError(e)
            }, function() {
                while (q.length > 0) q.shift().onCompleted();
                observer.onCompleted()
            }));
            return refCountDisposable
        }, source)
    };

    function concatMap(source, selector, thisArg) {
        var selectorFunc = bindCallback(selector, thisArg, 3);
        return source.map(function(x, i) {
            var result = selectorFunc(x, i, source);
            isPromise(result) && (result = observableFromPromise(result));
            (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));
            return result
        }).concatAll()
    }
    observableProto.selectConcat = observableProto.concatMap = function(selector, resultSelector, thisArg) {
        if (isFunction(selector) && isFunction(resultSelector)) return this.concatMap(function(x, i) {
            var selectorResult = selector(x, i);
            isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
            (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));
            return selectorResult.map(function(y, i2) {
                return resultSelector(x, y, i, i2)
            })
        });
        return isFunction(selector) ? concatMap(this, selector, thisArg) : concatMap(this, function() {
            return selector
        })
    };
    observableProto.concatMapObserver = observableProto.selectConcatObserver = function(onNext, onError, onCompleted, thisArg) {
        var source = this,
            onNextFunc = bindCallback(onNext, thisArg, 2),
            onErrorFunc = bindCallback(onError, thisArg, 1),
            onCompletedFunc = bindCallback(onCompleted, thisArg, 0);
        return (new AnonymousObservable(function(observer) {
            var index =
                0;
            return source.subscribe(function(x) {
                var result;
                try {
                    result = onNextFunc(x, index++)
                } catch (e) {
                    observer.onError(e);
                    return
                }
                isPromise(result) && (result = observableFromPromise(result));
                observer.onNext(result)
            }, function(err) {
                var result;
                try {
                    result = onErrorFunc(err)
                } catch (e) {
                    observer.onError(e);
                    return
                }
                isPromise(result) && (result = observableFromPromise(result));
                observer.onNext(result);
                observer.onCompleted()
            }, function() {
                var result;
                try {
                    result = onCompletedFunc()
                } catch (e) {
                    observer.onError(e);
                    return
                }
                isPromise(result) &&
                    (result = observableFromPromise(result));
                observer.onNext(result);
                observer.onCompleted()
            })
        }, this)).concatAll()
    };
    observableProto.defaultIfEmpty = function(defaultValue) {
        var source = this;
        defaultValue === undefined && (defaultValue = null);
        return new AnonymousObservable(function(observer) {
            var found = false;
            return source.subscribe(function(x) {
                found = true;
                observer.onNext(x)
            }, function(e) {
                observer.onError(e)
            }, function() {
                !found && observer.onNext(defaultValue);
                observer.onCompleted()
            })
        }, source)
    };

    function arrayIndexOfComparer(array,
        item, comparer) {
        for (var i = 0, len = array.length; i < len; i++)
            if (comparer(array[i], item)) return i;
        return -1
    }

    function HashSet(comparer) {
        this.comparer = comparer;
        this.set = []
    }
    HashSet.prototype.push = function(value) {
        var retValue = arrayIndexOfComparer(this.set, value, this.comparer) === -1;
        retValue && this.set.push(value);
        return retValue
    };
    observableProto.distinct = function(keySelector, comparer) {
        var source = this;
        comparer || (comparer = defaultComparer);
        return new AnonymousObservable(function(o) {
            var hashSet = new HashSet(comparer);
            return source.subscribe(function(x) {
                var key = x;
                if (keySelector) try {
                    key = keySelector(x)
                } catch (e) {
                    o.onError(e);
                    return
                }
                hashSet.push(key) && o.onNext(x)
            }, function(e) {
                o.onError(e)
            }, function() {
                o.onCompleted()
            })
        }, this)
    };
    observableProto.groupBy = function(keySelector, elementSelector, comparer) {
        return this.groupByUntil(keySelector, elementSelector, observableNever, comparer)
    };
    observableProto.groupByUntil = function(keySelector, elementSelector, durationSelector, comparer) {
        var source = this;
        elementSelector || (elementSelector =
            identity);
        comparer || (comparer = defaultComparer);
        return new AnonymousObservable(function(observer) {
            function handleError(e) {
                return function(item) {
                    item.onError(e)
                }
            }
            var map = new Dictionary(0, comparer),
                groupDisposable = new CompositeDisposable,
                refCountDisposable = new RefCountDisposable(groupDisposable);
            groupDisposable.add(source.subscribe(function(x) {
                var key;
                try {
                    key = keySelector(x)
                } catch (e) {
                    map.getValues().forEach(handleError(e));
                    observer.onError(e);
                    return
                }
                var fireNewMapEntry = false,
                    writer = map.tryGetValue(key);
                if (!writer) {
                    writer = new Subject;
                    map.set(key, writer);
                    fireNewMapEntry = true
                }
                if (fireNewMapEntry) {
                    var group = new GroupedObservable(key, writer, refCountDisposable),
                        durationGroup = new GroupedObservable(key, writer);
                    try {
                        duration = durationSelector(durationGroup)
                    } catch (e) {
                        map.getValues().forEach(handleError(e));
                        observer.onError(e);
                        return
                    }
                    observer.onNext(group);
                    var md = new SingleAssignmentDisposable;
                    groupDisposable.add(md);
                    var expire = function() {
                        map.remove(key) && writer.onCompleted();
                        groupDisposable.remove(md)
                    };
                    md.setDisposable(duration.take(1).subscribe(noop,
                        function(exn) {
                            map.getValues().forEach(handleError(exn));
                            observer.onError(exn)
                        }, expire))
                }
                var element;
                try {
                    element = elementSelector(x)
                } catch (e) {
                    map.getValues().forEach(handleError(e));
                    observer.onError(e);
                    return
                }
                writer.onNext(element)
            }, function(ex) {
                map.getValues().forEach(handleError(ex));
                observer.onError(ex)
            }, function() {
                map.getValues().forEach(function(item) {
                    item.onCompleted()
                });
                observer.onCompleted()
            }));
            return refCountDisposable
        }, source)
    };
    var MapObservable = function(__super__) {
        inherits(MapObservable,
            __super__);

        function MapObservable(source, selector, thisArg) {
            this.source = source;
            this.selector = bindCallback(selector, thisArg, 3);
            __super__.call(this)
        }
        MapObservable.prototype.internalMap = function(selector, thisArg) {
            var self = this;
            return new MapObservable(this.source, function(x, i, o) {
                return selector.call(this, self.selector(x, i, o), i, o)
            }, thisArg)
        };
        MapObservable.prototype.subscribeCore = function(observer) {
            return this.source.subscribe(new MapObserver(observer, this.selector, this))
        };
        return MapObservable
    }(ObservableBase);

    function MapObserver(observer, selector, source) {
        this.observer = observer;
        this.selector = selector;
        this.source = source;
        this.i = 0;
        this.isStopped = false
    }
    MapObserver.prototype.onNext = function(x) {
        if (this.isStopped) return;
        var result = tryCatch(this.selector).call(this, x, this.i++, this.source);
        if (result === errorObj) return this.observer.onError(result.e);
        this.observer.onNext(result)
    };
    MapObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
            this.isStopped = true;
            this.observer.onError(e)
        }
    };
    MapObserver.prototype.onCompleted =
        function() {
            if (!this.isStopped) {
                this.isStopped = true;
                this.observer.onCompleted()
            }
        };
    MapObserver.prototype.dispose = function() {
        this.isStopped = true
    };
    MapObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
            this.isStopped = true;
            this.observer.onError(e);
            return true
        }
        return false
    };
    observableProto.map = observableProto.select = function(selector, thisArg) {
        var selectorFn = typeof selector === "function" ? selector : function() {
            return selector
        };
        return this instanceof MapObservable ? this.internalMap(selectorFn, thisArg) : new MapObservable(this,
            selectorFn, thisArg)
    };
    observableProto.pluck = function() {
        var args = arguments,
            len = arguments.length;
        if (len === 0) throw new Error("List of properties cannot be empty.");
        return this.map(function(x) {
            var currentProp = x;
            for (var i = 0; i < len; i++) {
                var p = currentProp[args[i]];
                if (typeof p !== "undefined") currentProp = p;
                else return undefined
            }
            return currentProp
        })
    };

    function flatMap(source, selector, thisArg) {
        var selectorFunc = bindCallback(selector, thisArg, 3);
        return source.map(function(x, i) {
            var result = selectorFunc(x, i, source);
            isPromise(result) &&
                (result = observableFromPromise(result));
            (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));
            return result
        }).mergeAll()
    }
    observableProto.selectMany = observableProto.flatMap = function(selector, resultSelector, thisArg) {
        if (isFunction(selector) && isFunction(resultSelector)) return this.flatMap(function(x, i) {
            var selectorResult = selector(x, i);
            isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
            (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult =
                observableFrom(selectorResult));
            return selectorResult.map(function(y, i2) {
                return resultSelector(x, y, i, i2)
            })
        }, thisArg);
        return isFunction(selector) ? flatMap(this, selector, thisArg) : flatMap(this, function() {
            return selector
        })
    };
    observableProto.flatMapObserver = observableProto.selectManyObserver = function(onNext, onError, onCompleted, thisArg) {
        var source = this;
        return (new AnonymousObservable(function(observer) {
            var index = 0;
            return source.subscribe(function(x) {
                var result;
                try {
                    result = onNext.call(thisArg, x, index++)
                } catch (e) {
                    observer.onError(e);
                    return
                }
                isPromise(result) && (result = observableFromPromise(result));
                observer.onNext(result)
            }, function(err) {
                var result;
                try {
                    result = onError.call(thisArg, err)
                } catch (e) {
                    observer.onError(e);
                    return
                }
                isPromise(result) && (result = observableFromPromise(result));
                observer.onNext(result);
                observer.onCompleted()
            }, function() {
                var result;
                try {
                    result = onCompleted.call(thisArg)
                } catch (e) {
                    observer.onError(e);
                    return
                }
                isPromise(result) && (result = observableFromPromise(result));
                observer.onNext(result);
                observer.onCompleted()
            })
        }, source)).mergeAll()
    };
    observableProto.selectSwitch = observableProto.flatMapLatest = observableProto.switchMap = function(selector, thisArg) {
        return this.select(selector, thisArg).switchLatest()
    };
    observableProto.skip = function(count) {
        if (count < 0) throw new ArgumentOutOfRangeError;
        var source = this;
        return new AnonymousObservable(function(o) {
            var remaining = count;
            return source.subscribe(function(x) {
                if (remaining <= 0) o.onNext(x);
                else remaining--
            }, function(e) {
                o.onError(e)
            }, function() {
                o.onCompleted()
            })
        }, source)
    };
    observableProto.skipWhile = function(predicate,
        thisArg) {
        var source = this,
            callback = bindCallback(predicate, thisArg, 3);
        return new AnonymousObservable(function(o) {
            var i = 0,
                running = false;
            return source.subscribe(function(x) {
                if (!running) try {
                    running = !callback(x, i++, source)
                } catch (e) {
                    o.onError(e);
                    return
                }
                running && o.onNext(x)
            }, function(e) {
                o.onError(e)
            }, function() {
                o.onCompleted()
            })
        }, source)
    };
    observableProto.take = function(count, scheduler) {
        if (count < 0) throw new ArgumentOutOfRangeError;
        if (count === 0) return observableEmpty(scheduler);
        var source = this;
        return new AnonymousObservable(function(o) {
            var remaining =
                count;
            return source.subscribe(function(x) {
                if (remaining-- > 0) {
                    o.onNext(x);
                    remaining === 0 && o.onCompleted()
                }
            }, function(e) {
                o.onError(e)
            }, function() {
                o.onCompleted()
            })
        }, source)
    };
    observableProto.takeWhile = function(predicate, thisArg) {
        var source = this,
            callback = bindCallback(predicate, thisArg, 3);
        return new AnonymousObservable(function(o) {
            var i = 0,
                running = true;
            return source.subscribe(function(x) {
                    if (running) {
                        try {
                            running = callback(x, i++, source)
                        } catch (e) {
                            o.onError(e);
                            return
                        }
                        if (running) o.onNext(x);
                        else o.onCompleted()
                    }
                },
                function(e) {
                    o.onError(e)
                },
                function() {
                    o.onCompleted()
                })
        }, source)
    };
    var FilterObservable = function(__super__) {
        inherits(FilterObservable, __super__);

        function FilterObservable(source, predicate, thisArg) {
            this.source = source;
            this.predicate = bindCallback(predicate, thisArg, 3);
            __super__.call(this)
        }
        FilterObservable.prototype.subscribeCore = function(observer) {
            return this.source.subscribe(new FilterObserver(observer, this.predicate, this))
        };
        FilterObservable.prototype.internalFilter = function(predicate, thisArg) {
            var self =
                this;
            return new FilterObservable(this.source, function(x, i, o) {
                return self.predicate(x, i, o) && predicate.call(this, x, i, o)
            }, thisArg)
        };
        return FilterObservable
    }(ObservableBase);

    function FilterObserver(observer, predicate, source) {
        this.observer = observer;
        this.predicate = predicate;
        this.source = source;
        this.i = 0;
        this.isStopped = false
    }
    FilterObserver.prototype.onNext = function(x) {
        if (this.isStopped) return;
        var shouldYield = tryCatch(this.predicate).call(this, x, this.i++, this.source);
        if (shouldYield === errorObj) return this.observer.onError(shouldYield.e);
        shouldYield && this.observer.onNext(x)
    };
    FilterObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
            this.isStopped = true;
            this.observer.onError(e)
        }
    };
    FilterObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
            this.isStopped = true;
            this.observer.onCompleted()
        }
    };
    FilterObserver.prototype.dispose = function() {
        this.isStopped = true
    };
    FilterObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
            this.isStopped = true;
            this.observer.onError(e);
            return true
        }
        return false
    };
    observableProto.filter = observableProto.where =
        function(predicate, thisArg) {
            return this instanceof FilterObservable ? this.internalFilter(predicate, thisArg) : new FilterObservable(this, predicate, thisArg)
        };

    function extremaBy(source, keySelector, comparer) {
        return new AnonymousObservable(function(o) {
            var hasValue = false,
                lastKey = null,
                list = [];
            return source.subscribe(function(x) {
                var comparison, key;
                try {
                    key = keySelector(x)
                } catch (ex) {
                    o.onError(ex);
                    return
                }
                comparison = 0;
                if (!hasValue) {
                    hasValue = true;
                    lastKey = key
                } else try {
                    comparison = comparer(key, lastKey)
                } catch (ex1) {
                    o.onError(ex1);
                    return
                }
                if (comparison > 0) {
                    lastKey = key;
                    list = []
                }
                if (comparison >= 0) list.push(x)
            }, function(e) {
                o.onError(e)
            }, function() {
                o.onNext(list);
                o.onCompleted()
            })
        }, source)
    }

    function firstOnly(x) {
        if (x.length === 0) throw new EmptyError;
        return x[0]
    }
    observableProto.aggregate = function() {
        var hasSeed = false,
            accumulator, seed, source = this;
        if (arguments.length === 2) {
            hasSeed = true;
            seed = arguments[0];
            accumulator = arguments[1]
        } else accumulator = arguments[0];
        return new AnonymousObservable(function(o) {
            var hasAccumulation, accumulation, hasValue;
            return source.subscribe(function(x) {
                !hasValue && (hasValue = true);
                try {
                    if (hasAccumulation) accumulation = accumulator(accumulation, x);
                    else {
                        accumulation = hasSeed ? accumulator(seed, x) : x;
                        hasAccumulation = true
                    }
                } catch (e) {
                    return o.onError(e)
                }
            }, function(e) {
                o.onError(e)
            }, function() {
                hasValue && o.onNext(accumulation);
                !hasValue && hasSeed && o.onNext(seed);
                !hasValue && !hasSeed && o.onError(new EmptyError);
                o.onCompleted()
            })
        }, source)
    };
    observableProto.reduce = function(accumulator) {
        var hasSeed = false,
            seed, source = this;
        if (arguments.length ===
            2) {
            hasSeed = true;
            seed = arguments[1]
        }
        return new AnonymousObservable(function(o) {
                var hasAccumulation, accumulation, hasValue;
                return source.subscribe(function(x) {
                    !hasValue && (hasValue = true);
                    try {
                        if (hasAccumulation) accumulation = accumulator(accumulation, x);
                        else {
                            accumulation = hasSeed ? accumulator(seed, x) : x;
                            hasAccumulation = true
                        }
                    } catch (e) {
                        return o.onError(e)
                    }
                }, function(e) {
                    o.onError(e)
                }, function() {
                    hasValue && o.onNext(accumulation);
                    !hasValue && hasSeed && o.onNext(seed);
                    !hasValue && !hasSeed && o.onError(new EmptyError);
                    o.onCompleted()
                })
            },
            source)
    };
    observableProto.some = function(predicate, thisArg) {
        var source = this;
        return predicate ? source.filter(predicate, thisArg).some() : new AnonymousObservable(function(observer) {
            return source.subscribe(function() {
                observer.onNext(true);
                observer.onCompleted()
            }, function(e) {
                observer.onError(e)
            }, function() {
                observer.onNext(false);
                observer.onCompleted()
            })
        }, source)
    };
    observableProto.any = function() {
        return this.some.apply(this, arguments)
    };
    observableProto.isEmpty = function() {
        return this.any().map(not)
    };
    observableProto.every =
        function(predicate, thisArg) {
            return this.filter(function(v) {
                return !predicate(v)
            }, thisArg).some().map(not)
        };
    observableProto.all = function() {
        return this.every.apply(this, arguments)
    };
    observableProto.includes = function(searchElement, fromIndex) {
        var source = this;

        function comparer(a, b) {
            return a === 0 && b === 0 || (a === b || isNaN(a) && isNaN(b))
        }
        return new AnonymousObservable(function(o) {
            var i = 0,
                n = +fromIndex || 0;
            Math.abs(n) === Infinity && (n = 0);
            if (n < 0) {
                o.onNext(false);
                o.onCompleted();
                return disposableEmpty
            }
            return source.subscribe(function(x) {
                if (i++ >=
                    n && comparer(x, searchElement)) {
                    o.onNext(true);
                    o.onCompleted()
                }
            }, function(e) {
                o.onError(e)
            }, function() {
                o.onNext(false);
                o.onCompleted()
            })
        }, this)
    };
    observableProto.contains = function(searchElement, fromIndex) {
        observableProto.includes(searchElement, fromIndex)
    };
    observableProto.count = function(predicate, thisArg) {
        return predicate ? this.filter(predicate, thisArg).count() : this.reduce(function(count) {
            return count + 1
        }, 0)
    };
    observableProto.indexOf = function(searchElement, fromIndex) {
        var source = this;
        return new AnonymousObservable(function(o) {
            var i =
                0,
                n = +fromIndex || 0;
            Math.abs(n) === Infinity && (n = 0);
            if (n < 0) {
                o.onNext(-1);
                o.onCompleted();
                return disposableEmpty
            }
            return source.subscribe(function(x) {
                if (i >= n && x === searchElement) {
                    o.onNext(i);
                    o.onCompleted()
                }
                i++
            }, function(e) {
                o.onError(e)
            }, function() {
                o.onNext(-1);
                o.onCompleted()
            })
        }, source)
    };
    observableProto.sum = function(keySelector, thisArg) {
        return keySelector && isFunction(keySelector) ? this.map(keySelector, thisArg).sum() : this.reduce(function(prev, curr) {
            return prev + curr
        }, 0)
    };
    observableProto.minBy = function(keySelector,
        comparer) {
        comparer || (comparer = defaultSubComparer);
        return extremaBy(this, keySelector, function(x, y) {
            return comparer(x, y) * -1
        })
    };
    observableProto.min = function(comparer) {
        return this.minBy(identity, comparer).map(function(x) {
            return firstOnly(x)
        })
    };
    observableProto.maxBy = function(keySelector, comparer) {
        comparer || (comparer = defaultSubComparer);
        return extremaBy(this, keySelector, comparer)
    };
    observableProto.max = function(comparer) {
        return this.maxBy(identity, comparer).map(function(x) {
            return firstOnly(x)
        })
    };
    observableProto.average =
        function(keySelector, thisArg) {
            return keySelector && isFunction(keySelector) ? this.map(keySelector, thisArg).average() : this.reduce(function(prev, cur) {
                return {
                    sum: prev.sum + cur,
                    count: prev.count + 1
                }
            }, {
                sum: 0,
                count: 0
            }).map(function(s) {
                if (s.count === 0) throw new EmptyError;
                return s.sum / s.count
            })
        };
    observableProto.sequenceEqual = function(second, comparer) {
        var first = this;
        comparer || (comparer = defaultComparer);
        return new AnonymousObservable(function(o) {
            var donel = false,
                doner = false,
                ql = [],
                qr = [];
            var subscription1 = first.subscribe(function(x) {
                var equal,
                    v;
                if (qr.length > 0) {
                    v = qr.shift();
                    try {
                        equal = comparer(v, x)
                    } catch (e) {
                        o.onError(e);
                        return
                    }
                    if (!equal) {
                        o.onNext(false);
                        o.onCompleted()
                    }
                } else if (doner) {
                    o.onNext(false);
                    o.onCompleted()
                } else ql.push(x)
            }, function(e) {
                o.onError(e)
            }, function() {
                donel = true;
                if (ql.length === 0)
                    if (qr.length > 0) {
                        o.onNext(false);
                        o.onCompleted()
                    } else if (doner) {
                    o.onNext(true);
                    o.onCompleted()
                }
            });
            (isArrayLike(second) || isIterable(second)) && (second = observableFrom(second));
            isPromise(second) && (second = observableFromPromise(second));
            var subscription2 =
                second.subscribe(function(x) {
                    var equal;
                    if (ql.length > 0) {
                        var v = ql.shift();
                        try {
                            equal = comparer(v, x)
                        } catch (exception) {
                            o.onError(exception);
                            return
                        }
                        if (!equal) {
                            o.onNext(false);
                            o.onCompleted()
                        }
                    } else if (donel) {
                        o.onNext(false);
                        o.onCompleted()
                    } else qr.push(x)
                }, function(e) {
                    o.onError(e)
                }, function() {
                    doner = true;
                    if (qr.length === 0)
                        if (ql.length > 0) {
                            o.onNext(false);
                            o.onCompleted()
                        } else if (donel) {
                        o.onNext(true);
                        o.onCompleted()
                    }
                });
            return new CompositeDisposable(subscription1, subscription2)
        }, first)
    };

    function elementAtOrDefault(source,
        index, hasDefault, defaultValue) {
        if (index < 0) throw new ArgumentOutOfRangeError;
        return new AnonymousObservable(function(o) {
            var i = index;
            return source.subscribe(function(x) {
                if (i-- === 0) {
                    o.onNext(x);
                    o.onCompleted()
                }
            }, function(e) {
                o.onError(e)
            }, function() {
                if (!hasDefault) o.onError(new ArgumentOutOfRangeError);
                else {
                    o.onNext(defaultValue);
                    o.onCompleted()
                }
            })
        }, source)
    }
    observableProto.elementAt = function(index) {
        return elementAtOrDefault(this, index, false)
    };
    observableProto.elementAtOrDefault = function(index, defaultValue) {
        return elementAtOrDefault(this,
            index, true, defaultValue)
    };

    function singleOrDefaultAsync(source, hasDefault, defaultValue) {
        return new AnonymousObservable(function(o) {
            var value = defaultValue,
                seenValue = false;
            return source.subscribe(function(x) {
                if (seenValue) o.onError(new Error("Sequence contains more than one element"));
                else {
                    value = x;
                    seenValue = true
                }
            }, function(e) {
                o.onError(e)
            }, function() {
                if (!seenValue && !hasDefault) o.onError(new EmptyError);
                else {
                    o.onNext(value);
                    o.onCompleted()
                }
            })
        }, source)
    }
    observableProto.single = function(predicate, thisArg) {
        return predicate &&
            isFunction(predicate) ? this.where(predicate, thisArg).single() : singleOrDefaultAsync(this, false)
    };
    observableProto.singleOrDefault = function(predicate, defaultValue, thisArg) {
        return predicate && isFunction(predicate) ? this.filter(predicate, thisArg).singleOrDefault(null, defaultValue) : singleOrDefaultAsync(this, true, defaultValue)
    };

    function firstOrDefaultAsync(source, hasDefault, defaultValue) {
        return new AnonymousObservable(function(o) {
            return source.subscribe(function(x) {
                    o.onNext(x);
                    o.onCompleted()
                }, function(e) {
                    o.onError(e)
                },
                function() {
                    if (!hasDefault) o.onError(new EmptyError);
                    else {
                        o.onNext(defaultValue);
                        o.onCompleted()
                    }
                })
        }, source)
    }
    observableProto.first = function(predicate, thisArg) {
        return predicate ? this.where(predicate, thisArg).first() : firstOrDefaultAsync(this, false)
    };
    observableProto.firstOrDefault = function(predicate, defaultValue, thisArg) {
        return predicate ? this.where(predicate).firstOrDefault(null, defaultValue) : firstOrDefaultAsync(this, true, defaultValue)
    };

    function lastOrDefaultAsync(source, hasDefault, defaultValue) {
        return new AnonymousObservable(function(o) {
            var value =
                defaultValue,
                seenValue = false;
            return source.subscribe(function(x) {
                value = x;
                seenValue = true
            }, function(e) {
                o.onError(e)
            }, function() {
                if (!seenValue && !hasDefault) o.onError(new EmptyError);
                else {
                    o.onNext(value);
                    o.onCompleted()
                }
            })
        }, source)
    }
    observableProto.last = function(predicate, thisArg) {
        return predicate ? this.where(predicate, thisArg).last() : lastOrDefaultAsync(this, false)
    };
    observableProto.lastOrDefault = function(predicate, defaultValue, thisArg) {
        return predicate ? this.where(predicate, thisArg).lastOrDefault(null, defaultValue) :
            lastOrDefaultAsync(this, true, defaultValue)
    };

    function findValue(source, predicate, thisArg, yieldIndex) {
        var callback = bindCallback(predicate, thisArg, 3);
        return new AnonymousObservable(function(o) {
            var i = 0;
            return source.subscribe(function(x) {
                var shouldRun;
                try {
                    shouldRun = callback(x, i, source)
                } catch (e) {
                    o.onError(e);
                    return
                }
                if (shouldRun) {
                    o.onNext(yieldIndex ? i : x);
                    o.onCompleted()
                } else i++
            }, function(e) {
                o.onError(e)
            }, function() {
                o.onNext(yieldIndex ? -1 : undefined);
                o.onCompleted()
            })
        }, source)
    }
    observableProto.find = function(predicate,
        thisArg) {
        return findValue(this, predicate, thisArg, false)
    };
    observableProto.findIndex = function(predicate, thisArg) {
        return findValue(this, predicate, thisArg, true)
    };
    observableProto.toSet = function() {
        if (typeof root.Set === "undefined") throw new TypeError;
        var source = this;
        return new AnonymousObservable(function(o) {
            var s = new root.Set;
            return source.subscribe(function(x) {
                s.add(x)
            }, function(e) {
                o.onError(e)
            }, function() {
                o.onNext(s);
                o.onCompleted()
            })
        }, source)
    };
    observableProto.toMap = function(keySelector, elementSelector) {
        if (typeof root.Map ===
            "undefined") throw new TypeError;
        var source = this;
        return new AnonymousObservable(function(o) {
            var m = new root.Map;
            return source.subscribe(function(x) {
                var key;
                try {
                    key = keySelector(x)
                } catch (e) {
                    o.onError(e);
                    return
                }
                var element = x;
                if (elementSelector) try {
                    element = elementSelector(x)
                } catch (e) {
                    o.onError(e);
                    return
                }
                m.set(key, element)
            }, function(e) {
                o.onError(e)
            }, function() {
                o.onNext(m);
                o.onCompleted()
            })
        }, source)
    };
    var fnString = "function",
        throwString = "throw",
        isObject = Rx.internals.isObject;

    function toThunk(obj, ctx) {
        if (Array.isArray(obj)) return objectToThunk.call(ctx,
            obj);
        if (isGeneratorFunction(obj)) return observableSpawn(obj.call(ctx));
        if (isGenerator(obj)) return observableSpawn(obj);
        if (isObservable(obj)) return observableToThunk(obj);
        if (isPromise(obj)) return promiseToThunk(obj);
        if (typeof obj === fnString) return obj;
        if (isObject(obj) || Array.isArray(obj)) return objectToThunk.call(ctx, obj);
        return obj
    }

    function objectToThunk(obj) {
        var ctx = this;
        return function(done) {
            var keys = Object.keys(obj),
                pending = keys.length,
                results = new obj.constructor,
                finished;
            if (!pending) {
                timeoutScheduler.schedule(function() {
                    done(null,
                        results)
                });
                return
            }
            for (var i = 0, len = keys.length; i < len; i++) run(obj[keys[i]], keys[i]);

            function run(fn, key) {
                if (finished) return;
                try {
                    fn = toThunk(fn, ctx);
                    if (typeof fn !== fnString) {
                        results[key] = fn;
                        return --pending || done(null, results)
                    }
                    fn.call(ctx, function(err, res) {
                        if (finished) return;
                        if (err) {
                            finished = true;
                            return done(err)
                        }
                        results[key] = res;
                        --pending || done(null, results)
                    })
                } catch (e) {
                    finished = true;
                    done(e)
                }
            }
        }
    }

    function observableToThunk(observable) {
        return function(fn) {
            var value, hasValue = false;
            observable.subscribe(function(v) {
                value =
                    v;
                hasValue = true
            }, fn, function() {
                hasValue && fn(null, value)
            })
        }
    }

    function promiseToThunk(promise) {
        return function(fn) {
            promise.then(function(res) {
                fn(null, res)
            }, fn)
        }
    }

    function isObservable(obj) {
        return obj && typeof obj.subscribe === fnString
    }

    function isGeneratorFunction(obj) {
        return obj && obj.constructor && obj.constructor.name === "GeneratorFunction"
    }

    function isGenerator(obj) {
        return obj && typeof obj.next === fnString && typeof obj[throwString] === fnString
    }
    var observableSpawn = Rx.spawn = function(fn) {
        var isGenFun = isGeneratorFunction(fn);
        return function(done) {
            var ctx = this,
                gen = fn;
            if (isGenFun) {
                for (var args = [], i = 0, len = arguments.length; i < len; i++) args.push(arguments[i]);
                var len = args.length,
                    hasCallback = len && typeof args[len - 1] === fnString;
                done = hasCallback ? args.pop() : handleError;
                gen = fn.apply(this, args)
            } else done = done || handleError;
            next();

            function exit(err, res) {
                timeoutScheduler.schedule(done.bind(ctx, err, res))
            }

            function next(err, res) {
                var ret;
                if (arguments.length > 2)
                    for (var res = [], i = 1, len = arguments.length; i < len; i++) res.push(arguments[i]);
                if (err) try {
                    ret =
                        gen[throwString](err)
                } catch (e) {
                    return exit(e)
                }
                if (!err) try {
                    ret = gen.next(res)
                } catch (e) {
                    return exit(e)
                }
                if (ret.done) return exit(null, ret.value);
                ret.value = toThunk(ret.value, ctx);
                if (typeof ret.value === fnString) {
                    var called = false;
                    try {
                        ret.value.call(ctx, function() {
                            if (called) return;
                            called = true;
                            next.apply(ctx, arguments)
                        })
                    } catch (e) {
                        timeoutScheduler.schedule(function() {
                            if (called) return;
                            called = true;
                            next.call(ctx, e)
                        })
                    }
                    return
                }
                next(new TypeError("Rx.spawn only supports a function, Promise, Observable, Object or Array."))
            }
        }
    };

    function handleError(err) {
        if (!err) return;
        timeoutScheduler.schedule(function() {
            throw err;
        })
    }
    Observable.start = function(func, context, scheduler) {
        return observableToAsync(func, context, scheduler)()
    };
    var observableToAsync = Observable.toAsync = function(func, context, scheduler) {
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        return function() {
            var args = arguments,
                subject = new AsyncSubject;
            scheduler.schedule(function() {
                var result;
                try {
                    result = func.apply(context, args)
                } catch (e) {
                    subject.onError(e);
                    return
                }
                subject.onNext(result);
                subject.onCompleted()
            });
            return subject.asObservable()
        }
    };
    Observable.fromCallback = function(func, context, selector) {
        return function() {
            var len = arguments.length,
                args = new Array(len);
            for (var i = 0; i < len; i++) args[i] = arguments[i];
            return (new AnonymousObservable(function(observer) {
                function handler() {
                    var len = arguments.length,
                        results = new Array(len);
                    for (var i = 0; i < len; i++) results[i] = arguments[i];
                    if (selector) {
                        try {
                            results = selector.apply(context, results)
                        } catch (e) {
                            return observer.onError(e)
                        }
                        observer.onNext(results)
                    } else if (results.length <=
                        1) observer.onNext.apply(observer, results);
                    else observer.onNext(results);
                    observer.onCompleted()
                }
                args.push(handler);
                func.apply(context, args)
            })).publishLast().refCount()
        }
    };
    Observable.fromNodeCallback = function(func, context, selector) {
        return function() {
            var len = arguments.length,
                args = new Array(len);
            for (var i = 0; i < len; i++) args[i] = arguments[i];
            return (new AnonymousObservable(function(observer) {
                function handler(err) {
                    if (err) {
                        observer.onError(err);
                        return
                    }
                    var len = arguments.length,
                        results = [];
                    for (var i = 1; i < len; i++) results[i -
                        1] = arguments[i];
                    if (selector) {
                        try {
                            results = selector.apply(context, results)
                        } catch (e) {
                            return observer.onError(e)
                        }
                        observer.onNext(results)
                    } else if (results.length <= 1) observer.onNext.apply(observer, results);
                    else observer.onNext(results);
                    observer.onCompleted()
                }
                args.push(handler);
                func.apply(context, args)
            })).publishLast().refCount()
        }
    };

    function fixEvent(event) {
        var stopPropagation = function() {
            this.cancelBubble = true
        };
        var preventDefault = function() {
            this.bubbledKeyCode = this.keyCode;
            if (this.ctrlKey) try {
                this.keyCode =
                    0
            } catch (e) {}
            this.defaultPrevented = true;
            this.returnValue = false;
            this.modified = true
        };
        event || (event = root.event);
        if (!event.target) {
            event.target = event.target || event.srcElement;
            if (event.type == "mouseover") event.relatedTarget = event.fromElement;
            if (event.type == "mouseout") event.relatedTarget = event.toElement;
            if (!event.stopPropagation) {
                event.stopPropagation = stopPropagation;
                event.preventDefault = preventDefault
            }
            switch (event.type) {
                case "keypress":
                    var c = "charCode" in event ? event.charCode : event.keyCode;
                    if (c == 10) {
                        c = 0;
                        event.keyCode = 13
                    } else if (c == 13 || c == 27) c = 0;
                    else if (c == 3) c = 99;
                    event.charCode = c;
                    event.keyChar = event.charCode ? String.fromCharCode(event.charCode) : "";
                    break
            }
        }
        return event
    }

    function createListener(element, name, handler) {
        if (element.addEventListener) {
            element.addEventListener(name, handler, false);
            return disposableCreate(function() {
                element.removeEventListener(name, handler, false)
            })
        }
        if (element.attachEvent) {
            var innerHandler = function(event) {
                handler(fixEvent(event))
            };
            element.attachEvent("on" + name, innerHandler);
            return disposableCreate(function() {
                element.detachEvent("on" +
                    name, innerHandler)
            })
        }
        element["on" + name] = handler;
        return disposableCreate(function() {
            element["on" + name] = null
        })
    }

    function createEventListener(el, eventName, handler) {
        var disposables = new CompositeDisposable;
        if (Object.prototype.toString.call(el) === "[object NodeList]")
            for (var i = 0, len = el.length; i < len; i++) disposables.add(createEventListener(el.item(i), eventName, handler));
        else if (el) disposables.add(createListener(el, eventName, handler));
        return disposables
    }
    Rx.config.useNativeEvents = false;
    Observable.fromEvent = function(element,
        eventName, selector) {
        if (element.addListener) return fromEventPattern(function(h) {
            element.addListener(eventName, h)
        }, function(h) {
            element.removeListener(eventName, h)
        }, selector);
        if (!Rx.config.useNativeEvents)
            if (typeof element.on === "function" && typeof element.off === "function") return fromEventPattern(function(h) {
                element.on(eventName, h)
            }, function(h) {
                element.off(eventName, h)
            }, selector);
        return (new AnonymousObservable(function(observer) {
            return createEventListener(element, eventName, function handler(e) {
                var results =
                    e;
                if (selector) try {
                    results = selector(arguments)
                } catch (err) {
                    return observer.onError(err)
                }
                observer.onNext(results)
            })
        })).publish().refCount()
    };
    var fromEventPattern = Observable.fromEventPattern = function(addHandler, removeHandler, selector) {
        return (new AnonymousObservable(function(observer) {
            function innerHandler(e) {
                var result = e;
                if (selector) try {
                    result = selector(arguments)
                } catch (err) {
                    return observer.onError(err)
                }
                observer.onNext(result)
            }
            var returnValue = addHandler(innerHandler);
            return disposableCreate(function() {
                if (removeHandler) removeHandler(innerHandler,
                    returnValue)
            })
        })).publish().refCount()
    };
    Observable.startAsync = function(functionAsync) {
        var promise;
        try {
            promise = functionAsync()
        } catch (e) {
            return observableThrow(e)
        }
        return observableFromPromise(promise)
    };
    var PausableObservable = function(__super__) {
        inherits(PausableObservable, __super__);

        function subscribe(observer) {
            var conn = this.source.publish(),
                subscription = conn.subscribe(observer),
                connection = disposableEmpty;
            var pausable = this.pauser.distinctUntilChanged().subscribe(function(b) {
                if (b) connection = conn.connect();
                else {
                    connection.dispose();
                    connection = disposableEmpty
                }
            });
            return new CompositeDisposable(subscription, connection, pausable)
        }

        function PausableObservable(source, pauser) {
            this.source = source;
            this.controller = new Subject;
            if (pauser && pauser.subscribe) this.pauser = this.controller.merge(pauser);
            else this.pauser = this.controller;
            __super__.call(this, subscribe, source)
        }
        PausableObservable.prototype.pause = function() {
            this.controller.onNext(false)
        };
        PausableObservable.prototype.resume = function() {
            this.controller.onNext(true)
        };
        return PausableObservable
    }(Observable);
    observableProto.pausable = function(pauser) {
        return new PausableObservable(this, pauser)
    };

    function combineLatestSource(source, subject, resultSelector) {
        return new AnonymousObservable(function(o) {
            var hasValue = [false, false],
                hasValueAll = false,
                isDone = false,
                values = new Array(2),
                err;

            function next(x, i) {
                values[i] = x;
                var res;
                hasValue[i] = true;
                if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
                    if (err) {
                        o.onError(err);
                        return
                    }
                    try {
                        res = resultSelector.apply(null, values)
                    } catch (ex) {
                        o.onError(ex);
                        return
                    }
                    o.onNext(res)
                }
                if (isDone && values[1]) o.onCompleted()
            }
            return new CompositeDisposable(source.subscribe(function(x) {
                next(x, 0)
            }, function(e) {
                if (values[1]) o.onError(e);
                else err = e
            }, function() {
                isDone = true;
                values[1] && o.onCompleted()
            }), subject.subscribe(function(x) {
                next(x, 1)
            }, function(e) {
                o.onError(e)
            }, function() {
                isDone = true;
                next(true, 1)
            }))
        }, source)
    }
    var PausableBufferedObservable = function(__super__) {
        inherits(PausableBufferedObservable, __super__);

        function subscribe(o) {
            var q = [],
                previousShouldFire;
            var subscription =
                combineLatestSource(this.source, this.pauser.distinctUntilChanged().startWith(false), function(data, shouldFire) {
                    return {
                        data: data,
                        shouldFire: shouldFire
                    }
                }).subscribe(function(results) {
                    if (previousShouldFire !== undefined && results.shouldFire != previousShouldFire) {
                        previousShouldFire = results.shouldFire;
                        if (results.shouldFire)
                            while (q.length > 0) o.onNext(q.shift())
                    } else {
                        previousShouldFire = results.shouldFire;
                        if (results.shouldFire) o.onNext(results.data);
                        else q.push(results.data)
                    }
                }, function(err) {
                    while (q.length > 0) o.onNext(q.shift());
                    o.onError(err)
                }, function() {
                    while (q.length > 0) o.onNext(q.shift());
                    o.onCompleted()
                });
            return subscription
        }

        function PausableBufferedObservable(source, pauser) {
            this.source = source;
            this.controller = new Subject;
            if (pauser && pauser.subscribe) this.pauser = this.controller.merge(pauser);
            else this.pauser = this.controller;
            __super__.call(this, subscribe, source)
        }
        PausableBufferedObservable.prototype.pause = function() {
            this.controller.onNext(false)
        };
        PausableBufferedObservable.prototype.resume = function() {
            this.controller.onNext(true)
        };
        return PausableBufferedObservable
    }(Observable);
    observableProto.pausableBuffered = function(subject) {
        return new PausableBufferedObservable(this, subject)
    };
    var ControlledObservable = function(__super__) {
        inherits(ControlledObservable, __super__);

        function subscribe(observer) {
            return this.source.subscribe(observer)
        }

        function ControlledObservable(source, enableQueue, scheduler) {
            __super__.call(this, subscribe, source);
            this.subject = new ControlledSubject(enableQueue, scheduler);
            this.source = source.multicast(this.subject).refCount()
        }
        ControlledObservable.prototype.request = function(numberOfItems) {
            return this.subject.request(numberOfItems == null ? -1 : numberOfItems)
        };
        return ControlledObservable
    }(Observable);
    var ControlledSubject = function(__super__) {
        function subscribe(observer) {
            return this.subject.subscribe(observer)
        }
        inherits(ControlledSubject, __super__);

        function ControlledSubject(enableQueue, scheduler) {
            enableQueue == null && (enableQueue = true);
            __super__.call(this, subscribe);
            this.subject = new Subject;
            this.enableQueue = enableQueue;
            this.queue =
                enableQueue ? [] : null;
            this.requestedCount = 0;
            this.requestedDisposable = disposableEmpty;
            this.error = null;
            this.hasFailed = false;
            this.hasCompleted = false;
            this.scheduler = scheduler || currentThreadScheduler
        }
        addProperties(ControlledSubject.prototype, Observer, {
            onCompleted: function() {
                this.hasCompleted = true;
                if (!this.enableQueue || this.queue.length === 0) this.subject.onCompleted();
                else this.queue.push(Notification.createOnCompleted())
            },
            onError: function(error) {
                this.hasFailed = true;
                this.error = error;
                if (!this.enableQueue ||
                    this.queue.length === 0) this.subject.onError(error);
                else this.queue.push(Notification.createOnError(error))
            },
            onNext: function(value) {
                var hasRequested = false;
                if (this.requestedCount === 0) this.enableQueue && this.queue.push(Notification.createOnNext(value));
                else {
                    this.requestedCount !== -1 && this.requestedCount-- === 0 && this.disposeCurrentRequest();
                    hasRequested = true
                }
                hasRequested && this.subject.onNext(value)
            },
            _processRequest: function(numberOfItems) {
                if (this.enableQueue) {
                    while (this.queue.length >= numberOfItems && numberOfItems >
                        0 || this.queue.length > 0 && this.queue[0].kind !== "N") {
                        var first = this.queue.shift();
                        first.accept(this.subject);
                        if (first.kind === "N") numberOfItems--;
                        else {
                            this.disposeCurrentRequest();
                            this.queue = []
                        }
                    }
                    return {
                        numberOfItems: numberOfItems,
                        returnValue: this.queue.length !== 0
                    }
                }
                return {
                    numberOfItems: numberOfItems,
                    returnValue: false
                }
            },
            request: function(number) {
                this.disposeCurrentRequest();
                var self = this;
                this.requestedDisposable = this.scheduler.scheduleWithState(number, function(s, i) {
                    var r = self._processRequest(i),
                        remaining =
                        r.numberOfItems;
                    if (!r.returnValue) {
                        self.requestedCount = remaining;
                        self.requestedDisposable = disposableCreate(function() {
                            self.requestedCount = 0
                        })
                    }
                });
                return this.requestedDisposable
            },
            disposeCurrentRequest: function() {
                this.requestedDisposable.dispose();
                this.requestedDisposable = disposableEmpty
            }
        });
        return ControlledSubject
    }(Observable);
    observableProto.controlled = function(enableQueue, scheduler) {
        if (enableQueue && isScheduler(enableQueue)) {
            scheduler = enableQueue;
            enableQueue = true
        }
        if (enableQueue == null) enableQueue =
            true;
        return new ControlledObservable(this, enableQueue, scheduler)
    };
    var StopAndWaitObservable = function(__super__) {
        function subscribe(observer) {
            this.subscription = this.source.subscribe(new StopAndWaitObserver(observer, this, this.subscription));
            var self = this;
            timeoutScheduler.schedule(function() {
                self.source.request(1)
            });
            return this.subscription
        }
        inherits(StopAndWaitObservable, __super__);

        function StopAndWaitObservable(source) {
            __super__.call(this, subscribe, source);
            this.source = source
        }
        var StopAndWaitObserver =
            function(__sub__) {
                inherits(StopAndWaitObserver, __sub__);

                function StopAndWaitObserver(observer, observable, cancel) {
                    __sub__.call(this);
                    this.observer = observer;
                    this.observable = observable;
                    this.cancel = cancel
                }
                var stopAndWaitObserverProto = StopAndWaitObserver.prototype;
                stopAndWaitObserverProto.completed = function() {
                    this.observer.onCompleted();
                    this.dispose()
                };
                stopAndWaitObserverProto.error = function(error) {
                    this.observer.onError(error);
                    this.dispose()
                };
                stopAndWaitObserverProto.next = function(value) {
                    this.observer.onNext(value);
                    var self = this;
                    timeoutScheduler.schedule(function() {
                        self.observable.source.request(1)
                    })
                };
                stopAndWaitObserverProto.dispose = function() {
                    this.observer = null;
                    if (this.cancel) {
                        this.cancel.dispose();
                        this.cancel = null
                    }
                    __sub__.prototype.dispose.call(this)
                };
                return StopAndWaitObserver
            }(AbstractObserver);
        return StopAndWaitObservable
    }(Observable);
    ControlledObservable.prototype.stopAndWait = function() {
        return new StopAndWaitObservable(this)
    };
    var WindowedObservable = function(__super__) {
        function subscribe(observer) {
            this.subscription =
                this.source.subscribe(new WindowedObserver(observer, this, this.subscription));
            var self = this;
            timeoutScheduler.schedule(function() {
                self.source.request(self.windowSize)
            });
            return this.subscription
        }
        inherits(WindowedObservable, __super__);

        function WindowedObservable(source, windowSize) {
            __super__.call(this, subscribe, source);
            this.source = source;
            this.windowSize = windowSize
        }
        var WindowedObserver = function(__sub__) {
            inherits(WindowedObserver, __sub__);

            function WindowedObserver(observer, observable, cancel) {
                this.observer =
                    observer;
                this.observable = observable;
                this.cancel = cancel;
                this.received = 0
            }
            var windowedObserverPrototype = WindowedObserver.prototype;
            windowedObserverPrototype.completed = function() {
                this.observer.onCompleted();
                this.dispose()
            };
            windowedObserverPrototype.error = function(error) {
                this.observer.onError(error);
                this.dispose()
            };
            windowedObserverPrototype.next = function(value) {
                this.observer.onNext(value);
                this.received = ++this.received % this.observable.windowSize;
                if (this.received === 0) {
                    var self = this;
                    timeoutScheduler.schedule(function() {
                        self.observable.source.request(self.observable.windowSize)
                    })
                }
            };
            windowedObserverPrototype.dispose = function() {
                this.observer = null;
                if (this.cancel) {
                    this.cancel.dispose();
                    this.cancel = null
                }
                __sub__.prototype.dispose.call(this)
            };
            return WindowedObserver
        }(AbstractObserver);
        return WindowedObservable
    }(Observable);
    ControlledObservable.prototype.windowed = function(windowSize) {
        return new WindowedObservable(this, windowSize)
    };
    observableProto.pipe = function(dest) {
        var source = this.pausableBuffered();

        function onDrain() {
            source.resume()
        }
        dest.addListener("drain", onDrain);
        source.subscribe(function(x) {
            !dest.write(String(x)) &&
                source.pause()
        }, function(err) {
            dest.emit("error", err)
        }, function() {
            !dest._isStdio && dest.end();
            dest.removeListener("drain", onDrain)
        });
        source.resume();
        return dest
    };
    observableProto.multicast = function(subjectOrSubjectSelector, selector) {
        var source = this;
        return typeof subjectOrSubjectSelector === "function" ? new AnonymousObservable(function(observer) {
                var connectable = source.multicast(subjectOrSubjectSelector());
                return new CompositeDisposable(selector(connectable).subscribe(observer), connectable.connect())
            }, source) :
            new ConnectableObservable(source, subjectOrSubjectSelector)
    };
    observableProto.publish = function(selector) {
        return selector && isFunction(selector) ? this.multicast(function() {
            return new Subject
        }, selector) : this.multicast(new Subject)
    };
    observableProto.share = function() {
        return this.publish().refCount()
    };
    observableProto.publishLast = function(selector) {
        return selector && isFunction(selector) ? this.multicast(function() {
            return new AsyncSubject
        }, selector) : this.multicast(new AsyncSubject)
    };
    observableProto.publishValue =
        function(initialValueOrSelector, initialValue) {
            return arguments.length === 2 ? this.multicast(function() {
                return new BehaviorSubject(initialValue)
            }, initialValueOrSelector) : this.multicast(new BehaviorSubject(initialValueOrSelector))
        };
    observableProto.shareValue = function(initialValue) {
        return this.publishValue(initialValue).refCount()
    };
    observableProto.replay = function(selector, bufferSize, windowSize, scheduler) {
        return selector && isFunction(selector) ? this.multicast(function() {
            return new ReplaySubject(bufferSize,
                windowSize, scheduler)
        }, selector) : this.multicast(new ReplaySubject(bufferSize, windowSize, scheduler))
    };
    observableProto.shareReplay = function(bufferSize, windowSize, scheduler) {
        return this.replay(null, bufferSize, windowSize, scheduler).refCount()
    };
    var InnerSubscription = function(subject, observer) {
        this.subject = subject;
        this.observer = observer
    };
    InnerSubscription.prototype.dispose = function() {
        if (!this.subject.isDisposed && this.observer !== null) {
            var idx = this.subject.observers.indexOf(this.observer);
            this.subject.observers.splice(idx,
                1);
            this.observer = null
        }
    };
    var BehaviorSubject = Rx.BehaviorSubject = function(__super__) {
        function subscribe(observer) {
            checkDisposed(this);
            if (!this.isStopped) {
                this.observers.push(observer);
                observer.onNext(this.value);
                return new InnerSubscription(this, observer)
            }
            if (this.hasError) observer.onError(this.error);
            else observer.onCompleted();
            return disposableEmpty
        }
        inherits(BehaviorSubject, __super__);

        function BehaviorSubject(value) {
            __super__.call(this, subscribe);
            this.value = value, this.observers = [], this.isDisposed =
                false, this.isStopped = false, this.hasError = false
        }
        addProperties(BehaviorSubject.prototype, Observer, {
            getValue: function() {
                checkDisposed(this);
                if (this.hasError) throw this.error;
                return this.value
            },
            hasObservers: function() {
                return this.observers.length > 0
            },
            onCompleted: function() {
                checkDisposed(this);
                if (this.isStopped) return;
                this.isStopped = true;
                for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) os[i].onCompleted();
                this.observers.length = 0
            },
            onError: function(error) {
                checkDisposed(this);
                if (this.isStopped) return;
                this.isStopped = true;
                this.hasError = true;
                this.error = error;
                for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) os[i].onError(error);
                this.observers.length = 0
            },
            onNext: function(value) {
                checkDisposed(this);
                if (this.isStopped) return;
                this.value = value;
                for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) os[i].onNext(value)
            },
            dispose: function() {
                this.isDisposed = true;
                this.observers = null;
                this.value = null;
                this.exception = null
            }
        });
        return BehaviorSubject
    }(Observable);
    var ReplaySubject = Rx.ReplaySubject =
        function(__super__) {
            var maxSafeInteger = Math.pow(2, 53) - 1;

            function createRemovableDisposable(subject, observer) {
                return disposableCreate(function() {
                    observer.dispose();
                    !subject.isDisposed && subject.observers.splice(subject.observers.indexOf(observer), 1)
                })
            }

            function subscribe(observer) {
                var so = new ScheduledObserver(this.scheduler, observer),
                    subscription = createRemovableDisposable(this, so);
                checkDisposed(this);
                this._trim(this.scheduler.now());
                this.observers.push(so);
                for (var i = 0, len = this.q.length; i < len; i++) so.onNext(this.q[i].value);
                if (this.hasError) so.onError(this.error);
                else if (this.isStopped) so.onCompleted();
                so.ensureActive();
                return subscription
            }
            inherits(ReplaySubject, __super__);

            function ReplaySubject(bufferSize, windowSize, scheduler) {
                this.bufferSize = bufferSize == null ? maxSafeInteger : bufferSize;
                this.windowSize = windowSize == null ? maxSafeInteger : windowSize;
                this.scheduler = scheduler || currentThreadScheduler;
                this.q = [];
                this.observers = [];
                this.isStopped = false;
                this.isDisposed = false;
                this.hasError = false;
                this.error = null;
                __super__.call(this,
                    subscribe)
            }
            addProperties(ReplaySubject.prototype, Observer.prototype, {
                hasObservers: function() {
                    return this.observers.length > 0
                },
                _trim: function(now) {
                    while (this.q.length > this.bufferSize) this.q.shift();
                    while (this.q.length > 0 && now - this.q[0].interval > this.windowSize) this.q.shift()
                },
                onNext: function(value) {
                    checkDisposed(this);
                    if (this.isStopped) return;
                    var now = this.scheduler.now();
                    this.q.push({
                        interval: now,
                        value: value
                    });
                    this._trim(now);
                    for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
                        var observer =
                            os[i];
                        observer.onNext(value);
                        observer.ensureActive()
                    }
                },
                onError: function(error) {
                    checkDisposed(this);
                    if (this.isStopped) return;
                    this.isStopped = true;
                    this.error = error;
                    this.hasError = true;
                    var now = this.scheduler.now();
                    this._trim(now);
                    for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
                        var observer = os[i];
                        observer.onError(error);
                        observer.ensureActive()
                    }
                    this.observers.length = 0
                },
                onCompleted: function() {
                    checkDisposed(this);
                    if (this.isStopped) return;
                    this.isStopped = true;
                    var now = this.scheduler.now();
                    this._trim(now);
                    for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
                        var observer = os[i];
                        observer.onCompleted();
                        observer.ensureActive()
                    }
                    this.observers.length = 0
                },
                dispose: function() {
                    this.isDisposed = true;
                    this.observers = null
                }
            });
            return ReplaySubject
        }(Observable);
    var ConnectableObservable = Rx.ConnectableObservable = function(__super__) {
        inherits(ConnectableObservable, __super__);

        function ConnectableObservable(source, subject) {
            var hasSubscription = false,
                subscription, sourceObservable = source.asObservable();
            this.connect = function() {
                if (!hasSubscription) {
                    hasSubscription = true;
                    subscription = new CompositeDisposable(sourceObservable.subscribe(subject), disposableCreate(function() {
                        hasSubscription = false
                    }))
                }
                return subscription
            };
            __super__.call(this, function(o) {
                return subject.subscribe(o)
            })
        }
        ConnectableObservable.prototype.refCount = function() {
            var connectableSubscription, count = 0,
                source = this;
            return new AnonymousObservable(function(observer) {
                var shouldConnect = ++count === 1,
                    subscription = source.subscribe(observer);
                shouldConnect &&
                    (connectableSubscription = source.connect());
                return function() {
                    subscription.dispose();
                    --count === 0 && connectableSubscription.dispose()
                }
            })
        };
        return ConnectableObservable
    }(Observable);
    var Dictionary = function() {
        var primes = [1, 3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143, 4194301, 8388593, 16777213, 33554393, 67108859, 134217689, 268435399, 536870909, 1073741789, 2147483647],
            noSuchkey = "no such key",
            duplicatekey = "duplicate key";

        function isPrime(candidate) {
            if ((candidate &
                    1) === 0) return candidate === 2;
            var num1 = Math.sqrt(candidate),
                num2 = 3;
            while (num2 <= num1) {
                if (candidate % num2 === 0) return false;
                num2 += 2
            }
            return true
        }

        function getPrime(min) {
            var index, num, candidate;
            for (index = 0; index < primes.length; ++index) {
                num = primes[index];
                if (num >= min) return num
            }
            candidate = min | 1;
            while (candidate < primes[primes.length - 1]) {
                if (isPrime(candidate)) return candidate;
                candidate += 2
            }
            return min
        }

        function stringHashFn(str) {
            var hash = 757602046;
            if (!str.length) return hash;
            for (var i = 0, len = str.length; i < len; i++) {
                var character =
                    str.charCodeAt(i);
                hash = (hash << 5) - hash + character;
                hash = hash & hash
            }
            return hash
        }

        function numberHashFn(key) {
            var c2 = 668265261;
            key = key ^ 61 ^ key >>> 16;
            key = key + (key << 3);
            key = key ^ key >>> 4;
            key = key * c2;
            key = key ^ key >>> 15;
            return key
        }
        var getHashCode = function() {
            var uniqueIdCounter = 0;
            return function(obj) {
                if (obj == null) throw new Error(noSuchkey);
                if (typeof obj === "string") return stringHashFn(obj);
                if (typeof obj === "number") return numberHashFn(obj);
                if (typeof obj === "boolean") return obj === true ? 1 : 0;
                if (obj instanceof Date) return numberHashFn(obj.valueOf());
                if (obj instanceof RegExp) return stringHashFn(obj.toString());
                if (typeof obj.valueOf === "function") {
                    var valueOf = obj.valueOf();
                    if (typeof valueOf === "number") return numberHashFn(valueOf);
                    if (typeof valueOf === "string") return stringHashFn(valueOf)
                }
                if (obj.hashCode) return obj.hashCode();
                var id = 17 * uniqueIdCounter++;
                obj.hashCode = function() {
                    return id
                };
                return id
            }
        }();

        function newEntry() {
            return {
                key: null,
                value: null,
                next: 0,
                hashCode: 0
            }
        }

        function Dictionary(capacity, comparer) {
            if (capacity < 0) throw new ArgumentOutOfRangeError;
            if (capacity > 0) this._initialize(capacity);
            this.comparer = comparer || defaultComparer;
            this.freeCount = 0;
            this.size = 0;
            this.freeList = -1
        }
        var dictionaryProto = Dictionary.prototype;
        dictionaryProto._initialize = function(capacity) {
            var prime = getPrime(capacity),
                i;
            this.buckets = new Array(prime);
            this.entries = new Array(prime);
            for (i = 0; i < prime; i++) {
                this.buckets[i] = -1;
                this.entries[i] = newEntry()
            }
            this.freeList = -1
        };
        dictionaryProto.add = function(key, value) {
            this._insert(key, value, true)
        };
        dictionaryProto._insert = function(key, value,
            add) {
            if (!this.buckets) this._initialize(0);
            var index3, num = getHashCode(key) & 2147483647,
                index1 = num % this.buckets.length;
            for (var index2 = this.buckets[index1]; index2 >= 0; index2 = this.entries[index2].next)
                if (this.entries[index2].hashCode === num && this.comparer(this.entries[index2].key, key)) {
                    if (add) throw new Error(duplicatekey);
                    this.entries[index2].value = value;
                    return
                }
            if (this.freeCount > 0) {
                index3 = this.freeList;
                this.freeList = this.entries[index3].next;
                --this.freeCount
            } else {
                if (this.size === this.entries.length) {
                    this._resize();
                    index1 = num % this.buckets.length
                }
                index3 = this.size;
                ++this.size
            }
            this.entries[index3].hashCode = num;
            this.entries[index3].next = this.buckets[index1];
            this.entries[index3].key = key;
            this.entries[index3].value = value;
            this.buckets[index1] = index3
        };
        dictionaryProto._resize = function() {
            var prime = getPrime(this.size * 2),
                numArray = new Array(prime);
            for (index = 0; index < numArray.length; ++index) numArray[index] = -1;
            var entryArray = new Array(prime);
            for (index = 0; index < this.size; ++index) entryArray[index] = this.entries[index];
            for (var index =
                    this.size; index < prime; ++index) entryArray[index] = newEntry();
            for (var index1 = 0; index1 < this.size; ++index1) {
                var index2 = entryArray[index1].hashCode % prime;
                entryArray[index1].next = numArray[index2];
                numArray[index2] = index1
            }
            this.buckets = numArray;
            this.entries = entryArray
        };
        dictionaryProto.remove = function(key) {
            if (this.buckets) {
                var num = getHashCode(key) & 2147483647,
                    index1 = num % this.buckets.length,
                    index2 = -1;
                for (var index3 = this.buckets[index1]; index3 >= 0; index3 = this.entries[index3].next)
                    if (this.entries[index3].hashCode ===
                        num && this.comparer(this.entries[index3].key, key)) {
                        if (index2 < 0) this.buckets[index1] = this.entries[index3].next;
                        else this.entries[index2].next = this.entries[index3].next;
                        this.entries[index3].hashCode = -1;
                        this.entries[index3].next = this.freeList;
                        this.entries[index3].key = null;
                        this.entries[index3].value = null;
                        this.freeList = index3;
                        ++this.freeCount;
                        return true
                    } else index2 = index3
            }
            return false
        };
        dictionaryProto.clear = function() {
            var index, len;
            if (this.size <= 0) return;
            for (index = 0, len = this.buckets.length; index < len; ++index) this.buckets[index] = -1;
            for (index = 0; index < this.size; ++index) this.entries[index] = newEntry();
            this.freeList = -1;
            this.size = 0
        };
        dictionaryProto._findEntry = function(key) {
            if (this.buckets) {
                var num = getHashCode(key) & 2147483647;
                for (var index = this.buckets[num % this.buckets.length]; index >= 0; index = this.entries[index].next)
                    if (this.entries[index].hashCode === num && this.comparer(this.entries[index].key, key)) return index
            }
            return -1
        };
        dictionaryProto.count = function() {
            return this.size - this.freeCount
        };
        dictionaryProto.tryGetValue = function(key) {
            var entry =
                this._findEntry(key);
            return entry >= 0 ? this.entries[entry].value : undefined
        };
        dictionaryProto.getValues = function() {
            var index = 0,
                results = [];
            if (this.entries)
                for (var index1 = 0; index1 < this.size; index1++)
                    if (this.entries[index1].hashCode >= 0) results[index++] = this.entries[index1].value;
            return results
        };
        dictionaryProto.get = function(key) {
            var entry = this._findEntry(key);
            if (entry >= 0) return this.entries[entry].value;
            throw new Error(noSuchkey);
        };
        dictionaryProto.set = function(key, value) {
            this._insert(key, value, false)
        };
        dictionaryProto.containskey =
            function(key) {
                return this._findEntry(key) >= 0
            };
        return Dictionary
    }();
    observableProto.join = function(right, leftDurationSelector, rightDurationSelector, resultSelector) {
        var left = this;
        return new AnonymousObservable(function(observer) {
            var group = new CompositeDisposable;
            var leftDone = false,
                rightDone = false;
            var leftId = 0,
                rightId = 0;
            var leftMap = new Dictionary,
                rightMap = new Dictionary;
            group.add(left.subscribe(function(value) {
                var id = leftId++;
                var md = new SingleAssignmentDisposable;
                leftMap.add(id, value);
                group.add(md);
                var expire =
                    function() {
                        leftMap.remove(id) && leftMap.count() === 0 && leftDone && observer.onCompleted();
                        group.remove(md)
                    };
                var duration;
                try {
                    duration = leftDurationSelector(value)
                } catch (e) {
                    observer.onError(e);
                    return
                }
                md.setDisposable(duration.take(1).subscribe(noop, observer.onError.bind(observer), expire));
                rightMap.getValues().forEach(function(v) {
                    var result;
                    try {
                        result = resultSelector(value, v)
                    } catch (exn) {
                        observer.onError(exn);
                        return
                    }
                    observer.onNext(result)
                })
            }, observer.onError.bind(observer), function() {
                leftDone = true;
                (rightDone ||
                    leftMap.count() === 0) && observer.onCompleted()
            }));
            group.add(right.subscribe(function(value) {
                var id = rightId++;
                var md = new SingleAssignmentDisposable;
                rightMap.add(id, value);
                group.add(md);
                var expire = function() {
                    rightMap.remove(id) && rightMap.count() === 0 && rightDone && observer.onCompleted();
                    group.remove(md)
                };
                var duration;
                try {
                    duration = rightDurationSelector(value)
                } catch (e) {
                    observer.onError(e);
                    return
                }
                md.setDisposable(duration.take(1).subscribe(noop, observer.onError.bind(observer), expire));
                leftMap.getValues().forEach(function(v) {
                    var result;
                    try {
                        result = resultSelector(v, value)
                    } catch (exn) {
                        observer.onError(exn);
                        return
                    }
                    observer.onNext(result)
                })
            }, observer.onError.bind(observer), function() {
                rightDone = true;
                (leftDone || rightMap.count() === 0) && observer.onCompleted()
            }));
            return group
        }, left)
    };
    observableProto.groupJoin = function(right, leftDurationSelector, rightDurationSelector, resultSelector) {
        var left = this;
        return new AnonymousObservable(function(observer) {
            var group = new CompositeDisposable;
            var r = new RefCountDisposable(group);
            var leftMap = new Dictionary,
                rightMap = new Dictionary;
            var leftId = 0,
                rightId = 0;

            function handleError(e) {
                return function(v) {
                    v.onError(e)
                }
            }
            group.add(left.subscribe(function(value) {
                var s = new Subject;
                var id = leftId++;
                leftMap.add(id, s);
                var result;
                try {
                    result = resultSelector(value, addRef(s, r))
                } catch (e) {
                    leftMap.getValues().forEach(handleError(e));
                    observer.onError(e);
                    return
                }
                observer.onNext(result);
                rightMap.getValues().forEach(function(v) {
                    s.onNext(v)
                });
                var md = new SingleAssignmentDisposable;
                group.add(md);
                var expire = function() {
                    leftMap.remove(id) &&
                        s.onCompleted();
                    group.remove(md)
                };
                var duration;
                try {
                    duration = leftDurationSelector(value)
                } catch (e) {
                    leftMap.getValues().forEach(handleError(e));
                    observer.onError(e);
                    return
                }
                md.setDisposable(duration.take(1).subscribe(noop, function(e) {
                    leftMap.getValues().forEach(handleError(e));
                    observer.onError(e)
                }, expire))
            }, function(e) {
                leftMap.getValues().forEach(handleError(e));
                observer.onError(e)
            }, observer.onCompleted.bind(observer)));
            group.add(right.subscribe(function(value) {
                var id = rightId++;
                rightMap.add(id, value);
                var md = new SingleAssignmentDisposable;
                group.add(md);
                var expire = function() {
                    rightMap.remove(id);
                    group.remove(md)
                };
                var duration;
                try {
                    duration = rightDurationSelector(value)
                } catch (e) {
                    leftMap.getValues().forEach(handleError(e));
                    observer.onError(e);
                    return
                }
                md.setDisposable(duration.take(1).subscribe(noop, function(e) {
                    leftMap.getValues().forEach(handleError(e));
                    observer.onError(e)
                }, expire));
                leftMap.getValues().forEach(function(v) {
                    v.onNext(value)
                })
            }, function(e) {
                leftMap.getValues().forEach(handleError(e));
                observer.onError(e)
            }));
            return r
        }, left)
    };
    observableProto.buffer = function(bufferOpeningsOrClosingSelector, bufferClosingSelector) {
        return this.window.apply(this, arguments).selectMany(function(x) {
            return x.toArray()
        })
    };
    observableProto.window = function(windowOpeningsOrClosingSelector, windowClosingSelector) {
        if (arguments.length === 1 && typeof arguments[0] !== "function") return observableWindowWithBoundaries.call(this, windowOpeningsOrClosingSelector);
        return typeof windowOpeningsOrClosingSelector === "function" ? observableWindowWithClosingSelector.call(this,
            windowOpeningsOrClosingSelector) : observableWindowWithOpenings.call(this, windowOpeningsOrClosingSelector, windowClosingSelector)
    };

    function observableWindowWithOpenings(windowOpenings, windowClosingSelector) {
        return windowOpenings.groupJoin(this, windowClosingSelector, observableEmpty, function(_, win) {
            return win
        })
    }

    function observableWindowWithBoundaries(windowBoundaries) {
        var source = this;
        return new AnonymousObservable(function(observer) {
                var win = new Subject,
                    d = new CompositeDisposable,
                    r = new RefCountDisposable(d);
                observer.onNext(addRef(win, r));
                d.add(source.subscribe(function(x) {
                    win.onNext(x)
                }, function(err) {
                    win.onError(err);
                    observer.onError(err)
                }, function() {
                    win.onCompleted();
                    observer.onCompleted()
                }));
                isPromise(windowBoundaries) && (windowBoundaries = observableFromPromise(windowBoundaries));
                d.add(windowBoundaries.subscribe(function(w) {
                    win.onCompleted();
                    win = new Subject;
                    observer.onNext(addRef(win, r))
                }, function(err) {
                    win.onError(err);
                    observer.onError(err)
                }, function() {
                    win.onCompleted();
                    observer.onCompleted()
                }));
                return r
            },
            source)
    }

    function observableWindowWithClosingSelector(windowClosingSelector) {
        var source = this;
        return new AnonymousObservable(function(observer) {
            var m = new SerialDisposable,
                d = new CompositeDisposable(m),
                r = new RefCountDisposable(d),
                win = new Subject;
            observer.onNext(addRef(win, r));
            d.add(source.subscribe(function(x) {
                win.onNext(x)
            }, function(err) {
                win.onError(err);
                observer.onError(err)
            }, function() {
                win.onCompleted();
                observer.onCompleted()
            }));

            function createWindowClose() {
                var windowClose;
                try {
                    windowClose = windowClosingSelector()
                } catch (e) {
                    observer.onError(e);
                    return
                }
                isPromise(windowClose) && (windowClose = observableFromPromise(windowClose));
                var m1 = new SingleAssignmentDisposable;
                m.setDisposable(m1);
                m1.setDisposable(windowClose.take(1).subscribe(noop, function(err) {
                    win.onError(err);
                    observer.onError(err)
                }, function() {
                    win.onCompleted();
                    win = new Subject;
                    observer.onNext(addRef(win, r));
                    createWindowClose()
                }))
            }
            createWindowClose();
            return r
        }, source)
    }
    observableProto.pairwise = function() {
        var source = this;
        return new AnonymousObservable(function(observer) {
            var previous, hasPrevious =
                false;
            return source.subscribe(function(x) {
                if (hasPrevious) observer.onNext([previous, x]);
                else hasPrevious = true;
                previous = x
            }, observer.onError.bind(observer), observer.onCompleted.bind(observer))
        }, source)
    };
    observableProto.partition = function(predicate, thisArg) {
        return [this.filter(predicate, thisArg), this.filter(function(x, i, o) {
            return !predicate.call(thisArg, x, i, o)
        })]
    };

    function enumerableWhile(condition, source) {
        return new Enumerable(function() {
            return new Enumerator(function() {
                return condition() ? {
                    done: false,
                    value: source
                } : {
                    done: true,
                    value: undefined
                }
            })
        })
    }
    observableProto.letBind = observableProto["let"] = function(func) {
        return func(this)
    };
    Observable["if"] = Observable.ifThen = function(condition, thenSource, elseSourceOrScheduler) {
        return observableDefer(function() {
            elseSourceOrScheduler || (elseSourceOrScheduler = observableEmpty());
            isPromise(thenSource) && (thenSource = observableFromPromise(thenSource));
            isPromise(elseSourceOrScheduler) && (elseSourceOrScheduler = observableFromPromise(elseSourceOrScheduler));
            typeof elseSourceOrScheduler.now ===
                "function" && (elseSourceOrScheduler = observableEmpty(elseSourceOrScheduler));
            return condition() ? thenSource : elseSourceOrScheduler
        })
    };
    Observable["for"] = Observable.forIn = function(sources, resultSelector, thisArg) {
        return enumerableOf(sources, resultSelector, thisArg).concat()
    };
    var observableWhileDo = Observable["while"] = Observable.whileDo = function(condition, source) {
        isPromise(source) && (source = observableFromPromise(source));
        return enumerableWhile(condition, source).concat()
    };
    observableProto.doWhile = function(condition) {
        return observableConcat([this,
            observableWhileDo(condition, this)
        ])
    };
    Observable["case"] = Observable.switchCase = function(selector, sources, defaultSourceOrScheduler) {
        return observableDefer(function() {
            isPromise(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableFromPromise(defaultSourceOrScheduler));
            defaultSourceOrScheduler || (defaultSourceOrScheduler = observableEmpty());
            typeof defaultSourceOrScheduler.now === "function" && (defaultSourceOrScheduler = observableEmpty(defaultSourceOrScheduler));
            var result = sources[selector()];
            isPromise(result) &&
                (result = observableFromPromise(result));
            return result || defaultSourceOrScheduler
        })
    };
    observableProto.expand = function(selector, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        var source = this;
        return new AnonymousObservable(function(observer) {
            var q = [],
                m = new SerialDisposable,
                d = new CompositeDisposable(m),
                activeCount = 0,
                isAcquired = false;
            var ensureActive = function() {
                var isOwner = false;
                if (q.length > 0) {
                    isOwner = !isAcquired;
                    isAcquired = true
                }
                if (isOwner) m.setDisposable(scheduler.scheduleRecursive(function(self) {
                    var work;
                    if (q.length > 0) work = q.shift();
                    else {
                        isAcquired = false;
                        return
                    }
                    var m1 = new SingleAssignmentDisposable;
                    d.add(m1);
                    m1.setDisposable(work.subscribe(function(x) {
                        observer.onNext(x);
                        var result = null;
                        try {
                            result = selector(x)
                        } catch (e) {
                            observer.onError(e)
                        }
                        q.push(result);
                        activeCount++;
                        ensureActive()
                    }, observer.onError.bind(observer), function() {
                        d.remove(m1);
                        activeCount--;
                        if (activeCount === 0) observer.onCompleted()
                    }));
                    self()
                }))
            };
            q.push(source);
            activeCount++;
            ensureActive();
            return d
        }, this)
    };
    Observable.forkJoin = function() {
        var allSources = [];
        if (Array.isArray(arguments[0])) allSources = arguments[0];
        else
            for (var i = 0, len = arguments.length; i < len; i++) allSources.push(arguments[i]);
        return new AnonymousObservable(function(subscriber) {
            var count = allSources.length;
            if (count === 0) {
                subscriber.onCompleted();
                return disposableEmpty
            }
            var group = new CompositeDisposable,
                finished = false,
                hasResults = new Array(count),
                hasCompleted = new Array(count),
                results = new Array(count);
            for (var idx = 0; idx < count; idx++)(function(i) {
                var source = allSources[i];
                isPromise(source) && (source =
                    observableFromPromise(source));
                group.add(source.subscribe(function(value) {
                    if (!finished) {
                        hasResults[i] = true;
                        results[i] = value
                    }
                }, function(e) {
                    finished = true;
                    subscriber.onError(e);
                    group.dispose()
                }, function() {
                    if (!finished) {
                        if (!hasResults[i]) {
                            subscriber.onCompleted();
                            return
                        }
                        hasCompleted[i] = true;
                        for (var ix = 0; ix < count; ix++)
                            if (!hasCompleted[ix]) return;
                        finished = true;
                        subscriber.onNext(results);
                        subscriber.onCompleted()
                    }
                }))
            })(idx);
            return group
        })
    };
    observableProto.forkJoin = function(second, resultSelector) {
        var first =
            this;
        return new AnonymousObservable(function(observer) {
            var leftStopped = false,
                rightStopped = false,
                hasLeft = false,
                hasRight = false,
                lastLeft, lastRight, leftSubscription = new SingleAssignmentDisposable,
                rightSubscription = new SingleAssignmentDisposable;
            isPromise(second) && (second = observableFromPromise(second));
            leftSubscription.setDisposable(first.subscribe(function(left) {
                hasLeft = true;
                lastLeft = left
            }, function(err) {
                rightSubscription.dispose();
                observer.onError(err)
            }, function() {
                leftStopped = true;
                if (rightStopped)
                    if (!hasLeft) observer.onCompleted();
                    else if (!hasRight) observer.onCompleted();
                else {
                    var result;
                    try {
                        result = resultSelector(lastLeft, lastRight)
                    } catch (e) {
                        observer.onError(e);
                        return
                    }
                    observer.onNext(result);
                    observer.onCompleted()
                }
            }));
            rightSubscription.setDisposable(second.subscribe(function(right) {
                hasRight = true;
                lastRight = right
            }, function(err) {
                leftSubscription.dispose();
                observer.onError(err)
            }, function() {
                rightStopped = true;
                if (leftStopped)
                    if (!hasLeft) observer.onCompleted();
                    else if (!hasRight) observer.onCompleted();
                else {
                    var result;
                    try {
                        result = resultSelector(lastLeft,
                            lastRight)
                    } catch (e) {
                        observer.onError(e);
                        return
                    }
                    observer.onNext(result);
                    observer.onCompleted()
                }
            }));
            return new CompositeDisposable(leftSubscription, rightSubscription)
        }, first)
    };
    observableProto.manySelect = function(selector, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        var source = this;
        return observableDefer(function() {
            var chain;
            return source.map(function(x) {
                var curr = new ChainObservable(x);
                chain && chain.onNext(x);
                chain = curr;
                return curr
            }).tap(noop, function(e) {
                    chain && chain.onError(e)
                },
                function() {
                    chain && chain.onCompleted()
                }).observeOn(scheduler).map(selector)
        }, source)
    };
    var ChainObservable = function(__super__) {
        function subscribe(observer) {
            var self = this,
                g = new CompositeDisposable;
            g.add(currentThreadScheduler.schedule(function() {
                observer.onNext(self.head);
                g.add(self.tail.mergeAll().subscribe(observer))
            }));
            return g
        }
        inherits(ChainObservable, __super__);

        function ChainObservable(head) {
            __super__.call(this, subscribe);
            this.head = head;
            this.tail = new AsyncSubject
        }
        addProperties(ChainObservable.prototype,
            Observer, {
                onCompleted: function() {
                    this.onNext(Observable.empty())
                },
                onError: function(e) {
                    this.onNext(Observable.throwError(e))
                },
                onNext: function(v) {
                    this.tail.onNext(v);
                    this.tail.onCompleted()
                }
            });
        return ChainObservable
    }(Observable);
    var Map = root.Map || function() {
        function Map() {
            this._keys = [];
            this._values = []
        }
        Map.prototype.get = function(key) {
            var i = this._keys.indexOf(key);
            return i !== -1 ? this._values[i] : undefined
        };
        Map.prototype.set = function(key, value) {
            var i = this._keys.indexOf(key);
            i !== -1 && (this._values[i] = value);
            this._values[this._keys.push(key) - 1] = value
        };
        Map.prototype.forEach = function(callback, thisArg) {
            for (var i = 0, len = this._keys.length; i < len; i++) callback.call(thisArg, this._values[i], this._keys[i])
        };
        return Map
    }();

    function Pattern(patterns) {
        this.patterns = patterns
    }
    Pattern.prototype.and = function(other) {
        return new Pattern(this.patterns.concat(other))
    };
    Pattern.prototype.thenDo = function(selector) {
        return new Plan(this, selector)
    };

    function Plan(expression, selector) {
        this.expression = expression;
        this.selector = selector
    }
    Plan.prototype.activate = function(externalSubscriptions, observer, deactivate) {
        var self = this;
        var joinObservers = [];
        for (var i = 0, len = this.expression.patterns.length; i < len; i++) joinObservers.push(planCreateObserver(externalSubscriptions, this.expression.patterns[i], observer.onError.bind(observer)));
        var activePlan = new ActivePlan(joinObservers, function() {
            var result;
            try {
                result = self.selector.apply(self, arguments)
            } catch (e) {
                observer.onError(e);
                return
            }
            observer.onNext(result)
        }, function() {
            for (var j = 0, jlen = joinObservers.length; j <
                jlen; j++) joinObservers[j].removeActivePlan(activePlan);
            deactivate(activePlan)
        });
        for (i = 0, len = joinObservers.length; i < len; i++) joinObservers[i].addActivePlan(activePlan);
        return activePlan
    };

    function planCreateObserver(externalSubscriptions, observable, onError) {
        var entry = externalSubscriptions.get(observable);
        if (!entry) {
            var observer = new JoinObserver(observable, onError);
            externalSubscriptions.set(observable, observer);
            return observer
        }
        return entry
    }

    function ActivePlan(joinObserverArray, onNext, onCompleted) {
        this.joinObserverArray =
            joinObserverArray;
        this.onNext = onNext;
        this.onCompleted = onCompleted;
        this.joinObservers = new Map;
        for (var i = 0, len = this.joinObserverArray.length; i < len; i++) {
            var joinObserver = this.joinObserverArray[i];
            this.joinObservers.set(joinObserver, joinObserver)
        }
    }
    ActivePlan.prototype.dequeue = function() {
        this.joinObservers.forEach(function(v) {
            v.queue.shift()
        })
    };
    ActivePlan.prototype.match = function() {
        var i, len, hasValues = true;
        for (i = 0, len = this.joinObserverArray.length; i < len; i++)
            if (this.joinObserverArray[i].queue.length ===
                0) {
                hasValues = false;
                break
            }
        if (hasValues) {
            var firstValues = [],
                isCompleted = false;
            for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
                firstValues.push(this.joinObserverArray[i].queue[0]);
                this.joinObserverArray[i].queue[0].kind === "C" && (isCompleted = true)
            }
            if (isCompleted) this.onCompleted();
            else {
                this.dequeue();
                var values = [];
                for (i = 0, len = firstValues.length; i < firstValues.length; i++) values.push(firstValues[i].value);
                this.onNext.apply(this, values)
            }
        }
    };
    var JoinObserver = function(__super__) {
        inherits(JoinObserver, __super__);

        function JoinObserver(source, onError) {
            __super__.call(this);
            this.source = source;
            this.onError = onError;
            this.queue = [];
            this.activePlans = [];
            this.subscription = new SingleAssignmentDisposable;
            this.isDisposed = false
        }
        var JoinObserverPrototype = JoinObserver.prototype;
        JoinObserverPrototype.next = function(notification) {
            if (!this.isDisposed) {
                if (notification.kind === "E") return this.onError(notification.exception);
                this.queue.push(notification);
                var activePlans = this.activePlans.slice(0);
                for (var i = 0, len = activePlans.length; i <
                    len; i++) activePlans[i].match()
            }
        };
        JoinObserverPrototype.error = noop;
        JoinObserverPrototype.completed = noop;
        JoinObserverPrototype.addActivePlan = function(activePlan) {
            this.activePlans.push(activePlan)
        };
        JoinObserverPrototype.subscribe = function() {
            this.subscription.setDisposable(this.source.materialize().subscribe(this))
        };
        JoinObserverPrototype.removeActivePlan = function(activePlan) {
            this.activePlans.splice(this.activePlans.indexOf(activePlan), 1);
            this.activePlans.length === 0 && this.dispose()
        };
        JoinObserverPrototype.dispose =
            function() {
                __super__.prototype.dispose.call(this);
                if (!this.isDisposed) {
                    this.isDisposed = true;
                    this.subscription.dispose()
                }
            };
        return JoinObserver
    }(AbstractObserver);
    observableProto.and = function(right) {
        return new Pattern([this, right])
    };
    observableProto.thenDo = function(selector) {
        return (new Pattern([this])).thenDo(selector)
    };
    Observable.when = function() {
        var len = arguments.length,
            plans;
        if (Array.isArray(arguments[0])) plans = arguments[0];
        else {
            plans = new Array(len);
            for (var i = 0; i < len; i++) plans[i] = arguments[i]
        }
        return new AnonymousObservable(function(o) {
            var activePlans = [],
                externalSubscriptions = new Map;
            var outObserver = observerCreate(function(x) {
                o.onNext(x)
            }, function(err) {
                externalSubscriptions.forEach(function(v) {
                    v.onError(err)
                });
                o.onError(err)
            }, function(x) {
                o.onCompleted()
            });
            try {
                for (var i = 0, len = plans.length; i < len; i++) activePlans.push(plans[i].activate(externalSubscriptions, outObserver, function(activePlan) {
                    var idx = activePlans.indexOf(activePlan);
                    activePlans.splice(idx, 1);
                    activePlans.length === 0 && o.onCompleted()
                }))
            } catch (e) {
                observableThrow(e).subscribe(o)
            }
            var group =
                new CompositeDisposable;
            externalSubscriptions.forEach(function(joinObserver) {
                joinObserver.subscribe();
                group.add(joinObserver)
            });
            return group
        })
    };

    function observableTimerDate(dueTime, scheduler) {
        return new AnonymousObservable(function(observer) {
            return scheduler.scheduleWithAbsolute(dueTime, function() {
                observer.onNext(0);
                observer.onCompleted()
            })
        })
    }

    function observableTimerDateAndPeriod(dueTime, period, scheduler) {
        return new AnonymousObservable(function(observer) {
            var d = dueTime,
                p = normalizeTime(period);
            return scheduler.scheduleRecursiveWithAbsoluteAndState(0,
                d,
                function(count, self) {
                    if (p > 0) {
                        var now = scheduler.now();
                        d = d + p;
                        d <= now && (d = now + p)
                    }
                    observer.onNext(count);
                    self(count + 1, d)
                })
        })
    }

    function observableTimerTimeSpan(dueTime, scheduler) {
        return new AnonymousObservable(function(observer) {
            return scheduler.scheduleWithRelative(normalizeTime(dueTime), function() {
                observer.onNext(0);
                observer.onCompleted()
            })
        })
    }

    function observableTimerTimeSpanAndPeriod(dueTime, period, scheduler) {
        return dueTime === period ? new AnonymousObservable(function(observer) {
            return scheduler.schedulePeriodicWithState(0,
                period,
                function(count) {
                    observer.onNext(count);
                    return count + 1
                })
        }) : observableDefer(function() {
            return observableTimerDateAndPeriod(scheduler.now() + dueTime, period, scheduler)
        })
    }
    var observableinterval = Observable.interval = function(period, scheduler) {
        return observableTimerTimeSpanAndPeriod(period, period, isScheduler(scheduler) ? scheduler : timeoutScheduler)
    };
    var observableTimer = Observable.timer = function(dueTime, periodOrScheduler, scheduler) {
        var period;
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        if (periodOrScheduler !==
            undefined && typeof periodOrScheduler === "number") period = periodOrScheduler;
        else if (isScheduler(periodOrScheduler)) scheduler = periodOrScheduler;
        if (dueTime instanceof Date && period === undefined) return observableTimerDate(dueTime.getTime(), scheduler);
        if (dueTime instanceof Date && period !== undefined) {
            period = periodOrScheduler;
            return observableTimerDateAndPeriod(dueTime.getTime(), period, scheduler)
        }
        return period === undefined ? observableTimerTimeSpan(dueTime, scheduler) : observableTimerTimeSpanAndPeriod(dueTime, period,
            scheduler)
    };

    function observableDelayTimeSpan(source, dueTime, scheduler) {
        return new AnonymousObservable(function(observer) {
            var active = false,
                cancelable = new SerialDisposable,
                exception = null,
                q = [],
                running = false,
                subscription;
            subscription = source.materialize().timestamp(scheduler).subscribe(function(notification) {
                var d, shouldRun;
                if (notification.value.kind === "E") {
                    q = [];
                    q.push(notification);
                    exception = notification.value.exception;
                    shouldRun = !running
                } else {
                    q.push({
                        value: notification.value,
                        timestamp: notification.timestamp +
                            dueTime
                    });
                    shouldRun = !active;
                    active = true
                }
                if (shouldRun)
                    if (exception !== null) observer.onError(exception);
                    else {
                        d = new SingleAssignmentDisposable;
                        cancelable.setDisposable(d);
                        d.setDisposable(scheduler.scheduleRecursiveWithRelative(dueTime, function(self) {
                            var e, recurseDueTime, result, shouldRecurse;
                            if (exception !== null) return;
                            running = true;
                            do {
                                result = null;
                                if (q.length > 0 && q[0].timestamp - scheduler.now() <= 0) result = q.shift().value;
                                if (result !== null) result.accept(observer)
                            } while (result !== null);
                            shouldRecurse = false;
                            recurseDueTime =
                                0;
                            if (q.length > 0) {
                                shouldRecurse = true;
                                recurseDueTime = Math.max(0, q[0].timestamp - scheduler.now())
                            } else active = false;
                            e = exception;
                            running = false;
                            if (e !== null) observer.onError(e);
                            else if (shouldRecurse) self(recurseDueTime)
                        }))
                    }
            });
            return new CompositeDisposable(subscription, cancelable)
        }, source)
    }

    function observableDelayDate(source, dueTime, scheduler) {
        return observableDefer(function() {
            return observableDelayTimeSpan(source, dueTime - scheduler.now(), scheduler)
        })
    }
    observableProto.delay = function(dueTime, scheduler) {
        isScheduler(scheduler) ||
            (scheduler = timeoutScheduler);
        return dueTime instanceof Date ? observableDelayDate(this, dueTime.getTime(), scheduler) : observableDelayTimeSpan(this, dueTime, scheduler)
    };
    observableProto.debounce = observableProto.throttleWithTimeout = function(dueTime, scheduler) {
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        var source = this;
        return new AnonymousObservable(function(observer) {
            var cancelable = new SerialDisposable,
                hasvalue = false,
                value, id = 0;
            var subscription = source.subscribe(function(x) {
                hasvalue = true;
                value = x;
                id++;
                var currentId = id,
                    d = new SingleAssignmentDisposable;
                cancelable.setDisposable(d);
                d.setDisposable(scheduler.scheduleWithRelative(dueTime, function() {
                    hasvalue && id === currentId && observer.onNext(value);
                    hasvalue = false
                }))
            }, function(e) {
                cancelable.dispose();
                observer.onError(e);
                hasvalue = false;
                id++
            }, function() {
                cancelable.dispose();
                hasvalue && observer.onNext(value);
                observer.onCompleted();
                hasvalue = false;
                id++
            });
            return new CompositeDisposable(subscription, cancelable)
        }, this)
    };
    observableProto.throttle = function(dueTime,
        scheduler) {
        return this.debounce(dueTime, scheduler)
    };
    observableProto.windowWithTime = function(timeSpan, timeShiftOrScheduler, scheduler) {
        var source = this,
            timeShift;
        timeShiftOrScheduler == null && (timeShift = timeSpan);
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        if (typeof timeShiftOrScheduler === "number") timeShift = timeShiftOrScheduler;
        else if (isScheduler(timeShiftOrScheduler)) {
            timeShift = timeSpan;
            scheduler = timeShiftOrScheduler
        }
        return new AnonymousObservable(function(observer) {
            var groupDisposable, nextShift =
                timeShift,
                nextSpan = timeSpan,
                q = [],
                refCountDisposable, timerD = new SerialDisposable,
                totalTime = 0;
            groupDisposable = new CompositeDisposable(timerD), refCountDisposable = new RefCountDisposable(groupDisposable);

            function createTimer() {
                var m = new SingleAssignmentDisposable,
                    isSpan = false,
                    isShift = false;
                timerD.setDisposable(m);
                if (nextSpan === nextShift) {
                    isSpan = true;
                    isShift = true
                } else if (nextSpan < nextShift) isSpan = true;
                else isShift = true;
                var newTotalTime = isSpan ? nextSpan : nextShift,
                    ts = newTotalTime - totalTime;
                totalTime = newTotalTime;
                if (isSpan) nextSpan += timeShift;
                if (isShift) nextShift += timeShift;
                m.setDisposable(scheduler.scheduleWithRelative(ts, function() {
                    if (isShift) {
                        var s = new Subject;
                        q.push(s);
                        observer.onNext(addRef(s, refCountDisposable))
                    }
                    isSpan && q.shift().onCompleted();
                    createTimer()
                }))
            }
            q.push(new Subject);
            observer.onNext(addRef(q[0], refCountDisposable));
            createTimer();
            groupDisposable.add(source.subscribe(function(x) {
                for (var i = 0, len = q.length; i < len; i++) q[i].onNext(x)
            }, function(e) {
                for (var i = 0, len = q.length; i < len; i++) q[i].onError(e);
                observer.onError(e)
            }, function() {
                for (var i = 0, len = q.length; i < len; i++) q[i].onCompleted();
                observer.onCompleted()
            }));
            return refCountDisposable
        }, source)
    };
    observableProto.windowWithTimeOrCount = function(timeSpan, count, scheduler) {
        var source = this;
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        return new AnonymousObservable(function(observer) {
            var timerD = new SerialDisposable,
                groupDisposable = new CompositeDisposable(timerD),
                refCountDisposable = new RefCountDisposable(groupDisposable),
                n = 0,
                windowId = 0,
                s = new Subject;

            function createTimer(id) {
                var m = new SingleAssignmentDisposable;
                timerD.setDisposable(m);
                m.setDisposable(scheduler.scheduleWithRelative(timeSpan, function() {
                    if (id !== windowId) return;
                    n = 0;
                    var newId = ++windowId;
                    s.onCompleted();
                    s = new Subject;
                    observer.onNext(addRef(s, refCountDisposable));
                    createTimer(newId)
                }))
            }
            observer.onNext(addRef(s, refCountDisposable));
            createTimer(0);
            groupDisposable.add(source.subscribe(function(x) {
                var newId = 0,
                    newWindow = false;
                s.onNext(x);
                if (++n === count) {
                    newWindow = true;
                    n = 0;
                    newId = ++windowId;
                    s.onCompleted();
                    s = new Subject;
                    observer.onNext(addRef(s, refCountDisposable))
                }
                newWindow && createTimer(newId)
            }, function(e) {
                s.onError(e);
                observer.onError(e)
            }, function() {
                s.onCompleted();
                observer.onCompleted()
            }));
            return refCountDisposable
        }, source)
    };
    observableProto.bufferWithTime = function(timeSpan, timeShiftOrScheduler, scheduler) {
        return this.windowWithTime.apply(this, arguments).selectMany(function(x) {
            return x.toArray()
        })
    };
    observableProto.bufferWithTimeOrCount = function(timeSpan, count, scheduler) {
        return this.windowWithTimeOrCount(timeSpan,
            count, scheduler).selectMany(function(x) {
            return x.toArray()
        })
    };
    observableProto.timeInterval = function(scheduler) {
        var source = this;
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        return observableDefer(function() {
            var last = scheduler.now();
            return source.map(function(x) {
                var now = scheduler.now(),
                    span = now - last;
                last = now;
                return {
                    value: x,
                    interval: span
                }
            })
        })
    };
    observableProto.timestamp = function(scheduler) {
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        return this.map(function(x) {
            return {
                value: x,
                timestamp: scheduler.now()
            }
        })
    };

    function sampleObservable(source, sampler) {
        return new AnonymousObservable(function(observer) {
            var atEnd, value, hasValue;

            function sampleSubscribe() {
                if (hasValue) {
                    hasValue = false;
                    observer.onNext(value)
                }
                atEnd && observer.onCompleted()
            }
            return new CompositeDisposable(source.subscribe(function(newValue) {
                hasValue = true;
                value = newValue
            }, observer.onError.bind(observer), function() {
                atEnd = true
            }), sampler.subscribe(sampleSubscribe, observer.onError.bind(observer), sampleSubscribe))
        }, source)
    }
    observableProto.sample = observableProto.throttleLatest =
        function(intervalOrSampler, scheduler) {
            isScheduler(scheduler) || (scheduler = timeoutScheduler);
            return typeof intervalOrSampler === "number" ? sampleObservable(this, observableinterval(intervalOrSampler, scheduler)) : sampleObservable(this, intervalOrSampler)
        };
    observableProto.timeout = function(dueTime, other, scheduler) {
        (other == null || typeof other === "string") && (other = observableThrow(new Error(other || "Timeout")));
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        var source = this,
            schedulerMethod = dueTime instanceof
        Date ? "scheduleWithAbsolute" : "scheduleWithRelative";
        return new AnonymousObservable(function(observer) {
            var id = 0,
                original = new SingleAssignmentDisposable,
                subscription = new SerialDisposable,
                switched = false,
                timer = new SerialDisposable;
            subscription.setDisposable(original);

            function createTimer() {
                var myId = id;
                timer.setDisposable(scheduler[schedulerMethod](dueTime, function() {
                    if (id === myId) {
                        isPromise(other) && (other = observableFromPromise(other));
                        subscription.setDisposable(other.subscribe(observer))
                    }
                }))
            }
            createTimer();
            original.setDisposable(source.subscribe(function(x) {
                if (!switched) {
                    id++;
                    observer.onNext(x);
                    createTimer()
                }
            }, function(e) {
                if (!switched) {
                    id++;
                    observer.onError(e)
                }
            }, function() {
                if (!switched) {
                    id++;
                    observer.onCompleted()
                }
            }));
            return new CompositeDisposable(subscription, timer)
        }, source)
    };
    Observable.generateWithAbsoluteTime = function(initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        return new AnonymousObservable(function(observer) {
            var first =
                true,
                hasResult = false,
                result, state = initialState,
                time;
            return scheduler.scheduleRecursiveWithAbsolute(scheduler.now(), function(self) {
                hasResult && observer.onNext(result);
                try {
                    if (first) first = false;
                    else state = iterate(state);
                    hasResult = condition(state);
                    if (hasResult) {
                        result = resultSelector(state);
                        time = timeSelector(state)
                    }
                } catch (e) {
                    observer.onError(e);
                    return
                }
                if (hasResult) self(time);
                else observer.onCompleted()
            })
        })
    };
    Observable.generateWithRelativeTime = function(initialState, condition, iterate, resultSelector, timeSelector,
        scheduler) {
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        return new AnonymousObservable(function(observer) {
            var first = true,
                hasResult = false,
                result, state = initialState,
                time;
            return scheduler.scheduleRecursiveWithRelative(0, function(self) {
                hasResult && observer.onNext(result);
                try {
                    if (first) first = false;
                    else state = iterate(state);
                    hasResult = condition(state);
                    if (hasResult) {
                        result = resultSelector(state);
                        time = timeSelector(state)
                    }
                } catch (e) {
                    observer.onError(e);
                    return
                }
                if (hasResult) self(time);
                else observer.onCompleted()
            })
        })
    };
    observableProto.delaySubscription = function(dueTime, scheduler) {
        var scheduleMethod = dueTime instanceof Date ? "scheduleWithAbsolute" : "scheduleWithRelative";
        var source = this;
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        return new AnonymousObservable(function(o) {
            var d = new SerialDisposable;
            d.setDisposable(scheduler[scheduleMethod](dueTime, function() {
                d.setDisposable(source.subscribe(o))
            }));
            return d
        }, this)
    };
    observableProto.delayWithSelector = function(subscriptionDelay, delayDurationSelector) {
        var source =
            this,
            subDelay, selector;
        if (isFunction(subscriptionDelay)) selector = subscriptionDelay;
        else {
            subDelay = subscriptionDelay;
            selector = delayDurationSelector
        }
        return new AnonymousObservable(function(observer) {
            var delays = new CompositeDisposable,
                atEnd = false,
                subscription = new SerialDisposable;

            function start() {
                subscription.setDisposable(source.subscribe(function(x) {
                    var delay = tryCatch(selector)(x);
                    if (delay === errorObj) return observer.onError(delay.e);
                    var d = new SingleAssignmentDisposable;
                    delays.add(d);
                    d.setDisposable(delay.subscribe(function() {
                        observer.onNext(x);
                        delays.remove(d);
                        done()
                    }, function(e) {
                        observer.onError(e)
                    }, function() {
                        observer.onNext(x);
                        delays.remove(d);
                        done()
                    }))
                }, function(e) {
                    observer.onError(e)
                }, function() {
                    atEnd = true;
                    subscription.dispose();
                    done()
                }))
            }

            function done() {
                atEnd && delays.length === 0 && observer.onCompleted()
            }
            if (!subDelay) start();
            else subscription.setDisposable(subDelay.subscribe(start, function(e) {
                observer.onError(e)
            }, start));
            return new CompositeDisposable(subscription, delays)
        }, this)
    };
    observableProto.timeoutWithSelector = function(firstTimeout,
        timeoutdurationSelector, other) {
        if (arguments.length === 1) {
            timeoutdurationSelector = firstTimeout;
            firstTimeout = observableNever()
        }
        other || (other = observableThrow(new Error("Timeout")));
        var source = this;
        return new AnonymousObservable(function(observer) {
            var subscription = new SerialDisposable,
                timer = new SerialDisposable,
                original = new SingleAssignmentDisposable;
            subscription.setDisposable(original);
            var id = 0,
                switched = false;

            function setTimer(timeout) {
                var myId = id;

                function timerWins() {
                    return id === myId
                }
                var d = new SingleAssignmentDisposable;
                timer.setDisposable(d);
                d.setDisposable(timeout.subscribe(function() {
                    timerWins() && subscription.setDisposable(other.subscribe(observer));
                    d.dispose()
                }, function(e) {
                    timerWins() && observer.onError(e)
                }, function() {
                    timerWins() && subscription.setDisposable(other.subscribe(observer))
                }))
            }
            setTimer(firstTimeout);

            function observerWins() {
                var res = !switched;
                if (res) id++;
                return res
            }
            original.setDisposable(source.subscribe(function(x) {
                if (observerWins()) {
                    observer.onNext(x);
                    var timeout;
                    try {
                        timeout = timeoutdurationSelector(x)
                    } catch (e) {
                        observer.onError(e);
                        return
                    }
                    setTimer(isPromise(timeout) ? observableFromPromise(timeout) : timeout)
                }
            }, function(e) {
                observerWins() && observer.onError(e)
            }, function() {
                observerWins() && observer.onCompleted()
            }));
            return new CompositeDisposable(subscription, timer)
        }, source)
    };
    observableProto.debounceWithSelector = function(durationSelector) {
        var source = this;
        return new AnonymousObservable(function(observer) {
            var value, hasValue = false,
                cancelable = new SerialDisposable,
                id = 0;
            var subscription = source.subscribe(function(x) {
                var throttle;
                try {
                    throttle =
                        durationSelector(x)
                } catch (e) {
                    observer.onError(e);
                    return
                }
                isPromise(throttle) && (throttle = observableFromPromise(throttle));
                hasValue = true;
                value = x;
                id++;
                var currentid = id,
                    d = new SingleAssignmentDisposable;
                cancelable.setDisposable(d);
                d.setDisposable(throttle.subscribe(function() {
                    hasValue && id === currentid && observer.onNext(value);
                    hasValue = false;
                    d.dispose()
                }, observer.onError.bind(observer), function() {
                    hasValue && id === currentid && observer.onNext(value);
                    hasValue = false;
                    d.dispose()
                }))
            }, function(e) {
                cancelable.dispose();
                observer.onError(e);
                hasValue = false;
                id++
            }, function() {
                cancelable.dispose();
                hasValue && observer.onNext(value);
                observer.onCompleted();
                hasValue = false;
                id++
            });
            return new CompositeDisposable(subscription, cancelable)
        }, source)
    };
    observableProto.throttleWithSelector = function(durationSelector) {
        return this.debounceWithSelector(durationSelector)
    };
    observableProto.skipLastWithTime = function(duration, scheduler) {
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        var source = this;
        return new AnonymousObservable(function(o) {
            var q = [];
            return source.subscribe(function(x) {
                var now = scheduler.now();
                q.push({
                    interval: now,
                    value: x
                });
                while (q.length > 0 && now - q[0].interval >= duration) o.onNext(q.shift().value)
            }, function(e) {
                o.onError(e)
            }, function() {
                var now = scheduler.now();
                while (q.length > 0 && now - q[0].interval >= duration) o.onNext(q.shift().value);
                o.onCompleted()
            })
        }, source)
    };
    observableProto.takeLastWithTime = function(duration, scheduler) {
        var source = this;
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        return new AnonymousObservable(function(o) {
            var q = [];
            return source.subscribe(function(x) {
                var now = scheduler.now();
                q.push({
                    interval: now,
                    value: x
                });
                while (q.length > 0 && now - q[0].interval >= duration) q.shift()
            }, function(e) {
                o.onError(e)
            }, function() {
                var now = scheduler.now();
                while (q.length > 0) {
                    var next = q.shift();
                    if (now - next.interval <= duration) o.onNext(next.value)
                }
                o.onCompleted()
            })
        }, source)
    };
    observableProto.takeLastBufferWithTime = function(duration, scheduler) {
        var source = this;
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        return new AnonymousObservable(function(o) {
            var q = [];
            return source.subscribe(function(x) {
                var now = scheduler.now();
                q.push({
                    interval: now,
                    value: x
                });
                while (q.length > 0 && now - q[0].interval >= duration) q.shift()
            }, function(e) {
                o.onError(e)
            }, function() {
                var now = scheduler.now(),
                    res = [];
                while (q.length > 0) {
                    var next = q.shift();
                    now - next.interval <= duration && res.push(next.value)
                }
                o.onNext(res);
                o.onCompleted()
            })
        }, source)
    };
    observableProto.takeWithTime = function(duration, scheduler) {
        var source = this;
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        return new AnonymousObservable(function(o) {
            return new CompositeDisposable(scheduler.scheduleWithRelative(duration,
                function() {
                    o.onCompleted()
                }), source.subscribe(o))
        }, source)
    };
    observableProto.skipWithTime = function(duration, scheduler) {
        var source = this;
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        return new AnonymousObservable(function(observer) {
            var open = false;
            return new CompositeDisposable(scheduler.scheduleWithRelative(duration, function() {
                open = true
            }), source.subscribe(function(x) {
                open && observer.onNext(x)
            }, observer.onError.bind(observer), observer.onCompleted.bind(observer)))
        }, source)
    };
    observableProto.skipUntilWithTime =
        function(startTime, scheduler) {
            isScheduler(scheduler) || (scheduler = timeoutScheduler);
            var source = this,
                schedulerMethod = startTime instanceof Date ? "scheduleWithAbsolute" : "scheduleWithRelative";
            return new AnonymousObservable(function(o) {
                var open = false;
                return new CompositeDisposable(scheduler[schedulerMethod](startTime, function() {
                    open = true
                }), source.subscribe(function(x) {
                    open && o.onNext(x)
                }, function(e) {
                    o.onError(e)
                }, function() {
                    o.onCompleted()
                }))
            }, source)
        };
    observableProto.takeUntilWithTime = function(endTime,
        scheduler) {
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        var source = this,
            schedulerMethod = endTime instanceof Date ? "scheduleWithAbsolute" : "scheduleWithRelative";
        return new AnonymousObservable(function(o) {
            return new CompositeDisposable(scheduler[schedulerMethod](endTime, function() {
                o.onCompleted()
            }), source.subscribe(o))
        }, source)
    };
    observableProto.throttleFirst = function(windowDuration, scheduler) {
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        var duration = +windowDuration || 0;
        if (duration <= 0) throw new RangeError("windowDuration cannot be less or equal zero.");
        var source = this;
        return new AnonymousObservable(function(o) {
            var lastOnNext = 0;
            return source.subscribe(function(x) {
                var now = scheduler.now();
                if (lastOnNext === 0 || now - lastOnNext >= duration) {
                    lastOnNext = now;
                    o.onNext(x)
                }
            }, function(e) {
                o.onError(e)
            }, function() {
                o.onCompleted()
            })
        }, source)
    };
    observableProto.exclusive = function() {
        var sources = this;
        return new AnonymousObservable(function(observer) {
                var hasCurrent = false,
                    isStopped = false,
                    m = new SingleAssignmentDisposable,
                    g = new CompositeDisposable;
                g.add(m);
                m.setDisposable(sources.subscribe(function(innerSource) {
                    if (!hasCurrent) {
                        hasCurrent =
                            true;
                        isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
                        var innerSubscription = new SingleAssignmentDisposable;
                        g.add(innerSubscription);
                        innerSubscription.setDisposable(innerSource.subscribe(observer.onNext.bind(observer), observer.onError.bind(observer), function() {
                            g.remove(innerSubscription);
                            hasCurrent = false;
                            if (isStopped && g.length === 1) observer.onCompleted()
                        }))
                    }
                }, observer.onError.bind(observer), function() {
                    isStopped = true;
                    if (!hasCurrent && g.length === 1) observer.onCompleted()
                }));
                return g
            },
            this)
    };
    observableProto.exclusiveMap = function(selector, thisArg) {
        var sources = this,
            selectorFunc = bindCallback(selector, thisArg, 3);
        return new AnonymousObservable(function(observer) {
            var index = 0,
                hasCurrent = false,
                isStopped = true,
                m = new SingleAssignmentDisposable,
                g = new CompositeDisposable;
            g.add(m);
            m.setDisposable(sources.subscribe(function(innerSource) {
                if (!hasCurrent) {
                    hasCurrent = true;
                    innerSubscription = new SingleAssignmentDisposable;
                    g.add(innerSubscription);
                    isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
                    innerSubscription.setDisposable(innerSource.subscribe(function(x) {
                        var result;
                        try {
                            result = selectorFunc(x, index++, innerSource)
                        } catch (e) {
                            observer.onError(e);
                            return
                        }
                        observer.onNext(result)
                    }, function(e) {
                        observer.onError(e)
                    }, function() {
                        g.remove(innerSubscription);
                        hasCurrent = false;
                        if (isStopped && g.length === 1) observer.onCompleted()
                    }))
                }
            }, function(e) {
                observer.onError(e)
            }, function() {
                isStopped = true;
                if (g.length === 1 && !hasCurrent) observer.onCompleted()
            }));
            return g
        }, this)
    };
    observableProto.transduce = function(transducer) {
        var source =
            this;

        function transformForObserver(o) {
            return {
                "@@transducer/init": function() {
                    return o
                },
                "@@transducer/step": function(obs, input) {
                    return obs.onNext(input)
                },
                "@@transducer/result": function(obs) {
                    return obs.onCompleted()
                }
            }
        }
        return new AnonymousObservable(function(o) {
            var xform = transducer(transformForObserver(o));
            return source.subscribe(function(v) {
                try {
                    xform["@@transducer/step"](o, v)
                } catch (e) {
                    o.onError(e)
                }
            }, function(e) {
                o.onError(e)
            }, function() {
                xform["@@transducer/result"](o)
            })
        }, source)
    };
    Rx.VirtualTimeScheduler =
        function(__super__) {
            function localNow() {
                return this.toDateTimeOffset(this.clock)
            }

            function scheduleNow(state, action) {
                return this.scheduleAbsoluteWithState(state, this.clock, action)
            }

            function scheduleRelative(state, dueTime, action) {
                return this.scheduleRelativeWithState(state, this.toRelative(dueTime), action)
            }

            function scheduleAbsolute(state, dueTime, action) {
                return this.scheduleRelativeWithState(state, this.toRelative(dueTime - this.now()), action)
            }

            function invokeAction(scheduler, action) {
                action();
                return disposableEmpty
            }
            inherits(VirtualTimeScheduler, __super__);

            function VirtualTimeScheduler(initialClock, comparer) {
                this.clock = initialClock;
                this.comparer = comparer;
                this.isEnabled = false;
                this.queue = new PriorityQueue(1024);
                __super__.call(this, localNow, scheduleNow, scheduleRelative, scheduleAbsolute)
            }
            var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;
            VirtualTimeSchedulerPrototype.add = notImplemented;
            VirtualTimeSchedulerPrototype.toDateTimeOffset = notImplemented;
            VirtualTimeSchedulerPrototype.toRelative = notImplemented;
            VirtualTimeSchedulerPrototype.schedulePeriodicWithState = function(state, period, action) {
                var s = new SchedulePeriodicRecursive(this, state, period, action);
                return s.start()
            };
            VirtualTimeSchedulerPrototype.scheduleRelativeWithState = function(state, dueTime, action) {
                var runAt = this.add(this.clock, dueTime);
                return this.scheduleAbsoluteWithState(state, runAt, action)
            };
            VirtualTimeSchedulerPrototype.scheduleRelative = function(dueTime, action) {
                return this.scheduleRelativeWithState(action, dueTime, invokeAction)
            };
            VirtualTimeSchedulerPrototype.start =
                function() {
                    if (!this.isEnabled) {
                        this.isEnabled = true;
                        do {
                            var next = this.getNext();
                            if (next !== null) {
                                this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
                                next.invoke()
                            } else this.isEnabled = false
                        } while (this.isEnabled)
                    }
                };
            VirtualTimeSchedulerPrototype.stop = function() {
                this.isEnabled = false
            };
            VirtualTimeSchedulerPrototype.advanceTo = function(time) {
                var dueToClock = this.comparer(this.clock, time);
                if (this.comparer(this.clock, time) > 0) throw new ArgumentOutOfRangeError;
                if (dueToClock === 0) return;
                if (!this.isEnabled) {
                    this.isEnabled =
                        true;
                    do {
                        var next = this.getNext();
                        if (next !== null && this.comparer(next.dueTime, time) <= 0) {
                            this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
                            next.invoke()
                        } else this.isEnabled = false
                    } while (this.isEnabled);
                    this.clock = time
                }
            };
            VirtualTimeSchedulerPrototype.advanceBy = function(time) {
                var dt = this.add(this.clock, time),
                    dueToClock = this.comparer(this.clock, dt);
                if (dueToClock > 0) throw new ArgumentOutOfRangeError;
                if (dueToClock === 0) return;
                this.advanceTo(dt)
            };
            VirtualTimeSchedulerPrototype.sleep = function(time) {
                var dt =
                    this.add(this.clock, time);
                if (this.comparer(this.clock, dt) >= 0) throw new ArgumentOutOfRangeError;
                this.clock = dt
            };
            VirtualTimeSchedulerPrototype.getNext = function() {
                while (this.queue.length > 0) {
                    var next = this.queue.peek();
                    if (next.isCancelled()) this.queue.dequeue();
                    else return next
                }
                return null
            };
            VirtualTimeSchedulerPrototype.scheduleAbsolute = function(dueTime, action) {
                return this.scheduleAbsoluteWithState(action, dueTime, invokeAction)
            };
            VirtualTimeSchedulerPrototype.scheduleAbsoluteWithState = function(state, dueTime,
                action) {
                var self = this;

                function run(scheduler, state1) {
                    self.queue.remove(si);
                    return action(scheduler, state1)
                }
                var si = new ScheduledItem(this, state, run, dueTime, this.comparer);
                this.queue.enqueue(si);
                return si.disposable
            };
            return VirtualTimeScheduler
        }(Scheduler);
    Rx.HistoricalScheduler = function(__super__) {
        inherits(HistoricalScheduler, __super__);

        function HistoricalScheduler(initialClock, comparer) {
            var clock = initialClock == null ? 0 : initialClock;
            var cmp = comparer || defaultSubComparer;
            __super__.call(this, clock, cmp)
        }
        var HistoricalSchedulerProto = HistoricalScheduler.prototype;
        HistoricalSchedulerProto.add = function(absolute, relative) {
            return absolute + relative
        };
        HistoricalSchedulerProto.toDateTimeOffset = function(absolute) {
            return (new Date(absolute)).getTime()
        };
        HistoricalSchedulerProto.toRelative = function(timeSpan) {
            return timeSpan
        };
        return HistoricalScheduler
    }(Rx.VirtualTimeScheduler);
    var AnonymousObservable = Rx.AnonymousObservable = function(__super__) {
        inherits(AnonymousObservable, __super__);

        function fixSubscriber(subscriber) {
            return subscriber &&
                isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty
        }

        function setDisposable(s, state) {
            var ado = state[0],
                subscribe = state[1];
            var sub = tryCatch(subscribe)(ado);
            if (sub === errorObj)
                if (!ado.fail(errorObj.e)) return thrower(errorObj.e);
            ado.setDisposable(fixSubscriber(sub))
        }

        function AnonymousObservable(subscribe, parent) {
            this.source = parent;

            function s(observer) {
                var ado = new AutoDetachObserver(observer),
                    state = [ado, subscribe];
                if (currentThreadScheduler.scheduleRequired()) currentThreadScheduler.scheduleWithState(state,
                    setDisposable);
                else setDisposable(null, state);
                return ado
            }
            __super__.call(this, s)
        }
        return AnonymousObservable
    }(Observable);
    var AutoDetachObserver = function(__super__) {
        inherits(AutoDetachObserver, __super__);

        function AutoDetachObserver(observer) {
            __super__.call(this);
            this.observer = observer;
            this.m = new SingleAssignmentDisposable
        }
        var AutoDetachObserverPrototype = AutoDetachObserver.prototype;
        AutoDetachObserverPrototype.next = function(value) {
            var result = tryCatch(this.observer.onNext).call(this.observer, value);
            if (result ===
                errorObj) {
                this.dispose();
                thrower(result.e)
            }
        };
        AutoDetachObserverPrototype.error = function(err) {
            var result = tryCatch(this.observer.onError).call(this.observer, err);
            this.dispose();
            result === errorObj && thrower(result.e)
        };
        AutoDetachObserverPrototype.completed = function() {
            var result = tryCatch(this.observer.onCompleted).call(this.observer);
            this.dispose();
            result === errorObj && thrower(result.e)
        };
        AutoDetachObserverPrototype.setDisposable = function(value) {
            this.m.setDisposable(value)
        };
        AutoDetachObserverPrototype.getDisposable =
            function() {
                return this.m.getDisposable()
            };
        AutoDetachObserverPrototype.dispose = function() {
            __super__.prototype.dispose.call(this);
            this.m.dispose()
        };
        return AutoDetachObserver
    }(AbstractObserver);
    var GroupedObservable = function(__super__) {
        inherits(GroupedObservable, __super__);

        function subscribe(observer) {
            return this.underlyingObservable.subscribe(observer)
        }

        function GroupedObservable(key, underlyingObservable, mergedDisposable) {
            __super__.call(this, subscribe);
            this.key = key;
            this.underlyingObservable = !mergedDisposable ?
                underlyingObservable : new AnonymousObservable(function(observer) {
                    return new CompositeDisposable(mergedDisposable.getDisposable(), underlyingObservable.subscribe(observer))
                })
        }
        return GroupedObservable
    }(Observable);
    var Subject = Rx.Subject = function(__super__) {
        function subscribe(observer) {
            checkDisposed(this);
            if (!this.isStopped) {
                this.observers.push(observer);
                return new InnerSubscription(this, observer)
            }
            if (this.hasError) {
                observer.onError(this.error);
                return disposableEmpty
            }
            observer.onCompleted();
            return disposableEmpty
        }
        inherits(Subject, __super__);

        function Subject() {
            __super__.call(this, subscribe);
            this.isDisposed = false, this.isStopped = false, this.observers = [];
            this.hasError = false
        }
        addProperties(Subject.prototype, Observer.prototype, {
            hasObservers: function() {
                return this.observers.length > 0
            },
            onCompleted: function() {
                checkDisposed(this);
                if (!this.isStopped) {
                    this.isStopped = true;
                    for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) os[i].onCompleted();
                    this.observers.length = 0
                }
            },
            onError: function(error) {
                checkDisposed(this);
                if (!this.isStopped) {
                    this.isStopped = true;
                    this.error = error;
                    this.hasError = true;
                    for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) os[i].onError(error);
                    this.observers.length = 0
                }
            },
            onNext: function(value) {
                checkDisposed(this);
                if (!this.isStopped)
                    for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) os[i].onNext(value)
            },
            dispose: function() {
                this.isDisposed = true;
                this.observers = null
            }
        });
        Subject.create = function(observer, observable) {
            return new AnonymousSubject(observer, observable)
        };
        return Subject
    }(Observable);
    var AsyncSubject = Rx.AsyncSubject = function(__super__) {
        function subscribe(observer) {
            checkDisposed(this);
            if (!this.isStopped) {
                this.observers.push(observer);
                return new InnerSubscription(this, observer)
            }
            if (this.hasError) observer.onError(this.error);
            else if (this.hasValue) {
                observer.onNext(this.value);
                observer.onCompleted()
            } else observer.onCompleted();
            return disposableEmpty
        }
        inherits(AsyncSubject, __super__);

        function AsyncSubject() {
            __super__.call(this, subscribe);
            this.isDisposed = false;
            this.isStopped = false;
            this.hasValue =
                false;
            this.observers = [];
            this.hasError = false
        }
        addProperties(AsyncSubject.prototype, Observer, {
            hasObservers: function() {
                checkDisposed(this);
                return this.observers.length > 0
            },
            onCompleted: function() {
                var i, len;
                checkDisposed(this);
                if (!this.isStopped) {
                    this.isStopped = true;
                    var os = cloneArray(this.observers),
                        len = os.length;
                    if (this.hasValue)
                        for (i = 0; i < len; i++) {
                            var o = os[i];
                            o.onNext(this.value);
                            o.onCompleted()
                        } else
                            for (i = 0; i < len; i++) os[i].onCompleted();
                    this.observers.length = 0
                }
            },
            onError: function(error) {
                checkDisposed(this);
                if (!this.isStopped) {
                    this.isStopped = true;
                    this.hasError = true;
                    this.error = error;
                    for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) os[i].onError(error);
                    this.observers.length = 0
                }
            },
            onNext: function(value) {
                checkDisposed(this);
                if (this.isStopped) return;
                this.value = value;
                this.hasValue = true
            },
            dispose: function() {
                this.isDisposed = true;
                this.observers = null;
                this.exception = null;
                this.value = null
            }
        });
        return AsyncSubject
    }(Observable);
    var AnonymousSubject = Rx.AnonymousSubject = function(__super__) {
        inherits(AnonymousSubject,
            __super__);

        function subscribe(observer) {
            return this.observable.subscribe(observer)
        }

        function AnonymousSubject(observer, observable) {
            this.observer = observer;
            this.observable = observable;
            __super__.call(this, subscribe)
        }
        addProperties(AnonymousSubject.prototype, Observer.prototype, {
            onCompleted: function() {
                this.observer.onCompleted()
            },
            onError: function(error) {
                this.observer.onError(error)
            },
            onNext: function(value) {
                this.observer.onNext(value)
            }
        });
        return AnonymousSubject
    }(Observable);
    Rx.Pauser = function(__super__) {
        inherits(Pauser,
            __super__);

        function Pauser() {
            __super__.call(this)
        }
        Pauser.prototype.pause = function() {
            this.onNext(false)
        };
        Pauser.prototype.resume = function() {
            this.onNext(true)
        };
        return Pauser
    }(Subject);
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root.Rx = Rx;
        define(function() {
            return Rx
        })
    } else if (freeExports && freeModule)
        if (moduleExports)(freeModule.exports = Rx).Rx = Rx;
        else freeExports.Rx = Rx;
    else root.Rx = Rx;
    var rEndingLine = captureLine()
}).call(this);
(function(factory) {
    var objectTypes = {
        "boolean": false,
        "function": true,
        "object": true,
        "number": false,
        "string": false,
        "undefined": false
    };
    var root = objectTypes[typeof window] && window || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window ===
            freeGlobal)) root = freeGlobal;
    if (typeof define === "function" && define.amd) define(["rx", "exports"], function(Rx, exports) {
        root.Rx = factory(root, exports, Rx);
        return root.Rx
    });
    else if (typeof module === "object" && module && module.exports === freeExports) module.exports = factory(root, module.exports, require("rx"));
    else root.Rx = factory(root, {}, root.Rx)
}).call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        observerCreate = Rx.Observer.create,
        disposableCreate = Rx.Disposable.create,
        CompositeDisposable = Rx.CompositeDisposable,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        AsyncSubject = Rx.AsyncSubject,
        Subject = Rx.Subject,
        Scheduler = Rx.Scheduler,
        defaultNow = function() {
            return !!Date.now ? Date.now : function() {
                return +new Date
            }
        }(),
        dom = Rx.DOM = {},
        hasOwnProperty = {}.hasOwnProperty,
        noop = Rx.helpers.noop;

    function fixEvent(event) {
        var stopPropagation = function() {
            this.cancelBubble = true
        };
        var preventDefault = function() {
            this.bubbledKeyCode = this.keyCode;
            if (this.ctrlKey) try {
                this.keyCode =
                    0
            } catch (e) {}
            this.defaultPrevented = true;
            this.returnValue = false;
            this.modified = true
        };
        event || (event = root.event);
        if (!event.target) {
            event.target = event.target || event.srcElement;
            if (event.type == "mouseover") event.relatedTarget = event.fromElement;
            if (event.type == "mouseout") event.relatedTarget = event.toElement;
            if (!event.stopPropagation) {
                event.stopPropagation = stopPropagation;
                event.preventDefault = preventDefault
            }
            switch (event.type) {
                case "keypress":
                    var c = "charCode" in event ? event.charCode : event.keyCode;
                    if (c == 10) {
                        c = 0;
                        event.keyCode = 13
                    } else if (c == 13 || c == 27) c = 0;
                    else if (c == 3) c = 99;
                    event.charCode = c;
                    event.keyChar = event.charCode ? String.fromCharCode(event.charCode) : "";
                    break
            }
        }
        return event
    }

    function createListener(element, name, handler) {
        if (element.addEventListener) {
            if (name == "tap") $(element).tap(handler, false);
            else element.addEventListener(name, handler, false);
            return disposableCreate(function() {
                element.removeEventListener(name, handler, false)
            })
        }
        if (element.attachEvent) {
            var innerHandler = function(event) {
                handler(fixEvent(event))
            };
            element.attachEvent("on" + name, innerHandler);
            return disposableCreate(function() {
                element.detachEvent("on" + name, innerHandler)
            })
        }
        element["on" + name] = handler;
        return disposableCreate(function() {
            element["on" + name] = null
        })
    }

    function createEventListener(el, eventName, handler) {
        var disposables = new CompositeDisposable;
        if (Object.prototype.toString.call(el) === "[object NodeList]")
            for (var i = 0, len = el.length; i < len; i++) disposables.add(createEventListener(el.item(i), eventName, handler));
        else if (el) disposables.add(createListener(el,
            eventName, handler));
        return disposables
    }
    var fromEvent = dom.fromEvent = function(element, eventName, selector) {
        return (new AnonymousObservable(function(observer) {
            return createEventListener(element, eventName, function handler(e) {
                var results = e;
                if (selector) try {
                    results = selector(arguments)
                } catch (err) {
                    observer.onError(err);
                    return
                }
                observer.onNext(results)
            })
        })).publish().refCount()
    };
    (function() {
        var events = "blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
            "change select submit keydown keypress keyup error contextmenu";
        if (root.PointerEvent) events += " pointerdown pointerup pointermove pointerover pointerout pointerenter pointerleave";
        if (root.TouchEvent) events += " touchstart touchend touchmove touchcancel";
        events = events.split(" ");
        for (var i = 0, len = events.length; i < len; i++)(function(e) {
            dom[e] = function(element, selector) {
                return fromEvent(element, e, selector)
            }
        })(events[i])
    })();
    dom.ready = function() {
        return new AnonymousObservable(function(observer) {
            function handler() {
                observer.onNext();
                observer.onCompleted()
            }

            function createListener() {
                if (document.addEventListener) {
                    document.addEventListener("DOMContentLoaded", handler, false);
                    root.addEventListener("load", handler, false);
                    return function() {
                        document.removeEventListener("DOMContentLoaded", handler, false);
                        root.removeEventListener("load", handler, false)
                    }
                } else if (document.attachEvent) {
                    root.attachEvent("onload", handler);
                    return function() {
                        root.detachEvent("onload", handler)
                    }
                } else {
                    document["onload"] = handler;
                    return function() {
                        document["onload"] = null
                    }
                }
            }
            var returnFn = noop;
            if (document.readyState === "complete") setTimeout(handler, 0);
            else returnFn = createListener();
            return returnFn
        })
    };

    function getXMLHttpRequest() {
        if (root.XMLHttpRequest) return new root.XMLHttpRequest;
        else {
            var progId;
            try {
                var progIds = ["Msxml2.XMLHTTP", "Microsoft.XMLHTTP", "Msxml2.XMLHTTP.4.0"];
                for (var i = 0; i < 3; i++) try {
                    progId = progIds[i];
                    if (new root.ActiveXObject(progId)) break
                } catch (e) {}
                return new root.ActiveXObject(progId)
            } catch (e) {
                throw new Error("XMLHttpRequest is not supported by your browser");
            }
        }
    }

    function getCORSRequest() {
        if ("withCredentials" in root.XMLHttpRequest.prototype) return new root.XMLHttpRequest;
        else if (!!root.XDomainRequest) return new XDomainRequest;
        else throw new Error("CORS is not supported by your browser");
    }

    function normalizeAjaxLoadEvent(e, xhr, settings) {
        var response = "response" in xhr ? xhr.response : settings.responseType === "json" ? JSON.parse(xhr.responseText) : xhr.responseText;
        return {
            response: response,
            status: xhr.status,
            responseType: xhr.responseType,
            xhr: xhr,
            originalEvent: e
        }
    }

    function normalizeAjaxErrorEvent(e,
        xhr, type) {
        return {
            type: type,
            status: xhr.status,
            xhr: xhr,
            originalEvent: e
        }
    }
    var ajaxRequest = dom.ajax = function(options) {
        var settings = {
            method: "GET",
            crossDomain: false,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            async: true,
            headers: {},
            responseType: "text"
        };
        if (typeof options === "string") settings.url = options;
        else
            for (var prop in options)
                if (hasOwnProperty.call(options, prop)) settings[prop] = options[prop]; if (!settings.crossDomain && !settings.headers["X-Requested-With"]) settings.headers["X-Requested-With"] =
            "XMLHttpRequest";
        settings.hasContent = settings.body !== undefined;
        return new AnonymousObservable(function(observer) {
            var isDone = false;
            try {
                var xhr = settings.crossDomain ? getCORSRequest() : getXMLHttpRequest()
            } catch (err) {
                observer.onError(err)
            }
            try {
                if (settings.user) xhr.open(settings.method, settings.url, settings.async, settings.user, settings.password);
                else xhr.open(settings.method, settings.url, settings.async);
                var headers = settings.headers;
                for (var header in headers)
                    if (hasOwnProperty.call(headers, header)) xhr.setRequestHeader(header,
                        headers[header]);
                if (!!xhr.upload || !("withCredentials" in xhr) && !!root.XDomainRequest) {
                    xhr.onload = function(e) {
                        if (settings.progressObserver) {
                            settings.progressObserver.onNext(e);
                            settings.progressObserver.onCompleted()
                        }
                        observer.onNext(normalizeAjaxLoadEvent(e, xhr, settings));
                        observer.onCompleted();
                        isDone = true
                    };
                    if (settings.progressObserver) xhr.onprogress = function(e) {
                        settings.progressObserver.onNext(e)
                    };
                    xhr.onerror = function(e) {
                        settings.progressObserver && settings.progressObserver.onError(e);
                        observer.onError(normalizeAjaxErrorEvent(e,
                            xhr, "error"));
                        isDone = true
                    };
                    xhr.onabort = function(e) {
                        settings.progressObserver && settings.progressObserver.onError(e);
                        observer.onError(normalizeAjaxErrorEvent(e, xhr, "abort"));
                        isDone = true
                    }
                } else xhr.onreadystatechange = function(e) {
                    if (xhr.readyState === 4) {
                        var status = xhr.status == 1223 ? 204 : xhr.status;
                        if (status >= 200 && status <= 300 || status === 0 || status === "") {
                            observer.onNext(normalizeAjaxLoadEvent(e, xhr, settings));
                            observer.onCompleted()
                        } else observer.onError(normalizeAjaxErrorEvent(e, xhr, "error"));
                        isDone = true
                    }
                };
                xhr.send(settings.hasContent &&
                    settings.body || null)
            } catch (e) {
                observer.onError(e)
            }
            return function() {
                if (!isDone && xhr.readyState !== 4) xhr.abort()
            }
        })
    };
    dom.post = function(url, body) {
        return ajaxRequest({
            url: url,
            body: body,
            method: "POST"
        })
    };
    var observableGet = dom.get = function(url) {
        return ajaxRequest({
            url: url
        })
    };
    dom.getJSON = function(url) {
        if (!root.JSON && typeof root.JSON.parse !== "function") throw new TypeError("JSON is not supported in your runtime.");
        return ajaxRequest({
            url: url,
            responseType: "json"
        }).map(function(x) {
            return x.response
        })
    };
    var destroy =
        function() {
            var trash = document.createElement("div");
            return function(element) {
                trash.appendChild(element);
                trash.innerHTML = ""
            }
        }();
    dom.jsonpRequest = function() {
        var id = 0;
        return function(options) {
            return new AnonymousObservable(function(observer) {
                var callbackId = "callback_" + (id++).toString(36);
                var settings = {
                    jsonp: "JSONPCallback",
                    async: true,
                    jsonpCallback: "rxjsjsonpCallbacks" + callbackId
                };
                if (typeof options === "string") settings.url = options;
                else
                    for (var prop in options)
                        if (hasOwnProperty.call(options, prop)) settings[prop] =
                            options[prop]; var script = document.createElement("script");
                script.type = "text/javascript";
                script.async = settings.async;
                script.src = settings.url.replace(settings.jsonp, settings.jsonpCallback);
                root[settings.jsonpCallback] = function(data) {
                    root[settings.jsonpCallback].called = true;
                    root[settings.jsonpCallback].data = data
                };
                var handler = function(e) {
                    if (e.type === "load" && !root[settings.jsonpCallback].called) e = {
                        type: "error"
                    };
                    var status = e.type === "error" ? 400 : 200;
                    var data = root[settings.jsonpCallback].data;
                    if (status ===
                        200) {
                        observer.onNext({
                            status: status,
                            responseType: "jsonp",
                            response: data,
                            originalEvent: e
                        });
                        observer.onCompleted()
                    } else observer.onError({
                        type: "error",
                        status: status,
                        originalEvent: e
                    })
                };
                script.onload = script.onreadystatechanged = script.onerror = handler;
                var head = document.getElementsByTagName("head")[0] || document.documentElement;
                head.insertBefore(script, head.firstChild);
                return function() {
                    script.onload = script.onreadystatechanged = script.onerror = null;
                    destroy(script);
                    script = null
                }
            })
        }
    }();
    dom.fromWebSocket = function(url,
        protocol, openObserver, closingObserver) {
        if (!WebSocket) throw new TypeError("WebSocket not implemented in your runtime.");
        var socket;
        var socketClose = function(code, reason) {
            if (socket) {
                if (closingObserver) {
                    closingObserver.onNext();
                    closingObserver.onCompleted()
                }
                if (!code) socket.close();
                else socket.close(code, reason)
            }
        };
        var observable = new AnonymousObservable(function(obs) {
            socket = protocol ? new WebSocket(url, protocol) : new WebSocket(url);
            var openHandler = function(e) {
                openObserver.onNext(e);
                openObserver.onCompleted();
                socket.removeEventListener("open", openHandler, false)
            };
            var messageHandler = function(e) {
                obs.onNext(e)
            };
            var errHandler = function(e) {
                obs.onError(e)
            };
            var closeHandler = function(e) {
                if (e.code !== 1E3 || !e.wasClean) return obs.onError(e);
                obs.onCompleted()
            };
            openObserver && socket.addEventListener("open", openHandler, false);
            socket.addEventListener("message", messageHandler, false);
            socket.addEventListener("error", errHandler, false);
            socket.addEventListener("close", closeHandler, false);
            return function() {
                socketClose();
                socket.removeEventListener("message",
                    messageHandler, false);
                socket.removeEventListener("error", errHandler, false);
                socket.removeEventListener("close", closeHandler, false)
            }
        });
        var observer = observerCreate(function(data) {
            socket.readyState === WebSocket.OPEN && socket.send(data)
        }, function(e) {
            if (!e.code) throw new Error('no code specified. be sure to pass { code: ###, reason: "" } to onError()');
            socketClose(e.code, e.reason || "")
        }, function() {
            socketClose(1E3, "")
        });
        return Subject.create(observer, observable)
    };
    dom.fromWebWorker = function(url) {
        if (!root.Worker) throw new TypeError("Worker not implemented in your runtime.");
        var worker = new root.Worker(url);
        var observable = new AnonymousObservable(function(obs) {
            function messageHandler(data) {
                obs.onNext(data)
            }

            function errHandler(err) {
                obs.onError(err)
            }
            worker.addEventListener("message", messageHandler, false);
            worker.addEventListener("error", errHandler, false);
            return function() {
                worker.close();
                worker.removeEventListener("message", messageHandler, false);
                worker.removeEventListener("error", errHandler, false)
            }
        });
        var observer = observerCreate(function(data) {
            worker.postMessage(data)
        });
        return Subject.create(observer,
            observable)
    };
    dom.fromEventSource = function(url, openObserver) {
        if (!root.EventSource) throw new TypeError("EventSource not implemented in your runtime.");
        return new AnonymousObservable(function(observer) {
            var source = new root.EventSource(url);

            function onOpen(e) {
                openObserver.onNext(e);
                openObserver.onCompleted();
                source.removeEventListener("open", onOpen, false)
            }

            function onError(e) {
                if (e.readyState === EventSource.CLOSED) observer.onCompleted();
                else observer.onError(e)
            }

            function onMessage(e) {
                observer.onNext(e)
            }
            openObserver &&
                source.addEventListener("open", onOpen, false);
            source.addEventListener("error", onError, false);
            source.addEventListener("message", onMessage, false);
            return function() {
                source.removeEventListener("error", onError, false);
                source.removeEventListener("message", onMessage, false);
                source.close()
            }
        })
    };
    dom.fromMutationObserver = function(target, options) {
        var BrowserMutationObserver = root.MutationObserver || root.WebKitMutationObserver;
        if (!BrowserMutationObserver) throw new TypeError("MutationObserver not implemented in your runtime.");
        return observableCreate(function(observer) {
            var mutationObserver = new BrowserMutationObserver(observer.onNext.bind(observer));
            mutationObserver.observe(target, options);
            return mutationObserver.disconnect.bind(mutationObserver)
        })
    };
    var requestAnimFrame, cancelAnimFrame;
    if (root.requestAnimationFrame) {
        requestAnimFrame = root.requestAnimationFrame;
        cancelAnimFrame = root.cancelAnimationFrame
    } else if (root.mozRequestAnimationFrame) {
        requestAnimFrame = root.mozRequestAnimationFrame;
        cancelAnimFrame = root.mozCancelAnimationFrame
    } else if (root.webkitRequestAnimationFrame) {
        requestAnimFrame =
            root.webkitRequestAnimationFrame;
        cancelAnimFrame = root.webkitCancelAnimationFrame
    } else if (root.msRequestAnimationFrame) {
        requestAnimFrame = root.msRequestAnimationFrame;
        cancelAnimFrame = root.msCancelAnimationFrame
    } else if (root.oRequestAnimationFrame) {
        requestAnimFrame = root.oRequestAnimationFrame;
        cancelAnimFrame = root.oCancelAnimationFrame
    } else {
        requestAnimFrame = function(cb) {
            root.setTimeout(cb, 1E3 / 60)
        };
        cancelAnimFrame = root.clearTimeout
    }
    Scheduler.requestAnimationFrame = function() {
        function scheduleNow(state,
            action) {
            var scheduler = this,
                disposable = new SingleAssignmentDisposable;
            var id = requestAnimFrame(function() {
                !disposable.isDisposed && disposable.setDisposable(action(scheduler, state))
            });
            return new CompositeDisposable(disposable, disposableCreate(function() {
                cancelAnimFrame(id)
            }))
        }

        function scheduleRelative(state, dueTime, action) {
            var scheduler = this,
                dt = Scheduler.normalize(dueTime);
            if (dt === 0) return scheduler.scheduleWithState(state, action);
            var disposable = new SingleAssignmentDisposable;
            var id = root.setTimeout(function() {
                if (!disposable.isDisposed) disposable.setDisposable(action(scheduler,
                    state))
            }, dt);
            return new CompositeDisposable(disposable, disposableCreate(function() {
                root.clearTimeout(id)
            }))
        }

        function scheduleAbsolute(state, dueTime, action) {
            return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action)
        }
        return new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute)
    }();
    Scheduler.microtask = function() {
        var nextHandle = 1,
            tasksByHandle = {},
            currentlyRunning = false,
            scheduleMethod;

        function clearMethod(handle) {
            delete tasksByHandle[handle]
        }

        function runTask(handle) {
            if (currentlyRunning) root.setTimeout(function() {
                    runTask(handle)
                },
                0);
            else {
                var task = tasksByHandle[handle];
                if (task) {
                    currentlyRunning = true;
                    try {
                        task()
                    } catch (e) {
                        throw e;
                    } finally {
                        clearMethod(handle);
                        currentlyRunning = false
                    }
                }
            }
        }

        function postMessageSupported() {
            if (!root.postMessage || root.importScripts) return false;
            var isAsync = false,
                oldHandler = root.onmessage;
            root.onmessage = function() {
                isAsync = true
            };
            root.postMessage("", "*");
            root.onmessage = oldHandler;
            return isAsync
        }
        var BrowserMutationObserver = root.MutationObserver || root.WebKitMutationObserver;
        if (!!BrowserMutationObserver) {
            var PREFIX =
                "drainqueue_";
            var observer = new BrowserMutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    runTask(mutation.attributeName.substring(PREFIX.length))
                })
            });
            var element = document.createElement("div");
            observer.observe(element, {
                attributes: true
            });
            root.addEventListener("unload", function() {
                observer.disconnect();
                observer = null
            }, false);
            scheduleMethod = function(action) {
                var id = nextHandle++;
                tasksByHandle[id] = action;
                element.setAttribute(PREFIX + id, "drainQueue");
                return id
            }
        } else if (typeof root.setImmediate ===
            "function") scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            root.setImmediate(function() {
                runTask(id)
            });
            return id
        };
        else if (postMessageSupported()) {
            var MSG_PREFIX = "ms.rx.schedule" + Math.random();

            function onGlobalPostMessage(event) {
                if (typeof event.data === "string" && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) runTask(event.data.substring(MSG_PREFIX.length))
            }
            if (root.addEventListener) root.addEventListener("message", onGlobalPostMessage, false);
            else if (root.attachEvent) root.attachEvent("onmessage",
                onGlobalPostMessage);
            scheduleMethod = function(action) {
                var id = nextHandle++;
                tasksByHandle[currentId] = action;
                root.postMessage(MSG_PREFIX + currentId, "*");
                return id
            }
        } else if (!!root.MessageChannel) {
            var channel = new root.MessageChannel;
            channel.port1.onmessage = function(event) {
                runTask(event.data)
            };
            scheduleMethod = function(action) {
                var id = nextHandle++;
                tasksByHandle[id] = action;
                channel.port2.postMessage(id);
                return id
            }
        } else if ("document" in root && "onreadystatechange" in root.document.createElement("script")) scheduleMethod =
            function(action) {
                var scriptElement = root.document.createElement("script");
                var id = nextHandle++;
                tasksByHandle[id] = action;
                scriptElement.onreadystatechange = function() {
                    runTask(id);
                    scriptElement.onreadystatechange = null;
                    scriptElement.parentNode.removeChild(scriptElement);
                    scriptElement = null
                };
                root.document.documentElement.appendChild(scriptElement);
                return id
            };
        else scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            root.setTimeout(function() {
                runTask(id)
            }, 0);
            return id
        };

        function scheduleNow(state,
            action) {
            var scheduler = this,
                disposable = new SingleAssignmentDisposable;
            var id = scheduleMethod(function() {
                !disposable.isDisposed && disposable.setDisposable(action(scheduler, state))
            });
            return new CompositeDisposable(disposable, disposableCreate(function() {
                clearMethod(id)
            }))
        }

        function scheduleRelative(state, dueTime, action) {
            var scheduler = this,
                dt = Scheduler.normalize(dueTime);
            if (dt === 0) return scheduler.scheduleWithState(state, action);
            var disposable = new SingleAssignmentDisposable;
            var id = root.setTimeout(function() {
                if (!disposable.isDisposed) disposable.setDisposable(action(scheduler,
                    state))
            }, dt);
            return new CompositeDisposable(disposable, disposableCreate(function() {
                root.clearTimeout(id)
            }))
        }

        function scheduleAbsolute(state, dueTime, action) {
            return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action)
        }
        return new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute)
    }();
    Rx.DOM.geolocation = {
        getCurrentPosition: function(geolocationOptions) {
            if (!root.navigator && !root.navigation.geolocation) throw new TypeError("geolocation not available");
            return new AnonymousObservable(function(observer) {
                root.navigator.geolocation.getCurrentPosition(function(data) {
                    observer.onNext(data);
                    observer.onCompleted()
                }, observer.onError.bind(observer), geolocationOptions)
            })
        },
        watchPosition: function(geolocationOptions) {
            if (!root.navigator && !root.navigation.geolocation) throw new TypeError("geolocation not available");
            return (new AnonymousObservable(function(observer) {
                var watchId = root.navigator.geolocation.watchPosition(observer.onNext.bind(observer), observer.onError.bind(observer), geolocationOptions);
                return function() {
                    root.navigator.geolocation.clearWatch(watchId)
                }
            })).publish().refCount()
        }
    };
    dom.fromReader =
        function(file, progressObserver) {
            if (!root.FileReader) throw new TypeError("FileReader not implemented in your runtime.");

            function _fromReader(readerFn, file, encoding) {
                return new AnonymousObservable(function(observer) {
                    var reader = new root.FileReader;
                    var subject = new AsyncSubject;

                    function loadHandler(e) {
                        progressObserver && progressObserver.onCompleted();
                        subject.onNext(e.target.result);
                        subject.onCompleted()
                    }

                    function errorHandler(e) {
                        subject.onError(e.target.error)
                    }

                    function progressHandler(e) {
                        progressObserver.onNext(e)
                    }
                    reader.addEventListener("load", loadHandler, false);
                    reader.addEventListener("error", errorHandler, false);
                    progressObserver && reader.addEventListener("progress", progressHandler, false);
                    reader[readerFn](file, encoding);
                    return new CompositeDisposable(subject.subscribe(observer), disposableCreate(function() {
                        reader.readyState == root.FileReader.LOADING && reader.abort();
                        reader.removeEventListener("load", loadHandler, false);
                        reader.removeEventListener("error", errorHandler, false);
                        progressObserver && reader.removeEventListener("progress",
                            progressHandler, false)
                    }))
                })
            }
            return {
                asArrayBuffer: function() {
                    return _fromReader("readAsArrayBuffer", file)
                },
                asBinaryString: function() {
                    return _fromReader("readAsBinaryString", file)
                },
                asDataURL: function() {
                    return _fromReader("readAsDataURL", file)
                },
                asText: function(encoding) {
                    return _fromReader("readAsText", file, encoding)
                }
            }
        };
    return Rx
});
(function(f) {
    if (typeof exports === "object" && typeof module !== "undefined") module.exports = f();
    else if (typeof define === "function" && define.amd) define([], f);
    else {
        var g;
        if (typeof window !== "undefined") g = window;
        else if (typeof global !== "undefined") g = global;
        else if (typeof self !== "undefined") g = self;
        else g = this;
        g.getShortId = f()
    }
})(function() {
    var define, module, exports;
    return function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    var f = new Error("Cannot find module '" + o + "'");
                    throw f.code = "MODULE_NOT_FOUND", f;
                }
                var l = n[o] = {
                    exports: {}
                };
                t[o][0].call(l.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e)
                }, l, l.exports, e, t, n, r)
            }
            return n[o].exports
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s
    }({
        1: [function(require, module, exports) {
            var randomFromSeed = require("./random/random-from-seed");
            var ORIGINAL = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
            var alphabet;
            var previousSeed;
            var shuffled;

            function reset() {
                shuffled = false
            }

            function setCharacters(_alphabet_) {
                if (!_alphabet_) {
                    if (alphabet !== ORIGINAL) {
                        alphabet = ORIGINAL;
                        reset()
                    }
                    return
                }
                if (_alphabet_ === alphabet) return;
                if (_alphabet_.length !== ORIGINAL.length) throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. You submitted " + _alphabet_.length + " characters: " + _alphabet_);
                var unique = _alphabet_.split("").filter(function(item, ind, arr) {
                    return ind !== arr.lastIndexOf(item)
                });
                if (unique.length) throw new Error("Custom alphabet for shortid must be " +
                    ORIGINAL.length + " unique characters. These characters were not unique: " + unique.join(", "));
                alphabet = _alphabet_;
                reset()
            }

            function characters(_alphabet_) {
                setCharacters(_alphabet_);
                return alphabet
            }

            function setSeed(seed) {
                randomFromSeed.seed(seed);
                if (previousSeed !== seed) {
                    reset();
                    previousSeed = seed
                }
            }

            function shuffle() {
                if (!alphabet) setCharacters(ORIGINAL);
                var sourceArray = alphabet.split("");
                var targetArray = [];
                var r = randomFromSeed.nextValue();
                var characterIndex;
                while (sourceArray.length > 0) {
                    r = randomFromSeed.nextValue();
                    characterIndex = Math.floor(r * sourceArray.length);
                    targetArray.push(sourceArray.splice(characterIndex, 1)[0])
                }
                return targetArray.join("")
            }

            function getShuffled() {
                if (shuffled) return shuffled;
                shuffled = shuffle();
                return shuffled
            }

            function lookup(index) {
                var alphabetShuffled = getShuffled();
                return alphabetShuffled[index]
            }
            module.exports = {
                characters: characters,
                seed: setSeed,
                lookup: lookup,
                shuffled: getShuffled
            }
        }, {
            "./random/random-from-seed": 7
        }],
        2: [function(require, module, exports) {
            var alphabet = require("./alphabet");

            function decode(id) {
                var characters = alphabet.shuffled();
                return {
                    version: characters.indexOf(id.substr(0, 1)) & 15,
                    worker: characters.indexOf(id.substr(1, 1)) & 15
                }
            }
            module.exports = decode
        }, {
            "./alphabet": 1
        }],
        3: [function(require, module, exports) {
            var randomByte = require("./random/random-byte");

            function encode(lookup, number) {
                var loopCounter = 0;
                var done;
                var str = "";
                while (!done) {
                    str = str + lookup(number >> 4 * loopCounter & 15 | randomByte());
                    done = number < Math.pow(16, loopCounter + 1);
                    loopCounter++
                }
                return str
            }
            module.exports = encode
        }, {
            "./random/random-byte": 6
        }],
        4: [function(require, module, exports) {
            var alphabet = require("./alphabet");
            var encode = require("./encode");
            var decode = require("./decode");
            var isValid = require("./is-valid");
            var REDUCE_TIME = 1426452414093;
            var version = 5;
            var clusterWorkerId = require("./util/cluster-worker-id") || 0;
            var counter;
            var previousSeconds;

            function generate() {
                var str = "";
                var seconds = Math.floor((Date.now() - REDUCE_TIME) * .001);
                if (seconds === previousSeconds) counter++;
                else {
                    counter = 0;
                    previousSeconds = seconds
                }
                str = str +
                    encode(alphabet.lookup, version);
                str = str + encode(alphabet.lookup, clusterWorkerId);
                if (counter > 0) str = str + encode(alphabet.lookup, counter);
                str = str + encode(alphabet.lookup, seconds);
                return str
            }

            function seed(seedValue) {
                alphabet.seed(seedValue);
                return module.exports
            }

            function worker(workerId) {
                clusterWorkerId = workerId;
                return module.exports
            }

            function characters(newCharacters) {
                if (newCharacters !== undefined) alphabet.characters(newCharacters);
                return alphabet.shuffled()
            }
            module.exports = generate;
            module.exports.generate =
                generate;
            module.exports.seed = seed;
            module.exports.worker = worker;
            module.exports.characters = characters;
            module.exports.decode = decode;
            module.exports.isValid = isValid
        }, {
            "./alphabet": 1,
            "./decode": 2,
            "./encode": 3,
            "./is-valid": 5,
            "./util/cluster-worker-id": 8
        }],
        5: [function(require, module, exports) {
            var alphabet = require("./alphabet");

            function isShortId(id) {
                if (!id || typeof id !== "string" || id.length < 6) return false;
                var characters = alphabet.characters();
                var invalidCharacters = id.split("").map(function(_char) {
                    if (characters.indexOf(_char) ===
                        -1) return _char
                }).join("").split("").join("");
                return invalidCharacters.length === 0
            }
            module.exports = isShortId
        }, {
            "./alphabet": 1
        }],
        6: [function(require, module, exports) {
            var crypto = window.crypto || window.msCrypto;

            function randomByte() {
                if (!crypto || !crypto.getRandomValues) return Math.floor(Math.random() * 256) & 48;
                var dest = new Uint8Array(1);
                crypto.getRandomValues(dest);
                return dest[0] & 48
            }
            module.exports = randomByte
        }, {}],
        7: [function(require, module, exports) {
            var seed = 1;

            function getNextValue() {
                seed = (seed * 9301 + 49297) %
                    233280;
                return seed / 233280
            }

            function setSeed(_seed_) {
                seed = _seed_
            }
            module.exports = {
                nextValue: getNextValue,
                seed: setSeed
            }
        }, {}],
        8: [function(require, module, exports) {
            module.exports = 0
        }, {}]
    }, {}, [4])(4)
});
(function(root, undefined) {
    var lib = {};
    lib.version = "0.4.1";
    lib.settings = {
        currency: {
            symbol: "$",
            format: "%s%v",
            decimal: ".",
            thousand: ",",
            precision: 2,
            grouping: 3
        },
        number: {
            precision: 0,
            grouping: 3,
            thousand: ",",
            decimal: "."
        }
    };
    var nativeMap = Array.prototype.map,
        nativeIsArray = Array.isArray,
        toString = Object.prototype.toString;

    function isString(obj) {
        return !!(obj === "" || obj && obj.charCodeAt && obj.substr)
    }

    function isArray(obj) {
        return nativeIsArray ? nativeIsArray(obj) : toString.call(obj) === "[object Array]"
    }

    function isObject(obj) {
        return obj &&
            toString.call(obj) === "[object Object]"
    }

    function defaults(object, defs) {
        var key;
        object = object || {};
        defs = defs || {};
        for (key in defs)
            if (defs.hasOwnProperty(key))
                if (object[key] == null) object[key] = defs[key];
        return object
    }

    function map(obj, iterator, context) {
        var results = [],
            i, j;
        if (!obj) return results;
        if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
        for (i = 0, j = obj.length; i < j; i++) results[i] = iterator.call(context, obj[i], i, obj);
        return results
    }

    function checkPrecision(val, base) {
        val = Math.round(Math.abs(val));
        return isNaN(val) ? base : val
    }

    function checkCurrencyFormat(format) {
        var defaults = lib.settings.currency.format;
        if (typeof format === "function") format = format();
        if (isString(format) && format.match("%v")) return {
            pos: format,
            neg: format.replace("-", "").replace("%v", "-%v"),
            zero: format
        };
        else if (!format || !format.pos || !format.pos.match("%v")) return !isString(defaults) ? defaults : lib.settings.currency.format = {
            pos: defaults,
            neg: defaults.replace("%v", "-%v"),
            zero: defaults
        };
        return format
    }
    var unformat = lib.unformat = lib.parse = function(value,
        decimal) {
        if (isArray(value)) return map(value, function(val) {
            return unformat(val, decimal)
        });
        value = value || 0;
        if (typeof value === "number") return value;
        decimal = decimal || lib.settings.number.decimal;
        var regex = new RegExp("[^0-9-" + decimal + "]", ["g"]),
            unformatted = parseFloat(("" + value).replace(/\((.*)\)/, "-$1").replace(regex, "").replace(decimal, "."));
        return !isNaN(unformatted) ? unformatted : 0
    };
    var toFixed = lib.toFixed = function(value, precision) {
        precision = checkPrecision(precision, lib.settings.number.precision);
        var power =
            Math.pow(10, precision);
        return (Math.round(lib.unformat(value) * power) / power).toFixed(precision)
    };
    var formatNumber = lib.formatNumber = lib.format = function(number, precision, thousand, decimal) {
        if (isArray(number)) return map(number, function(val) {
            return formatNumber(val, precision, thousand, decimal)
        });
        number = unformat(number);
        var opts = defaults(isObject(precision) ? precision : {
                precision: precision,
                thousand: thousand,
                decimal: decimal
            }, lib.settings.number),
            usePrecision = checkPrecision(opts.precision),
            negative = number < 0 ? "-" :
            "",
            base = parseInt(toFixed(Math.abs(number || 0), usePrecision), 10) + "",
            mod = base.length > 3 ? base.length % 3 : 0;
        return negative + (mod ? base.substr(0, mod) + opts.thousand : "") + base.substr(mod).replace(/(\d{3})(?=\d)/g, "$1" + opts.thousand) + (usePrecision ? opts.decimal + toFixed(Math.abs(number), usePrecision).split(".")[1] : "")
    };
    var formatMoney = lib.formatMoney = function(number, symbol, precision, thousand, decimal, format) {
        if (isArray(number)) return map(number, function(val) {
            return formatMoney(val, symbol, precision, thousand, decimal,
                format)
        });
        number = unformat(number);
        var opts = defaults(isObject(symbol) ? symbol : {
                symbol: symbol,
                precision: precision,
                thousand: thousand,
                decimal: decimal,
                format: format
            }, lib.settings.currency),
            formats = checkCurrencyFormat(opts.format),
            useFormat = number > 0 ? formats.pos : number < 0 ? formats.neg : formats.zero;
        return useFormat.replace("%s", opts.symbol).replace("%v", formatNumber(Math.abs(number), checkPrecision(opts.precision), opts.thousand, opts.decimal))
    };
    lib.formatColumn = function(list, symbol, precision, thousand, decimal,
        format) {
        if (!list) return [];
        var opts = defaults(isObject(symbol) ? symbol : {
                symbol: symbol,
                precision: precision,
                thousand: thousand,
                decimal: decimal,
                format: format
            }, lib.settings.currency),
            formats = checkCurrencyFormat(opts.format),
            padAfterSymbol = formats.pos.indexOf("%s") < formats.pos.indexOf("%v") ? true : false,
            maxLength = 0,
            formatted = map(list, function(val, i) {
                if (isArray(val)) return lib.formatColumn(val, opts);
                else {
                    val = unformat(val);
                    var useFormat = val > 0 ? formats.pos : val < 0 ? formats.neg : formats.zero,
                        fVal = useFormat.replace("%s",
                            opts.symbol).replace("%v", formatNumber(Math.abs(val), checkPrecision(opts.precision), opts.thousand, opts.decimal));
                    if (fVal.length > maxLength) maxLength = fVal.length;
                    return fVal
                }
            });
        return map(formatted, function(val, i) {
            if (isString(val) && val.length < maxLength) return padAfterSymbol ? val.replace(opts.symbol, opts.symbol + (new Array(maxLength - val.length + 1)).join(" ")) : (new Array(maxLength - val.length + 1)).join(" ") + val;
            return val
        })
    };
    if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) exports =
            module.exports = lib;
        exports.accounting = lib
    } else if (typeof define === "function" && define.amd) define([], function() {
        return lib
    });
    else {
        lib.noConflict = function(oldAccounting) {
            return function() {
                root.accounting = oldAccounting;
                lib.noConflict = undefined;
                return lib
            }
        }(root.accounting);
        root["accounting"] = lib
    }
})(this);
clazz = {};
clazz.define = function(moduleName, deps, callback) {
    var module;
    var args = [];
    args.push(deps);
    var result = callback ? callback.apply(null, args) : undefined
};
clazz.simpleExtend = function(d, s) {
    for (var prop in s) d[prop] = s[prop];
    return d
};
clazz.makeArray = function(arr) {
    var ret = [];
    var keys = Object.keys(arr);
    for (i = 0, len = keys.length; i < len; i++) {
        var key = keys[i];
        ret[i] = arr[key]
    }
    return ret
};
clazz.underscore = function(s) {
    var strColons = /\=\=/;
    var strWords = /([A-Z]+)([A-Z][a-z])/g;
    strLowUp = /([a-z\d])([A-Z])/g;
    strDash = /([a-z\d])([A-Z])/g;
    strQuote = /"/g;
    strSingleQuote = /'/g;
    return s.replace(strColons, "/").replace(strWords, "$1_$2").replace(strLowUp, "$1_$2").replace(strDash, "_").toLowerCase()
};
clazz.getNext = function(obj, prop, add) {
    var result = obj[prop];
    if (result === undefined && add === true) result = obj[prop] = {};
    return result
};
clazz.isContainer = function(current) {
    return /^f|^o/.test(typeof current)
};
clazz.getGlobal = function() {
    try {
        global = window
    } catch (e) {}
    return global
};
clazz.getObject = function(name, roots, add) {
    var parts = name ? name.split(".") : [],
        length = parts.length,
        current, r = 0,
        i, container, rootsLength;
    roots = [roots || clazz.getGlobal()];
    rootsLength = roots.length;
    if (!length) return roots[0];
    for (r; r < rootsLength; r++) {
        current = roots[r];
        container = undefined;
        for (i = 0; i < length && clazz.isContainer(current); i++) {
            container = current;
            current = clazz.getNext(container, parts[i])
        }
        if (container !== undefined && current !== undefined) break
    }
    if (add === false && current !== undefined) delete container[parts[i -
        1]];
    if (add === true && current === undefined) {
        current = roots[0];
        for (i = 0; i < length && clazz.isContainer(current); i++) current = clazz.getNext(current, parts[i], true)
    }
    return current
};
clazz.define("clazz/construct/construct", clazz, function(clazz) {
    var initializing = 0;
    var canGetDescriptor;
    try {
        Object.getOwnPropertyDescriptor({});
        canGetDescriptor = true
    } catch (e) {
        canGetDescriptor = false
    }
    var getDescriptor = function(newProps, name) {
        var descriptor = Object.getOwnPropertyDescriptor(newProps, name);
        if (descriptor && (descriptor.get || descriptor.set)) return descriptor;
        return null
    };
    var inheritGetterSetter = function(newProps, oldProps, addTo) {
        addTo = addTo || newProps;
        var descriptor;
        for (var name in newProps)
            if (descriptor =
                getDescriptor(newProps, name)) this._defineProperty(addTo, oldProps, name, descriptor);
            else clazz.construct._overwrite(addTo, oldProps, name, newProps[name])
    };
    var simpleInherit = function(newProps, oldProps, addTo) {
        addTo = addTo || newProps;
        for (var name in newProps) clazz.construct._overwrite(addTo, oldProps, name, newProps[name])
    };
    clazz.construct = function() {
        if (arguments.length) return clazz.construct.extend.apply(clazz.construct, arguments)
    };
    clazz.simpleExtend(clazz.construct, {
        constructorExtends: true,
        newInstance: function() {
            var inst =
                this.instance(),
                args;
            if (inst.setup) args = inst.setup.apply(inst, arguments);
            if (inst.init) inst.init.apply(inst, args || arguments);
            return inst
        },
        _inherit: canGetDescriptor ? inheritGetterSetter : simpleInherit,
        _defineProperty: function(what, oldProps, propName, descriptor) {
            Object.defineProperty(what, propName, descriptor)
        },
        _overwrite: function(what, oldProps, propName, val) {
            what[propName] = val
        },
        setup: function(base, fullName) {
            this.defaults = clazz.simpleExtend(true, {}, base.defaults, this.defaults)
        },
        instance: function() {
            initializing =
                1;
            var inst = new this;
            initializing = 0;
            return inst
        },
        extend: function(name, staticProperties, instanceProperties) {
            clazz.extend = this;
            var fullName = name,
                klass = staticProperties,
                proto = instanceProperties;
            if (typeof fullName !== "string") {
                proto = klass;
                klass = fullName;
                fullName = null
            }
            if (!proto) {
                proto = klass;
                klass = null
            }
            proto = proto || {};
            var _super_class = this,
                _super = this.prototype,
                Constructor, parts, current, _fullName, _shortName, propName, shortName, namespace, prototype;
            prototype = this.instance();
            clazz.construct._inherit(proto, _super,
                prototype);
            if (fullName) {
                parts = fullName.split(".");
                shortName = parts.pop()
            }
            if (typeof constructorName === "undefined") Constructor = function() {
                return init.apply(this, arguments)
            };

            function init() {
                if (!initializing) return this.constructor !== Constructor && arguments.length && Constructor.constructorExtends ? Constructor.extend.apply(Constructor, arguments) : Constructor.newInstance.apply(Constructor, arguments)
            }
            for (propName in _super_class)
                if (_super_class.hasOwnProperty(propName)) Constructor[propName] = _super_class[propName];
            clazz.construct._inherit(klass, _super_class, Constructor);
            if (fullName) {
                current = clazz.getObject(parts.join("."), clazz.getGlobal(), true);
                namespace = current;
                _fullName = clazz.underscore(fullName.replace(/\./g, "_"));
                _shortName = clazz.underscore(shortName);
                current[shortName] = Constructor
            }
            clazz.simpleExtend(Constructor, {
                constructor: Constructor,
                prototype: prototype,
                namespace: namespace,
                _shortName: _shortName,
                fullName: fullName,
                _fullName: _fullName
            });
            if (shortName !== undefined) Constructor.shortName = shortName;
            Constructor.prototype.constructor =
                Constructor;
            var t = [_super_class].concat(clazz.makeArray(arguments)),
                args = Constructor.setup.apply(Constructor, t);
            if (Constructor.init) Constructor.init.apply(Constructor, args || t);
            return Constructor
        }
    });
    clazz.construct.prototype.setup = function() {};
    clazz.construct.prototype.init = function() {};
    return clazz.construct
});
(function(root, factory) {
    if (typeof define === "function" && define.amd) define(factory);
    else if (typeof exports === "object") module.exports = factory(require, exports, module);
    else root.SVG = factory()
})(this, function(require, exports, module) {
    var SVG = this.SVG = function(element) {
        if (SVG.supported) {
            element = new SVG.Doc(element);
            if (!SVG.parser) SVG.prepare(element);
            return element
        }
    };
    SVG.ns = "http://www.w3.org/2000/svg";
    SVG.xmlns = "http://www.w3.org/2000/xmlns/";
    SVG.xlink = "http://www.w3.org/1999/xlink";
    SVG.supported = function() {
        return !!document.createElementNS &&
            !!document.createElementNS(SVG.ns, "svg").createSVGRect
    }();
    if (!SVG.supported) return false;
    SVG.did = 1E3;
    SVG.eid = function(name) {
        return "Svgjs" + capitalize(name) + SVG.did++
    };
    SVG.create = function(name) {
        var element = document.createElementNS(this.ns, name);
        element.setAttribute("id", this.eid(name));
        return element
    };
    SVG.extend = function() {
        var modules, methods, key, i;
        modules = [].slice.call(arguments);
        methods = modules.pop();
        for (i = modules.length - 1; i >= 0; i--)
            if (modules[i])
                for (key in methods) modules[i].prototype[key] = methods[key];
        if (SVG.Set && SVG.Set.inherit) SVG.Set.inherit()
    };
    SVG.invent = function(config) {
        var initializer = typeof config.create == "function" ? config.create : function() {
            this.constructor.call(this, SVG.create(config.create))
        };
        if (config.inherit) initializer.prototype = new config.inherit;
        if (config.extend) SVG.extend(initializer, config.extend);
        if (config.construct) SVG.extend(config.parent || SVG.Container, config.construct);
        return initializer
    };
    SVG.adopt = function(node) {
        if (node.instance) return node.instance;
        var element;
        if (node.nodeName ==
            "svg") element = node.parentNode instanceof SVGElement ? new SVG.Nested : new SVG.Doc;
        else if (node.nodeName == "lineairGradient") element = new SVG.Gradient("lineair");
        else if (node.nodeName == "radialGradient") element = new SVG.Gradient("radial");
        else if (SVG[capitalize(node.nodeName)]) element = new(SVG[capitalize(node.nodeName)]);
        else element = new SVG.Element(node);
        element.type = node.nodeName;
        element.node = node;
        node.instance = element;
        if (element instanceof SVG.Doc) element.namespace().defs();
        return element
    };
    SVG.prepare =
        function(element) {
            var body = document.getElementsByTagName("body")[0],
                draw = (body ? new SVG.Doc(body) : element.nested()).size(2, 0),
                path = SVG.create("path");
            draw.node.appendChild(path);
            SVG.parser = {
                body: body || element.parent(),
                draw: draw.style("opacity:0;position:fixed;left:100%;top:100%;overflow:hidden"),
                poly: draw.polyline().node,
                path: path
            }
        };
    SVG.regex = {
        unit: /^(-?[\d\.]+)([a-z%]{0,2})$/,
        hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
        rgb: /rgb\((\d+),(\d+),(\d+)\)/,
        reference: /#([a-z0-9\-_]+)/i,
        matrix: /matrix\(|\)/g,
        whitespace: /\s/g,
        isHex: /^#[a-f0-9]{3,6}$/i,
        isRgb: /^rgb\(/,
        isCss: /[^:]+:[^;]+;?/,
        isBlank: /^(\s+)?$/,
        isNumber: /^-?[\d\.]+$/,
        isPercent: /^-?[\d\.]+%$/,
        isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i
    };
    SVG.utils = {
        map: function(array, block) {
            var i, il = array.length,
                result = [];
            for (i = 0; i < il; i++) result.push(block(array[i]));
            return result
        },
        radians: function(d) {
            return d % 360 * Math.PI / 180
        },
        degrees: function(r) {
            return r * 180 / Math.PI % 360
        },
        filterSVGElements: function(p) {
            return [].filter.call(p, function(el) {
                return el instanceof
                SVGElement
            })
        }
    };
    SVG.defaults = {
        attrs: {
            "fill-opacity": 1,
            "stroke-opacity": 1,
            "stroke-width": 0,
            "stroke-linejoin": "miter",
            "stroke-linecap": "butt",
            fill: "#000000",
            stroke: "#000000",
            opacity: 1,
            x: 0,
            y: 0,
            cx: 0,
            cy: 0,
            width: 0,
            height: 0,
            r: 0,
            rx: 0,
            ry: 0,
            offset: 0,
            "stop-opacity": 1,
            "stop-color": "#000000",
            "font-size": 16,
            "font-family": "Helvetica, Arial, sans-serif",
            "text-anchor": "start"
        }
    };
    SVG.Color = function(color) {
        var match;
        this.r = 0;
        this.g = 0;
        this.b = 0;
        if (typeof color === "string")
            if (SVG.regex.isRgb.test(color)) {
                match = SVG.regex.rgb.exec(color.replace(/\s/g,
                    ""));
                this.r = parseInt(match[1]);
                this.g = parseInt(match[2]);
                this.b = parseInt(match[3])
            } else {
                if (SVG.regex.isHex.test(color)) {
                    match = SVG.regex.hex.exec(fullHex(color));
                    this.r = parseInt(match[1], 16);
                    this.g = parseInt(match[2], 16);
                    this.b = parseInt(match[3], 16)
                }
            } else if (typeof color === "object") {
            this.r = color.r;
            this.g = color.g;
            this.b = color.b
        }
    };
    SVG.extend(SVG.Color, {
        toString: function() {
            return this.toHex()
        },
        toHex: function() {
            return "#" + compToHex(this.r) + compToHex(this.g) + compToHex(this.b)
        },
        toRgb: function() {
            return "rgb(" + [this.r, this.g, this.b].join() + ")"
        },
        brightness: function() {
            return this.r / 255 * .3 + this.g / 255 * .59 + this.b / 255 * .11
        },
        morph: function(color) {
            this.destination = new SVG.Color(color);
            return this
        },
        at: function(pos) {
            if (!this.destination) return this;
            pos = pos < 0 ? 0 : pos > 1 ? 1 : pos;
            return new SVG.Color({
                r: ~~(this.r + (this.destination.r - this.r) * pos),
                g: ~~(this.g + (this.destination.g - this.g) * pos),
                b: ~~(this.b + (this.destination.b - this.b) * pos)
            })
        }
    });
    SVG.Color.test = function(color) {
        color += "";
        return SVG.regex.isHex.test(color) || SVG.regex.isRgb.test(color)
    };
    SVG.Color.isRgb = function(color) {
        return color && typeof color.r == "number" && typeof color.g == "number" && typeof color.b == "number"
    };
    SVG.Color.isColor = function(color) {
        return SVG.Color.isRgb(color) || SVG.Color.test(color)
    };
    SVG.Array = function(array, fallback) {
        array = (array || []).valueOf();
        if (array.length == 0 && fallback) array = fallback.valueOf();
        this.value = this.parse(array)
    };
    SVG.extend(SVG.Array, {
        morph: function(array) {
            this.destination = this.parse(array);
            if (this.value.length != this.destination.length) {
                var lastValue = this.value[this.value.length -
                        1],
                    lastDestination = this.destination[this.destination.length - 1];
                while (this.value.length > this.destination.length) this.destination.push(lastDestination);
                while (this.value.length < this.destination.length) this.value.push(lastValue)
            }
            return this
        },
        settle: function() {
            for (var i = 0, il = this.value.length, seen = []; i < il; i++)
                if (seen.indexOf(this.value[i]) == -1) seen.push(this.value[i]);
            return this.value = seen
        },
        at: function(pos) {
            if (!this.destination) return this;
            for (var i = 0, il = this.value.length, array = []; i < il; i++) array.push(this.value[i] +
                (this.destination[i] - this.value[i]) * pos);
            return new SVG.Array(array)
        },
        toString: function() {
            return this.value.join(" ")
        },
        valueOf: function() {
            return this.value
        },
        parse: function(array) {
            array = array.valueOf();
            if (Array.isArray(array)) return array;
            return this.split(array)
        },
        split: function(string) {
            return string.trim().split(/\s+/)
        },
        reverse: function() {
            this.value.reverse();
            return this
        }
    });
    SVG.PointArray = function(array, fallback) {
        this.constructor.call(this, array, fallback || [
            [0, 0]
        ])
    };
    SVG.PointArray.prototype = new SVG.Array;
    SVG.extend(SVG.PointArray, {
        toString: function() {
            for (var i = 0, il = this.value.length, array = []; i < il; i++) array.push(this.value[i].join(","));
            return array.join(" ")
        },
        toLine: function() {
            return {
                x1: this.value[0][0],
                y1: this.value[0][1],
                x2: this.value[1][0],
                y2: this.value[1][1]
            }
        },
        at: function(pos) {
            if (!this.destination) return this;
            for (var i = 0, il = this.value.length, array = []; i < il; i++) array.push([this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos, this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos]);
            return new SVG.PointArray(array)
        },
        parse: function(array) {
            array = array.valueOf();
            if (Array.isArray(array)) return array;
            array = this.split(array);
            for (var i = 0, il = array.length, p, points = []; i < il; i++) {
                p = array[i].split(",");
                points.push([parseFloat(p[0]), parseFloat(p[1])])
            }
            return points
        },
        move: function(x, y) {
            var box = this.bbox();
            x -= box.x;
            y -= box.y;
            if (!isNaN(x) && !isNaN(y))
                for (var i = this.value.length - 1; i >= 0; i--) this.value[i] = [this.value[i][0] + x, this.value[i][1] + y];
            return this
        },
        size: function(width, height) {
            var i, box = this.bbox();
            for (i = this.value.length - 1; i >= 0; i--) {
                this.value[i][0] = (this.value[i][0] - box.x) * width / box.width + box.x;
                this.value[i][1] = (this.value[i][1] - box.y) * height / box.height + box.y
            }
            return this
        },
        bbox: function() {
            SVG.parser.poly.setAttribute("points", this.toString());
            return SVG.parser.poly.getBBox()
        }
    });
    SVG.PathArray = function(array, fallback) {
        this.constructor.call(this, array, fallback || [
            ["M", 0, 0]
        ])
    };
    SVG.PathArray.prototype = new SVG.Array;
    SVG.extend(SVG.PathArray, {
        toString: function() {
            return arrayToString(this.value)
        },
        move: function(x,
            y) {
            var box = this.bbox();
            x -= box.x;
            y -= box.y;
            if (!isNaN(x) && !isNaN(y))
                for (var l, i = this.value.length - 1; i >= 0; i--) {
                    l = this.value[i][0];
                    if (l == "M" || l == "L" || l == "T") {
                        this.value[i][1] += x;
                        this.value[i][2] += y
                    } else if (l == "H") this.value[i][1] += x;
                    else if (l == "V") this.value[i][1] += y;
                    else if (l == "C" || l == "S" || l == "Q") {
                        this.value[i][1] += x;
                        this.value[i][2] += y;
                        this.value[i][3] += x;
                        this.value[i][4] += y;
                        if (l == "C") {
                            this.value[i][5] += x;
                            this.value[i][6] += y
                        }
                    } else if (l == "A") {
                        this.value[i][6] += x;
                        this.value[i][7] += y
                    }
                }
            return this
        },
        size: function(width,
            height) {
            var i, l, box = this.bbox();
            for (i = this.value.length - 1; i >= 0; i--) {
                l = this.value[i][0];
                if (l == "M" || l == "L" || l == "T") {
                    this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;
                    this.value[i][2] = (this.value[i][2] - box.y) * height / box.height + box.y
                } else if (l == "H") this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;
                else if (l == "V") this.value[i][1] = (this.value[i][1] - box.y) * height / box.height + box.y;
                else if (l == "C" || l == "S" || l == "Q") {
                    this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;
                    this.value[i][2] =
                        (this.value[i][2] - box.y) * height / box.height + box.y;
                    this.value[i][3] = (this.value[i][3] - box.x) * width / box.width + box.x;
                    this.value[i][4] = (this.value[i][4] - box.y) * height / box.height + box.y;
                    if (l == "C") {
                        this.value[i][5] = (this.value[i][5] - box.x) * width / box.width + box.x;
                        this.value[i][6] = (this.value[i][6] - box.y) * height / box.height + box.y
                    }
                } else if (l == "A") {
                    this.value[i][1] = this.value[i][1] * width / box.width;
                    this.value[i][2] = this.value[i][2] * height / box.height;
                    this.value[i][6] = (this.value[i][6] - box.x) * width / box.width + box.x;
                    this.value[i][7] = (this.value[i][7] - box.y) * height / box.height + box.y
                }
            }
            return this
        },
        parse: function(array) {
            if (array instanceof SVG.PathArray) return array.valueOf();
            var i, il, x0, y0, x1, y1, x2, y2, s, seg, segs, x = 0,
                y = 0;
            SVG.parser.path.setAttribute("d", typeof array === "string" ? array : arrayToString(array));
            segs = SVG.parser.path.pathSegList;
            for (i = 0, il = segs.numberOfItems; i < il; ++i) {
                seg = segs.getItem(i);
                s = seg.pathSegTypeAsLetter;
                if (s == "M" || s == "L" || s == "H" || s == "V" || s == "C" || s == "S" || s == "Q" || s == "T" || s == "A") {
                    if ("x" in seg) x = seg.x;
                    if ("y" in seg) y = seg.y
                } else {
                    if ("x1" in seg) x1 = x + seg.x1;
                    if ("x2" in seg) x2 = x + seg.x2;
                    if ("y1" in seg) y1 = y + seg.y1;
                    if ("y2" in seg) y2 = y + seg.y2;
                    if ("x" in seg) x += seg.x;
                    if ("y" in seg) y += seg.y;
                    if (s == "m") segs.replaceItem(SVG.parser.path.createSVGPathSegMovetoAbs(x, y), i);
                    else if (s == "l") segs.replaceItem(SVG.parser.path.createSVGPathSegLinetoAbs(x, y), i);
                    else if (s == "h") segs.replaceItem(SVG.parser.path.createSVGPathSegLinetoHorizontalAbs(x), i);
                    else if (s == "v") segs.replaceItem(SVG.parser.path.createSVGPathSegLinetoVerticalAbs(y),
                        i);
                    else if (s == "c") segs.replaceItem(SVG.parser.path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);
                    else if (s == "s") segs.replaceItem(SVG.parser.path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);
                    else if (s == "q") segs.replaceItem(SVG.parser.path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);
                    else if (s == "t") segs.replaceItem(SVG.parser.path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);
                    else if (s == "a") segs.replaceItem(SVG.parser.path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag,
                        seg.sweepFlag), i);
                    else if (s == "z" || s == "Z") {
                        x = x0;
                        y = y0
                    }
                }
                if (s == "M" || s == "m") {
                    x0 = x;
                    y0 = y
                }
            }
            array = [];
            segs = SVG.parser.path.pathSegList;
            for (i = 0, il = segs.numberOfItems; i < il; ++i) {
                seg = segs.getItem(i);
                s = seg.pathSegTypeAsLetter;
                x = [s];
                if (s == "M" || s == "L" || s == "T") x.push(seg.x, seg.y);
                else if (s == "H") x.push(seg.x);
                else if (s == "V") x.push(seg.y);
                else if (s == "C") x.push(seg.x1, seg.y1, seg.x2, seg.y2, seg.x, seg.y);
                else if (s == "S") x.push(seg.x2, seg.y2, seg.x, seg.y);
                else if (s == "Q") x.push(seg.x1, seg.y1, seg.x, seg.y);
                else if (s == "A") x.push(seg.r1,
                    seg.r2, seg.angle, seg.largeArcFlag | 0, seg.sweepFlag | 0, seg.x, seg.y);
                array.push(x)
            }
            return array
        },
        bbox: function() {
            SVG.parser.path.setAttribute("d", this.toString());
            return SVG.parser.path.getBBox()
        }
    });
    SVG.Number = SVG.invent({
        create: function(value, unit) {
            this.value = 0;
            this.unit = unit || "";
            if (typeof value === "number") this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -3.4E38 : +3.4E38 : value;
            else if (typeof value === "string") {
                unit = value.match(SVG.regex.unit);
                if (unit) {
                    this.value = parseFloat(unit[1]);
                    if (unit[2] == "%") this.value /=
                        100;
                    else if (unit[2] == "s") this.value *= 1E3;
                    this.unit = unit[2]
                }
            } else if (value instanceof SVG.Number) {
                this.value = value.valueOf();
                this.unit = value.unit
            }
        },
        extend: {
            toString: function() {
                return (this.unit == "%" ? ~~(this.value * 1E8) / 1E6 : this.unit == "s" ? this.value / 1E3 : this.value) + this.unit
            },
            valueOf: function() {
                return this.value
            },
            plus: function(number) {
                return new SVG.Number(this + new SVG.Number(number), this.unit)
            },
            minus: function(number) {
                return this.plus(-new SVG.Number(number))
            },
            times: function(number) {
                return new SVG.Number(this *
                    new SVG.Number(number), this.unit)
            },
            divide: function(number) {
                return new SVG.Number(this / new SVG.Number(number), this.unit)
            },
            to: function(unit) {
                var number = new SVG.Number(this);
                if (typeof unit === "string") number.unit = unit;
                return number
            },
            morph: function(number) {
                this.destination = new SVG.Number(number);
                return this
            },
            at: function(pos) {
                if (!this.destination) return this;
                return (new SVG.Number(this.destination)).minus(this).times(pos).plus(this)
            }
        }
    });
    SVG.ViewBox = function(element) {
        var x, y, width, height, wm = 1,
            hm = 1,
            box = element.bbox(),
            view = (element.attr("viewBox") || "").match(/-?[\d\.]+/g),
            we = element,
            he = element;
        width = new SVG.Number(element.width());
        height = new SVG.Number(element.height());
        while (width.unit == "%") {
            wm *= width.value;
            width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width());
            we = we.parent()
        }
        while (height.unit == "%") {
            hm *= height.value;
            height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height());
            he = he.parent()
        }
        this.x = box.x;
        this.y = box.y;
        this.width = width * wm;
        this.height =
            height * hm;
        this.zoom = 1;
        if (view) {
            x = parseFloat(view[0]);
            y = parseFloat(view[1]);
            width = parseFloat(view[2]);
            height = parseFloat(view[3]);
            this.zoom = this.width / this.height > width / height ? this.height / height : this.width / width;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height
        }
    };
    SVG.extend(SVG.ViewBox, {
        toString: function() {
            return this.x + " " + this.y + " " + this.width + " " + this.height
        }
    });
    SVG.Element = SVG.invent({
        create: function(node) {
            this._stroke = SVG.defaults.attrs.stroke;
            if (this.node = node) {
                this.type = node.nodeName;
                this.node.instance =
                    this;
                this._stroke = node.getAttribute("stroke") || this._stroke
            }
        },
        extend: {
            x: function(x) {
                return this.attr("x", x)
            },
            y: function(y) {
                return this.attr("y", y)
            },
            cx: function(x) {
                return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2)
            },
            cy: function(y) {
                return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2)
            },
            move: function(x, y) {
                return this.x(x).y(y)
            },
            center: function(x, y) {
                return this.cx(x).cy(y)
            },
            width: function(width) {
                return this.attr("width", width)
            },
            height: function(height) {
                return this.attr("height",
                    height)
            },
            size: function(width, height) {
                var p = proportionalSize(this.bbox(), width, height);
                return this.width(new SVG.Number(p.width)).height(new SVG.Number(p.height))
            },
            clone: function() {
                var clone = assignNewId(this.node.cloneNode(true));
                this.after(clone);
                return clone
            },
            remove: function() {
                if (this.parent()) this.parent().removeElement(this);
                return this
            },
            replace: function(element) {
                this.after(element).remove();
                return element
            },
            addTo: function(parent) {
                return parent.put(this)
            },
            putIn: function(parent) {
                return parent.add(this)
            },
            id: function(id) {
                return this.attr("id", id)
            },
            inside: function(x, y) {
                var box = this.bbox();
                return x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height
            },
            show: function() {
                return this.style("display", "")
            },
            hide: function() {
                return this.style("display", "none")
            },
            visible: function() {
                return this.style("display") != "none"
            },
            toString: function() {
                return this.attr("id")
            },
            classes: function() {
                var attr = this.attr("class");
                return attr == null ? [] : attr.trim().split(/\s+/)
            },
            hasClass: function(name) {
                return this.classes().indexOf(name) !=
                    -1
            },
            addClass: function(name) {
                if (!this.hasClass(name)) {
                    var array = this.classes();
                    array.push(name);
                    this.attr("class", array.join(" "))
                }
                return this
            },
            removeClass: function(name) {
                if (this.hasClass(name)) this.attr("class", this.classes().filter(function(c) {
                    return c != name
                }).join(" "));
                return this
            },
            toggleClass: function(name) {
                return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)
            },
            reference: function(attr) {
                return SVG.get(this.attr(attr))
            },
            parent: function(type) {
                if (this.node.parentNode) {
                    var parent = SVG.adopt(this.node.parentNode);
                    if (type)
                        while (!(parent instanceof type) && parent.node.parentNode instanceof SVGElement) parent = SVG.adopt(parent.node.parentNode);
                    return parent
                }
            },
            doc: function(type) {
                return this instanceof SVG.Doc ? this : this.parent(SVG.Doc)
            },
            "native": function() {
                return this.node
            },
            svg: function(svg) {
                var well = document.createElement("svg");
                if (svg && this instanceof SVG.Parent) {
                    well.innerHTML = "<svg>" + svg.replace(/\n/, "").replace(/<(\w+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
                    for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++) this.node.appendChild(well.firstChild.firstChild)
                } else {
                    well.appendChild(svg =
                        document.createElement("svg"));
                    svg.appendChild(this.node.cloneNode(true));
                    return well.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "")
                }
                return this
            }
        }
    });
    SVG.FX = SVG.invent({
        create: function(element) {
            this.target = element
        },
        extend: {
            animate: function(d, ease, delay) {
                var akeys, skeys, key, element = this.target,
                    fx = this;
                if (typeof d == "object") {
                    delay = d.delay;
                    ease = d.ease;
                    d = d.duration
                }
                d = d == "=" ? d : d == null ? 1E3 : (new SVG.Number(d)).valueOf();
                ease = ease || "<>";
                fx.at = function(pos) {
                    var i;
                    pos = pos < 0 ? 0 : pos > 1 ? 1 : pos;
                    if (akeys == null) {
                        akeys = [];
                        for (key in fx.attrs) akeys.push(key);
                        if (element.morphArray && (fx.destination.plot || akeys.indexOf("points") > -1)) {
                            var box, p = new element.morphArray(fx.destination.plot || fx.attrs.points || element.array());
                            if (fx.destination.size) p.size(fx.destination.size.width.to, fx.destination.size.height.to);
                            box = p.bbox();
                            if (fx.destination.x) p.move(fx.destination.x.to, box.y);
                            else if (fx.destination.cx) p.move(fx.destination.cx.to - box.width / 2, box.y);
                            box = p.bbox();
                            if (fx.destination.y) p.move(box.x, fx.destination.y.to);
                            else if (fx.destination.cy) p.move(box.x,
                                fx.destination.cy.to - box.height / 2);
                            fx.destination = {
                                plot: element.array().morph(p)
                            }
                        }
                    }
                    if (skeys == null) {
                        skeys = [];
                        for (key in fx.styles) skeys.push(key)
                    }
                    pos = ease == "<>" ? -Math.cos(pos * Math.PI) / 2 + .5 : ease == ">" ? Math.sin(pos * Math.PI / 2) : ease == "<" ? -Math.cos(pos * Math.PI / 2) + 1 : ease == "-" ? pos : typeof ease == "function" ? ease(pos) : pos;
                    if (fx.destination.plot) element.plot(fx.destination.plot.at(pos));
                    else {
                        if (fx.destination.x) element.x(fx.destination.x.at(pos));
                        else if (fx.destination.cx) element.cx(fx.destination.cx.at(pos));
                        if (fx.destination.y) element.y(fx.destination.y.at(pos));
                        else if (fx.destination.cy) element.cy(fx.destination.cy.at(pos));
                        if (fx.destination.size) element.size(fx.destination.size.width.at(pos), fx.destination.size.height.at(pos))
                    }
                    if (fx.destination.viewbox) element.viewbox(fx.destination.viewbox.x.at(pos), fx.destination.viewbox.y.at(pos), fx.destination.viewbox.width.at(pos), fx.destination.viewbox.height.at(pos));
                    if (fx.destination.leading) element.leading(fx.destination.leading.at(pos));
                    for (i = akeys.length -
                        1; i >= 0; i--) element.attr(akeys[i], at(fx.attrs[akeys[i]], pos));
                    for (i = skeys.length - 1; i >= 0; i--) element.style(skeys[i], at(fx.styles[skeys[i]], pos));
                    if (fx.situation.during) fx.situation.during.call(element, pos, function(from, to) {
                        return at({
                            from: from,
                            to: to
                        }, pos)
                    })
                };
                if (typeof d === "number") this.timeout = setTimeout(function() {
                    var start = (new Date).getTime();
                    fx.situation.start = start;
                    fx.situation.play = true;
                    fx.situation.finish = start + d;
                    fx.situation.duration = d;
                    fx.situation.ease = ease;
                    fx.render = function() {
                        if (fx.situation.play ===
                            true) {
                            var time = (new Date).getTime(),
                                pos = time > fx.situation.finish ? 1 : (time - fx.situation.start) / d;
                            if (fx.situation.reversing) pos = -pos + 1;
                            fx.at(pos);
                            if (time > fx.situation.finish) {
                                if (fx.destination.plot) element.plot((new SVG.PointArray(fx.destination.plot.destination)).settle());
                                if (fx.situation.loop === true || typeof fx.situation.loop == "number" && fx.situation.loop > 0) {
                                    if (fx.situation.reverse) fx.situation.reversing = !fx.situation.reversing;
                                    if (typeof fx.situation.loop == "number") {
                                        if (!fx.situation.reverse || fx.situation.reversing) --fx.situation.loop;
                                        if (!fx.situation.reverse && fx.situation.loop == 1) --fx.situation.loop
                                    }
                                    fx.animate(d, ease, delay)
                                } else fx.situation.after ? fx.situation.after.apply(element, [fx]) : fx.stop()
                            } else fx.animationFrame = requestAnimationFrame(fx.render)
                        } else fx.animationFrame = requestAnimationFrame(fx.render)
                    };
                    fx.render()
                }, (new SVG.Number(delay)).valueOf());
                return this
            },
            bbox: function() {
                return this.target.bbox()
            },
            attr: function(a, v) {
                if (typeof a == "object")
                    for (var key in a) this.attr(key, a[key]);
                else {
                    var from = this.target.attr(a);
                    if (a ==
                        "transform") {
                        if (this.attrs[a]) v = this.attrs[a].destination.multiply(v);
                        this.attrs[a] = this.target.ctm().morph(v);
                        if (this.param) {
                            v = this.target.transform("rotation");
                            this.attrs[a].param = {
                                from: this.target.param || {
                                    rotation: v,
                                    cx: this.param.cx,
                                    cy: this.param.cy
                                },
                                to: this.param
                            }
                        }
                    } else this.attrs[a] = SVG.Color.isColor(v) ? (new SVG.Color(from)).morph(v) : SVG.regex.unit.test(v) ? (new SVG.Number(from)).morph(v) : {
                        from: from,
                        to: v
                    }
                }
                return this
            },
            style: function(s, v) {
                if (typeof s == "object")
                    for (var key in s) this.style(key, s[key]);
                else this.styles[s] = {
                    from: this.target.style(s),
                    to: v
                };
                return this
            },
            x: function(x) {
                this.destination.x = (new SVG.Number(this.target.x())).morph(x);
                return this
            },
            y: function(y) {
                this.destination.y = (new SVG.Number(this.target.y())).morph(y);
                return this
            },
            cx: function(x) {
                this.destination.cx = (new SVG.Number(this.target.cx())).morph(x);
                return this
            },
            cy: function(y) {
                this.destination.cy = (new SVG.Number(this.target.cy())).morph(y);
                return this
            },
            move: function(x, y) {
                return this.x(x).y(y)
            },
            center: function(x, y) {
                return this.cx(x).cy(y)
            },
            size: function(width, height) {
                if (this.target instanceof SVG.Text) this.attr("font-size", width);
                else {
                    var box = this.target.bbox();
                    this.destination.size = {
                        width: (new SVG.Number(box.width)).morph(width),
                        height: (new SVG.Number(box.height)).morph(height)
                    }
                }
                return this
            },
            plot: function(p) {
                this.destination.plot = p;
                return this
            },
            leading: function(value) {
                if (this.target.destination.leading) this.destination.leading = (new SVG.Number(this.target.destination.leading)).morph(value);
                return this
            },
            viewbox: function(x, y, width, height) {
                if (this.target instanceof SVG.Container) {
                    var box = this.target.viewbox();
                    this.destination.viewbox = {
                        x: (new SVG.Number(box.x)).morph(x),
                        y: (new SVG.Number(box.y)).morph(y),
                        width: (new SVG.Number(box.width)).morph(width),
                        height: (new SVG.Number(box.height)).morph(height)
                    }
                }
                return this
            },
            update: function(o) {
                if (this.target instanceof SVG.Stop) {
                    if (o.opacity != null) this.attr("stop-opacity", o.opacity);
                    if (o.color != null) this.attr("stop-color", o.color);
                    if (o.offset != null) this.attr("offset", new SVG.Number(o.offset))
                }
                return this
            },
            during: function(during) {
                this.situation.during =
                    during;
                return this
            },
            after: function(after) {
                this.situation.after = after;
                return this
            },
            loop: function(times, reverse) {
                this.situation.loop = this.situation.loops = times || true;
                this.situation.reverse = !!reverse;
                return this
            },
            stop: function(fulfill) {
                if (fulfill === true) {
                    this.animate(0);
                    if (this.situation.after) this.situation.after.apply(this.target, [this])
                } else {
                    clearTimeout(this.timeout);
                    cancelAnimationFrame(this.animationFrame);
                    this.attrs = {};
                    this.styles = {};
                    this.situation = {};
                    this.destination = {}
                }
                return this
            },
            pause: function() {
                if (this.situation.play ===
                    true) {
                    this.situation.play = false;
                    this.situation.pause = (new Date).getTime()
                }
                return this
            },
            play: function() {
                if (this.situation.play === false) {
                    var pause = (new Date).getTime() - this.situation.pause;
                    this.situation.finish += pause;
                    this.situation.start += pause;
                    this.situation.play = true
                }
                return this
            }
        },
        parent: SVG.Element,
        construct: {
            animate: function(d, ease, delay) {
                return (this.fx || (this.fx = new SVG.FX(this))).stop().animate(d, ease, delay)
            },
            stop: function(fulfill) {
                if (this.fx) this.fx.stop(fulfill);
                return this
            },
            pause: function() {
                if (this.fx) this.fx.pause();
                return this
            },
            play: function() {
                if (this.fx) this.fx.play();
                return this
            }
        }
    });
    SVG.BBox = SVG.invent({
        create: function(element) {
            if (element) {
                var box;
                try {
                    box = element.node.getBBox()
                } catch (e) {
                    box = {
                        x: element.node.clientLeft,
                        y: element.node.clientTop,
                        width: element.node.clientWidth,
                        height: element.node.clientHeight
                    }
                }
                this.x = box.x;
                this.y = box.y;
                this.width = box.width;
                this.height = box.height
            }
            fullBox(this)
        },
        parent: SVG.Element,
        construct: {
            bbox: function() {
                return new SVG.BBox(this)
            }
        }
    });
    SVG.TBox = SVG.invent({
        create: function(element) {
            if (element) {
                var t =
                    element.ctm().extract(),
                    box = element.bbox();
                this.width = box.width * t.scaleX;
                this.height = box.height * t.scaleY;
                this.x = box.x + t.x;
                this.y = box.y + t.y
            }
            fullBox(this)
        },
        parent: SVG.Element,
        construct: {
            tbox: function() {
                return new SVG.TBox(this)
            }
        }
    });
    SVG.RBox = SVG.invent({
        create: function(element) {
            if (element) {
                var e = element.doc().parent(),
                    box = element.node.getBoundingClientRect(),
                    zoom = 1;
                this.x = box.left;
                this.y = box.top;
                this.x -= e.offsetLeft;
                this.y -= e.offsetTop;
                while (e = e.offsetParent) {
                    this.x -= e.offsetLeft;
                    this.y -= e.offsetTop
                }
                e =
                    element;
                while (e.parent && (e = e.parent()))
                    if (e.viewbox) {
                        zoom *= e.viewbox().zoom;
                        this.x -= e.x() || 0;
                        this.y -= e.y() || 0
                    }
                this.width = box.width /= zoom;
                this.height = box.height /= zoom
            }
            fullBox(this);
            this.x += window.scrollX;
            this.y += window.scrollY
        },
        parent: SVG.Element,
        construct: {
            rbox: function() {
                return new SVG.RBox(this)
            }
        }
    });
    [SVG.BBox, SVG.TBox, SVG.RBox].forEach(function(c) {
        SVG.extend(c, {
            merge: function(box) {
                var b = new c;
                b.x = Math.min(this.x, box.x);
                b.y = Math.min(this.y, box.y);
                b.width = Math.max(this.x + this.width, box.x + box.width) -
                    b.x;
                b.height = Math.max(this.y + this.height, box.y + box.height) - b.y;
                return fullBox(b)
            }
        })
    });
    SVG.Matrix = SVG.invent({
        create: function(source) {
            var i, base = arrayToMatrix([1, 0, 0, 1, 0, 0]);
            source = source instanceof SVG.Element ? source.matrixify() : typeof source === "string" ? stringToMatrix(source) : arguments.length == 6 ? arrayToMatrix([].slice.call(arguments)) : typeof source === "object" ? source : base;
            for (i = abcdef.length - 1; i >= 0; i--) this[abcdef[i]] = source && typeof source[abcdef[i]] === "number" ? source[abcdef[i]] : base[abcdef[i]]
        },
        extend: {
            extract: function() {
                var px =
                    deltaTransformPoint(this, 0, 1),
                    py = deltaTransformPoint(this, 1, 0),
                    skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90;
                return {
                    x: this.e,
                    y: this.f,
                    skewX: -skewX,
                    skewY: 180 / Math.PI * Math.atan2(py.y, py.x),
                    scaleX: Math.sqrt(this.a * this.a + this.b * this.b),
                    scaleY: Math.sqrt(this.c * this.c + this.d * this.d),
                    rotation: skewX
                }
            },
            clone: function() {
                return new SVG.Matrix(this)
            },
            morph: function(matrix) {
                this.destination = new SVG.Matrix(matrix);
                return this
            },
            at: function(pos) {
                if (!this.destination) return this;
                var matrix = new SVG.Matrix({
                    a: this.a +
                        (this.destination.a - this.a) * pos,
                    b: this.b + (this.destination.b - this.b) * pos,
                    c: this.c + (this.destination.c - this.c) * pos,
                    d: this.d + (this.destination.d - this.d) * pos,
                    e: this.e + (this.destination.e - this.e) * pos,
                    f: this.f + (this.destination.f - this.f) * pos
                });
                if (this.param && this.param.to) {
                    var param = {
                        rotation: this.param.from.rotation + (this.param.to.rotation - this.param.from.rotation) * pos,
                        cx: this.param.from.cx,
                        cy: this.param.from.cy
                    };
                    matrix = matrix.rotate((this.param.to.rotation - this.param.from.rotation * 2) * pos, param.cx, param.cy);
                    matrix.param = param
                }
                return matrix
            },
            multiply: function(matrix) {
                return new SVG.Matrix(this["native"]().multiply(parseMatrix(matrix)["native"]()))
            },
            inverse: function() {
                return new SVG.Matrix(this["native"]().inverse())
            },
            translate: function(x, y) {
                return new SVG.Matrix(this["native"]().translate(x || 0, y || 0))
            },
            scale: function(x, y, cx, cy) {
                if (arguments.length == 1 || arguments.length == 3) y = x;
                if (arguments.length == 3) {
                    cy = cx;
                    cx = y
                }
                return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0))
            },
            rotate: function(r, cx, cy) {
                r = SVG.utils.radians(r);
                return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0))
            },
            flip: function(a, o) {
                return a == "x" ? this.scale(-1, 1, o, 0) : this.scale(1, -1, 0, o)
            },
            skew: function(x, y, cx, cy) {
                return this.around(cx, cy, this["native"]().skewX(x || 0).skewY(y || 0))
            },
            around: function(cx, cy, matrix) {
                return this.multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0)).multiply(matrix).multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0))
            },
            "native": function() {
                var matrix = SVG.parser.draw.node.createSVGMatrix();
                for (var i = abcdef.length -
                        1; i >= 0; i--) matrix[abcdef[i]] = this[abcdef[i]];
                return matrix
            },
            toString: function() {
                return "matrix(" + this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.e + "," + this.f + ")"
            }
        },
        parent: SVG.Element,
        construct: {
            ctm: function() {
                return new SVG.Matrix(this.node.getCTM())
            }
        }
    });
    SVG.extend(SVG.Element, {
        attr: function(a, v, n) {
            if (a == null) {
                a = {};
                v = this.node.attributes;
                for (n = v.length - 1; n >= 0; n--) a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue;
                return a
            } else if (typeof a == "object")
                for (v in a) this.attr(v,
                    a[v]);
            else if (v === null) this.node.removeAttribute(a);
            else if (v == null) {
                v = this.node.getAttribute(a);
                return v == null ? SVG.defaults.attrs[a] : SVG.regex.isNumber.test(v) ? parseFloat(v) : v
            } else {
                if (a == "stroke-width") this.attr("stroke", parseFloat(v) > 0 ? this._stroke : null);
                else if (a == "stroke") this._stroke = v;
                if (a == "fill" || a == "stroke") {
                    if (SVG.regex.isImage.test(v)) v = this.doc().defs().image(v, 0, 0);
                    if (v instanceof SVG.Image) v = this.doc().defs().pattern(0, 0, function() {
                        this.add(v)
                    })
                }
                if (typeof v === "number") v = new SVG.Number(v);
                else if (SVG.Color.isColor(v)) v = new SVG.Color(v);
                else if (Array.isArray(v)) v = new SVG.Array(v);
                else if (v instanceof SVG.Matrix && v.param) this.param = v.param;
                if (a == "leading") {
                    if (this.leading) this.leading(v)
                } else typeof n === "string" ? this.node.setAttributeNS(n, a, v.toString()) : this.node.setAttribute(a, v.toString());
                if (this.rebuild && (a == "font-size" || a == "x")) this.rebuild(a, v)
            }
            return this
        }
    });
    SVG.extend(SVG.Element, SVG.FX, {
        transform: function(o, relative) {
            var target = this.target || this,
                matrix;
            if (typeof o !== "object") {
                matrix =
                    (new SVG.Matrix(target)).extract();
                if (typeof this.param === "object") {
                    matrix.rotation = this.param.rotation;
                    matrix.cx = this.param.cx;
                    matrix.cy = this.param.cy
                }
                return typeof o === "string" ? matrix[o] : matrix
            }
            matrix = this instanceof SVG.FX && this.attrs.transform ? this.attrs.transform : new SVG.Matrix(target);
            relative = !!relative || !!o.relative;
            if (o.a != null) matrix = relative ? matrix.multiply(new SVG.Matrix(o)) : new SVG.Matrix(o);
            else if (o.rotation != null) {
                ensureCentre(o, target);
                if (relative) o.rotation += this.param && this.param.rotation !=
                    null ? this.param.rotation : matrix.extract().rotation;
                this.param = o;
                if (this instanceof SVG.Element) matrix = relative ? matrix.rotate(o.rotation, o.cx, o.cy) : matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy)
            } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {
                ensureCentre(o, target);
                o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1;
                o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1;
                if (!relative) {
                    var e = matrix.extract();
                    o.scaleX = o.scaleX * 1 / e.scaleX;
                    o.scaleY = o.scaleY * 1 / e.scaleY
                }
                matrix =
                    matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy)
            } else if (o.skewX != null || o.skewY != null) {
                ensureCentre(o, target);
                o.skewX = o.skewX != null ? o.skewX : 0;
                o.skewY = o.skewY != null ? o.skewY : 0;
                if (!relative) {
                    var e = matrix.extract();
                    matrix = matrix.multiply((new SVG.Matrix).skew(e.skewX, e.skewY, o.cx, o.cy).inverse())
                }
                matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy)
            } else if (o.flip) matrix = matrix.flip(o.flip, o.offset == null ? target.bbox()["c" + o.flip] : o.offset);
            else if (o.x != null || o.y != null)
                if (relative) matrix = matrix.translate(o.x, o.y);
                else {
                    if (o.x !=
                        null) matrix.e = o.x;
                    if (o.y != null) matrix.f = o.y
                }
            return this.attr("transform", matrix)
        }
    });
    SVG.extend(SVG.Element, {
        untransform: function() {
            return this.attr("transform", null)
        },
        matrixify: function() {
            var matrix = (this.attr("transform") || "").split(/\)\s*/).slice(0, -1).map(function(str) {
                var kv = str.trim().split("(");
                return [kv[0], kv[1].split(",").map(function(str) {
                    return parseFloat(str)
                })]
            }).reduce(function(matrix, transform) {
                if (transform[0] == "matrix") return matrix.multiply(arrayToMatrix(transform[1]));
                return matrix[transform[0]].apply(matrix,
                    transform[1])
            }, new SVG.Matrix);
            this.attr("transform", matrix);
            return matrix
        }
    });
    SVG.extend(SVG.Element, {
        style: function(s, v) {
            if (arguments.length == 0) return this.node.style.cssText || "";
            else if (arguments.length < 2)
                if (typeof s == "object")
                    for (v in s) this.style(v, s[v]);
                else if (SVG.regex.isCss.test(s)) {
                s = s.split(";");
                for (var i = 0; i < s.length; i++) {
                    v = s[i].split(":");
                    this.style(v[0].replace(/\s+/g, ""), v[1])
                }
            } else return this.node.style[camelCase(s)];
            else this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ?
                "" : v;
            return this
        }
    });
    SVG.Parent = SVG.invent({
        create: function(element) {
            this.constructor.call(this, element)
        },
        inherit: SVG.Element,
        extend: {
            children: function() {
                return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function(node) {
                    return SVG.adopt(node)
                })
            },
            add: function(element, i) {
                if (!this.has(element)) {
                    i = i == null ? this.children().length : i;
                    this.node.insertBefore(element.node, this.node.childNodes[i] || null)
                }
                return this
            },
            put: function(element, i) {
                this.add(element, i);
                return element
            },
            has: function(element) {
                return this.index(element) >=
                    0
            },
            index: function(element) {
                return this.children().indexOf(element)
            },
            get: function(i) {
                return this.children()[i]
            },
            first: function() {
                return this.children()[0]
            },
            last: function() {
                return this.children()[this.children().length - 1]
            },
            each: function(block, deep) {
                var i, il, children = this.children();
                for (i = 0, il = children.length; i < il; i++) {
                    if (children[i] instanceof SVG.Element) block.apply(children[i], [i, children]);
                    if (deep && children[i] instanceof SVG.Container) children[i].each(block, deep)
                }
                return this
            },
            removeElement: function(element) {
                this.node.removeChild(element.node);
                return this
            },
            clear: function() {
                while (this.node.hasChildNodes()) this.node.removeChild(this.node.lastChild);
                delete this._defs;
                return this
            },
            defs: function() {
                return this.doc().defs()
            }
        }
    });
    SVG.Container = SVG.invent({
        create: function(element) {
            this.constructor.call(this, element)
        },
        inherit: SVG.Parent,
        extend: {
            viewbox: function(v) {
                if (arguments.length == 0) return new SVG.ViewBox(this);
                v = arguments.length == 1 ? [v.x, v.y, v.width, v.height] : [].slice.call(arguments);
                return this.attr("viewBox", v)
            }
        }
    });
    ["click", "dblclick", "mousedown",
        "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"
    ].forEach(function(event) {
        SVG.Element.prototype[event] = function(f) {
            var self = this;
            this.node["on" + event] = typeof f == "function" ? function() {
                return f.apply(self, arguments)
            } : null;
            return this
        }
    });
    SVG.listeners = [];
    SVG.handlerMap = [];
    SVG.on = function(node, event, listener) {
        var l = listener.bind(node.instance || node),
            index = (SVG.handlerMap.indexOf(node) + 1 || SVG.handlerMap.push(node)) - 1,
            ev = event.split(".")[0],
            ns =
            event.split(".")[1] || "*";
        SVG.listeners[index] = SVG.listeners[index] || {};
        SVG.listeners[index][ev] = SVG.listeners[index][ev] || {};
        SVG.listeners[index][ev][ns] = SVG.listeners[index][ev][ns] || {};
        SVG.listeners[index][ev][ns][listener] = l;
        node.addEventListener(ev, l, false)
    };
    SVG.off = function(node, event, listener) {
        var index = SVG.handlerMap.indexOf(node),
            ev = event && event.split(".")[0],
            ns = event && event.split(".")[1];
        if (index == -1) return;
        if (listener) {
            if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns || "*"]) {
                node.removeEventListener(ev,
                    SVG.listeners[index][ev][ns || "*"][listener], false);
                delete SVG.listeners[index][ev][ns || "*"][listener]
            }
        } else if (ns && ev) {
            if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns]) {
                for (listener in SVG.listeners[index][ev][ns]) SVG.off(node, [ev, ns].join("."), listener);
                delete SVG.listeners[index][ev][ns]
            }
        } else if (ns)
            for (event in SVG.listeners[index])
                for (namespace in SVG.listeners[index][event]) {
                    if (ns === namespace) SVG.off(node, [event, ns].join("."))
                } else if (ev) {
                    if (SVG.listeners[index][ev]) {
                        for (namespace in SVG.listeners[index][ev]) SVG.off(node, [ev, namespace].join("."));
                        delete SVG.listeners[index][ev]
                    }
                } else {
                    for (event in SVG.listeners[index]) SVG.off(node, event);
                    delete SVG.listeners[index]
                }
    };
    SVG.extend(SVG.Element, {
        on: function(event, listener) {
            SVG.on(this.node, event, listener);
            return this
        },
        off: function(event, listener) {
            SVG.off(this.node, event, listener);
            return this
        },
        fire: function(event, data) {
            if (event instanceof Event) this.node.dispatchEvent(event);
            else this.node.dispatchEvent(new CustomEvent(event, {
                detail: data
            }));
            return this
        }
    });
    SVG.Defs = SVG.invent({
        create: "defs",
        inherit: SVG.Container
    });
    SVG.G = SVG.invent({
        create: "g",
        inherit: SVG.Container,
        extend: {
            x: function(x) {
                return x == null ? this.transform("x") : this.transform({
                    x: -this.x() + x
                }, true)
            },
            y: function(y) {
                return y == null ? this.transform("y") : this.transform({
                    y: -this.y() + y
                }, true)
            },
            cx: function(x) {
                return x == null ? this.tbox().cx : this.x(x - this.tbox().width / 2)
            },
            cy: function(y) {
                return y == null ? this.tbox().cy : this.y(y - this.tbox().height / 2)
            }
        },
        construct: {
            group: function() {
                return this.put(new SVG.G)
            }
        }
    });
    SVG.extend(SVG.Element, {
        siblings: function() {
            return this.parent().children()
        },
        position: function() {
            return this.parent().index(this)
        },
        next: function() {
            return this.siblings()[this.position() + 1]
        },
        previous: function() {
            return this.siblings()[this.position() - 1]
        },
        forward: function() {
            var i = this.position() + 1,
                p = this.parent();
            p.removeElement(this).add(this, i);
            if (p instanceof SVG.Doc) p.node.appendChild(p.defs().node);
            return this
        },
        backward: function() {
            var i = this.position();
            if (i > 0) this.parent().removeElement(this).add(this, i - 1);
            return this
        },
        front: function() {
            var p = this.parent();
            p.node.appendChild(this.node);
            if (p instanceof SVG.Doc) p.node.appendChild(p.defs().node);
            return this
        },
        back: function() {
            if (this.position() > 0) this.parent().removeElement(this).add(this, 0);
            return this
        },
        before: function(element) {
            element.remove();
            var i = this.position();
            this.parent().add(element, i);
            return this
        },
        after: function(element) {
            element.remove();
            var i = this.position();
            this.parent().add(element, i + 1);
            return this
        }
    });
    SVG.Mask = SVG.invent({
        create: function() {
            this.constructor.call(this, SVG.create("mask"));
            this.targets = []
        },
        inherit: SVG.Container,
        extend: {
            remove: function() {
                for (var i = this.targets.length - 1; i >= 0; i--)
                    if (this.targets[i]) this.targets[i].unmask();
                delete this.targets;
                this.parent().removeElement(this);
                return this
            }
        },
        construct: {
            mask: function() {
                return this.defs().put(new SVG.Mask)
            }
        }
    });
    SVG.extend(SVG.Element, {
        maskWith: function(element) {
            this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element);
            this.masker.targets.push(this);
            return this.attr("mask", 'url("#' + this.masker.attr("id") + '")')
        },
        unmask: function() {
            delete this.masker;
            return this.attr("mask", null)
        }
    });
    SVG.ClipPath = SVG.invent({
        create: function() {
            this.constructor.call(this, SVG.create("clipPath"));
            this.targets = []
        },
        inherit: SVG.Container,
        extend: {
            remove: function() {
                for (var i = this.targets.length - 1; i >= 0; i--)
                    if (this.targets[i]) this.targets[i].unclip();
                delete this.targets;
                this.parent().removeElement(this);
                return this
            }
        },
        construct: {
            clip: function() {
                return this.defs().put(new SVG.ClipPath)
            }
        }
    });
    SVG.extend(SVG.Element, {
        clipWith: function(element) {
            this.clipper = element instanceof SVG.ClipPath ?
                element : this.parent().clip().add(element);
            this.clipper.targets.push(this);
            return this.attr("clip-path", 'url("#' + this.clipper.attr("id") + '")')
        },
        unclip: function() {
            delete this.clipper;
            return this.attr("clip-path", null)
        }
    });
    SVG.Gradient = SVG.invent({
        create: function(type) {
            this.constructor.call(this, SVG.create(type + "Gradient"));
            this.type = type
        },
        inherit: SVG.Container,
        extend: {
            at: function(offset, color, opacity) {
                return this.put(new SVG.Stop).update(offset, color, opacity)
            },
            update: function(block) {
                this.clear();
                if (typeof block ==
                    "function") block.call(this, this);
                return this
            },
            fill: function() {
                return "url(#" + this.id() + ")"
            },
            toString: function() {
                return this.fill()
            }
        },
        construct: {
            gradient: function(type, block) {
                return this.defs().gradient(type, block)
            }
        }
    });
    SVG.extend(SVG.Gradient, SVG.FX, {
        from: function(x, y) {
            return (this.target || this).type == "radial" ? this.attr({
                fx: new SVG.Number(x),
                fy: new SVG.Number(y)
            }) : this.attr({
                x1: new SVG.Number(x),
                y1: new SVG.Number(y)
            })
        },
        to: function(x, y) {
            return (this.target || this).type == "radial" ? this.attr({
                cx: new SVG.Number(x),
                cy: new SVG.Number(y)
            }) : this.attr({
                x2: new SVG.Number(x),
                y2: new SVG.Number(y)
            })
        }
    });
    SVG.extend(SVG.Defs, {
        gradient: function(type, block) {
            return this.put(new SVG.Gradient(type)).update(block)
        }
    });
    SVG.Stop = SVG.invent({
        create: "stop",
        inherit: SVG.Element,
        extend: {
            update: function(o) {
                if (typeof o == "number" || o instanceof SVG.Number) o = {
                    offset: arguments[0],
                    color: arguments[1],
                    opacity: arguments[2]
                };
                if (o.opacity != null) this.attr("stop-opacity", o.opacity);
                if (o.color != null) this.attr("stop-color", o.color);
                if (o.offset != null) this.attr("offset",
                    new SVG.Number(o.offset));
                return this
            }
        }
    });
    SVG.Pattern = SVG.invent({
        create: "pattern",
        inherit: SVG.Container,
        extend: {
            fill: function() {
                return "url(#" + this.id() + ")"
            },
            update: function(block) {
                this.clear();
                if (typeof block == "function") block.call(this, this);
                return this
            },
            toString: function() {
                return this.fill()
            }
        },
        construct: {
            pattern: function(width, height, block) {
                return this.defs().pattern(width, height, block)
            }
        }
    });
    SVG.extend(SVG.Defs, {
        pattern: function(width, height, block) {
            return this.put(new SVG.Pattern).update(block).attr({
                x: 0,
                y: 0,
                width: width,
                height: height,
                patternUnits: "userSpaceOnUse"
            })
        }
    });
    SVG.Doc = SVG.invent({
        create: function(element) {
            if (element) {
                element = typeof element == "string" ? document.getElementById(element) : element;
                if (element.nodeName == "svg") this.constructor.call(this, element);
                else {
                    this.constructor.call(this, SVG.create("svg"));
                    element.appendChild(this.node)
                }
                this.namespace().size("100%", "100%").defs()
            }
        },
        inherit: SVG.Container,
        extend: {
            namespace: function() {
                return this.attr({
                    xmlns: SVG.ns,
                    version: "1.1"
                }).attr("xmlns:xlink",
                    SVG.xlink, SVG.xmlns)
            },
            defs: function() {
                if (!this._defs) {
                    var defs;
                    if (defs = this.node.getElementsByTagName("defs")[0]) this._defs = SVG.adopt(defs);
                    else this._defs = new SVG.Defs;
                    this.node.appendChild(this._defs.node)
                }
                return this._defs
            },
            parent: function() {
                return this.node.parentNode.nodeName == "#document" ? null : this.node.parentNode
            },
            spof: function(spof) {
                var pos = this.node.getScreenCTM();
                if (pos) this.style("left", -pos.e % 1 + "px").style("top", -pos.f % 1 + "px");
                return this
            },
            remove: function() {
                if (this.parent()) this.parent().removeChild(this.node);
                return this
            }
        }
    });
    SVG.Shape = SVG.invent({
        create: function(element) {
            this.constructor.call(this, element)
        },
        inherit: SVG.Element
    });
    SVG.Bare = SVG.invent({
        create: function(element, inherit) {
            this.constructor.call(this, SVG.create(element));
            if (inherit)
                for (var method in inherit.prototype)
                    if (typeof inherit.prototype[method] === "function") this[method] = inherit.prototype[method]
        },
        inherit: SVG.Element,
        extend: {
            words: function(text) {
                while (this.node.hasChildNodes()) this.node.removeChild(this.node.lastChild);
                this.node.appendChild(document.createTextNode(text));
                return this
            }
        }
    });
    SVG.extend(SVG.Parent, {
        element: function(element, inherit) {
            return this.put(new SVG.Bare(element, inherit))
        },
        symbol: function() {
            return this.defs().element("symbol", SVG.Container)
        }
    });
    SVG.Use = SVG.invent({
        create: "use",
        inherit: SVG.Shape,
        extend: {
            element: function(element, file) {
                return this.attr("href", (file || "") + "#" + element, SVG.xlink)
            }
        },
        construct: {
            use: function(element, file) {
                return this.put(new SVG.Use).element(element, file)
            }
        }
    });
    SVG.Rect = SVG.invent({
        create: "rect",
        inherit: SVG.Shape,
        construct: {
            rect: function(width,
                height) {
                return this.put((new SVG.Rect).size(width, height))
            }
        }
    });
    SVG.Circle = SVG.invent({
        create: "circle",
        inherit: SVG.Shape,
        construct: {
            circle: function(size) {
                return this.put(new SVG.Circle).rx((new SVG.Number(size)).divide(2)).move(0, 0)
            }
        }
    });
    SVG.extend(SVG.Circle, SVG.FX, {
        rx: function(rx) {
            return this.attr("r", rx)
        },
        ry: function(ry) {
            return this.rx(ry)
        }
    });
    SVG.Ellipse = SVG.invent({
        create: "ellipse",
        inherit: SVG.Shape,
        construct: {
            ellipse: function(width, height) {
                return this.put(new SVG.Ellipse).size(width, height).move(0,
                    0)
            }
        }
    });
    SVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {
        rx: function(rx) {
            return this.attr("rx", rx)
        },
        ry: function(ry) {
            return this.attr("ry", ry)
        }
    });
    SVG.extend(SVG.Circle, SVG.Ellipse, {
        x: function(x) {
            return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())
        },
        y: function(y) {
            return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())
        },
        cx: function(x) {
            return x == null ? this.attr("cx") : this.attr("cx", x)
        },
        cy: function(y) {
            return y == null ? this.attr("cy") : this.attr("cy", y)
        },
        width: function(width) {
            return width == null ? this.rx() * 2 : this.rx((new SVG.Number(width)).divide(2))
        },
        height: function(height) {
            return height == null ? this.ry() * 2 : this.ry((new SVG.Number(height)).divide(2))
        },
        size: function(width, height) {
            var p = proportionalSize(this.bbox(), width, height);
            return this.rx((new SVG.Number(p.width)).divide(2)).ry((new SVG.Number(p.height)).divide(2))
        }
    });
    SVG.Line = SVG.invent({
        create: "line",
        inherit: SVG.Shape,
        extend: {
            array: function() {
                return new SVG.PointArray([
                    [this.attr("x1"), this.attr("y1")],
                    [this.attr("x2"), this.attr("y2")]
                ])
            },
            plot: function(x1, y1, x2, y2) {
                if (arguments.length == 4) x1 = {
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2
                };
                else x1 = (new SVG.PointArray(x1)).toLine();
                return this.attr(x1)
            },
            move: function(x, y) {
                return this.attr(this.array().move(x, y).toLine())
            },
            size: function(width, height) {
                var p = proportionalSize(this.bbox(), width, height);
                return this.attr(this.array().size(p.width, p.height).toLine())
            }
        },
        construct: {
            line: function(x1, y1, x2, y2) {
                return this.put(new SVG.Line).plot(x1, y1, x2, y2)
            }
        }
    });
    SVG.Polyline = SVG.invent({
        create: "polyline",
        inherit: SVG.Shape,
        construct: {
            polyline: function(p) {
                return this.put(new SVG.Polyline).plot(p)
            }
        }
    });
    SVG.Polygon = SVG.invent({
        create: "polygon",
        inherit: SVG.Shape,
        construct: {
            polygon: function(p) {
                return this.put(new SVG.Polygon).plot(p)
            }
        }
    });
    SVG.extend(SVG.Polyline, SVG.Polygon, {
        array: function() {
            return this._array || (this._array = new SVG.PointArray(this.attr("points")))
        },
        plot: function(p) {
            return this.attr("points", this._array = new SVG.PointArray(p))
        },
        move: function(x, y) {
            return this.attr("points", this.array().move(x, y))
        },
        size: function(width, height) {
            var p = proportionalSize(this.bbox(), width, height);
            return this.attr("points",
                this.array().size(p.width, p.height))
        }
    });
    SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {
        morphArray: SVG.PointArray,
        x: function(x) {
            return x == null ? this.bbox().x : this.move(x, this.bbox().y)
        },
        y: function(y) {
            return y == null ? this.bbox().y : this.move(this.bbox().x, y)
        },
        width: function(width) {
            var b = this.bbox();
            return width == null ? b.width : this.size(width, b.height)
        },
        height: function(height) {
            var b = this.bbox();
            return height == null ? b.height : this.size(b.width, height)
        }
    });
    SVG.Path = SVG.invent({
        create: "path",
        inherit: SVG.Shape,
        extend: {
            morphArray: SVG.PathArray,
            array: function() {
                return this._array || (this._array = new SVG.PathArray(this.attr("d")))
            },
            plot: function(p) {
                return this.attr("d", this._array = new SVG.PathArray(p))
            },
            move: function(x, y) {
                return this.attr("d", this.array().move(x, y))
            },
            x: function(x) {
                return x == null ? this.bbox().x : this.move(x, this.bbox().y)
            },
            y: function(y) {
                return y == null ? this.bbox().y : this.move(this.bbox().x, y)
            },
            size: function(width, height) {
                var p = proportionalSize(this.bbox(), width, height);
                return this.attr("d", this.array().size(p.width,
                    p.height))
            },
            width: function(width) {
                return width == null ? this.bbox().width : this.size(width, this.bbox().height)
            },
            height: function(height) {
                return height == null ? this.bbox().height : this.size(this.bbox().width, height)
            }
        },
        construct: {
            path: function(d) {
                return this.put(new SVG.Path).plot(d)
            }
        }
    });
    SVG.Image = SVG.invent({
        create: "image",
        inherit: SVG.Shape,
        extend: {
            load: function(url) {
                if (!url) return this;
                var self = this,
                    img = document.createElement("img");
                img.onload = function() {
                    var p = self.parent(SVG.Pattern);
                    if (self.width() == 0 &&
                        self.height() == 0) self.size(img.width, img.height);
                    if (p && p.width() == 0 && p.height() == 0) p.size(self.width(), self.height());
                    if (typeof self._loaded === "function") self._loaded.call(self, {
                        width: img.width,
                        height: img.height,
                        ratio: img.width / img.height,
                        url: url
                    })
                };
                return this.attr("href", img.src = this.src = url, SVG.xlink)
            },
            loaded: function(loaded) {
                this._loaded = loaded;
                return this
            }
        },
        construct: {
            image: function(source, width, height) {
                return this.put(new SVG.Image).load(source).size(width || 0, height || width || 0)
            }
        }
    });
    SVG.Text =
        SVG.invent({
            create: function() {
                this.constructor.call(this, SVG.create("text"));
                this._leading = new SVG.Number(1.3);
                this._rebuild = true;
                this._build = false;
                this.attr("font-family", SVG.defaults.attrs["font-family"])
            },
            inherit: SVG.Shape,
            extend: {
                x: function(x) {
                    if (x == null) return this.attr("x");
                    if (!this.textPath) this.lines().each(function() {
                        if (this.newLined) this.x(x)
                    });
                    return this.attr("x", x)
                },
                y: function(y) {
                    var oy = this.attr("y"),
                        o = typeof oy === "number" ? oy - this.bbox().y : 0;
                    if (y == null) return typeof oy === "number" ? oy -
                        o : oy;
                    return this.attr("y", typeof y === "number" ? y + o : y)
                },
                cx: function(x) {
                    return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)
                },
                cy: function(y) {
                    return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)
                },
                text: function(text) {
                    if (typeof text === "undefined") return this.content;
                    this.clear().build(true);
                    if (typeof text === "function") text.call(this, this);
                    else {
                        text = (this.content = text).split("\n");
                        for (var i = 0, il = text.length; i < il; i++) this.tspan(text[i]).newLine()
                    }
                    return this.build(false).rebuild()
                },
                size: function(size) {
                    return this.attr("font-size",
                        size).rebuild()
                },
                leading: function(value) {
                    if (value == null) return this._leading;
                    this._leading = new SVG.Number(value);
                    return this.rebuild()
                },
                lines: function() {
                    var lines = SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function(el) {
                        return SVG.adopt(el)
                    });
                    return new SVG.Set(lines)
                },
                rebuild: function(rebuild) {
                    if (typeof rebuild == "boolean") this._rebuild = rebuild;
                    if (this._rebuild) {
                        var self = this;
                        this.lines().each(function() {
                            if (this.newLined) {
                                if (!this.textPath) this.attr("x", self.attr("x"));
                                this.attr("dy",
                                    self._leading * new SVG.Number(self.attr("font-size")))
                            }
                        });
                        this.fire("rebuild")
                    }
                    return this
                },
                build: function(build) {
                    this._build = !!build;
                    return this
                }
            },
            construct: {
                text: function(text) {
                    return this.put(new SVG.Text).text(text)
                },
                plain: function(text) {
                    return this.put(new SVG.Text).plain(text)
                }
            }
        });
    SVG.Tspan = SVG.invent({
        create: "tspan",
        inherit: SVG.Shape,
        extend: {
            text: function(text) {
                typeof text === "function" ? text.call(this, this) : this.plain(text);
                return this
            },
            dx: function(dx) {
                return this.attr("dx", dx)
            },
            dy: function(dy) {
                return this.attr("dy",
                    dy)
            },
            newLine: function() {
                var t = this.parent(SVG.Text);
                this.newLined = true;
                return this.dy(t._leading * t.attr("font-size")).attr("x", t.x())
            }
        }
    });
    SVG.extend(SVG.Text, SVG.Tspan, {
        plain: function(text) {
            if (this._build === false) this.clear();
            this.node.appendChild(document.createTextNode(this.content = text));
            return this
        },
        tspan: function(text) {
            var node = (this.textPath() || this).node,
                tspan = new SVG.Tspan;
            if (this._build === false) this.clear();
            node.appendChild(tspan.node);
            return tspan.text(text)
        },
        clear: function() {
            var node = (this.textPath() ||
                this).node;
            while (node.hasChildNodes()) node.removeChild(node.lastChild);
            if (this instanceof SVG.Text) this.content = "";
            return this
        },
        length: function() {
            return this.node.getComputedTextLength()
        }
    });
    SVG.TextPath = SVG.invent({
        create: "textPath",
        inherit: SVG.Element,
        parent: SVG.Text,
        construct: {
            path: function(d) {
                var path = new SVG.TextPath,
                    track = this.doc().defs().path(d);
                while (this.node.hasChildNodes()) path.node.appendChild(this.node.firstChild);
                this.node.appendChild(path.node);
                path.attr("href", "#" + track, SVG.xlink);
                return this
            },
            plot: function(d) {
                var track = this.track();
                if (track) track.plot(d);
                return this
            },
            track: function() {
                var path = this.textPath();
                if (path) return path.reference("href")
            },
            textPath: function() {
                if (this.node.firstChild && this.node.firstChild.nodeName == "textPath") return SVG.adopt(this.node.firstChild)
            }
        }
    });
    SVG.Nested = SVG.invent({
        create: function() {
            this.constructor.call(this, SVG.create("svg"));
            this.style("overflow", "visible")
        },
        inherit: SVG.Container,
        construct: {
            nested: function() {
                return this.put(new SVG.Nested)
            }
        }
    });
    SVG.A = SVG.invent({
        create: "a",
        inherit: SVG.Container,
        extend: {
            to: function(url) {
                return this.attr("href", url, SVG.xlink)
            },
            show: function(target) {
                return this.attr("show", target, SVG.xlink)
            },
            target: function(target) {
                return this.attr("target", target)
            }
        },
        construct: {
            link: function(url) {
                return this.put(new SVG.A).to(url)
            }
        }
    });
    SVG.extend(SVG.Element, {
        linkTo: function(url) {
            var link = new SVG.A;
            if (typeof url == "function") url.call(link, link);
            else link.to(url);
            return this.parent().put(link).put(this)
        }
    });
    SVG.Marker = SVG.invent({
        create: "marker",
        inherit: SVG.Container,
        extend: {
            width: function(width) {
                return this.attr("markerWidth", width)
            },
            height: function(height) {
                return this.attr("markerHeight", height)
            },
            ref: function(x, y) {
                return this.attr("refX", x).attr("refY", y)
            },
            update: function(block) {
                this.clear();
                if (typeof block == "function") block.call(this, this);
                return this
            },
            toString: function() {
                return "url(#" + this.id() + ")"
            }
        },
        construct: {
            marker: function(width, height, block) {
                return this.defs().marker(width, height, block)
            }
        }
    });
    SVG.extend(SVG.Defs, {
        marker: function(width,
            height, block) {
            return this.put(new SVG.Marker).size(width, height).ref(width / 2, height / 2).viewbox(0, 0, width, height).attr("orient", "auto").update(block)
        }
    });
    SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {
        marker: function(marker, width, height, block) {
            var attr = ["marker"];
            if (marker != "all") attr.push(marker);
            attr = attr.join("-");
            marker = arguments[1] instanceof SVG.Marker ? arguments[1] : this.doc().marker(width, height, block);
            return this.attr(attr, marker)
        }
    });
    var sugar = {
        stroke: ["color", "width", "opacity", "linecap",
            "linejoin", "miterlimit", "dasharray", "dashoffset"
        ],
        fill: ["color", "opacity", "rule"],
        prefix: function(t, a) {
            return a == "color" ? t : t + "-" + a
        }
    };
    ["fill", "stroke"].forEach(function(m) {
        var i, extension = {};
        extension[m] = function(o) {
            if (typeof o == "string" || SVG.Color.isRgb(o) || o && typeof o.fill === "function") this.attr(m, o);
            else
                for (i = sugar[m].length - 1; i >= 0; i--)
                    if (o[sugar[m][i]] != null) this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]); return this
        };
        SVG.extend(SVG.Element, SVG.FX, extension)
    });
    SVG.extend(SVG.Element, SVG.FX, {
        rotate: function(d, cx, cy) {
            return this.transform({
                rotation: d,
                cx: cx,
                cy: cy
            })
        },
        skew: function(x, y, cx, cy) {
            return this.transform({
                skewX: x,
                skewY: y,
                cx: cx,
                cy: cy
            })
        },
        scale: function(x, y, cx, cy) {
            return arguments.length == 1 || arguments.length == 3 ? this.transform({
                scale: x,
                cx: y,
                cy: cx
            }) : this.transform({
                scaleX: x,
                scaleY: y,
                cx: cx,
                cy: cy
            })
        },
        translate: function(x, y) {
            return this.transform({
                x: x,
                y: y
            })
        },
        flip: function(a, o) {
            return this.transform({
                flip: a,
                offset: o
            })
        },
        matrix: function(m) {
            return this.attr("transform", new SVG.Matrix(m))
        },
        opacity: function(value) {
            return this.attr("opacity", value)
        },
        dx: function(x) {
            return this.x((this.target || this).x() + x)
        },
        dy: function(y) {
            return this.y((this.target || this).y() + y)
        },
        dmove: function(x, y) {
            return this.dx(x).dy(y)
        }
    });
    SVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {
        radius: function(x, y) {
            return (this.target || this).type == "radial" ? this.attr({
                r: new SVG.Number(x)
            }) : this.rx(x).ry(y == null ? x : y)
        }
    });
    SVG.extend(SVG.Path, {
        length: function() {
            return this.node.getTotalLength()
        },
        pointAt: function(length) {
            return this.node.getPointAtLength(length)
        }
    });
    SVG.extend(SVG.Parent, SVG.Text, SVG.FX, {
        font: function(o) {
            for (var k in o) k == "leading" ? this.leading(o[k]) : k == "anchor" ? this.attr("text-anchor", o[k]) : k == "size" || k == "family" || k == "weight" || k == "stretch" || k == "variant" || k == "style" ? this.attr("font-" + k, o[k]) : this.attr(k, o[k]);
            return this
        }
    });
    SVG.Set = SVG.invent({
        create: function(members) {
            Array.isArray(members) ? this.members = members : this.clear()
        },
        extend: {
            add: function() {
                var i, il, elements = [].slice.call(arguments);
                for (i = 0, il = elements.length; i < il; i++) this.members.push(elements[i]);
                return this
            },
            remove: function(element) {
                var i = this.index(element);
                if (i > -1) this.members.splice(i, 1);
                return this
            },
            each: function(block) {
                for (var i = 0, il = this.members.length; i < il; i++) block.apply(this.members[i], [i, this.members]);
                return this
            },
            clear: function() {
                this.members = [];
                return this
            },
            length: function() {
                return this.members.length
            },
            has: function(element) {
                return this.index(element) >= 0
            },
            index: function(element) {
                return this.members.indexOf(element)
            },
            get: function(i) {
                return this.members[i]
            },
            first: function() {
                return this.get(0)
            },
            last: function() {
                return this.get(this.members.length - 1)
            },
            valueOf: function() {
                return this.members
            },
            bbox: function() {
                var box = new SVG.BBox;
                if (this.members.length == 0) return box;
                var rbox = this.members[0].rbox();
                box.x = rbox.x;
                box.y = rbox.y;
                box.width = rbox.width;
                box.height = rbox.height;
                this.each(function() {
                    box = box.merge(this.rbox())
                });
                return box
            }
        },
        construct: {
            set: function(members) {
                return new SVG.Set(members)
            }
        }
    });
    SVG.FX.Set = SVG.invent({
        create: function(set) {
            this.set = set
        }
    });
    SVG.Set.inherit = function() {
        var m, methods = [];
        for (var m in SVG.Shape.prototype)
            if (typeof SVG.Shape.prototype[m] == "function" && typeof SVG.Set.prototype[m] != "function") methods.push(m);
        methods.forEach(function(method) {
            SVG.Set.prototype[method] = function() {
                for (var i = 0, il = this.members.length; i < il; i++)
                    if (this.members[i] && typeof this.members[i][method] == "function") this.members[i][method].apply(this.members[i], arguments);
                return method == "animate" ? this.fx || (this.fx = new SVG.FX.Set(this)) : this
            }
        });
        methods = [];
        for (var m in SVG.FX.prototype)
            if (typeof SVG.FX.prototype[m] ==
                "function" && typeof SVG.FX.Set.prototype[m] != "function") methods.push(m);
        methods.forEach(function(method) {
            SVG.FX.Set.prototype[method] = function() {
                for (var i = 0, il = this.set.members.length; i < il; i++) this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments);
                return this
            }
        })
    };
    SVG.extend(SVG.Element, {
        data: function(a, v, r) {
            if (typeof a == "object")
                for (v in a) this.data(v, a[v]);
            else if (arguments.length < 2) try {
                return JSON.parse(this.attr("data-" + a))
            } catch (e) {
                return this.attr("data-" + a)
            } else this.attr("data-" +
                a, v === null ? null : r === true || typeof v === "string" || typeof v === "number" ? v : JSON.stringify(v));
            return this
        }
    });
    SVG.extend(SVG.Element, {
        remember: function(k, v) {
            if (typeof arguments[0] == "object")
                for (var v in k) this.remember(v, k[v]);
            else if (arguments.length == 1) return this.memory()[k];
            else this.memory()[k] = v;
            return this
        },
        forget: function() {
            if (arguments.length == 0) this._memory = {};
            else
                for (var i = arguments.length - 1; i >= 0; i--) delete this.memory()[arguments[i]];
            return this
        },
        memory: function() {
            return this._memory || (this._memory = {})
        }
    });
    SVG.get = function(id, doc) {
        if (doc) node = doc.getElementById(idFromReference(id) || id);
        else node = document.getElementById(idFromReference(id) || id);
        if (node) return SVG.adopt(node)
    };
    SVG.select = function(query, parent) {
        return new SVG.Set(SVG.utils.map((parent || document).querySelectorAll(query), function(node) {
            return SVG.adopt(node)
        }))
    };
    SVG.extend(SVG.Parent, {
        select: function(query) {
            return SVG.select(query, this.node)
        }
    });

    function camelCase(s) {
        return s.toLowerCase().replace(/-(.)/g, function(m, g) {
            return g.toUpperCase()
        })
    }

    function capitalize(s) {
        return s.charAt(0).toUpperCase() + s.slice(1)
    }

    function fullHex(hex) {
        return hex.length == 4 ? ["#", hex.substring(1, 2), hex.substring(1, 2), hex.substring(2, 3), hex.substring(2, 3), hex.substring(3, 4), hex.substring(3, 4)].join("") : hex
    }

    function compToHex(comp) {
        var hex = comp.toString(16);
        return hex.length == 1 ? "0" + hex : hex
    }

    function proportionalSize(box, width, height) {
        if (height == null) height = box.height / box.width * width;
        else if (width == null) width = box.width / box.height * height;
        return {
            width: width,
            height: height
        }
    }

    function deltaTransformPoint(matrix, x, y) {
        return {
            x: x * matrix.a + y * matrix.c + 0,
            y: x * matrix.b + y * matrix.d + 0
        }
    }

    function arrayToMatrix(a) {
        return {
            a: a[0],
            b: a[1],
            c: a[2],
            d: a[3],
            e: a[4],
            f: a[5]
        }
    }

    function parseMatrix(matrix) {
        if (!(matrix instanceof SVG.Matrix)) matrix = new SVG.Matrix(matrix);
        return matrix
    }

    function ensureCentre(o, target) {
        o.cx = o.cx == null ? target.bbox().cx : o.cx;
        o.cy = o.cy == null ? target.bbox().cy : o.cy
    }

    function stringToMatrix(source) {
        source = source.replace(SVG.regex.whitespace, "").replace(SVG.regex.matrix, "").split(",");
        return arrayToMatrix(SVG.utils.map(source, function(n) {
            return parseFloat(n)
        }))
    }

    function at(o, pos) {
        return typeof o.from == "number" ? o.from + (o.to - o.from) * pos : o instanceof SVG.Color || o instanceof SVG.Number || o instanceof SVG.Matrix ? o.at(pos) : pos < 1 ? o.from : o.to
    }

    function arrayToString(a) {
        for (var i = 0, il = a.length, s = ""; i < il; i++) {
            s += a[i][0];
            if (a[i][1] != null) {
                s += a[i][1];
                if (a[i][2] != null) {
                    s += " ";
                    s += a[i][2];
                    if (a[i][3] != null) {
                        s += " ";
                        s += a[i][3];
                        s += " ";
                        s += a[i][4];
                        if (a[i][5] != null) {
                            s += " ";
                            s += a[i][5];
                            s += " ";
                            s += a[i][6];
                            if (a[i][7] != null) {
                                s += " ";
                                s += a[i][7]
                            }
                        }
                    }
                }
            }
        }
        return s + " "
    }

    function assignNewId(node) {
        for (var i = node.childNodes.length - 1; i >= 0; i--)
            if (node.childNodes[i] instanceof SVGElement) assignNewId(node.childNodes[i]);
        return SVG.adopt(node).id(SVG.eid(node.nodeName))
    }

    function fullBox(b) {
        if (b.x == null) {
            b.x = 0;
            b.y = 0;
            b.width = 0;
            b.height = 0
        }
        b.w = b.width;
        b.h = b.height;
        b.x2 = b.x + b.width;
        b.y2 = b.y + b.height;
        b.cx = b.x + b.width / 2;
        b.cy = b.y + b.height / 2;
        return b
    }

    function idFromReference(url) {
        var m = url.toString().match(SVG.regex.reference);
        if (m) return m[1]
    }
    var abcdef = "abcdef".split("");
    if (typeof CustomEvent !== "function") {
        var CustomEvent = function(event, options) {
            options = options || {
                bubbles: false,
                cancelable: false,
                detail: undefined
            };
            var e = document.createEvent("CustomEvent");
            e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail);
            return e
        };
        CustomEvent.prototype = window.Event.prototype;
        window.CustomEvent = CustomEvent
    }(function(w) {
        var lastTime = 0;
        var vendors = ["moz", "webkit"];
        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            w.requestAnimationFrame =
                w[vendors[x] + "RequestAnimationFrame"];
            w.cancelAnimationFrame = w[vendors[x] + "CancelAnimationFrame"] || w[vendors[x] + "CancelRequestAnimationFrame"]
        }
        w.requestAnimationFrame = w.requestAnimationFrame || function(callback) {
            var currTime = (new Date).getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = w.setTimeout(function() {
                callback(currTime + timeToCall)
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id
        };
        w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout
    })(window);
    return SVG
});
(function(global, factory) {
    if (typeof define === "function" && define.amd) define(["jquery", "./pointertouch"], function(jQuery) {
        return factory(global, jQuery)
    });
    else if (typeof exports === "object") factory(global, require("jquery"), require("./pointertouch"));
    else factory(global, global.jQuery)
})(typeof window !== "undefined" ? window : this, function(window, $) {
    var document = window.document;
    var datakey = "__pz__";
    var slice = Array.prototype.slice;
    var pointerEvents = !!window.PointerEvent;
    var supportsInputEvent = function() {
        var input =
            document.createElement("input");
        input.setAttribute("oninput", "return");
        return typeof input.oninput === "function"
    }();
    var rupper = /([A-Z])/g;
    var rsvg = /^http:[\w\.\/]+svg$/;
    var rinline = /^inline/;
    var floating = "(\\-?[\\d\\.e]+)";
    var commaSpace = "\\,?\\s*";
    var rmatrix = new RegExp("^matrix\\(" + floating + commaSpace + floating + commaSpace + floating + commaSpace + floating + commaSpace + floating + commaSpace + floating + "\\)$");

    function matrixEquals(first, second) {
        var i = first.length;
        while (--i)
            if (+first[i] !== +second[i]) return false;
        return true
    }

    function createResetOptions(opts) {
        var options = {
            range: true,
            animate: true
        };
        if (typeof opts === "boolean") options.animate = opts;
        else $.extend(options, opts);
        return options
    }

    function Matrix(a, b, c, d, e, f, g, h, i) {
        if ($.type(a) === "array") this.elements = [+a[0], +a[2], +a[4], +a[1], +a[3], +a[5], 0, 0, 1];
        else this.elements = [a, b, c, d, e, f, g || 0, h || 0, i || 1]
    }
    Matrix.prototype = {
        x: function(matrix) {
            var isVector = matrix instanceof Vector;
            var a = this.elements,
                b = matrix.elements;
            if (isVector && b.length === 3) return new Vector(a[0] *
                b[0] + a[1] * b[1] + a[2] * b[2], a[3] * b[0] + a[4] * b[1] + a[5] * b[2], a[6] * b[0] + a[7] * b[1] + a[8] * b[2]);
            else if (b.length === a.length) return new Matrix(a[0] * b[0] + a[1] * b[3] + a[2] * b[6], a[0] * b[1] + a[1] * b[4] + a[2] * b[7], a[0] * b[2] + a[1] * b[5] + a[2] * b[8], a[3] * b[0] + a[4] * b[3] + a[5] * b[6], a[3] * b[1] + a[4] * b[4] + a[5] * b[7], a[3] * b[2] + a[4] * b[5] + a[5] * b[8], a[6] * b[0] + a[7] * b[3] + a[8] * b[6], a[6] * b[1] + a[7] * b[4] + a[8] * b[7], a[6] * b[2] + a[7] * b[5] + a[8] * b[8]);
            return false
        },
        inverse: function() {
            var d = 1 / this.determinant(),
                a = this.elements;
            return new Matrix(d * (a[8] *
                a[4] - a[7] * a[5]), d * -(a[8] * a[1] - a[7] * a[2]), d * (a[5] * a[1] - a[4] * a[2]), d * -(a[8] * a[3] - a[6] * a[5]), d * (a[8] * a[0] - a[6] * a[2]), d * -(a[5] * a[0] - a[3] * a[2]), d * (a[7] * a[3] - a[6] * a[4]), d * -(a[7] * a[0] - a[6] * a[1]), d * (a[4] * a[0] - a[3] * a[1]))
        },
        determinant: function() {
            var a = this.elements;
            return a[0] * (a[8] * a[4] - a[7] * a[5]) - a[3] * (a[8] * a[1] - a[7] * a[2]) + a[6] * (a[5] * a[1] - a[4] * a[2])
        }
    };

    function Vector(x, y, z) {
        this.elements = [x, y, z]
    }
    Vector.prototype.e = Matrix.prototype.e = function(i) {
        return this.elements[i]
    };

    function Panzoom(elem, options) {
        if (!(this instanceof Panzoom)) return new Panzoom(elem, options);
        if (elem.nodeType !== 1) $.error("Panzoom called on non-Element node");
        if (!$.contains(document, elem)) $.error("Panzoom element must be attached to the document");
        var d = $.data(elem, datakey);
        if (d) return d;
        this.options = options = $.extend({}, Panzoom.defaults, options);
        this.elem = elem;
        var $elem = this.$elem = $(elem);
        this.$set = options.$set && options.$set.length ? options.$set : $elem;
        this.$doc = $(elem.ownerDocument || document);
        this.$parent = $elem.parent();
        this.isSVG = rsvg.test(elem.namespaceURI) &&
            elem.nodeName.toLowerCase() !== "svg";
        this.panning = false;
        this._buildTransform();
        this._transform = !this.isSVG && $.cssProps.transform.replace(rupper, "-$1").toLowerCase();
        this._buildTransition();
        this.resetDimensions();
        var $empty = $();
        var self = this;
        $.each(["$zoomIn", "$zoomOut", "$zoomRange", "$reset"], function(i, name) {
            self[name] = options[name] || $empty
        });
        this.enable();
        $.data(elem, datakey, this)
    }
    Panzoom.rmatrix = rmatrix;
    Panzoom.events = $.pointertouch;
    Panzoom.defaults = {
        eventNamespace: ".panzoom",
        transition: true,
        cursor: "move",
        disablePan: false,
        disableZoom: false,
        increment: .3,
        minScale: .4,
        maxScale: 5,
        rangeStep: .05,
        duration: 200,
        easing: "ease-in-out",
        contain: false
    };
    Panzoom.prototype = {
        constructor: Panzoom,
        instance: function() {
            return this
        },
        enable: function() {
            this._initStyle();
            this._bind();
            this.disabled = false
        },
        disable: function() {
            this.disabled = true;
            this._resetStyle();
            this._unbind()
        },
        isDisabled: function() {
            return this.disabled
        },
        destroy: function() {
            this.disable();
            $.removeData(this.elem, datakey)
        },
        resetDimensions: function() {
            var $parent = this.$parent;
            this.container = {
                width: $parent.innerWidth(),
                height: $parent.innerHeight()
            };
            var po = $parent.offset();
            var elem = this.elem;
            var $elem = this.$elem;
            var dims;
            if (this.isSVG) {
                dims = elem.getBoundingClientRect();
                dims = {
                    left: dims.left - po.left,
                    top: dims.top - po.top,
                    width: dims.width,
                    height: dims.height,
                    margin: {
                        left: 0,
                        top: 0
                    }
                }
            } else dims = {
                left: $.css(elem, "left", true) || 0,
                top: $.css(elem, "top", true) || 0,
                width: $elem.innerWidth(),
                height: $elem.innerHeight(),
                margin: {
                    top: $.css(elem, "marginTop", true) || 0,
                    left: $.css(elem, "marginLeft",
                        true) || 0
                }
            };
            dims.widthBorder = $.css(elem, "borderLeftWidth", true) + $.css(elem, "borderRightWidth", true) || 0;
            dims.heightBorder = $.css(elem, "borderTopWidth", true) + $.css(elem, "borderBottomWidth", true) || 0;
            this.dimensions = dims
        },
        reset: function(options) {
            options = createResetOptions(options);
            var matrix = this.setMatrix(this._origTransform, options);
            if (!options.silent) this._trigger("reset", matrix)
        },
        resetZoom: function(options) {
            options = createResetOptions(options);
            var origMatrix = this.getMatrix(this._origTransform);
            options.dValue =
                origMatrix[3];
            this.zoom(origMatrix[0], options)
        },
        resetPan: function(options) {
            var origMatrix = this.getMatrix(this._origTransform);
            this.pan(origMatrix[4], origMatrix[5], createResetOptions(options))
        },
        setTransform: function(transform) {
            var method = this.isSVG ? "attr" : "style";
            var $set = this.$set;
            var i = $set.length;
            while (i--) $[method]($set[i], "transform", transform)
        },
        getTransform: function(transform) {
            var $set = this.$set;
            var transformElem = $set[0];
            if (transform) this.setTransform(transform);
            else transform = $[this.isSVG ? "attr" :
                "style"](transformElem, "transform");
            if (transform !== "none" && !rmatrix.test(transform)) this.setTransform(transform = $.css(transformElem, "transform"));
            return transform || "none"
        },
        getMatrix: function(transform) {
            var matrix = rmatrix.exec(transform || this.getTransform());
            if (matrix) matrix.shift();
            return matrix || [1, 0, 0, 1, 0, 0]
        },
        setMatrix: function(matrix, options) {
            if (this.disabled) return;
            if (!options) options = {};
            if (typeof matrix === "string") matrix = this.getMatrix(matrix);
            var dims, container, marginW, marginH, diffW, diffH, left,
                top, width, height;
            var scale = +matrix[0];
            var $parent = this.$parent;
            var contain = typeof options.contain !== "undefined" ? options.contain : this.options.contain;
            if (contain) {
                dims = this._checkDims();
                container = this.container;
                width = dims.width + dims.widthBorder;
                height = dims.height + dims.heightBorder;
                marginW = (width * Math.abs(scale) - container.width) / 2;
                marginH = (height * Math.abs(scale) - container.height) / 2;
                left = dims.left + dims.margin.left;
                top = dims.top + dims.margin.top;
                if (contain === "invert") {
                    diffW = width > container.width ? width - container.width :
                        0;
                    diffH = height > container.height ? height - container.height : 0;
                    marginW += (container.width - width) / 2;
                    marginH += (container.height - height) / 2;
                    matrix[4] = Math.max(Math.min(matrix[4], marginW - left), -marginW - left - diffW);
                    matrix[5] = Math.max(Math.min(matrix[5], marginH - top), -marginH - top - diffH + dims.heightBorder)
                } else {
                    marginH += dims.heightBorder / 2;
                    diffW = container.width > width ? container.width - width : 0;
                    diffH = container.height > height ? container.height - height : 0;
                    if ($parent.css("textAlign") !== "center" || !rinline.test($.css(this.elem,
                            "display"))) marginW = marginH = 0;
                    else diffW = 0;
                    matrix[4] = Math.min(Math.max(matrix[4], marginW - left), -marginW - left + diffW);
                    matrix[5] = Math.min(Math.max(matrix[5], marginH - top), -marginH - top + diffH)
                }
            }
            if (options.animate !== "skip") this.transition(!options.animate);
            if (options.range) this.$zoomRange.val(scale);
            this.setTransform("matrix(" + matrix.join(",") + ")");
            if (!options.silent) this._trigger("change", matrix);
            return matrix
        },
        isPanning: function() {
            return this.panning
        },
        transition: function(off) {
            if (!this._transition) return;
            var transition = off || !this.options.transition ? "none" : this._transition;
            var $set = this.$set;
            var i = $set.length;
            while (i--)
                if ($.style($set[i], "transition") !== transition) $.style($set[i], "transition", transition)
        },
        pan: function(x, y, options) {
            if (this.options.disablePan) return;
            if (!options) options = {};
            var matrix = options.matrix;
            if (!matrix) matrix = this.getMatrix();
            if (options.relative) {
                x += +matrix[4];
                y += +matrix[5]
            }
            matrix[4] = x;
            matrix[5] = y;
            this.setMatrix(matrix, options);
            if (!options.silent) this._trigger("pan", matrix[4],
                matrix[5])
        },
        zoom: function(scale, opts) {
            if (typeof scale === "object") {
                opts = scale;
                scale = null
            } else if (!opts) opts = {};
            var options = $.extend({}, this.options, opts);
            if (options.disableZoom) return;
            var animate = false;
            var matrix = options.matrix || this.getMatrix();
            if (typeof scale !== "number") {
                scale = +matrix[0] + options.increment * (scale ? -1 : 1);
                animate = true
            }
            if (scale > options.maxScale) scale = options.maxScale;
            else if (scale < options.minScale) scale = options.minScale;
            var focal = options.focal;
            if (focal && !options.disablePan) {
                var dims =
                    this._checkDims();
                var clientX = focal.clientX;
                var clientY = focal.clientY;
                if (!this.isSVG) {
                    clientX -= (dims.width + dims.widthBorder) / 2;
                    clientY -= (dims.height + dims.heightBorder) / 2
                }
                var clientV = new Vector(clientX, clientY, 1);
                var surfaceM = new Matrix(matrix);
                var o = this.parentOffset || this.$parent.offset();
                var offsetM = new Matrix(1, 0, o.left - this.$doc.scrollLeft(), 0, 1, o.top - this.$doc.scrollTop());
                var surfaceV = surfaceM.inverse().x(offsetM.inverse().x(clientV));
                var scaleBy = scale / matrix[0];
                surfaceM = surfaceM.x(new Matrix([scaleBy,
                    0, 0, scaleBy, 0, 0
                ]));
                clientV = offsetM.x(surfaceM.x(surfaceV));
                matrix[4] = +matrix[4] + (clientX - clientV.e(0));
                matrix[5] = +matrix[5] + (clientY - clientV.e(1))
            }
            matrix[0] = scale;
            matrix[3] = typeof options.dValue === "number" ? options.dValue : scale;
            this.setMatrix(matrix, {
                animate: typeof options.animate === "boolean" ? options.animate : animate,
                range: !options.noSetRange
            });
            if (!options.silent) this._trigger("zoom", matrix[0], options)
        },
        option: function(key, value) {
            var options;
            if (!key) return $.extend({}, this.options);
            if (typeof key ===
                "string") {
                if (arguments.length === 1) return this.options[key] !== undefined ? this.options[key] : null;
                options = {};
                options[key] = value
            } else options = key;
            this._setOptions(options)
        },
        _setOptions: function(options) {
            $.each(options, $.proxy(function(key, value) {
                switch (key) {
                    case "disablePan":
                        this._resetStyle();
                    case "$zoomIn":
                    case "$zoomOut":
                    case "$zoomRange":
                    case "$reset":
                    case "disableZoom":
                    case "onStart":
                    case "onChange":
                    case "onZoom":
                    case "onPan":
                    case "onEnd":
                    case "onReset":
                    case "eventNamespace":
                        this._unbind()
                }
                this.options[key] =
                    value;
                switch (key) {
                    case "disablePan":
                        this._initStyle();
                    case "$zoomIn":
                    case "$zoomOut":
                    case "$zoomRange":
                    case "$reset":
                        this[key] = value;
                    case "disableZoom":
                    case "onStart":
                    case "onChange":
                    case "onZoom":
                    case "onPan":
                    case "onEnd":
                    case "onReset":
                    case "eventNamespace":
                        this._bind();
                        break;
                    case "cursor":
                        $.style(this.elem, "cursor", value);
                        break;
                    case "minScale":
                        this.$zoomRange.attr("min", value);
                        break;
                    case "maxScale":
                        this.$zoomRange.attr("max", value);
                        break;
                    case "rangeStep":
                        this.$zoomRange.attr("step", value);
                        break;
                    case "startTransform":
                        this._buildTransform();
                        break;
                    case "duration":
                    case "easing":
                        this._buildTransition();
                    case "transition":
                        this.transition();
                        break;
                    case "$set":
                        if (value instanceof $ && value.length) {
                            this.$set = value;
                            this._initStyle();
                            this._buildTransform()
                        }
                }
            }, this))
        },
        _initStyle: function() {
            var styles = {
                "backface-visibility": "hidden",
                "transform-origin": this.isSVG ? "0 0" : "50% 50%"
            };
            if (!this.options.disablePan) styles.cursor = this.options.cursor;
            this.$set.css(styles);
            var $parent = this.$parent;
            if ($parent.length &&
                !$.nodeName($parent[0], "body")) {
                styles = {
                    overflow: "hidden"
                };
                if ($parent.css("position") === "static") styles.position = "relative";
                $parent.css(styles)
            }
        },
        _resetStyle: function() {
            this.$elem.css({
                "cursor": "",
                "transition": ""
            });
            this.$parent.css({
                "overflow": "",
                "position": ""
            })
        },
        _bind: function() {
            var self = this;
            var options = this.options;
            var ns = options.eventNamespace;
            var str_start = pointerEvents ? "pointerdown" + ns : "touchstart" + ns + " mousedown" + ns;
            var str_click = pointerEvents ? "pointerup" + ns : "touchend" + ns + " click" + ns;
            var events = {};
            var $reset = this.$reset;
            var $zoomRange = this.$zoomRange;
            $.each(["Start", "Change", "Zoom", "Pan", "End", "Reset"], function() {
                var m = options["on" + this];
                if ($.isFunction(m)) events["panzoom" + this.toLowerCase() + ns] = m
            });
            if (!options.disablePan || !options.disableZoom) events[str_start] = function(e) {
                var touches;
                if (e.type === "touchstart" ? (touches = e.touches) && (touches.length === 1 && !options.disablePan || touches.length === 2) : !options.disablePan && e.which === 1) {
                    e.preventDefault();
                    e.stopPropagation();
                    self._startMove(e, touches)
                }
            };
            this.$elem.on(events);
            if ($reset.length) $reset.on(str_click, function(e) {
                e.preventDefault();
                self.reset()
            });
            if ($zoomRange.length) $zoomRange.attr({
                step: options.rangeStep === Panzoom.defaults.rangeStep && $zoomRange.attr("step") || options.rangeStep,
                min: options.minScale,
                max: options.maxScale
            }).prop({
                value: this.getMatrix()[0]
            });
            if (options.disableZoom) return;
            var $zoomIn = this.$zoomIn;
            var $zoomOut = this.$zoomOut;
            if ($zoomIn.length && $zoomOut.length) {
                $zoomIn.on(str_click, function(e) {
                    e.preventDefault();
                    self.zoom()
                });
                $zoomOut.on(str_click, function(e) {
                    e.preventDefault();
                    self.zoom(true)
                })
            }
            if ($zoomRange.length) {
                events = {};
                events[(pointerEvents ? "pointerdown" : "mousedown") + ns] = function() {
                    self.transition(true)
                };
                events[(supportsInputEvent ? "input" : "change") + ns] = function() {
                    self.zoom(+this.value, {
                        noSetRange: true
                    })
                };
                $zoomRange.on(events)
            }
        },
        _unbind: function() {
            this.$elem.add(this.$zoomIn).add(this.$zoomOut).add(this.$reset).off(this.options.eventNamespace)
        },
        _buildTransform: function() {
            return this._origTransform = this.getTransform(this.options.startTransform)
        },
        _buildTransition: function() {
            if (this._transform) {
                var options = this.options;
                this._transition = this._transform + " " + options.duration + "ms " + options.easing
            }
        },
        _checkDims: function() {
            var dims = this.dimensions;
            if (!dims.width || !dims.height) this.resetDimensions();
            return this.dimensions
        },
        _getDistance: function(touches) {
            var touch1 = touches[0];
            var touch2 = touches[1];
            return Math.sqrt(Math.pow(Math.abs(touch2.clientX - touch1.clientX), 2) + Math.pow(Math.abs(touch2.clientY - touch1.clientY), 2))
        },
        _getMiddle: function(touches) {
            var touch1 =
                touches[0];
            var touch2 = touches[1];
            return {
                clientX: (touch2.clientX - touch1.clientX) / 2 + touch1.clientX,
                clientY: (touch2.clientY - touch1.clientY) / 2 + touch1.clientY
            }
        },
        _trigger: function(event) {
            if (typeof event === "string") event = "panzoom" + event;
            this.$elem.triggerHandler(event, [this].concat(slice.call(arguments, 1)))
        },
        _startMove: function(event, touches) {
            var move, moveEvent, endEvent, startDistance, startScale, startMiddle, startPageX, startPageY;
            var self = this;
            var options = this.options;
            var ns = options.eventNamespace;
            var matrix =
                this.getMatrix();
            var original = matrix.slice(0);
            var origPageX = +original[4];
            var origPageY = +original[5];
            var panOptions = {
                matrix: matrix,
                animate: "skip"
            };
            if (pointerEvents) {
                moveEvent = "pointermove";
                endEvent = "pointerup"
            } else if (event.type === "touchstart") {
                moveEvent = "touchmove";
                endEvent = "touchend"
            } else {
                moveEvent = "mousemove";
                endEvent = "mouseup"
            }
            moveEvent += ns;
            endEvent += ns;
            this.transition(true);
            this.panning = true;
            this._trigger("start", event, touches);
            if (touches && touches.length === 2) {
                startDistance = this._getDistance(touches);
                startScale = +matrix[0];
                startMiddle = this._getMiddle(touches);
                move = function(e) {
                    e.preventDefault();
                    if (e.touches == null || e.touches.length !== 2) {
                        console.log("touches1:", e.touches);
                        return
                    }
                    var middle = self._getMiddle(touches = e.touches);
                    var diff = self._getDistance(touches) - startDistance;
                    self.zoom(diff * (options.increment / 100) + startScale, {
                        focal: middle,
                        matrix: matrix,
                        animate: false
                    });
                    self.pan(+matrix[4] + middle.clientX - startMiddle.clientX, +matrix[5] + middle.clientY - startMiddle.clientY, panOptions);
                    startMiddle = middle
                }
            } else {
                startPageX =
                    event.pageX;
                startPageY = event.pageY;
                move = function(e) {
                    e.preventDefault();
                    self.pan(origPageX + e.pageX - startPageX, origPageY + e.pageY - startPageY, panOptions)
                }
            }
            $(document).off(ns).on(moveEvent, move).on(endEvent, function(e) {
                e.preventDefault();
                $(this).off(ns);
                self.panning = false;
                e.type = "panzoomend";
                self._trigger(e, matrix, !matrixEquals(matrix, original))
            })
        }
    };
    $.Panzoom = Panzoom;
    $.fn.panzoom = function(options) {
        var instance, args, m, ret;
        if (typeof options === "string") {
            ret = [];
            args = slice.call(arguments, 1);
            this.each(function() {
                instance =
                    $.data(this, datakey);
                if (!instance) ret.push(undefined);
                else if (options.charAt(0) !== "_" && typeof(m = instance[options]) === "function" && (m = m.apply(instance, args)) !== undefined) ret.push(m)
            });
            return ret.length ? ret.length === 1 ? ret[0] : ret : this
        }
        return this.each(function() {
            new Panzoom(this, options)
        })
    };
    return Panzoom
});
(function(global, factory) {
    if (typeof define === "function" && define.amd) define(["jquery"], function(jQuery) {
        return factory(global, jQuery)
    });
    else if (typeof exports === "object") factory(global, require("jquery"));
    else factory(global, global.jQuery)
})(typeof window !== "undefined" ? window : this, function(window, $) {
    var list = "over out down up move enter leave cancel".split(" ");
    var hook = $.extend({}, $.event.mouseHooks);
    var events = {};
    if (window.PointerEvent) $.each(list, function(i, name) {
        $.event.fixHooks[events[name] = "pointer" +
            name] = hook
    });
    else {
        var mouseProps = hook.props;
        hook.props = mouseProps.concat(["touches", "changedTouches", "targetTouches", "altKey", "ctrlKey", "metaKey", "shiftKey"]);
        hook.filter = function(event, originalEvent) {
            var touch;
            var i = mouseProps.length;
            if (!originalEvent.pageX && originalEvent.touches && (touch = originalEvent.touches[0]))
                while (i--) event[mouseProps[i]] = touch[mouseProps[i]];
            return event
        };
        $.each(list, function(i, name) {
            if (i < 2) events[name] = "mouse" + name;
            else {
                var touch = "touch" + (name === "down" ? "start" : name === "up" ?
                    "end" : name);
                $.event.fixHooks[touch] = hook;
                events[name] = touch + " mouse" + name
            }
        })
    }
    $.pointertouch = events;
    return events
});
var module;
(function(require) {
    var isNode = module && !!module.exports;
    var allowedResultTypes = ["value", "path", "pointer", "parent", "parentProperty", "all"];
    var vm = isNode ? require("vm") : {
        runInNewContext: function(expr, context) {
            return eval(Object.keys(context).reduce(function(s, vr) {
                return "var " + vr + "=" + JSON.stringify(context[vr]).replace(/\u2028|\u2029/g, function(m) {
                    return "\\u202" + (m === "\u2028" ? "8" : "9")
                }) + ";" + s
            }, expr))
        }
    };

    function push(arr, elem) {
        arr = arr.slice();
        arr.push(elem);
        return arr
    }

    function unshift(elem, arr) {
        arr = arr.slice();
        arr.unshift(elem);
        return arr
    }

    function NewError(value) {
        this.avoidNew = true;
        this.value = value;
        this.message = 'JSONPath should not be called with "new" (it prevents return of (unwrapped) scalar values)'
    }

    function JSONPath(opts, expr, obj, callback, otherTypeCallback) {
        if (!(this instanceof JSONPath)) try {
            return new JSONPath(opts, expr, obj, callback, otherTypeCallback)
        } catch (e) {
            if (!e.avoidNew) throw e;
            return e.value
        }
        if (typeof opts === "string") {
            otherTypeCallback = callback;
            callback = obj;
            obj = expr;
            expr = opts;
            opts = {}
        }
        opts = opts || {};
        var objArgs = opts.hasOwnProperty("json") && opts.hasOwnProperty("path");
        this.json = opts.json || obj;
        this.path = opts.path || expr;
        this.resultType = opts.resultType && opts.resultType.toLowerCase() || "value";
        this.flatten = opts.flatten || false;
        this.wrap = opts.hasOwnProperty("wrap") ? opts.wrap : true;
        this.sandbox = opts.sandbox || {};
        this.preventEval = opts.preventEval || false;
        this.parent = opts.parent || null;
        this.parentProperty = opts.parentProperty || null;
        this.callback = opts.callback || callback || null;
        this.otherTypeCallback = opts.otherTypeCallback ||
            otherTypeCallback || function() {
                throw new Error("You must supply an otherTypeCallback callback option with the @other() operator.");
            };
        if (opts.autostart !== false) {
            var ret = this.evaluate({
                path: objArgs ? opts.path : expr,
                json: objArgs ? opts.json : obj
            });
            if (!ret || typeof ret !== "object") throw new NewError(ret);
            return ret
        }
    }
    JSONPath.prototype.evaluate = function(expr, json, callback, otherTypeCallback) {
        var self = this,
            flatten = this.flatten,
            wrap = this.wrap,
            currParent = this.parent,
            currParentProperty = this.parentProperty;
        this.currResultType =
            this.resultType;
        this.currPreventEval = this.preventEval;
        this.currSandbox = this.sandbox;
        callback = callback || this.callback;
        this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;
        json = json || this.json;
        expr = expr || this.path;
        if (expr && typeof expr === "object") {
            if (!expr.path) throw new Error('You must supply a "path" property when providing an object argument to JSONPath.evaluate().');
            json = expr.hasOwnProperty("json") ? expr.json : json;
            flatten = expr.hasOwnProperty("flatten") ? expr.flatten : flatten;
            this.currResultType =
                expr.hasOwnProperty("resultType") ? expr.resultType : this.currResultType;
            this.currSandbox = expr.hasOwnProperty("sandbox") ? expr.sandbox : this.currSandbox;
            wrap = expr.hasOwnProperty("wrap") ? expr.wrap : wrap;
            this.currPreventEval = expr.hasOwnProperty("preventEval") ? expr.preventEval : this.currPreventEval;
            callback = expr.hasOwnProperty("callback") ? expr.callback : callback;
            this.currOtherTypeCallback = expr.hasOwnProperty("otherTypeCallback") ? expr.otherTypeCallback : this.currOtherTypeCallback;
            currParent = expr.hasOwnProperty("parent") ?
                expr.parent : currParent;
            currParentProperty = expr.hasOwnProperty("parentProperty") ? expr.parentProperty : currParentProperty;
            expr = expr.path
        }
        currParent = currParent || null;
        currParentProperty = currParentProperty || null;
        if (Array.isArray(expr)) expr = JSONPath.toPathString(expr);
        if (!expr || !json || allowedResultTypes.indexOf(this.currResultType) === -1) return;
        this._obj = json;
        var exprList = JSONPath.toPathArray(expr);
        if (exprList[0] === "$" && exprList.length > 1) exprList.shift();
        var result = this._trace(exprList, json, ["$"], currParent,
            currParentProperty, callback);
        result = result.filter(function(ea) {
            return ea && !ea.isParentSelector
        });
        if (!result.length) return wrap ? [] : undefined;
        if (result.length === 1 && !wrap && !Array.isArray(result[0].value)) return this._getPreferredOutput(result[0]);
        return result.reduce(function(result, ea) {
            var valOrPath = self._getPreferredOutput(ea);
            if (flatten && Array.isArray(valOrPath)) result = result.concat(valOrPath);
            else result.push(valOrPath);
            return result
        }, [])
    };
    JSONPath.prototype._getPreferredOutput = function(ea) {
        var resultType =
            this.currResultType;
        switch (resultType) {
            case "all":
                ea.path = typeof ea.path === "string" ? ea.path : JSONPath.toPathString(ea.path);
                return ea;
            case "value":
            case "parent":
            case "parentProperty":
                return ea[resultType];
            case "path":
                return JSONPath.toPathString(ea[resultType]);
            case "pointer":
                return JSONPath.toPointer(ea.path)
        }
    };
    JSONPath.prototype._handleCallback = function(fullRetObj, callback, type) {
        if (callback) {
            var preferredOutput = this._getPreferredOutput(fullRetObj);
            fullRetObj.path = typeof fullRetObj.path === "string" ?
                fullRetObj.path : JSONPath.toPathString(fullRetObj.path);
            callback(preferredOutput, type, fullRetObj)
        }
    };
    JSONPath.prototype._trace = function(expr, val, path, parent, parentPropName, callback) {
        var retObj, self = this;
        if (!expr.length) {
            retObj = {
                path: path,
                value: val,
                parent: parent,
                parentProperty: parentPropName
            };
            this._handleCallback(retObj, callback, "value");
            return retObj
        }
        var loc = expr[0],
            x = expr.slice(1);
        var ret = [];

        function addRet(elems) {
            ret = ret.concat(elems)
        }
        if (val && Object.prototype.hasOwnProperty.call(val, loc)) addRet(this._trace(x,
            val[loc], push(path, loc), val, loc, callback));
        else if (loc === "*") this._walk(loc, x, val, path, parent, parentPropName, callback, function(m, l, x, v, p, par, pr, cb) {
            addRet(self._trace(unshift(m, x), v, p, par, pr, cb))
        });
        else if (loc === "..") {
            addRet(this._trace(x, val, path, parent, parentPropName, callback));
            this._walk(loc, x, val, path, parent, parentPropName, callback, function(m, l, x, v, p, par, pr, cb) {
                if (typeof v[m] === "object") addRet(self._trace(unshift(l, x), v[m], push(p, m), v, m, cb))
            })
        } else if (loc[0] === "(") {
            if (this.currPreventEval) throw new Error("Eval [(expr)] prevented in JSONPath expression.");
            addRet(this._trace(unshift(this._eval(loc, val, path[path.length - 1], path.slice(0, -1), parent, parentPropName), x), val, path, parent, parentPropName, callback))
        } else if (loc === "^") return path.length ? {
            path: path.slice(0, -1),
            expr: x,
            isParentSelector: true
        } : [];
        else if (loc === "~") {
            retObj = {
                path: push(path, loc),
                value: parentPropName,
                parent: parent,
                parentProperty: null
            };
            this._handleCallback(retObj, callback, "property");
            return retObj
        } else if (loc === "$") addRet(this._trace(x, val, path, null, null, callback));
        else if (loc.indexOf("?(") ===
            0) {
            if (this.currPreventEval) throw new Error("Eval [?(expr)] prevented in JSONPath expression.");
            this._walk(loc, x, val, path, parent, parentPropName, callback, function(m, l, x, v, p, par, pr, cb) {
                if (self._eval(l.replace(/^\?\((.*?)\)$/, "$1"), v[m], m, p, par, pr)) addRet(self._trace(unshift(m, x), v, p, par, pr, cb))
            })
        } else if (loc.indexOf(",") > -1) {
            var parts, i;
            for (parts = loc.split(","), i = 0; i < parts.length; i++) addRet(this._trace(unshift(parts[i], x), val, path, parent, parentPropName, callback))
        } else if (loc[0] === "@") {
            var addType = false;
            var valueType = loc.slice(1, -2);
            switch (valueType) {
                case "scalar":
                    if (!val || ["object", "function"].indexOf(typeof val) === -1) addType = true;
                    break;
                case "boolean":
                case "string":
                case "undefined":
                case "function":
                    if (typeof val === valueType) addType = true;
                    break;
                case "number":
                    if (typeof val === valueType && isFinite(val)) addType = true;
                    break;
                case "nonFinite":
                    if (typeof val === "number" && !isFinite(val)) addType = true;
                    break;
                case "object":
                    if (val && typeof val === valueType) addType = true;
                    break;
                case "array":
                    if (Array.isArray(val)) addType =
                        true;
                    break;
                case "other":
                    addType = this.currOtherTypeCallback(val, path, parent, parentPropName);
                    break;
                case "integer":
                    if (val === +val && isFinite(val) && !(val % 1)) addType = true;
                    break;
                case "null":
                    if (val === null) addType = true;
                    break
            }
            if (addType) {
                retObj = {
                    path: path,
                    value: val,
                    parent: parent,
                    parentProperty: parentPropName
                };
                this._handleCallback(retObj, callback, "value");
                return retObj
            }
        } else if (/^(-?[0-9]*):(-?[0-9]*):?([0-9]*)$/.test(loc)) addRet(this._slice(loc, x, val, path, parent, parentPropName, callback));
        return ret.reduce(function(all,
            ea) {
            return all.concat(ea.isParentSelector ? self._trace(ea.expr, val, ea.path, parent, parentPropName, callback) : ea)
        }, [])
    };
    JSONPath.prototype._walk = function(loc, expr, val, path, parent, parentPropName, callback, f) {
        var i, n, m;
        if (Array.isArray(val))
            for (i = 0, n = val.length; i < n; i++) f(i, loc, expr, val, path, parent, parentPropName, callback);
        else if (typeof val === "object")
            for (m in val)
                if (Object.prototype.hasOwnProperty.call(val, m)) f(m, loc, expr, val, path, parent, parentPropName, callback)
    };
    JSONPath.prototype._slice = function(loc,
        expr, val, path, parent, parentPropName, callback) {
        if (!Array.isArray(val)) return;
        var i, len = val.length,
            parts = loc.split(":"),
            start = parts[0] && parseInt(parts[0], 10) || 0,
            end = parts[1] && parseInt(parts[1], 10) || len,
            step = parts[2] && parseInt(parts[2], 10) || 1;
        start = start < 0 ? Math.max(0, start + len) : Math.min(len, start);
        end = end < 0 ? Math.max(0, end + len) : Math.min(len, end);
        var ret = [];
        for (i = start; i < end; i += step) ret = ret.concat(this._trace(unshift(i, expr), val, path, parent, parentPropName, callback));
        return ret
    };
    JSONPath.prototype._eval =
        function(code, _v, _vname, path, parent, parentPropName) {
            if (!this._obj || !_v) return false;
            if (code.indexOf("@parentProperty") > -1) {
                this.currSandbox._$_parentProperty = parentPropName;
                code = code.replace(/@parentProperty/g, "_$_parentProperty")
            }
            if (code.indexOf("@parent") > -1) {
                this.currSandbox._$_parent = parent;
                code = code.replace(/@parent/g, "_$_parent")
            }
            if (code.indexOf("@property") > -1) {
                this.currSandbox._$_property = _vname;
                code = code.replace(/@property/g, "_$_property")
            }
            if (code.indexOf("@path") > -1) {
                this.currSandbox._$_path =
                    JSONPath.toPathString(path.concat([_vname]));
                code = code.replace(/@path/g, "_$_path")
            }
            if (code.match(/@([\.\s\)\[])/)) {
                this.currSandbox._$_v = _v;
                code = code.replace(/@([\.\s\)\[])/g, "_$_v$1")
            }
            try {
                return vm.runInNewContext(code, this.currSandbox)
            } catch (e) {
                console.log(e);
                throw new Error("jsonPath: " + e.message + ": " + code);
            }
        };
    JSONPath.cache = {};
    JSONPath.toPathString = function(pathArr) {
        var i, n, x = pathArr,
            p = "$";
        for (i = 1, n = x.length; i < n; i++)
            if (!/^(~|\^|@.*?\(\))$/.test(x[i])) p += /^[0-9*]+$/.test(x[i]) ? "[" + x[i] + "]" : "['" +
                x[i] + "']";
        return p
    };
    JSONPath.toPointer = function(pointer) {
        var i, n, x = pointer,
            p = "";
        for (i = 1, n = x.length; i < n; i++)
            if (!/^(~|\^|@.*?\(\))$/.test(x[i])) p += "/" + x[i].toString().replace(/\~/g, "~0").replace(/\//g, "~1");
        return p
    };
    JSONPath.toPathArray = function(expr) {
        var cache = JSONPath.cache;
        if (cache[expr]) return cache[expr];
        var subx = [];
        var normalized = expr.replace(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\(\)/g, ";$&;").replace(/[\['](\??\(.*?\))[\]']/g, function($0,
            $1) {
            return "[#" + (subx.push($1) - 1) + "]"
        }).replace(/\['([^'\]]*)'\]/g, function($0, prop) {
            return "['" + prop.replace(/\./g, "%@%").replace(/~/g, "%%@@%%") + "']"
        }).replace(/~/g, ";~;").replace(/'?\.'?(?![^\[]*\])|\['?/g, ";").replace(/%@%/g, ".").replace(/%%@@%%/g, "~").replace(/(?:;)?(\^+)(?:;)?/g, function($0, ups) {
            return ";" + ups.split("").join(";") + ";"
        }).replace(/;;;|;;/g, ";..;").replace(/;$|'?\]|'$/g, "");
        var exprList = normalized.split(";").map(function(expr) {
            var match = expr.match(/#([0-9]+)/);
            return !match || !match[1] ?
                expr : subx[match[1]]
        });
        cache[expr] = exprList;
        return cache[expr]
    };
    JSONPath.eval = function(obj, expr, opts) {
        return JSONPath(opts, expr, obj)
    };
    if (typeof define === "function" && define.amd) define(function() {
        return JSONPath
    });
    else if (isNode) module.exports = JSONPath;
    else {
        self.jsonPath = {
            eval: JSONPath.eval
        };
        self.JSONPath = JSONPath
    }
})(typeof require === "undefined" ? null : require);
(function(root, factory) {
    if (typeof define === "function" && define.amd) define("sifter", factory);
    else if (typeof exports === "object") module.exports = factory();
    else root.Sifter = factory()
})(this, function() {
    var Sifter = function(items, settings) {
        this.items = items;
        this.settings = settings || {
            diacritics: true
        }
    };
    Sifter.prototype.tokenize = function(query) {
        query = trim(String(query || "").toLowerCase());
        if (!query || !query.length) return [];
        var i, n, regex, letter;
        var tokens = [];
        var words = query.split(/ +/);
        for (i = 0, n = words.length; i < n; i++) {
            regex =
                escape_regex(words[i]);
            if (this.settings.diacritics)
                for (letter in DIACRITICS)
                    if (DIACRITICS.hasOwnProperty(letter)) regex = regex.replace(new RegExp(letter, "g"), DIACRITICS[letter]);
            tokens.push({
                string: words[i],
                regex: new RegExp(regex, "i")
            })
        }
        return tokens
    };
    Sifter.prototype.iterator = function(object, callback) {
        var iterator;
        if (is_array(object)) iterator = Array.prototype.forEach || function(callback) {
            for (var i = 0, n = this.length; i < n; i++) callback(this[i], i, this)
        };
        else iterator = function(callback) {
            for (var key in this)
                if (this.hasOwnProperty(key)) callback(this[key],
                    key, this)
        };
        iterator.apply(object, [callback])
    };
    Sifter.prototype.getScoreFunction = function(search, options) {
        var self, fields, tokens, token_count;
        self = this;
        search = self.prepareSearch(search, options);
        tokens = search.tokens;
        fields = search.options.fields;
        token_count = tokens.length;
        var scoreValue = function(value, token) {
            var score, pos;
            if (!value) return 0;
            value = String(value || "");
            pos = value.search(token.regex);
            if (pos === -1) return 0;
            score = token.string.length / value.length;
            if (pos === 0) score += .5;
            return score
        };
        var scoreObject =
            function() {
                var field_count = fields.length;
                if (!field_count) return function() {
                    return 0
                };
                if (field_count === 1) return function(token, data) {
                    return scoreValue(data[fields[0]], token)
                };
                return function(token, data) {
                    for (var i = 0, sum = 0; i < field_count; i++) sum += scoreValue(data[fields[i]], token);
                    return sum / field_count
                }
            }();
        if (!token_count) return function() {
            return 0
        };
        if (token_count === 1) return function(data) {
            return scoreObject(tokens[0], data)
        };
        if (search.options.conjunction === "and") return function(data) {
            var score;
            for (var i =
                    0, sum = 0; i < token_count; i++) {
                score = scoreObject(tokens[i], data);
                if (score <= 0) return 0;
                sum += score
            }
            return sum / token_count
        };
        else return function(data) {
            for (var i = 0, sum = 0; i < token_count; i++) sum += scoreObject(tokens[i], data);
            return sum / token_count
        }
    };
    Sifter.prototype.getSortFunction = function(search, options) {
        var i, n, self, field, fields, fields_count, multiplier, multipliers, get_field, implicit_score, sort;
        self = this;
        search = self.prepareSearch(search, options);
        sort = !search.query && options.sort_empty || options.sort;
        get_field =
            function(name, result) {
                if (name === "$score") return result.score;
                return self.items[result.id][name]
            };
        fields = [];
        if (sort)
            for (i = 0, n = sort.length; i < n; i++)
                if (search.query || sort[i].field !== "$score") fields.push(sort[i]);
        if (search.query) {
            implicit_score = true;
            for (i = 0, n = fields.length; i < n; i++)
                if (fields[i].field === "$score") {
                    implicit_score = false;
                    break
                }
            if (implicit_score) fields.unshift({
                field: "$score",
                direction: "desc"
            })
        } else
            for (i = 0, n = fields.length; i < n; i++)
                if (fields[i].field === "$score") {
                    fields.splice(i, 1);
                    break
                }
        multipliers = [];
        for (i = 0, n = fields.length; i < n; i++) multipliers.push(fields[i].direction === "desc" ? -1 : 1);
        fields_count = fields.length;
        if (!fields_count) return null;
        else if (fields_count === 1) {
            field = fields[0].field;
            multiplier = multipliers[0];
            return function(a, b) {
                return multiplier * cmp(get_field(field, a), get_field(field, b))
            }
        } else return function(a, b) {
            var i, result, a_value, b_value, field;
            for (i = 0; i < fields_count; i++) {
                field = fields[i].field;
                result = multipliers[i] * cmp(get_field(field, a), get_field(field, b));
                if (result) return result
            }
            return 0
        }
    };
    Sifter.prototype.prepareSearch = function(query, options) {
        if (typeof query === "object") return query;
        options = extend({}, options);
        var option_fields = options.fields;
        var option_sort = options.sort;
        var option_sort_empty = options.sort_empty;
        if (option_fields && !is_array(option_fields)) options.fields = [option_fields];
        if (option_sort && !is_array(option_sort)) options.sort = [option_sort];
        if (option_sort_empty && !is_array(option_sort_empty)) options.sort_empty = [option_sort_empty];
        return {
            options: options,
            query: String(query || "").toLowerCase(),
            tokens: this.tokenize(query),
            total: 0,
            items: []
        }
    };
    Sifter.prototype.search = function(query, options) {
        var self = this,
            value, score, search, calculateScore;
        var fn_sort;
        var fn_score;
        search = this.prepareSearch(query, options);
        options = search.options;
        query = search.query;
        fn_score = options.score || self.getScoreFunction(search);
        if (query.length) self.iterator(self.items, function(item, id) {
            score = fn_score(item);
            if (options.filter === false || score > 0) search.items.push({
                "score": score,
                "id": id
            })
        });
        else self.iterator(self.items, function(item,
            id) {
            search.items.push({
                "score": 1,
                "id": id
            })
        });
        fn_sort = self.getSortFunction(search, options);
        if (fn_sort) search.items.sort(fn_sort);
        search.total = search.items.length;
        if (typeof options.limit === "number") search.items = search.items.slice(0, options.limit);
        return search
    };
    var cmp = function(a, b) {
        if (typeof a === "number" && typeof b === "number") return a > b ? 1 : a < b ? -1 : 0;
        a = asciifold(String(a || ""));
        b = asciifold(String(b || ""));
        if (a > b) return 1;
        if (b > a) return -1;
        return 0
    };
    var extend = function(a, b) {
        var i, n, k, object;
        for (i = 1, n = arguments.length; i <
            n; i++) {
            object = arguments[i];
            if (!object) continue;
            for (k in object)
                if (object.hasOwnProperty(k)) a[k] = object[k]
        }
        return a
    };
    var trim = function(str) {
        return (str + "").replace(/^\s+|\s+$|/g, "")
    };
    var escape_regex = function(str) {
        return (str + "").replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1")
    };
    var is_array = Array.isArray || typeof $ !== "undefined" && $.isArray || function(object) {
        return Object.prototype.toString.call(object) === "[object Array]"
    };
    var DIACRITICS = {
        "a": "[aÀÁÂÃÄÅàáâãäåĀāąĄ]",
        "c": "[cÇçćĆčČ]",
        "d": "[dđĐďĎð]",
        "e": "[eÈÉÊËèéêëěĚĒēęĘ]",
        "i": "[iÌÍÎÏìíîïĪī]",
        "l": "[lłŁ]",
        "n": "[nÑñňŇńŃ]",
        "o": "[oÒÓÔÕÕÖØòóôõöøŌō]",
        "r": "[rřŘ]",
        "s": "[sŠšśŚ]",
        "t": "[tťŤ]",
        "u": "[uÙÚÛÜùúûüůŮŪū]",
        "y": "[yŸÿýÝ]",
        "z": "[zŽžżŻźŹ]"
    };
    var asciifold = function() {
        var i, n, k, chunk;
        var foreignletters = "";
        var lookup = {};
        for (k in DIACRITICS)
            if (DIACRITICS.hasOwnProperty(k)) {
                chunk = DIACRITICS[k].substring(2, DIACRITICS[k].length - 1);
                foreignletters += chunk;
                for (i = 0, n = chunk.length; i < n; i++) lookup[chunk.charAt(i)] = k
            }
        var regexp = new RegExp("[" + foreignletters + "]", "g");
        return function(str) {
            return str.replace(regexp,
                function(foreignletter) {
                    return lookup[foreignletter]
                }).toLowerCase()
        }
    }();
    return Sifter
});
(function(root, factory) {
    if (typeof define === "function" && define.amd) define("microplugin", factory);
    else if (typeof exports === "object") module.exports = factory();
    else root.MicroPlugin = factory()
})(this, function() {
    var MicroPlugin = {};
    MicroPlugin.mixin = function(Interface) {
        Interface.plugins = {};
        Interface.prototype.initializePlugins = function(plugins) {
            var i, n, key;
            var self = this;
            var queue = [];
            self.plugins = {
                names: [],
                settings: {},
                requested: {},
                loaded: {}
            };
            if (utils.isArray(plugins))
                for (i = 0, n = plugins.length; i < n; i++)
                    if (typeof plugins[i] ===
                        "string") queue.push(plugins[i]);
                    else {
                        self.plugins.settings[plugins[i].name] = plugins[i].options;
                        queue.push(plugins[i].name)
                    } else if (plugins)
                for (key in plugins)
                    if (plugins.hasOwnProperty(key)) {
                        self.plugins.settings[key] = plugins[key];
                        queue.push(key)
                    }
            while (queue.length) self.require(queue.shift())
        };
        Interface.prototype.loadPlugin = function(name) {
            var self = this;
            var plugins = self.plugins;
            var plugin = Interface.plugins[name];
            if (!Interface.plugins.hasOwnProperty(name)) throw new Error('Unable to find "' + name + '" plugin');
            plugins.requested[name] = true;
            plugins.loaded[name] = plugin.fn.apply(self, [self.plugins.settings[name] || {}]);
            plugins.names.push(name)
        };
        Interface.prototype.require = function(name) {
            var self = this;
            var plugins = self.plugins;
            if (!self.plugins.loaded.hasOwnProperty(name)) {
                if (plugins.requested[name]) throw new Error('Plugin has circular dependency ("' + name + '")');
                self.loadPlugin(name)
            }
            return plugins.loaded[name]
        };
        Interface.define = function(name, fn) {
            Interface.plugins[name] = {
                "name": name,
                "fn": fn
            }
        }
    };
    var utils = {
        isArray: Array.isArray ||
            function(vArg) {
                return Object.prototype.toString.call(vArg) === "[object Array]"
            }
    };
    return MicroPlugin
});
(function(root, factory) {
    if (typeof define === "function" && define.amd) define("selectize", ["jquery", "sifter", "microplugin"], factory);
    else if (typeof exports === "object") module.exports = factory(require("jquery"), require("sifter"), require("microplugin"));
    else root.Selectize = factory(root.jQuery, root.Sifter, root.MicroPlugin)
})(this, function($, Sifter, MicroPlugin) {
    var highlight = function($element, pattern) {
        if (typeof pattern === "string" && !pattern.length) return;
        var regex = typeof pattern === "string" ? new RegExp(pattern,
            "i") : pattern;
        var highlight = function(node) {
            var skip = 0;
            if (node.nodeType === 3) {
                var pos = node.data.search(regex);
                if (pos >= 0 && node.data.length > 0) {
                    var match = node.data.match(regex);
                    var spannode = document.createElement("span");
                    spannode.className = "highlight";
                    var middlebit = node.splitText(pos);
                    var endbit = middlebit.splitText(match[0].length);
                    var middleclone = middlebit.cloneNode(true);
                    spannode.appendChild(middleclone);
                    middlebit.parentNode.replaceChild(spannode, middlebit);
                    skip = 1
                }
            } else if (node.nodeType === 1 && node.childNodes &&
                !/(script|style)/i.test(node.tagName))
                for (var i = 0; i < node.childNodes.length; ++i) i += highlight(node.childNodes[i]);
            return skip
        };
        return $element.each(function() {
            highlight(this)
        })
    };
    var MicroEvent = function() {};
    MicroEvent.prototype = {
        on: function(event, fct) {
            this._events = this._events || {};
            this._events[event] = this._events[event] || [];
            this._events[event].push(fct)
        },
        off: function(event, fct) {
            var n = arguments.length;
            if (n === 0) return delete this._events;
            if (n === 1) return delete this._events[event];
            this._events = this._events || {};
            if (event in this._events === false) return;
            this._events[event].splice(this._events[event].indexOf(fct), 1)
        },
        trigger: function(event) {
            this._events = this._events || {};
            if (event in this._events === false) return;
            for (var i = 0; i < this._events[event].length; i++) this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1))
        }
    };
    MicroEvent.mixin = function(destObject) {
        var props = ["on", "off", "trigger"];
        for (var i = 0; i < props.length; i++) destObject.prototype[props[i]] = MicroEvent.prototype[props[i]]
    };
    var IS_MAC = /Mac/.test(navigator.userAgent);
    var KEY_A = 65;
    var KEY_COMMA = 188;
    var KEY_RETURN = 13;
    var KEY_ESC = 27;
    var KEY_LEFT = 37;
    var KEY_UP = 38;
    var KEY_P = 80;
    var KEY_RIGHT = 39;
    var KEY_DOWN = 40;
    var KEY_N = 78;
    var KEY_BACKSPACE = 8;
    var KEY_DELETE = 46;
    var KEY_SHIFT = 16;
    var KEY_CMD = IS_MAC ? 91 : 17;
    var KEY_CTRL = IS_MAC ? 18 : 17;
    var KEY_TAB = 9;
    var TAG_SELECT = 1;
    var TAG_INPUT = 2;
    var SUPPORTS_VALIDITY_API = !/android/i.test(window.navigator.userAgent) && !!document.createElement("form").validity;
    var isset = function(object) {
        return typeof object !== "undefined"
    };
    var hash_key = function(value) {
        if (typeof value ===
            "undefined" || value === null) return null;
        if (typeof value === "boolean") return value ? "1" : "0";
        return value + ""
    };
    var escape_html = function(str) {
        return (str + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;")
    };
    var escape_replace = function(str) {
        return (str + "").replace(/\$/g, "$$$$")
    };
    var hook = {};
    hook.before = function(self, method, fn) {
        var original = self[method];
        self[method] = function() {
            fn.apply(self, arguments);
            return original.apply(self, arguments)
        }
    };
    hook.after = function(self, method,
        fn) {
        var original = self[method];
        self[method] = function() {
            var result = original.apply(self, arguments);
            fn.apply(self, arguments);
            return result
        }
    };
    var once = function(fn) {
        var called = false;
        return function() {
            if (called) return;
            called = true;
            fn.apply(this, arguments)
        }
    };
    var debounce = function(fn, delay) {
        var timeout;
        return function() {
            var self = this;
            var args = arguments;
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function() {
                fn.apply(self, args)
            }, delay)
        }
    };
    var debounce_events = function(self, types, fn) {
        var type;
        var trigger =
            self.trigger;
        var event_args = {};
        self.trigger = function() {
            var type = arguments[0];
            if (types.indexOf(type) !== -1) event_args[type] = arguments;
            else return trigger.apply(self, arguments)
        };
        fn.apply(self, []);
        self.trigger = trigger;
        for (type in event_args)
            if (event_args.hasOwnProperty(type)) trigger.apply(self, event_args[type])
    };
    var watchChildEvent = function($parent, event, selector, fn) {
        $parent.on(event, selector, function(e) {
            var child = e.target;
            while (child && child.parentNode !== $parent[0]) child = child.parentNode;
            e.currentTarget =
                child;
            return fn.apply(this, [e])
        })
    };
    var getSelection = function(input) {
        var result = {};
        if ("selectionStart" in input) {
            result.start = input.selectionStart;
            result.length = input.selectionEnd - result.start
        } else if (document.selection) {
            input.focus();
            var sel = document.selection.createRange();
            var selLen = document.selection.createRange().text.length;
            sel.moveStart("character", -input.value.length);
            result.start = sel.text.length - selLen;
            result.length = selLen
        }
        return result
    };
    var transferStyles = function($from, $to, properties) {
        var i,
            n, styles = {};
        if (properties)
            for (i = 0, n = properties.length; i < n; i++) styles[properties[i]] = $from.css(properties[i]);
        else styles = $from.css();
        $to.css(styles)
    };
    var measureString = function(str, $parent) {
        if (!str) return 0;
        var $test = $("<test>").css({
            position: "absolute",
            top: -99999,
            left: -99999,
            width: "auto",
            padding: 0,
            whiteSpace: "pre"
        }).text(str).appendTo("body");
        transferStyles($parent, $test, ["letterSpacing", "fontSize", "fontFamily", "fontWeight", "textTransform"]);
        var width = $test.width();
        $test.remove();
        return width
    };
    var autoGrow =
        function($input) {
            var currentWidth = null;
            var update = function(e, options) {
                var value, keyCode, printable, placeholder, width;
                var shift, character, selection;
                e = e || window.event || {};
                options = options || {};
                if (e.metaKey || e.altKey) return;
                if (!options.force && $input.data("grow") === false) return;
                value = $input.val();
                if (e.type && e.type.toLowerCase() === "keydown") {
                    keyCode = e.keyCode;
                    printable = keyCode >= 97 && keyCode <= 122 || keyCode >= 65 && keyCode <= 90 || keyCode >= 48 && keyCode <= 57 || keyCode === 32;
                    if (keyCode === KEY_DELETE || keyCode === KEY_BACKSPACE) {
                        selection =
                            getSelection($input[0]);
                        if (selection.length) value = value.substring(0, selection.start) + value.substring(selection.start + selection.length);
                        else if (keyCode === KEY_BACKSPACE && selection.start) value = value.substring(0, selection.start - 1) + value.substring(selection.start + 1);
                        else if (keyCode === KEY_DELETE && typeof selection.start !== "undefined") value = value.substring(0, selection.start) + value.substring(selection.start + 1)
                    } else if (printable) {
                        shift = e.shiftKey;
                        character = String.fromCharCode(e.keyCode);
                        if (shift) character =
                            character.toUpperCase();
                        else character = character.toLowerCase();
                        value += character
                    }
                }
                placeholder = $input.attr("placeholder");
                if (!value && placeholder) value = placeholder;
                width = measureString(value, $input) + 4;
                if (width !== currentWidth) {
                    currentWidth = width;
                    $input.width(width);
                    $input.triggerHandler("resize")
                }
            };
            $input.on("keydown keyup update blur", update);
            update()
        };
    var domToString = function(d) {
        var tmp = document.createElement("div");
        tmp.appendChild(d.cloneNode(true));
        return tmp.innerHTML
    };
    var Selectize = function($input,
        settings) {
        var key, i, n, dir, input, self = this;
        input = $input[0];
        input.selectize = self;
        var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);
        dir = computedStyle ? computedStyle.getPropertyValue("direction") : input.currentStyle && input.currentStyle.direction;
        dir = dir || $input.parents("[dir]:first").attr("dir") || "";
        $.extend(self, {
            order: 0,
            settings: settings,
            $input: $input,
            tabIndex: $input.attr("tabindex") || "",
            tagType: input.tagName.toLowerCase() === "select" ? TAG_SELECT : TAG_INPUT,
            rtl: /rtl/i.test(dir),
            eventNS: ".selectize" + ++Selectize.count,
            highlightedValue: null,
            isOpen: false,
            isDisabled: false,
            isRequired: $input.is("[required]"),
            isInvalid: false,
            isLocked: false,
            isFocused: false,
            isInputHidden: false,
            isSetup: false,
            isShiftDown: false,
            isCmdDown: false,
            isCtrlDown: false,
            ignoreFocus: false,
            ignoreBlur: false,
            ignoreHover: false,
            hasOptions: false,
            currentResults: null,
            lastValue: "",
            caretPos: 0,
            loading: 0,
            loadedSearches: {},
            $activeOption: null,
            $activeItems: [],
            optgroups: {},
            options: {},
            userOptions: {},
            items: [],
            renderCache: {},
            onSearchChange: settings.loadThrottle ===
                null ? self.onSearchChange : debounce(self.onSearchChange, settings.loadThrottle)
        });
        self.sifter = new Sifter(this.options, {
            diacritics: settings.diacritics
        });
        if (self.settings.options) {
            for (i = 0, n = self.settings.options.length; i < n; i++) self.registerOption(self.settings.options[i]);
            delete self.settings.options
        }
        if (self.settings.optgroups) {
            for (i = 0, n = self.settings.optgroups.length; i < n; i++) self.registerOptionGroup(self.settings.optgroups[i]);
            delete self.settings.optgroups
        }
        self.settings.mode = self.settings.mode || (self.settings.maxItems ===
            1 ? "single" : "multi");
        if (typeof self.settings.hideSelected !== "boolean") self.settings.hideSelected = self.settings.mode === "multi";
        self.initializePlugins(self.settings.plugins);
        self.setupCallbacks();
        self.setupTemplates();
        self.setup()
    };
    MicroEvent.mixin(Selectize);
    MicroPlugin.mixin(Selectize);
    $.extend(Selectize.prototype, {
        setup: function() {
            var self = this;
            var settings = self.settings;
            var eventNS = self.eventNS;
            var $window = $(window);
            var $document = $(document);
            var $input = self.$input;
            var $wrapper;
            var $control;
            var $control_input;
            var $dropdown;
            var $dropdown_content;
            var $dropdown_parent;
            var inputMode;
            var timeout_blur;
            var timeout_focus;
            var classes;
            var classes_plugins;
            inputMode = self.settings.mode;
            classes = $input.attr("class") || "";

            function hasTouch() {
                return "ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch
            }
            $wrapper = $("<div>").addClass(settings.wrapperClass).addClass(classes).addClass(inputMode);
            $control = $("<div>").addClass(settings.inputClass).addClass("items").appendTo($wrapper);
            $control_input =
                $("<input " + (hasTouch() ? "readonly" : "") + ' type="text" autocomplete="off" />').appendTo($control).attr("tabindex", $input.is(":disabled") ? "-1" : self.tabIndex);
            $dropdown_parent = $(settings.dropdownParent || $wrapper);
            $dropdown = $("<div>").addClass(settings.dropdownClass).addClass(inputMode).hide().appendTo($dropdown_parent);
            $dropdown_content = $("<div>").addClass(settings.dropdownContentClass).appendTo($dropdown);
            var padding = Modernizr.mobile ? "70" : "140";
            $control_close = $('<iron-icon style="margin:2px;margin-left:' +
                padding + 'px;cursor:pointer;" icon="close" />').appendTo($dropdown);
            $control_close.on("click", function(e) {
                self.blur(e.target)
            });
            if (hasTouch()) {
                $control_keyboard = $('<iron-icon id="kon" float="right" style="margin:2px;margin-left:25px;cursor:pointer;" icon="hardware:keyboard" />').appendTo($dropdown);
                $control_keyboard_hide = $('<iron-icon id="koff" float="right" style="margin:2px;margin-left:25px;cursor:pointer;" icon="hardware:keyboard-hide" />').appendTo($dropdown);
                $control_keyboard[0].style.color = "#212121";
                $control_keyboard_hide[0].style.color = "#DDDDDD";
                var initial_screen_size = window.innerHeight;
                window.addEventListener("resize", function() {
                    var is_keyboard = window.innerHeight < initial_screen_size;
                    console.log("is_keyboard:", is_keyboard);
                    if (!is_keyboard) {
                        $control_input.attr("readonly", true);
                        $control_keyboard[0].style.color = "#212121";
                        $control_keyboard_hide[0].style.color = "#DDDDDD"
                    }
                }, false);
                $control_keyboard.on("click", function(e) {
                    $control_input.removeAttr("readonly");
                    $control_input.focus();
                    $control_keyboard[0].style.color =
                        "#DDDDDD";
                    $control_keyboard_hide[0].style.color = "#212121"
                });
                $control_keyboard_hide.on("click", function(e) {
                    $control_input.attr("readonly", true);
                    $control_keyboard[0].style.color = "#212121";
                    $control_keyboard_hide[0].style.color = "#DDDDDD"
                })
            }
            if (self.settings.copyClassesToDropdown) $dropdown.addClass(classes);
            $wrapper.css({
                width: $input[0].style.width
            });
            if (self.plugins.names.length) {
                classes_plugins = "plugin-" + self.plugins.names.join(" plugin-");
                $wrapper.addClass(classes_plugins);
                $dropdown.addClass(classes_plugins)
            }
            if ((settings.maxItems ===
                    null || settings.maxItems > 1) && self.tagType === TAG_SELECT) $input.attr("multiple", "multiple");
            if (self.settings.placeholder) $control_input.attr("placeholder", settings.placeholder);
            if (!self.settings.splitOn && self.settings.delimiter) {
                var delimiterEscaped = self.settings.delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
                self.settings.splitOn = new RegExp("\\s*" + delimiterEscaped + "+\\s*")
            }
            if ($input.attr("autocorrect")) $control_input.attr("autocorrect", $input.attr("autocorrect"));
            if ($input.attr("autocapitalize")) $control_input.attr("autocapitalize",
                $input.attr("autocapitalize"));
            self.$wrapper = $wrapper;
            self.$control = $control;
            self.$control_input = $control_input;
            self.$dropdown = $dropdown;
            self.$dropdown_content = $dropdown_content;
            $dropdown.on("mouseenter", "[data-selectable]", function() {
                return self.onOptionHover.apply(self, arguments)
            });
            $dropdown.on("mousedown click", "[data-selectable]", function() {
                return self.onOptionSelect.apply(self, arguments)
            });
            watchChildEvent($control, "mousedown", "*:not(input)", function() {
                return self.onItemSelect.apply(self, arguments)
            });
            autoGrow($control_input);
            $control.on({
                mousedown: function() {
                    return self.onMouseDown.apply(self, arguments)
                },
                click: function() {
                    return self.onClick.apply(self, arguments)
                }
            });
            $control_input.on({
                mousedown: function(e) {
                    e.stopPropagation()
                },
                keydown: function() {
                    return self.onKeyDown.apply(self, arguments)
                },
                keyup: function() {
                    return self.onKeyUp.apply(self, arguments)
                },
                keypress: function() {
                    return self.onKeyPress.apply(self, arguments)
                },
                resize: function() {
                    self.positionDropdown.apply(self, [])
                },
                blur: function() {
                    return self.onBlur.apply(self,
                        arguments)
                },
                focus: function() {
                    self.ignoreBlur = false;
                    if (hasTouch()) return self.onFocus.apply(self, arguments)
                },
                paste: function() {
                    return self.onPaste.apply(self, arguments)
                }
            });
            $document.on("keydown" + eventNS, function(e) {
                self.isCmdDown = e[IS_MAC ? "metaKey" : "ctrlKey"];
                self.isCtrlDown = e[IS_MAC ? "altKey" : "ctrlKey"];
                self.isShiftDown = e.shiftKey
            });
            $document.on("keyup" + eventNS, function(e) {
                if (e.keyCode === KEY_CTRL) self.isCtrlDown = false;
                if (e.keyCode === KEY_SHIFT) self.isShiftDown = false;
                if (e.keyCode === KEY_CMD) self.isCmdDown =
                    false
            });
            $document.on("mousedown" + eventNS, function(e) {
                if (self.isFocused) {
                    if (e.target === self.$dropdown[0] || e.target.parentNode === self.$dropdown[0]) return false;
                    if (!self.$control.has(e.target).length && e.target !== self.$control[0]) self.blur(e.target)
                }
            });
            $window.on(["scroll" + eventNS, "resize" + eventNS].join(" "), function() {
                if (self.isOpen) self.positionDropdown.apply(self, arguments)
            });
            $window.on("mousemove" + eventNS, function() {
                self.ignoreHover = false
            });
            this.revertSettings = {
                $children: $input.children().detach(),
                tabindex: $input.attr("tabindex")
            };
            $input.attr("tabindex", -1).hide().after(self.$wrapper);
            if ($.isArray(settings.items)) {
                self.setValue(settings.items);
                delete settings.items
            }
            if (SUPPORTS_VALIDITY_API) $input.on("invalid" + eventNS, function(e) {
                e.preventDefault();
                self.isInvalid = true;
                self.refreshState()
            });
            self.updateOriginalInput();
            self.refreshItems();
            self.refreshState();
            self.updatePlaceholder();
            self.isSetup = true;
            if ($input.is(":disabled")) self.disable();
            self.on("change", this.onChange);
            $input.data("selectize",
                self);
            $input.addClass("selectized");
            self.trigger("initialize");
            if (settings.preload === true) self.onSearchChange("")
        },
        setupTemplates: function() {
            var self = this;
            var field_label = self.settings.labelField;
            var field_optgroup = self.settings.optgroupLabelField;
            var templates = {
                "optgroup": function(data) {
                    return '<div class="optgroup">' + data.html + "</div>"
                },
                "optgroup_header": function(data, escape) {
                    return '<div class="optgroup-header">' + escape(data[field_optgroup]) + "</div>"
                },
                "option": function(data, escape) {
                    return '<div class="option">' +
                        escape(data[field_label]) + "</div>"
                },
                "item": function(data, escape) {
                    return '<div class="item">' + escape(data[field_label]) + "</div>"
                },
                "option_create": function(data, escape) {
                    return '<div class="create">Add <strong>' + escape(data.input) + "</strong>&hellip;</div>"
                }
            };
            self.settings.render = $.extend({}, templates, self.settings.render)
        },
        setupCallbacks: function() {
            var key, fn, callbacks = {
                "initialize": "onInitialize",
                "change": "onChange",
                "item_add": "onItemAdd",
                "item_remove": "onItemRemove",
                "clear": "onClear",
                "option_add": "onOptionAdd",
                "option_remove": "onOptionRemove",
                "option_clear": "onOptionClear",
                "optgroup_add": "onOptionGroupAdd",
                "optgroup_remove": "onOptionGroupRemove",
                "optgroup_clear": "onOptionGroupClear",
                "dropdown_open": "onDropdownOpen",
                "dropdown_close": "onDropdownClose",
                "type": "onType",
                "load": "onLoad",
                "focus": "onFocus",
                "blur": "onBlur"
            };
            for (key in callbacks)
                if (callbacks.hasOwnProperty(key)) {
                    fn = this.settings[callbacks[key]];
                    if (fn) this.on(key, fn)
                }
        },
        onClick: function(e) {
            var self = this;
            if (!self.isFocused) {
                self.focus();
                e.preventDefault()
            }
        },
        onMouseDown: function(e) {
            var self = this;
            var defaultPrevented = e.isDefaultPrevented();
            var $target = $(e.target);
            if (self.isFocused) {
                if (e.target !== self.$control_input[0]) {
                    if (self.settings.mode === "multi" && !defaultPrevented) {
                        if (!self.isOpen) self.open();
                        self.setActiveItem(null)
                    } else self.isOpen ? self.close() : self.open();
                    return false
                }
            } else if (!defaultPrevented) window.setTimeout(function() {
                self.focus()
            }, 0)
        },
        onChange: function() {
            this.$input.trigger("change")
        },
        onPaste: function(e) {
            var self = this;
            if (self.isFull() || self.isInputHidden ||
                self.isLocked) e.preventDefault();
            else if (self.settings.splitOn) setTimeout(function() {
                var splitInput = $.trim(self.$control_input.val() || "").split(self.settings.splitOn);
                for (var i = 0, n = splitInput.length; i < n; i++) self.createItem(splitInput[i])
            }, 0)
        },
        onKeyPress: function(e) {
            if (this.isLocked) return e && e.preventDefault();
            var character = String.fromCharCode(e.keyCode || e.which);
            if (this.settings.create && this.settings.mode === "multi" && character === this.settings.delimiter) {
                this.createItem();
                e.preventDefault();
                return false
            }
        },
        onKeyDown: function(e) {
            var isInput = e.target === this.$control_input[0];
            var self = this;
            if (self.isLocked) {
                if (e.keyCode !== KEY_TAB) e.preventDefault();
                return
            }
            switch (e.keyCode) {
                case KEY_A:
                    if (self.isCmdDown) {
                        self.selectAll();
                        return
                    }
                    break;
                case KEY_ESC:
                    if (self.isOpen) {
                        e.preventDefault();
                        e.stopPropagation();
                        self.close()
                    }
                    return;
                case KEY_N:
                    if (!e.ctrlKey || e.altKey) break;
                case KEY_DOWN:
                    if (!self.isOpen && self.hasOptions) self.open();
                    else if (self.$activeOption) {
                        self.ignoreHover = true;
                        var $next = self.getAdjacentOption(self.$activeOption,
                            1);
                        if ($next.length) self.setActiveOption($next, true, true)
                    }
                    e.preventDefault();
                    return;
                case KEY_P:
                    if (!e.ctrlKey || e.altKey) break;
                case KEY_UP:
                    if (self.$activeOption) {
                        self.ignoreHover = true;
                        var $prev = self.getAdjacentOption(self.$activeOption, -1);
                        if ($prev.length) self.setActiveOption($prev, true, true)
                    }
                    e.preventDefault();
                    return;
                case KEY_RETURN:
                    if (self.isOpen && self.$activeOption) {
                        self.onOptionSelect({
                            currentTarget: self.$activeOption
                        });
                        e.preventDefault()
                    }
                    return;
                case KEY_LEFT:
                    self.advanceSelection(-1, e);
                    return;
                case KEY_RIGHT:
                    self.advanceSelection(1,
                        e);
                    return;
                case KEY_TAB:
                    if (self.settings.selectOnTab && self.isOpen && self.$activeOption) {
                        self.onOptionSelect({
                            currentTarget: self.$activeOption
                        });
                        if (!self.isFull()) e.preventDefault()
                    }
                    if (self.settings.create && self.createItem()) e.preventDefault();
                    return;
                case KEY_BACKSPACE:
                case KEY_DELETE:
                    self.deleteSelection(e);
                    return
            }
            if ((self.isFull() || self.isInputHidden) && !(IS_MAC ? e.metaKey : e.ctrlKey)) {
                e.preventDefault();
                return
            }
        },
        onKeyUp: function(e) {
            var self = this;
            if (self.isLocked) return e && e.preventDefault();
            var value =
                self.$control_input.val() || "";
            if (self.lastValue !== value) {
                self.lastValue = value;
                self.onSearchChange(value);
                self.refreshOptions();
                self.trigger("type", value)
            }
        },
        onSearchChange: function(value) {
            var self = this;
            var fn = self.settings.load;
            if (!fn) return;
            if (self.loadedSearches.hasOwnProperty(value)) return;
            self.loadedSearches[value] = true;
            self.load(function(callback) {
                fn.apply(self, [value, callback])
            })
        },
        onFocus: function(e) {
            var self = this;
            var wasFocused = self.isFocused;
            if (self.isDisabled) {
                self.blur();
                e && e.preventDefault();
                return false
            }
            if (self.ignoreFocus) return;
            self.isFocused = true;
            if (self.settings.preload === "focus") self.onSearchChange("");
            if (!wasFocused) self.trigger("focus");
            if (!self.$activeItems.length) {
                self.showInput();
                self.setActiveItem(null);
                self.refreshOptions(!!self.settings.openOnFocus)
            }
            self.refreshState()
        },
        onBlur: function(e, dest) {
            var self = this;
            if (!self.isFocused) return;
            self.isFocused = false;
            if (self.ignoreFocus) return;
            else if (!self.ignoreBlur && document.activeElement === self.$dropdown_content[0]) {
                self.ignoreBlur =
                    true;
                self.onFocus(e);
                return
            }
            var deactivate = function() {
                self.close();
                self.setTextboxValue("");
                self.setActiveItem(null);
                self.setActiveOption(null);
                self.setCaret(self.items.length);
                self.refreshState();
                (dest || document.body).focus();
                self.ignoreFocus = false;
                self.trigger("blur")
            };
            self.ignoreFocus = true;
            if (self.settings.create && self.settings.createOnBlur) self.createItem(null, false, deactivate);
            else deactivate()
        },
        onOptionHover: function(e) {
            if (this.ignoreHover) return;
            this.setActiveOption(e.currentTarget, false)
        },
        onOptionSelect: function(e) {
            var value, $target, $option, self = this;
            if (e.preventDefault) {
                e.preventDefault();
                e.stopPropagation()
            }
            $target = $(e.currentTarget);
            if ($target.hasClass("create")) self.createItem(null, function() {
                if (self.settings.closeAfterSelect) self.close()
            });
            else {
                value = $target.attr("data-value");
                if (typeof value !== "undefined") {
                    self.lastQuery = null;
                    self.setTextboxValue("");
                    self.addItem(value);
                    if (self.settings.closeAfterSelect) self.close();
                    else if (!self.settings.hideSelected && e.type && /mouse/.test(e.type)) self.setActiveOption(self.getOption(value))
                }
            }
        },
        onItemSelect: function(e) {
            var self = this;
            if (self.isLocked) return;
            if (self.settings.mode === "multi") {
                e.preventDefault();
                self.setActiveItem(e.currentTarget, e)
            }
        },
        load: function(fn) {
            var self = this;
            var $wrapper = self.$wrapper.addClass(self.settings.loadingClass);
            self.loading++;
            fn.apply(self, [function(results) {
                self.loading = Math.max(self.loading - 1, 0);
                if (results && results.length) {
                    self.addOption(results);
                    self.refreshOptions(self.isFocused && !self.isInputHidden)
                }
                if (!self.loading) $wrapper.removeClass(self.settings.loadingClass);
                self.trigger("load", results)
            }])
        },
        setTextboxValue: function(value) {
            var $input = this.$control_input;
            var changed = $input.val() !== value;
            if (changed) {
                $input.val(value).triggerHandler("update");
                this.lastValue = value
            }
        },
        getValue: function() {
            if (this.tagType === TAG_SELECT && this.$input.attr("multiple")) return this.items;
            else return this.items.join(this.settings.delimiter)
        },
        setValue: function(value, silent) {
            var events = silent ? [] : ["change"];
            debounce_events(this, events, function() {
                this.clear(silent);
                this.addItems(value, silent)
            })
        },
        setActiveItem: function($item, e) {
            var self = this;
            var eventName;
            var i, idx, begin, end, item, swap;
            var $last;
            if (self.settings.mode === "single") return;
            $item = $($item);
            if (!$item.length) {
                $(self.$activeItems).removeClass("active");
                self.$activeItems = [];
                if (self.isFocused) self.showInput();
                return
            }
            eventName = e && e.type.toLowerCase();
            if (eventName === "mousedown" && self.isShiftDown && self.$activeItems.length) {
                $last = self.$control.children(".active:last");
                begin = Array.prototype.indexOf.apply(self.$control[0].childNodes, [$last[0]]);
                end = Array.prototype.indexOf.apply(self.$control[0].childNodes, [$item[0]]);
                if (begin > end) {
                    swap = begin;
                    begin = end;
                    end = swap
                }
                for (i = begin; i <= end; i++) {
                    item = self.$control[0].childNodes[i];
                    if (self.$activeItems.indexOf(item) === -1) {
                        $(item).addClass("active");
                        self.$activeItems.push(item)
                    }
                }
                e.preventDefault()
            } else if (eventName === "mousedown" && self.isCtrlDown || eventName === "keydown" && this.isShiftDown)
                if ($item.hasClass("active")) {
                    idx = self.$activeItems.indexOf($item[0]);
                    self.$activeItems.splice(idx, 1);
                    $item.removeClass("active")
                } else self.$activeItems.push($item.addClass("active")[0]);
            else {
                $(self.$activeItems).removeClass("active");
                self.$activeItems = [$item.addClass("active")[0]]
            }
            self.hideInput();
            if (!this.isFocused) self.focus()
        },
        setActiveOption: function($option, scroll, animate) {
            var height_menu, height_item, y;
            var scroll_top, scroll_bottom;
            var self = this;
            if (self.$activeOption) self.$activeOption.removeClass("active");
            self.$activeOption = null;
            $option = $($option);
            if (!$option.length) return;
            self.$activeOption = $option.addClass("active");
            if (scroll || !isset(scroll)) {
                height_menu = self.$dropdown_content.height();
                height_item = self.$activeOption.outerHeight(true);
                scroll = self.$dropdown_content.scrollTop() || 0;
                y = self.$activeOption.offset().top - self.$dropdown_content.offset().top + scroll;
                scroll_top = y;
                scroll_bottom = y - height_menu + height_item;
                if (y + height_item > height_menu + scroll) self.$dropdown_content.stop().animate({
                    scrollTop: scroll_bottom
                }, animate ? self.settings.scrollDuration : 0);
                else if (y < scroll) self.$dropdown_content.stop().animate({
                    scrollTop: scroll_top
                }, animate ? self.settings.scrollDuration : 0)
            }
        },
        selectAll: function() {
            var self =
                this;
            if (self.settings.mode === "single") return;
            self.$activeItems = Array.prototype.slice.apply(self.$control.children(":not(input)").addClass("active"));
            if (self.$activeItems.length) {
                self.hideInput();
                self.close()
            }
            self.focus()
        },
        hideInput: function() {
            var self = this;
            self.setTextboxValue("");
            self.$control_input.css({
                opacity: 0,
                position: "absolute",
                left: self.rtl ? 1E4 : -1E4
            });
            self.isInputHidden = true
        },
        showInput: function() {
            this.$control_input.css({
                opacity: 1,
                position: "relative",
                left: 0
            });
            this.isInputHidden = false
        },
        focus: function() {
            var self =
                this;
            if (self.isDisabled) return;
            self.ignoreFocus = true;
            self.$control_input[0].focus();
            window.setTimeout(function() {
                self.ignoreFocus = false;
                self.onFocus()
            }, 0)
        },
        blur: function(dest) {
            this.$control_input[0].blur();
            this.onBlur(null, dest)
        },
        getScoreFunction: function(query) {
            return this.sifter.getScoreFunction(query, this.getSearchOptions())
        },
        getSearchOptions: function() {
            var settings = this.settings;
            var sort = settings.sortField;
            if (typeof sort === "string") sort = [{
                field: sort
            }];
            return {
                fields: settings.searchField,
                conjunction: settings.searchConjunction,
                sort: sort
            }
        },
        search: function(query) {
            var i, value, score, result, calculateScore;
            var self = this;
            var settings = self.settings;
            var options = this.getSearchOptions();
            if (settings.score) {
                calculateScore = self.settings.score.apply(this, [query]);
                if (typeof calculateScore !== "function") throw new Error('Selectize "score" setting must be a function that returns a function');
            }
            if (query !== self.lastQuery) {
                self.lastQuery = query;
                result = self.sifter.search(query, $.extend(options, {
                    score: calculateScore
                }));
                self.currentResults = result
            } else result =
                $.extend(true, {}, self.currentResults);
            if (settings.hideSelected)
                for (i = result.items.length - 1; i >= 0; i--)
                    if (self.items.indexOf(hash_key(result.items[i].id)) !== -1) result.items.splice(i, 1);
            return result
        },
        refreshOptions: function(triggerDropdown) {
            var i, j, k, n, groups, groups_order, option, option_html, optgroup, optgroups, html, html_children, has_create_option;
            var $active, $active_before, $create;
            if (typeof triggerDropdown === "undefined") triggerDropdown = true;
            var self = this;
            var query = $.trim(self.$control_input.val());
            var results =
                self.search(query);
            var $dropdown_content = self.$dropdown_content;
            var active_before = self.$activeOption && hash_key(self.$activeOption.attr("data-value"));
            n = results.items.length;
            if (typeof self.settings.maxOptions === "number") n = Math.min(n, self.settings.maxOptions);
            groups = {};
            groups_order = [];
            for (i = 0; i < n; i++) {
                option = self.options[results.items[i].id];
                option_html = self.render("option", option);
                optgroup = option[self.settings.optgroupField] || "";
                optgroups = $.isArray(optgroup) ? optgroup : [optgroup];
                for (j = 0, k = optgroups &&
                    optgroups.length; j < k; j++) {
                    optgroup = optgroups[j];
                    if (!self.optgroups.hasOwnProperty(optgroup)) optgroup = "";
                    if (!groups.hasOwnProperty(optgroup)) {
                        groups[optgroup] = document.createDocumentFragment();
                        groups_order.push(optgroup)
                    }
                    groups[optgroup].appendChild(option_html)
                }
            }
            if (this.settings.lockOptgroupOrder) groups_order.sort(function(a, b) {
                var a_order = self.optgroups[a].$order || 0;
                var b_order = self.optgroups[b].$order || 0;
                return a_order - b_order
            });
            html = document.createDocumentFragment();
            for (i = 0, n = groups_order.length; i <
                n; i++) {
                optgroup = groups_order[i];
                if (self.optgroups.hasOwnProperty(optgroup) && groups[optgroup].childNodes.length) {
                    html_children = document.createDocumentFragment();
                    html_children.appendChild(self.render("optgroup_header", self.optgroups[optgroup]));
                    html_children.appendChild(groups[optgroup]);
                    html.appendChild(self.render("optgroup", $.extend({}, self.optgroups[optgroup], {
                        html: domToString(html_children),
                        dom: html_children
                    })))
                } else html.appendChild(groups[optgroup])
            }
            $dropdown_content.html(html);
            if (self.settings.highlight &&
                results.query.length && results.tokens.length)
                for (i = 0, n = results.tokens.length; i < n; i++) highlight($dropdown_content, results.tokens[i].regex);
            if (!self.settings.hideSelected)
                for (i = 0, n = self.items.length; i < n; i++) self.getOption(self.items[i]).addClass("selected");
            has_create_option = self.canCreate(query);
            if (has_create_option) {
                $dropdown_content.prepend(self.render("option_create", {
                    input: query
                }));
                $create = $($dropdown_content[0].childNodes[0])
            }
            self.hasOptions = results.items.length > 0 || has_create_option;
            if (self.hasOptions) {
                if (results.items.length >
                    0) {
                    $active_before = active_before && self.getOption(active_before);
                    if ($active_before && $active_before.length) $active = $active_before;
                    else if (self.settings.mode === "single" && self.items.length) $active = self.getOption(self.items[0]);
                    if (!$active || !$active.length)
                        if ($create && !self.settings.addPrecedence) $active = self.getAdjacentOption($create, 1);
                        else $active = $dropdown_content.find("[data-selectable]:first")
                } else $active = $create;
                self.setActiveOption($active);
                if (triggerDropdown && !self.isOpen) self.open()
            } else {
                self.setActiveOption(null);
                if (triggerDropdown && self.isOpen) self.close()
            }
        },
        addOption: function(data) {
            var i, n, value, self = this;
            if ($.isArray(data)) {
                for (i = 0, n = data.length; i < n; i++) self.addOption(data[i]);
                return
            }
            if (value = self.registerOption(data)) {
                self.userOptions[value] = true;
                self.lastQuery = null;
                self.trigger("option_add", value, data)
            }
        },
        registerOption: function(data) {
            var key = hash_key(data[this.settings.valueField]);
            if (!key || this.options.hasOwnProperty(key)) return false;
            data.$order = data.$order || ++this.order;
            this.options[key] = data;
            return key
        },
        registerOptionGroup: function(data) {
            var key = hash_key(data[this.settings.optgroupValueField]);
            if (!key) return false;
            data.$order = data.$order || ++this.order;
            this.optgroups[key] = data;
            return key
        },
        addOptionGroup: function(id, data) {
            data[this.settings.optgroupValueField] = id;
            if (id = this.registerOptionGroup(data)) this.trigger("optgroup_add", id, data)
        },
        removeOptionGroup: function(id) {
            if (this.optgroups.hasOwnProperty(id)) {
                delete this.optgroups[id];
                this.renderCache = {};
                this.trigger("optgroup_remove", id)
            }
        },
        clearOptionGroups: function() {
            this.optgroups = {};
            this.renderCache = {};
            this.trigger("optgroup_clear")
        },
        updateOption: function(value, data) {
            var self = this;
            var $item, $item_new;
            var value_new, index_item, cache_items, cache_options, order_old;
            value = hash_key(value);
            value_new = hash_key(data[self.settings.valueField]);
            if (value === null) return;
            if (!self.options.hasOwnProperty(value)) return;
            if (typeof value_new !== "string") throw new Error("Value must be set in option data");
            order_old = self.options[value].$order;
            if (value_new !== value) {
                delete self.options[value];
                index_item =
                    self.items.indexOf(value);
                if (index_item !== -1) self.items.splice(index_item, 1, value_new)
            }
            data.$order = data.$order || order_old;
            self.options[value_new] = data;
            cache_items = self.renderCache["item"];
            cache_options = self.renderCache["option"];
            if (cache_items) {
                delete cache_items[value];
                delete cache_items[value_new]
            }
            if (cache_options) {
                delete cache_options[value];
                delete cache_options[value_new]
            }
            if (self.items.indexOf(value_new) !== -1) {
                $item = self.getItem(value);
                $item_new = $(self.render("item", data));
                if ($item.hasClass("active")) $item_new.addClass("active");
                $item.replaceWith($item_new)
            }
            self.lastQuery = null;
            if (self.isOpen) self.refreshOptions(false)
        },
        removeOption: function(value, silent) {
            var self = this;
            value = hash_key(value);
            var cache_items = self.renderCache["item"];
            var cache_options = self.renderCache["option"];
            if (cache_items) delete cache_items[value];
            if (cache_options) delete cache_options[value];
            delete self.userOptions[value];
            delete self.options[value];
            self.lastQuery = null;
            self.trigger("option_remove", value);
            self.removeItem(value, silent)
        },
        clearOptions: function() {
            var self =
                this;
            self.loadedSearches = {};
            self.userOptions = {};
            self.renderCache = {};
            self.options = self.sifter.items = {};
            self.lastQuery = null;
            self.trigger("option_clear");
            self.clear()
        },
        getOption: function(value) {
            return this.getElementWithValue(value, this.$dropdown_content.find("[data-selectable]"))
        },
        getAdjacentOption: function($option, direction) {
            var $options = this.$dropdown.find("[data-selectable]");
            var index = $options.index($option) + direction;
            return index >= 0 && index < $options.length ? $options.eq(index) : $()
        },
        getElementWithValue: function(value,
            $els) {
            value = hash_key(value);
            if (typeof value !== "undefined" && value !== null)
                for (var i = 0, n = $els.length; i < n; i++)
                    if ($els[i].getAttribute("data-value") === value) return $($els[i]);
            return $()
        },
        getItem: function(value) {
            return this.getElementWithValue(value, this.$control.children())
        },
        addItems: function(values, silent) {
            var items = $.isArray(values) ? values : [values];
            for (var i = 0, n = items.length; i < n; i++) {
                this.isPending = i < n - 1;
                this.addItem(items[i], silent)
            }
        },
        addItem: function(value, silent) {
            var events = silent ? [] : ["change"];
            debounce_events(this,
                events,
                function() {
                    var $item, $option, $options;
                    var self = this;
                    var inputMode = self.settings.mode;
                    var i, active, value_next, wasFull;
                    value = hash_key(value);
                    if (self.items.indexOf(value) !== -1) {
                        if (inputMode === "single") self.close();
                        return
                    }
                    if (!self.options.hasOwnProperty(value)) return;
                    if (inputMode === "single") self.clear(silent);
                    if (inputMode === "multi" && self.isFull()) return;
                    $item = $(self.render("item", self.options[value]));
                    wasFull = self.isFull();
                    self.items.splice(self.caretPos, 0, value);
                    self.insertAtCaret($item);
                    if (!self.isPending ||
                        !wasFull && self.isFull()) self.refreshState();
                    if (self.isSetup) {
                        $options = self.$dropdown_content.find("[data-selectable]");
                        if (!self.isPending) {
                            $option = self.getOption(value);
                            value_next = self.getAdjacentOption($option, 1).attr("data-value");
                            self.refreshOptions(self.isFocused && inputMode !== "single");
                            if (value_next) self.setActiveOption(self.getOption(value_next))
                        }
                        if (!$options.length || self.isFull()) self.close();
                        else self.positionDropdown();
                        self.updatePlaceholder();
                        self.trigger("item_add", value, $item);
                        self.updateOriginalInput({
                            silent: silent
                        })
                    }
                })
        },
        removeItem: function(value, silent) {
            var self = this;
            var $item, i, idx;
            $item = typeof value === "object" ? value : self.getItem(value);
            value = hash_key($item.attr("data-value"));
            i = self.items.indexOf(value);
            if (i !== -1) {
                $item.remove();
                if ($item.hasClass("active")) {
                    idx = self.$activeItems.indexOf($item[0]);
                    self.$activeItems.splice(idx, 1)
                }
                self.items.splice(i, 1);
                self.lastQuery = null;
                if (!self.settings.persist && self.userOptions.hasOwnProperty(value)) self.removeOption(value, silent);
                if (i < self.caretPos) self.setCaret(self.caretPos -
                    1);
                self.refreshState();
                self.updatePlaceholder();
                self.updateOriginalInput({
                    silent: silent
                });
                self.positionDropdown();
                self.trigger("item_remove", value, $item)
            }
        },
        createItem: function(input, triggerDropdown) {
            var self = this;
            var caret = self.caretPos;
            input = input || $.trim(self.$control_input.val() || "");
            var callback = arguments[arguments.length - 1];
            if (typeof callback !== "function") callback = function() {};
            if (typeof triggerDropdown !== "boolean") triggerDropdown = true;
            if (!self.canCreate(input)) {
                callback();
                return false
            }
            self.lock();
            var setup = typeof self.settings.create === "function" ? this.settings.create : function(input) {
                var data = {};
                data[self.settings.labelField] = input;
                data[self.settings.valueField] = input;
                return data
            };
            var create = once(function(data) {
                self.unlock();
                if (!data || typeof data !== "object") return callback();
                var value = hash_key(data[self.settings.valueField]);
                if (typeof value !== "string") return callback();
                self.setTextboxValue("");
                self.addOption(data);
                self.setCaret(caret);
                self.addItem(value);
                self.refreshOptions(triggerDropdown &&
                    self.settings.mode !== "single");
                callback(data)
            });
            var output = setup.apply(this, [input, create]);
            if (typeof output !== "undefined") create(output);
            return true
        },
        refreshItems: function() {
            this.lastQuery = null;
            if (this.isSetup) this.addItem(this.items);
            this.refreshState();
            this.updateOriginalInput()
        },
        refreshState: function() {
            var invalid, self = this;
            if (self.isRequired) {
                if (self.items.length) self.isInvalid = false;
                self.$control_input.prop("required", invalid)
            }
            self.refreshClasses()
        },
        refreshClasses: function() {
            var self = this;
            var isFull =
                self.isFull();
            var isLocked = self.isLocked;
            self.$wrapper.toggleClass("rtl", self.rtl);
            self.$control.toggleClass("focus", self.isFocused).toggleClass("disabled", self.isDisabled).toggleClass("required", self.isRequired).toggleClass("invalid", self.isInvalid).toggleClass("locked", isLocked).toggleClass("full", isFull).toggleClass("not-full", !isFull).toggleClass("input-active", self.isFocused && !self.isInputHidden).toggleClass("dropdown-active", self.isOpen).toggleClass("has-options", !$.isEmptyObject(self.options)).toggleClass("has-items",
                self.items.length > 0);
            self.$control_input.data("grow", !isFull && !isLocked)
        },
        isFull: function() {
            return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems
        },
        updateOriginalInput: function(opts) {
            var i, n, options, label, self = this;
            opts = opts || {};
            if (self.tagType === TAG_SELECT) {
                options = [];
                for (i = 0, n = self.items.length; i < n; i++) {
                    label = self.options[self.items[i]][self.settings.labelField] || "";
                    options.push('<option value="' + escape_html(self.items[i]) + '" selected="selected">' + escape_html(label) + "</option>")
                }
                if (!options.length &&
                    !this.$input.attr("multiple")) options.push('<option value="" selected="selected"></option>');
                self.$input.html(options.join(""))
            } else {
                self.$input.val(self.getValue());
                self.$input.attr("value", self.$input.val())
            }
            if (self.isSetup)
                if (!opts.silent) self.trigger("change", self.$input.val())
        },
        updatePlaceholder: function() {
            if (!this.settings.placeholder) return;
            var $input = this.$control_input;
            if (this.items.length) $input.removeAttr("placeholder");
            else $input.attr("placeholder", this.settings.placeholder);
            $input.triggerHandler("update", {
                force: true
            })
        },
        open: function() {
            var self = this;
            if (self.isLocked || self.isOpen || self.settings.mode === "multi" && self.isFull()) return;
            self.focus();
            self.isOpen = true;
            self.refreshState();
            self.$dropdown.css({
                visibility: "hidden",
                display: "block"
            });
            self.positionDropdown();
            self.$dropdown.css({
                visibility: "visible"
            });
            self.trigger("dropdown_open", self.$dropdown)
        },
        close: function() {
            var self = this;
            var trigger = self.isOpen;
            if (self.settings.mode === "single" && self.items.length) self.hideInput();
            self.isOpen = false;
            self.$dropdown.hide();
            self.setActiveOption(null);
            self.refreshState();
            if (trigger) self.trigger("dropdown_close", self.$dropdown)
        },
        positionDropdown: function() {
            var $control = this.$control;
            var offset = this.settings.dropdownParent === "body" ? $control.offset() : $control.position();
            offset.top += $control.outerHeight(true);
            this.$dropdown.css({
                width: $control.outerWidth(),
                top: offset.top,
                left: offset.left
            })
        },
        clear: function(silent) {
            var self = this;
            if (!self.items.length) return;
            self.$control.children(":not(input)").remove();
            self.items = [];
            self.lastQuery =
                null;
            self.setCaret(0);
            self.setActiveItem(null);
            self.updatePlaceholder();
            self.updateOriginalInput({
                silent: silent
            });
            self.refreshState();
            self.showInput();
            self.trigger("clear")
        },
        insertAtCaret: function($el) {
            var caret = Math.min(this.caretPos, this.items.length);
            if (caret === 0) this.$control.prepend($el);
            else $(this.$control[0].childNodes[caret]).before($el);
            this.setCaret(caret + 1)
        },
        deleteSelection: function(e) {
            var i, n, direction, selection, values, caret, option_select, $option_select, $tail;
            var self = this;
            direction =
                e && e.keyCode === KEY_BACKSPACE ? -1 : 1;
            selection = getSelection(self.$control_input[0]);
            if (self.$activeOption && !self.settings.hideSelected) option_select = self.getAdjacentOption(self.$activeOption, -1).attr("data-value");
            values = [];
            if (self.$activeItems.length) {
                $tail = self.$control.children(".active:" + (direction > 0 ? "last" : "first"));
                caret = self.$control.children(":not(input)").index($tail);
                if (direction > 0) caret++;
                for (i = 0, n = self.$activeItems.length; i < n; i++) values.push($(self.$activeItems[i]).attr("data-value"));
                if (e) {
                    e.preventDefault();
                    e.stopPropagation()
                }
            } else if ((self.isFocused || self.settings.mode === "single") && self.items.length)
                if (direction < 0 && selection.start === 0 && selection.length === 0) values.push(self.items[self.caretPos - 1]);
                else if (direction > 0 && selection.start === self.$control_input.val().length) values.push(self.items[self.caretPos]);
            if (!values.length || typeof self.settings.onDelete === "function" && self.settings.onDelete.apply(self, [values]) === false) return false;
            if (typeof caret !== "undefined") self.setCaret(caret);
            while (values.length) self.removeItem(values.pop());
            self.showInput();
            self.positionDropdown();
            self.refreshOptions(true);
            if (option_select) {
                $option_select = self.getOption(option_select);
                if ($option_select.length) self.setActiveOption($option_select)
            }
            return true
        },
        advanceSelection: function(direction, e) {
            var tail, selection, idx, valueLength, cursorAtEdge, $tail;
            var self = this;
            if (direction === 0) return;
            if (self.rtl) direction *= -1;
            tail = direction > 0 ? "last" : "first";
            selection = getSelection(self.$control_input[0]);
            if (self.isFocused && !self.isInputHidden) {
                valueLength = self.$control_input.val().length;
                cursorAtEdge = direction < 0 ? selection.start === 0 && selection.length === 0 : selection.start === valueLength;
                if (cursorAtEdge && !valueLength) self.advanceCaret(direction, e)
            } else {
                $tail = self.$control.children(".active:" + tail);
                if ($tail.length) {
                    idx = self.$control.children(":not(input)").index($tail);
                    self.setActiveItem(null);
                    self.setCaret(direction > 0 ? idx + 1 : idx)
                }
            }
        },
        advanceCaret: function(direction, e) {
            var self = this,
                fn, $adj;
            if (direction === 0) return;
            fn = direction > 0 ? "next" : "prev";
            if (self.isShiftDown) {
                $adj = self.$control_input[fn]();
                if ($adj.length) {
                    self.hideInput();
                    self.setActiveItem($adj);
                    e && e.preventDefault()
                }
            } else self.setCaret(self.caretPos + direction)
        },
        setCaret: function(i) {
            var self = this;
            if (self.settings.mode === "single") i = self.items.length;
            else i = Math.max(0, Math.min(self.items.length, i));
            if (!self.isPending) {
                var j, n, fn, $children, $child;
                $children = self.$control.children(":not(input)");
                for (j = 0, n = $children.length; j < n; j++) {
                    $child = $($children[j]).detach();
                    if (j < i) self.$control_input.before($child);
                    else self.$control.append($child)
                }
            }
            self.caretPos =
                i
        },
        lock: function() {
            this.close();
            this.isLocked = true;
            this.refreshState()
        },
        unlock: function() {
            this.isLocked = false;
            this.refreshState()
        },
        disable: function() {
            var self = this;
            self.$input.prop("disabled", true);
            self.$control_input.prop("disabled", true).prop("tabindex", -1);
            self.isDisabled = true;
            self.lock()
        },
        enable: function() {
            var self = this;
            self.$input.prop("disabled", false);
            self.$control_input.prop("disabled", false).prop("tabindex", self.tabIndex);
            self.isDisabled = false;
            self.unlock()
        },
        destroy: function() {
            var self = this;
            var eventNS = self.eventNS;
            var revertSettings = self.revertSettings;
            self.trigger("destroy");
            self.off();
            self.$wrapper.remove();
            self.$dropdown.remove();
            self.$input.html("").append(revertSettings.$children).removeAttr("tabindex").removeClass("selectized").attr({
                tabindex: revertSettings.tabindex
            }).show();
            self.$control_input.removeData("grow");
            self.$input.removeData("selectize");
            $(window).off(eventNS);
            $(document).off(eventNS);
            $(document.body).off(eventNS);
            delete self.$input[0].selectize
        },
        render: function(templateName,
            data) {
            var value, id, label;
            var html = "";
            var cache = false;
            var self = this;
            var regex_tag = /^[\t \r\n]*<([a-z][a-z0-9\-_]*(?:\:[a-z][a-z0-9\-_]*)?)/i;
            if (templateName === "option" || templateName === "item") {
                value = hash_key(data[self.settings.valueField]);
                cache = !!value
            }
            if (cache) {
                if (!isset(self.renderCache[templateName])) self.renderCache[templateName] = {};
                if (self.renderCache[templateName].hasOwnProperty(value)) return self.renderCache[templateName][value]
            }
            html = $(self.settings.render[templateName].apply(this, [data, escape_html]));
            if (templateName === "option" || templateName === "option_create") html.attr("data-selectable", "");
            else if (templateName === "optgroup") {
                id = data[self.settings.optgroupValueField] || "";
                html.attr("data-group", id)
            }
            if (templateName === "option" || templateName === "item") html.attr("data-value", value || "");
            if (cache) self.renderCache[templateName][value] = html[0];
            return html[0]
        },
        clearCache: function(templateName) {
            var self = this;
            if (typeof templateName === "undefined") self.renderCache = {};
            else delete self.renderCache[templateName]
        },
        canCreate: function(input) {
            var self = this;
            if (!self.settings.create) return false;
            var filter = self.settings.createFilter;
            return input.length && (typeof filter !== "function" || filter.apply(self, [input])) && (typeof filter !== "string" || (new RegExp(filter)).test(input)) && (!(filter instanceof RegExp) || filter.test(input))
        }
    });
    Selectize.count = 0;
    Selectize.defaults = {
        options: [],
        optgroups: [],
        plugins: [],
        delimiter: ",",
        splitOn: null,
        persist: true,
        diacritics: true,
        create: false,
        createOnBlur: false,
        createFilter: null,
        highlight: true,
        openOnFocus: true,
        maxOptions: 1E3,
        maxItems: null,
        hideSelected: null,
        addPrecedence: false,
        selectOnTab: false,
        preload: false,
        allowEmptyOption: false,
        closeAfterSelect: false,
        scrollDuration: 60,
        loadThrottle: 300,
        loadingClass: "loading",
        dataAttr: "data-data",
        optgroupField: "optgroup",
        valueField: "value",
        labelField: "text",
        optgroupLabelField: "label",
        optgroupValueField: "value",
        lockOptgroupOrder: false,
        sortField: "$order",
        searchField: ["text"],
        searchConjunction: "and",
        mode: null,
        wrapperClass: "selectize-control",
        inputClass: "selectize-input",
        dropdownClass: "selectize-dropdown",
        dropdownContentClass: "selectize-dropdown-content",
        dropdownParent: null,
        copyClassesToDropdown: true,
        render: {}
    };
    $.fn.selectize = function(settings_user) {
        var defaults = $.fn.selectize.defaults;
        var settings = $.extend({}, defaults, settings_user);
        var attr_data = settings.dataAttr;
        var field_label = settings.labelField;
        var field_value = settings.valueField;
        var field_optgroup = settings.optgroupField;
        var field_optgroup_label = settings.optgroupLabelField;
        var field_optgroup_value = settings.optgroupValueField;
        var init_textbox = function($input, settings_element) {
            var i, n, values, option;
            var data_raw = $input.attr(attr_data);
            if (!data_raw) {
                var value = $.trim($input.val() || "");
                if (!settings.allowEmptyOption && !value.length) return;
                values = value.split(settings.delimiter);
                for (i = 0, n = values.length; i < n; i++) {
                    option = {};
                    option[field_label] = values[i];
                    option[field_value] = values[i];
                    settings_element.options.push(option)
                }
                settings_element.items = values
            } else {
                settings_element.options = JSON.parse(data_raw);
                for (i = 0, n = settings_element.options.length; i <
                    n; i++) settings_element.items.push(settings_element.options[i][field_value])
            }
        };
        var init_select = function($input, settings_element) {
            var i, n, tagName, $children, order = 0;
            var options = settings_element.options;
            var optionsMap = {};
            var readData = function($el) {
                var data = attr_data && $el.attr(attr_data);
                if (typeof data === "string" && data.length) return JSON.parse(data);
                return null
            };
            var addOption = function($option, group) {
                $option = $($option);
                var value = hash_key($option.attr("value"));
                if (!value && !settings.allowEmptyOption) return;
                if (optionsMap.hasOwnProperty(value)) {
                    if (group) {
                        var arr = optionsMap[value][field_optgroup];
                        if (!arr) optionsMap[value][field_optgroup] = group;
                        else if (!$.isArray(arr)) optionsMap[value][field_optgroup] = [arr, group];
                        else arr.push(group)
                    }
                    return
                }
                var option = readData($option) || {};
                option[field_label] = option[field_label] || $option.text();
                option[field_value] = option[field_value] || value;
                option[field_optgroup] = option[field_optgroup] || group;
                optionsMap[value] = option;
                options.push(option);
                if ($option.is(":selected")) settings_element.items.push(value)
            };
            var addGroup = function($optgroup) {
                var i, n, id, optgroup, $options;
                $optgroup = $($optgroup);
                id = $optgroup.attr("label");
                if (id) {
                    optgroup = readData($optgroup) || {};
                    optgroup[field_optgroup_label] = id;
                    optgroup[field_optgroup_value] = id;
                    settings_element.optgroups.push(optgroup)
                }
                $options = $("option", $optgroup);
                for (i = 0, n = $options.length; i < n; i++) addOption($options[i], id)
            };
            settings_element.maxItems = $input.attr("multiple") ? null : 1;
            $children = $input.children();
            for (i = 0, n = $children.length; i < n; i++) {
                tagName = $children[i].tagName.toLowerCase();
                if (tagName === "optgroup") addGroup($children[i]);
                else if (tagName === "option") addOption($children[i])
            }
        };
        return this.each(function() {
            if (this.selectize) return;
            var instance;
            var $input = $(this);
            var tag_name = this.tagName.toLowerCase();
            var placeholder = $input.attr("placeholder") || $input.attr("data-placeholder");
            if (!placeholder && !settings.allowEmptyOption) placeholder = $input.children('option[value=""]').text();
            var settings_element = {
                "placeholder": placeholder,
                "options": [],
                "optgroups": [],
                "items": []
            };
            if (tag_name ===
                "select") init_select($input, settings_element);
            else init_textbox($input, settings_element);
            instance = new Selectize($input, $.extend(true, {}, defaults, settings_element, settings_user))
        })
    };
    $.fn.selectize.defaults = Selectize.defaults;
    $.fn.selectize.support = {
        validity: SUPPORTS_VALIDITY_API
    };
    Selectize.define("drag_drop", function(options) {
        if (!$.fn.sortable) throw new Error('The "drag_drop" plugin requires jQuery UI "sortable".');
        if (this.settings.mode !== "multi") return;
        var self = this;
        self.lock = function() {
            var original =
                self.lock;
            return function() {
                var sortable = self.$control.data("sortable");
                if (sortable) sortable.disable();
                return original.apply(self, arguments)
            }
        }();
        self.unlock = function() {
            var original = self.unlock;
            return function() {
                var sortable = self.$control.data("sortable");
                if (sortable) sortable.enable();
                return original.apply(self, arguments)
            }
        }();
        self.setup = function() {
            var original = self.setup;
            return function() {
                original.apply(this, arguments);
                var $control = self.$control.sortable({
                    items: "[data-value]",
                    forcePlaceholderSize: true,
                    disabled: self.isLocked,
                    start: function(e, ui) {
                        ui.placeholder.css("width", ui.helper.css("width"));
                        $control.css({
                            overflow: "visible"
                        })
                    },
                    stop: function() {
                        $control.css({
                            overflow: "hidden"
                        });
                        var active = self.$activeItems ? self.$activeItems.slice() : null;
                        var values = [];
                        $control.children("[data-value]").each(function() {
                            values.push($(this).attr("data-value"))
                        });
                        self.setValue(values);
                        self.setActiveItem(active)
                    }
                })
            }
        }()
    });
    Selectize.define("dropdown_header", function(options) {
        var self = this;
        options = $.extend({
            title: "Untitled",
            headerClass: "selectize-dropdown-header",
            titleRowClass: "selectize-dropdown-header-title",
            labelClass: "selectize-dropdown-header-label",
            closeClass: "selectize-dropdown-header-close",
            html: function(data) {
                return '<div class="' + data.headerClass + '">' + '<div class="' + data.titleRowClass + '">' + '<span class="' + data.labelClass + '">' + data.title + "</span>" + '<a href="javascript:void(0)" class="' + data.closeClass + '">&times;</a>' + "</div>" + "</div>"
            }
        }, options);
        self.setup = function() {
            var original = self.setup;
            return function() {
                original.apply(self,
                    arguments);
                self.$dropdown_header = $(options.html(options));
                self.$dropdown.prepend(self.$dropdown_header)
            }
        }()
    });
    Selectize.define("optgroup_columns", function(options) {
        var self = this;
        options = $.extend({
            equalizeWidth: true,
            equalizeHeight: true
        }, options);
        this.getAdjacentOption = function($option, direction) {
            var $options = $option.closest("[data-group]").find("[data-selectable]");
            var index = $options.index($option) + direction;
            return index >= 0 && index < $options.length ? $options.eq(index) : $()
        };
        this.onKeyDown = function() {
            var original =
                self.onKeyDown;
            return function(e) {
                var index, $option, $options, $optgroup;
                if (this.isOpen && (e.keyCode === KEY_LEFT || e.keyCode === KEY_RIGHT)) {
                    self.ignoreHover = true;
                    $optgroup = this.$activeOption.closest("[data-group]");
                    index = $optgroup.find("[data-selectable]").index(this.$activeOption);
                    if (e.keyCode === KEY_LEFT) $optgroup = $optgroup.prev("[data-group]");
                    else $optgroup = $optgroup.next("[data-group]");
                    $options = $optgroup.find("[data-selectable]");
                    $option = $options.eq(Math.min($options.length - 1, index));
                    if ($option.length) this.setActiveOption($option);
                    return
                }
                return original.apply(this, arguments)
            }
        }();
        var getScrollbarWidth = function() {
            var div;
            var width = getScrollbarWidth.width;
            var doc = document;
            if (typeof width === "undefined") {
                div = doc.createElement("div");
                div.innerHTML = '<div style="width:50px;height:50px;position:absolute;left:-50px;top:-50px;overflow:auto;"><div style="width:1px;height:100px;"></div></div>';
                div = div.firstChild;
                doc.body.appendChild(div);
                width = getScrollbarWidth.width = div.offsetWidth - div.clientWidth;
                doc.body.removeChild(div)
            }
            return width
        };
        var equalizeSizes = function() {
            var i, n, height_max, width, width_last, width_parent, $optgroups;
            $optgroups = $("[data-group]", self.$dropdown_content);
            n = $optgroups.length;
            if (!n || !self.$dropdown_content.width()) return;
            if (options.equalizeHeight) {
                height_max = 0;
                for (i = 0; i < n; i++) height_max = Math.max(height_max, $optgroups.eq(i).height());
                $optgroups.css({
                    height: height_max
                })
            }
            if (options.equalizeWidth) {
                width_parent = self.$dropdown_content.innerWidth() - getScrollbarWidth();
                width = Math.round(width_parent / n);
                $optgroups.css({
                    width: width
                });
                if (n > 1) {
                    width_last = width_parent - width * (n - 1);
                    $optgroups.eq(n - 1).css({
                        width: width_last
                    })
                }
            }
        };
        if (options.equalizeHeight || options.equalizeWidth) {
            hook.after(this, "positionDropdown", equalizeSizes);
            hook.after(this, "refreshOptions", equalizeSizes)
        }
    });
    Selectize.define("remove_button", function(options) {
        options = $.extend({
            label: "&times;",
            title: "Remove",
            className: "remove",
            append: true
        }, options);
        var singleClose = function(thisRef, options) {
            options.className = "remove-single";
            var self = thisRef;
            var html = '<a href="javascript:void(0)" class="' +
                options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + "</a>";
            var append = function(html_container, html_element) {
                return html_container + html_element
            };
            thisRef.setup = function() {
                var original = self.setup;
                return function() {
                    if (options.append) {
                        var id = $(self.$input.context).attr("id");
                        var selectizer = $("#" + id);
                        var render_item = self.settings.render.item;
                        self.settings.render.item = function(data) {
                            return append(render_item.apply(thisRef, arguments), html)
                        }
                    }
                    original.apply(thisRef, arguments);
                    thisRef.$control.on("click", "." + options.className, function(e) {
                        e.preventDefault();
                        if (self.isLocked) return;
                        self.clear()
                    })
                }
            }()
        };
        var multiClose = function(thisRef, options) {
            var self = thisRef;
            var html = '<a href="javascript:void(0)" class="' + options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + "</a>";
            var append = function(html_container, html_element) {
                var pos = html_container.search(/(<\/[^>]+>\s*)$/);
                return html_container.substring(0, pos) + html_element + html_container.substring(pos)
            };
            thisRef.setup = function() {
                var original = self.setup;
                return function() {
                    if (options.append) {
                        var render_item = self.settings.render.item;
                        self.settings.render.item = function(data) {
                            return append(render_item.apply(thisRef, arguments), html)
                        }
                    }
                    original.apply(thisRef, arguments);
                    thisRef.$control.on("click", "." + options.className, function(e) {
                        e.preventDefault();
                        if (self.isLocked) return;
                        var $item = $(e.currentTarget).parent();
                        self.setActiveItem($item);
                        if (self.deleteSelection()) self.setCaret(self.items.length)
                    })
                }
            }()
        };
        if (this.settings.mode ===
            "single") {
            singleClose(this, options);
            return
        } else multiClose(this, options)
    });
    Selectize.define("restore_on_backspace", function(options) {
        var self = this;
        options.text = options.text || function(option) {
            return option[this.settings.labelField]
        };
        this.onKeyDown = function() {
            var original = self.onKeyDown;
            return function(e) {
                var index, option;
                if (e.keyCode === KEY_BACKSPACE && this.$control_input.val() === "" && !this.$activeItems.length) {
                    index = this.caretPos - 1;
                    if (index >= 0 && index < this.items.length) {
                        option = this.options[this.items[index]];
                        if (this.deleteSelection(e)) {
                            this.setTextboxValue(options.text.apply(this, [option]));
                            this.refreshOptions(true)
                        }
                        e.preventDefault();
                        return
                    }
                }
                return original.apply(this, arguments)
            }
        }()
    });
    return Selectize
});
(function($, window, undefined) {
    var pluginName = "pep";
    var defaults = {
        initiate: function() {},
        start: function() {},
        drag: function() {},
        stop: function() {},
        easing: null,
        rest: function() {},
        moveTo: false,
        callIfNotStarted: ["stop", "rest"],
        startThreshold: [0, 0],
        grid: [1, 1],
        debug: false,
        activeClass: "pep-active",
        multiplier: 1,
        velocityMultiplier: 2.5,
        shouldPreventDefault: true,
        allowDragEventPropagation: true,
        stopEvents: "",
        hardwareAccelerate: true,
        useCSSTranslation: true,
        disableSelect: true,
        cssEaseString: "cubic-bezier(0.190, 1.000, 0.220, 1.000)",
        cssEaseDuration: 1E3,
        shouldEase: true,
        droppable: false,
        droppableActiveClass: "pep-dpa",
        overlapFunction: false,
        constrainTo: false,
        removeMargins: true,
        place: true,
        deferPlacement: false,
        axis: null,
        forceNonCSS3Movement: false,
        elementsWithInteraction: "input",
        revert: false,
        revertAfter: "stop",
        revertIf: function() {
            return true
        },
        ignoreRightClick: true,
        startPos: {
            left: null,
            top: null
        },
        useBoundingClientRect: false
    };

    function Pep(el, options) {
        this.name = pluginName;
        this.el = el;
        this.$el = $(el);
        this.options = $.extend({}, defaults, options);
        this.$document = $(this.$el[0].ownerDocument);
        this.$body = this.$document.find("body");
        this.moveTrigger = "MSPointerMove pointermove touchmove mousemove";
        this.startTrigger = "MSPointerDown pointerdown touchstart mousedown";
        this.stopTrigger = "MSPointerUp pointerup touchend mouseup";
        this.startTriggerArray = this.startTrigger.split(" ");
        this.moveTriggerArray = this.moveTrigger.split(" ");
        this.stopTriggerArray = this.stopTrigger.split(" ");
        this.stopEvents = [this.stopTrigger, this.options.stopEvents].join(" ");
        if (this.options.constrainTo ===
            "window") this.$container = this.$document;
        else if (this.options.constrainTo && this.options.constrainTo !== "parent") this.$container = $(this.options.constrainTo);
        else this.$container = this.$el.parent();
        if (this.isPointerEventCompatible()) this.applyMSDefaults();
        this.CSSEaseHash = this.getCSSEaseHash();
        this.scale = 1;
        this.started = false;
        this.disabled = false;
        this.activeDropRegions = [];
        this.resetVelocityQueue();
        this.init();
        return this
    }
    Pep.prototype.init = function() {
        if (this.options.debug) this.buildDebugDiv();
        if (this.options.disableSelect) this.disableSelect();
        if (this.options.place && !this.options.deferPlacement) {
            this.positionParent();
            this.placeObject()
        }
        this.ev = {};
        this.pos = {};
        this.subscribe()
    };
    Pep.prototype.subscribe = function() {
        var self = this;
        this.onStartEvent = function(ev) {
            self.handleStart(ev)
        };
        this.$el.on(this.startTrigger, this.onStartEvent);
        this.onStartEventOnElementsWithInteraction = function(ev) {
            ev.ignorePropagation = true
        };
        this.$el.on(this.startTrigger, this.options.elementsWithInteraction, this.onStartEventOnElementsWithInteraction);
        this.onStopEvents = function(ev) {
            self.handleStop(ev)
        };
        this.$document.on(this.stopEvents, this.onStopEvents);
        this.onMoveEvents = function(ev) {
            self.moveEvent = ev
        };
        this.$document.on(this.moveTrigger, this.onMoveEvents)
    };
    Pep.prototype.unsubscribe = function() {
        this.$el.off(this.startTrigger, this.onStartEvent);
        this.$el.off(this.startTrigger, this.options.elementsWithInteraction, this.onStartEventOnElementsWithInteraction);
        this.$document.off(this.stopEvents, this.onStopEvents);
        this.$document.off(this.moveTrigger, this.onMoveEvents)
    };
    Pep.prototype.handleStart = function(ev) {
        if (ev.ignorePropagation) return;
        var self = this;
        if (this.isValidMoveEvent(ev) && !this.disabled)
            if (!(this.options.ignoreRightClick && ev.which === 3)) {
                if (this.isPointerEventCompatible() && ev.preventManipulation) ev.preventManipulation();
                ev = this.normalizeEvent(ev);
                if (this.options.place && this.options.deferPlacement) {
                    this.positionParent();
                    this.placeObject()
                }
                this.log({
                    type: "event",
                    event: ev.type
                });
                if (this.options.hardwareAccelerate && !this.hardwareAccelerated) {
                    this.hardwareAccelerate();
                    this.hardwareAccelerated = true
                }
                var shouldContinue = this.options.initiate.call(this,
                    ev, this);
                if (shouldContinue === false) return;
                clearTimeout(this.restTimeout);
                this.$el.addClass(this.options.activeClass);
                this.removeCSSEasing();
                this.startX = this.ev.x = ev.pep.x;
                this.startY = this.ev.y = ev.pep.y;
                this.initialPosition = this.initialPosition || this.$el.position();
                this.startEvent = this.moveEvent = ev;
                this.active = true;
                if (this.options.shouldPreventDefault) ev.preventDefault();
                if (!this.options.allowDragEventPropagation) ev.stopPropagation();
                (function watchMoveLoop() {
                    if (!self.active) return;
                    self.handleMove();
                    self.requestAnimationFrame(watchMoveLoop)
                })();
                (function watchEasingLoop() {
                    if (!self.options.easing) return;
                    if (self.easing) self.options.easing.call(self, null, self);
                    self.requestAnimationFrame(watchEasingLoop)
                })()
            }
    };
    Pep.prototype.handleMove = function() {
        if (typeof this.moveEvent === "undefined") return;
        var ev = this.normalizeEvent(this.moveEvent);
        var curX = window.parseInt(ev.pep.x / this.options.grid[0]) * this.options.grid[0];
        var curY = window.parseInt(ev.pep.y / this.options.grid[1]) * this.options.grid[1];
        this.addToLIFO({
            time: ev.timeStamp,
            x: curX,
            y: curY
        });
        var dx, dy;
        if ($.inArray(ev.type, this.startTriggerArray) > -1) {
            dx = 0;
            dy = 0
        } else {
            dx = curX - this.ev.x;
            dy = curY - this.ev.y
        }
        this.dx = dx;
        this.dy = dy;
        this.ev.x = curX;
        this.ev.y = curY;
        if (dx === 0 && dy === 0) {
            this.log({
                type: "event",
                event: "** stopped **"
            });
            return
        }
        var initialDx = Math.abs(this.startX - curX);
        var initialDy = Math.abs(this.startY - curY);
        if (!this.started && (initialDx > this.options.startThreshold[0] || initialDy > this.options.startThreshold[1])) {
            this.started = true;
            this.$el.addClass("pep-start");
            this.options.start.call(this,
                this.startEvent, this)
        }
        this.doMoveTo(dx, dy);
        if (this.options.droppable) this.calculateActiveDropRegions();
        var continueDrag = this.options.drag.call(this, ev, this);
        if (continueDrag === false) {
            this.resetVelocityQueue();
            return
        }
        this.log({
            type: "event",
            event: ev.type
        });
        this.log({
            type: "event-coords",
            x: this.ev.x,
            y: this.ev.y
        });
        this.log({
            type: "velocity"
        })
    };
    Pep.prototype.doMoveTo = function(dx, dy) {
        var hash = this.handleConstraint(dx, dy);
        var xOp, yOp;
        if (typeof this.options.moveTo === "function") {
            xOp = dx >= 0 ? "+=" + Math.abs(dx / this.scale) *
                this.options.multiplier : "-=" + Math.abs(dx / this.scale) * this.options.multiplier;
            yOp = dy >= 0 ? "+=" + Math.abs(dy / this.scale) * this.options.multiplier : "-=" + Math.abs(dy / this.scale) * this.options.multiplier;
            if (this.options.constrainTo) {
                xOp = hash.x !== false ? hash.x : xOp;
                yOp = hash.y !== false ? hash.y : yOp
            }
            if (this.options.axis === "x") yOp = hash.y;
            if (this.options.axis === "y") xOp = hash.x;
            this.options.moveTo.call(this, xOp, yOp)
        } else if (!this.shouldUseCSSTranslation()) {
            xOp = dx >= 0 ? "+=" + Math.abs(dx / this.scale) * this.options.multiplier :
                "-=" + Math.abs(dx / this.scale) * this.options.multiplier;
            yOp = dy >= 0 ? "+=" + Math.abs(dy / this.scale) * this.options.multiplier : "-=" + Math.abs(dy / this.scale) * this.options.multiplier;
            if (this.options.constrainTo) {
                xOp = hash.x !== false ? hash.x : xOp;
                yOp = hash.y !== false ? hash.y : yOp
            }
            if (this.options.axis === "x") yOp = hash.y;
            if (this.options.axis === "y") xOp = hash.x;
            this.moveTo(xOp, yOp)
        } else {
            dx = dx / this.scale * this.options.multiplier;
            dy = dy / this.scale * this.options.multiplier;
            if (this.options.constrainTo) {
                dx = hash.x === false ? dx : 0;
                dy = hash.y ===
                    false ? dy : 0
            }
            if (this.options.axis === "x") dy = 0;
            if (this.options.axis === "y") dx = 0;
            this.moveToUsingTransforms(dx, dy)
        }
    };
    Pep.prototype.handleStop = function(ev) {
        if (!this.active) return;
        this.log({
            type: "event",
            event: ev.type
        });
        this.active = false;
        this.easing = true;
        this.$el.removeClass("pep-start").addClass("pep-ease");
        if (this.options.droppable) this.calculateActiveDropRegions();
        if (this.started || !this.started && $.inArray("stop", this.options.callIfNotStarted) > -1) this.options.stop.call(this, ev, this);
        if (this.options.shouldEase) this.ease(ev,
            this.started);
        else this.removeActiveClass();
        if (this.options.revert && (this.options.revertAfter === "stop" || !this.options.shouldEase) && (this.options.revertIf && this.options.revertIf.call(this))) this.revert();
        this.started = false;
        this.resetVelocityQueue()
    };
    Pep.prototype.ease = function(ev, started) {
        var pos = this.$el.position();
        var vel = this.velocity();
        var dt = this.dt;
        var x = vel.x / this.scale * this.options.multiplier;
        var y = vel.y / this.scale * this.options.multiplier;
        var hash = this.handleConstraint(x, y, true);
        if (this.cssAnimationsSupported()) this.$el.css(this.getCSSEaseHash());
        var xOp = vel.x > 0 ? "+=" + x : "-=" + Math.abs(x);
        var yOp = vel.y > 0 ? "+=" + y : "-=" + Math.abs(y);
        if (this.options.constrainTo) {
            xOp = hash.x !== false ? hash.x : xOp;
            yOp = hash.y !== false ? hash.y : yOp
        }
        if (this.options.axis === "x") yOp = "+=0";
        if (this.options.axis === "y") xOp = "+=0";
        var jsAnimateFallback = !this.cssAnimationsSupported() || this.options.forceNonCSS3Movement;
        if (typeof this.options.moveTo === "function") this.options.moveTo.call(this, xOp, yOp);
        else this.moveTo(xOp, yOp, jsAnimateFallback);
        var self = this;
        this.restTimeout = setTimeout(function() {
            if (self.options.droppable) self.calculateActiveDropRegions();
            self.easing = false;
            if (started || !started && $.inArray("rest", self.options.callIfNotStarted) > -1) self.options.rest.call(self, ev, self);
            if (self.options.revert && (self.options.revertAfter === "ease" && self.options.shouldEase) && (self.options.revertIf && self.options.revertIf.call(self))) self.revert();
            self.removeActiveClass()
        }, this.options.cssEaseDuration)
    };
    Pep.prototype.normalizeEvent = function(ev) {
        ev.pep = {};
        if (this.isTouch(ev)) {
            ev.pep.x = ev.originalEvent.touches[0].pageX;
            ev.pep.y = ev.originalEvent.touches[0].pageY;
            ev.pep.type = ev.type
        } else if (this.isPointerEventCompatible() || !this.isTouch(ev)) {
            if (ev.pageX) {
                ev.pep.x = ev.pageX;
                ev.pep.y = ev.pageY
            } else {
                ev.pep.x = ev.originalEvent.pageX;
                ev.pep.y = ev.originalEvent.pageY
            }
            ev.pep.type = ev.type
        }
        return ev
    };
    Pep.prototype.resetVelocityQueue = function() {
        this.velocityQueue = new Array(5)
    };
    Pep.prototype.moveTo = function(x, y, animate) {
        this.log({
            type: "delta",
            x: x,
            y: y
        });
        if (animate) this.$el.animate({
            top: y,
            left: x
        }, 0, "easeOutQuad", {
            queue: false
        });
        else this.$el.stop(true, false).css({
            top: y,
            left: x
        })
    };
    Pep.prototype.moveToUsingTransforms = function(x, y) {
        var matrixArray = this.matrixToArray(this.matrixString());
        if (!this.cssX) this.cssX = this.xTranslation(matrixArray);
        if (!this.cssY) this.cssY = this.yTranslation(matrixArray);
        this.cssX = this.cssX + x;
        this.cssY = this.cssY + y;
        this.log({
            type: "delta",
            x: x,
            y: y
        });
        matrixArray[4] = this.cssX;
        matrixArray[5] = this.cssY;
        this.translation = this.arrayToMatrix(matrixArray);
        this.transform(this.translation)
    };
    Pep.prototype.transform = function(value) {
        this.$el.css({
            "-webkit-transform": value,
            "-moz-transform": value,
            "-ms-transform": value,
            "-o-transform": value,
            "transform": value
        })
    };
    Pep.prototype.xTranslation = function(matrixArray) {
        matrixArray = matrixArray || this.matrixToArray(this.matrixString());
        return parseInt(matrixArray[4], 10)
    };
    Pep.prototype.yTranslation = function(matrixArray) {
        matrixArray = matrixArray || this.matrixToArray(this.matrixString());
        return parseInt(matrixArray[5], 10)
    };
    Pep.prototype.matrixString = function() {
        var validMatrix = function(o) {
            return !(!o || o === "none" || o.indexOf("matrix") < 0)
        };
        var matrix = "matrix(1, 0, 0, 1, 0, 0)";
        if (validMatrix(this.$el.css("-webkit-transform"))) matrix = this.$el.css("-webkit-transform");
        if (validMatrix(this.$el.css("-moz-transform"))) matrix = this.$el.css("-moz-transform");
        if (validMatrix(this.$el.css("-ms-transform"))) matrix = this.$el.css("-ms-transform");
        if (validMatrix(this.$el.css("-o-transform"))) matrix = this.$el.css("-o-transform");
        if (validMatrix(this.$el.css("transform"))) matrix = this.$el.css("transform");
        return matrix
    };
    Pep.prototype.matrixToArray = function(str) {
        return str.split("(")[1].split(")")[0].split(",")
    };
    Pep.prototype.arrayToMatrix = function(array) {
        return "matrix(" + array.join(",") + ")"
    };
    Pep.prototype.addToLIFO = function(val) {
        var arr = this.velocityQueue;
        arr = arr.slice(1, arr.length);
        arr.push(val);
        this.velocityQueue = arr
    };
    Pep.prototype.velocity = function() {
        var sumX = 0;
        var sumY = 0;
        for (var i = 0; i < this.velocityQueue.length - 1; i++)
            if (this.velocityQueue[i]) {
                sumX += this.velocityQueue[i + 1].x - this.velocityQueue[i].x;
                sumY += this.velocityQueue[i + 1].y - this.velocityQueue[i].y;
                this.dt = this.velocityQueue[i + 1].time - this.velocityQueue[i].time
            }
        return {
            x: sumX *
                this.options.velocityMultiplier,
            y: sumY * this.options.velocityMultiplier
        }
    };
    Pep.prototype.revert = function() {
        if (this.shouldUseCSSTranslation()) this.moveToUsingTransforms(-this.xTranslation(), -this.yTranslation());
        if (this.options.place) this.moveTo(this.initialPosition.left, this.initialPosition.top)
    };
    Pep.prototype.requestAnimationFrame = function(callback) {
        return window.requestAnimationFrame && window.requestAnimationFrame(callback) || window.webkitRequestAnimationFrame && window.webkitRequestAnimationFrame(callback) ||
            window.mozRequestAnimationFrame && window.mozRequestAnimationFrame(callback) || window.oRequestAnimationFrame && window.mozRequestAnimationFrame(callback) || window.msRequestAnimationFrame && window.msRequestAnimationFrame(callback) || window.setTimeout(callback, 1E3 / 60)
    };
    Pep.prototype.positionParent = function() {
        if (!this.options.constrainTo || this.parentPositioned) return;
        this.parentPositioned = true;
        if (this.options.constrainTo === "parent") this.$container.css({
            position: "relative"
        });
        else if (this.options.constrainTo ===
            "window" && this.$container.get(0).nodeName !== "#document" && this.$container.css("position") !== "static") this.$container.css({
            position: "static"
        })
    };
    Pep.prototype.placeObject = function() {
        if (this.objectPlaced) return;
        this.objectPlaced = true;
        this.offset = this.options.constrainTo === "parent" || this.hasNonBodyRelative() ? this.$el.position() : this.$el.offset();
        if (parseInt(this.$el.css("left"), 10)) this.offset.left = this.$el.css("left");
        if (typeof this.options.startPos.left === "number") this.offset.left = this.options.startPos.left;
        if (parseInt(this.$el.css("top"), 10)) this.offset.top = this.$el.css("top");
        if (typeof this.options.startPos.top === "number") this.offset.top = this.options.startPos.top;
        if (this.options.removeMargins) this.$el.css({
            margin: 0
        });
        this.$el.css({
            position: "absolute",
            top: this.offset.top,
            left: this.offset.left
        })
    };
    Pep.prototype.hasNonBodyRelative = function() {
        return this.$el.parents().filter(function() {
            var $this = $(this);
            return $this.is("body") || $this.css("position") === "relative"
        }).length > 1
    };
    Pep.prototype.setScale = function(val) {
        this.scale =
            val
    };
    Pep.prototype.setMultiplier = function(val) {
        this.options.multiplier = val
    };
    Pep.prototype.removeCSSEasing = function() {
        if (this.cssAnimationsSupported()) this.$el.css(this.getCSSEaseHash(true))
    };
    Pep.prototype.disableSelect = function() {
        this.$el.css({
            "-webkit-touch-callout": "none",
            "-webkit-user-select": "none",
            "-khtml-user-select": "none",
            "-moz-user-select": "none",
            "-ms-user-select": "none",
            "user-select": "none"
        })
    };
    Pep.prototype.removeActiveClass = function() {
        this.$el.removeClass([this.options.activeClass, "pep-ease"].join(" "))
    };
    Pep.prototype.handleConstraint = function(dx, dy, accountForTranslation) {
        var pos = this.$el.position();
        this.pos.x = pos.left;
        this.pos.y = pos.top;
        var hash = {
            x: false,
            y: false
        };
        var upperYLimit, upperXLimit, lowerXLimit, lowerYLimit;
        this.log({
            type: "pos-coords",
            x: this.pos.x,
            y: this.pos.y
        });
        if ($.isArray(this.options.constrainTo)) {
            if (this.options.constrainTo[3] !== undefined && this.options.constrainTo[1] !== undefined) {
                upperXLimit = this.options.constrainTo[1] === false ? Infinity : this.options.constrainTo[1];
                lowerXLimit = this.options.constrainTo[3] ===
                    false ? -Infinity : this.options.constrainTo[3]
            }
            if (this.options.constrainTo[0] !== false && this.options.constrainTo[2] !== false) {
                upperYLimit = this.options.constrainTo[2] === false ? Infinity : this.options.constrainTo[2];
                lowerYLimit = this.options.constrainTo[0] === false ? -Infinity : this.options.constrainTo[0]
            }
            if (this.pos.x + dx < lowerXLimit) hash.x = lowerXLimit;
            if (this.pos.y + dy < lowerYLimit) hash.y = lowerYLimit
        } else if (typeof this.options.constrainTo === "string") {
            lowerXLimit = 0;
            lowerYLimit = 0;
            upperXLimit = this.$container.width() -
                (this.options.useBoundingClientRect ? this.$el[0].getBoundingClientRect().width : this.$el.outerWidth());
            upperYLimit = this.$container.height() - (this.options.useBoundingClientRect ? this.$el[0].getBoundingClientRect().height : this.$el.outerHeight());
            if (this.pos.x + dx < 0) hash.x = 0;
            if (this.pos.y + dy < 0) hash.y = 0
        }
        if (this.pos.x + dx > upperXLimit) hash.x = upperXLimit;
        if (this.pos.y + dy > upperYLimit) hash.y = upperYLimit;
        if (this.shouldUseCSSTranslation() && accountForTranslation) {
            if (hash.x === lowerXLimit && this.xTranslation()) hash.x =
                lowerXLimit - this.xTranslation();
            if (hash.x === upperXLimit && this.xTranslation()) hash.x = upperXLimit - this.xTranslation();
            if (hash.y === lowerYLimit && this.yTranslation()) hash.y = lowerYLimit - this.yTranslation();
            if (hash.y === upperYLimit && this.yTranslation()) hash.y = upperYLimit - this.yTranslation()
        }
        return hash
    };
    Pep.prototype.getCSSEaseHash = function(reset) {
        if (typeof reset === "undefined") reset = false;
        var cssEaseString;
        if (reset) cssEaseString = "";
        else if (this.CSSEaseHash) return this.CSSEaseHash;
        else cssEaseString = ["all",
            this.options.cssEaseDuration + "ms", this.options.cssEaseString
        ].join(" ");
        return {
            "-webkit-transition": cssEaseString,
            "-moz-transition": cssEaseString,
            "-ms-transition": cssEaseString,
            "-o-transition": cssEaseString,
            "transition": cssEaseString
        }
    };
    Pep.prototype.calculateActiveDropRegions = function() {
        var self = this;
        this.activeDropRegions.length = 0;
        $.each($(this.options.droppable), function(idx, el) {
            var $el = $(el);
            if (self.isOverlapping($el, self.$el)) {
                $el.addClass(self.options.droppableActiveClass);
                self.activeDropRegions.push($el)
            } else $el.removeClass(self.options.droppableActiveClass)
        })
    };
    Pep.prototype.isOverlapping = function($a, $b) {
        if (this.options.overlapFunction) return this.options.overlapFunction($a, $b);
        var rect1 = $a[0].getBoundingClientRect();
        var rect2 = $b[0].getBoundingClientRect();
        return !(rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom)
    };
    Pep.prototype.isTouch = function(ev) {
        return ev.type.search("touch") > -1
    };
    Pep.prototype.isPointerEventCompatible = function() {
        return "MSPointerEvent" in window
    };
    Pep.prototype.applyMSDefaults = function(first_argument) {
        this.$el.css({
            "-ms-touch-action": "none",
            "touch-action": "none",
            "-ms-scroll-chaining": "none",
            "-ms-scroll-limit": "0 0 0 0"
        })
    };
    Pep.prototype.isValidMoveEvent = function(ev) {
        return !this.isTouch(ev) || this.isTouch(ev) && ev.originalEvent && ev.originalEvent.touches && ev.originalEvent.touches.length === 1
    };
    Pep.prototype.shouldUseCSSTranslation = function() {
        if (this.options.forceNonCSS3Movement) return false;
        if (typeof this.useCSSTranslation !== "undefined") return this.useCSSTranslation;
        var useCSSTranslation = false;
        if (!this.options.useCSSTranslation || typeof Modernizr !==
            "undefined" && !Modernizr.csstransforms) useCSSTranslation = false;
        else useCSSTranslation = true;
        this.useCSSTranslation = useCSSTranslation;
        return useCSSTranslation
    };
    Pep.prototype.cssAnimationsSupported = function() {
        if (typeof this.cssAnimationsSupport !== "undefined") return this.cssAnimationsSupport;
        if (typeof Modernizr !== "undefined" && Modernizr.cssanimations) {
            this.cssAnimationsSupport = true;
            return true
        }
        var animation = false,
            elm = document.createElement("div"),
            animationstring = "animation",
            keyframeprefix = "",
            domPrefixes =
            "Webkit Moz O ms Khtml".split(" "),
            pfx = "";
        if (elm.style.animationName) animation = true;
        if (animation === false)
            for (var i = 0; i < domPrefixes.length; i++)
                if (elm.style[domPrefixes[i] + "AnimationName"] !== undefined) {
                    pfx = domPrefixes[i];
                    animationstring = pfx + "Animation";
                    keyframeprefix = "-" + pfx.toLowerCase() + "-";
                    animation = true;
                    break
                }
        this.cssAnimationsSupport = animation;
        return animation
    };
    Pep.prototype.hardwareAccelerate = function() {
        this.$el.css({
            "-webkit-perspective": 1E3,
            "perspective": 1E3,
            "-webkit-backface-visibility": "hidden",
            "backface-visibility": "hidden"
        })
    };
    Pep.prototype.getMovementValues = function() {
        return {
            ev: this.ev,
            pos: this.pos,
            velocity: this.velocity()
        }
    };
    Pep.prototype.buildDebugDiv = function() {
        var $debugDiv;
        if ($("#pep-debug").length === 0) {
            $debugDiv = $("<div></div>");
            $debugDiv.attr("id", "pep-debug").append("<div style='font-weight:bold; background: red; color: white;'>DEBUG MODE</div>").append("<div id='pep-debug-event'>no event</div>").append("<div id='pep-debug-ev-coords'>event coords: <span class='pep-x'>-</span>, <span class='pep-y'>-</span></div>").append("<div id='pep-debug-pos-coords'>position coords: <span class='pep-x'>-</span>, <span class='pep-y'>-</span></div>").append("<div id='pep-debug-velocity'>velocity: <span class='pep-x'>-</span>, <span class='pep-y'>-</span></div>").append("<div id='pep-debug-delta'>&Delta; movement: <span class='pep-x'>-</span>, <span class='pep-y'>-</span></div>").css({
                position: "fixed",
                bottom: 5,
                right: 5,
                zIndex: 99999,
                textAlign: "right",
                fontFamily: "Arial, sans",
                fontSize: 10,
                border: "1px solid #DDD",
                padding: "3px",
                background: "white",
                color: "#333"
            })
        }
        var self = this;
        setTimeout(function() {
            self.debugElements = {
                $event: $("#pep-debug-event"),
                $velocityX: $("#pep-debug-velocity .pep-x"),
                $velocityY: $("#pep-debug-velocity .pep-y"),
                $dX: $("#pep-debug-delta .pep-x"),
                $dY: $("#pep-debug-delta .pep-y"),
                $evCoordsX: $("#pep-debug-ev-coords .pep-x"),
                $evCoordsY: $("#pep-debug-ev-coords .pep-y"),
                $posCoordsX: $("#pep-debug-pos-coords .pep-x"),
                $posCoordsY: $("#pep-debug-pos-coords .pep-y")
            }
        }, 0);
        $("body").append($debugDiv)
    };
    Pep.prototype.log = function(opts) {
        if (!this.options.debug) return;
        switch (opts.type) {
            case "event":
                this.debugElements.$event.text(opts.event);
                break;
            case "pos-coords":
                this.debugElements.$posCoordsX.text(opts.x);
                this.debugElements.$posCoordsY.text(opts.y);
                break;
            case "event-coords":
                this.debugElements.$evCoordsX.text(opts.x);
                this.debugElements.$evCoordsY.text(opts.y);
                break;
            case "delta":
                this.debugElements.$dX.text(opts.x);
                this.debugElements.$dY.text(opts.y);
                break;
            case "velocity":
                var vel = this.velocity();
                this.debugElements.$velocityX.text(Math.round(vel.x));
                this.debugElements.$velocityY.text(Math.round(vel.y));
                break
        }
    };
    Pep.prototype.toggle = function(on) {
        if (typeof on === "undefined") this.disabled = !this.disabled;
        else this.disabled = !on
    };
    $.extend($.easing, {
        easeOutQuad: function(x, t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b
        },
        easeOutCirc: function(x, t, b, c, d) {
            return c * Math.sqrt(1 - (t = t / d - 1) * t) + b
        },
        easeOutExpo: function(x, t, b, c, d) {
            return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b
        }
    });
    $.fn[pluginName] = function(options) {
        return this.each(function() {
            if (!$.data(this, "plugin_" + pluginName)) {
                var pepObj = new Pep(this, options);
                $.data(this, "plugin_" + pluginName, pepObj);
                $.pep.peps.push(pepObj)
            }
        })
    };
    $.pep = {};
    $.pep.peps = [];
    $.pep.toggleAll = function(on) {
        $.each(this.peps, function(index, pepObj) {
            pepObj.toggle(on)
        })
    };
    $.pep.unbind = function($obj) {
        var pep = $obj.data("plugin_" + pluginName);
        if (typeof pep === "undefined") return;
        pep.toggle(false);
        pep.unsubscribe();
        $obj.removeData("plugin_" + pluginName)
    }
})(jQuery,
    window);
(function(factory) {
    if (typeof define === "function" && define.amd) define(["jquery"], factory);
    else if (typeof module !== "undefined" && module.exports) module.exports = factory(require("jquery"));
    else factory(jQuery)
})(function($) {
    var $scrollTo = $.scrollTo = function(target, duration, settings) {
        return $(window).scrollTo(target, duration, settings)
    };
    $scrollTo.defaults = {
        axis: "xy",
        duration: 0,
        limit: true
    };

    function isWin(elem) {
        return !elem.nodeName || $.inArray(elem.nodeName.toLowerCase(), ["iframe", "#document", "html", "body"]) !==
            -1
    }
    $.fn.scrollTo = function(target, duration, settings) {
        if (typeof duration === "object") {
            settings = duration;
            duration = 0
        }
        if (typeof settings === "function") settings = {
            onAfter: settings
        };
        if (target === "max") target = 9E9;
        settings = $.extend({}, $scrollTo.defaults, settings);
        duration = duration || settings.duration;
        var queue = settings.queue && settings.axis.length > 1;
        if (queue) duration /= 2;
        settings.offset = both(settings.offset);
        settings.over = both(settings.over);
        return this.each(function() {
            if (target === null) return;
            var win = isWin(this),
                elem = win ? this.contentWindow || window : this,
                $elem = $(elem),
                targ = target,
                attr = {},
                toff;
            switch (typeof targ) {
                case "number":
                case "string":
                    if (/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(targ)) {
                        targ = both(targ);
                        break
                    }
                    targ = win ? $(targ) : $(targ, elem);
                case "object":
                    if (targ.length === 0) return;
                    if (targ.is || targ.style) toff = (targ = $(targ)).offset()
            }
            var offset = $.isFunction(settings.offset) && settings.offset(elem, targ) || settings.offset;
            $.each(settings.axis.split(""), function(i, axis) {
                var Pos = axis === "x" ? "Left" : "Top",
                    pos = Pos.toLowerCase(),
                    key = "scroll" + Pos,
                    prev = $elem[key](),
                    max = $scrollTo.max(elem, axis);
                if (toff) {
                    attr[key] = toff[pos] + (win ? 0 : prev - $elem.offset()[pos]);
                    if (settings.margin) {
                        attr[key] -= parseInt(targ.css("margin" + Pos), 10) || 0;
                        attr[key] -= parseInt(targ.css("border" + Pos + "Width"), 10) || 0
                    }
                    attr[key] += offset[pos] || 0;
                    if (settings.over[pos]) attr[key] += targ[axis === "x" ? "width" : "height"]() * settings.over[pos]
                } else {
                    var val = targ[pos];
                    attr[key] = val.slice && val.slice(-1) === "%" ? parseFloat(val) / 100 * max : val
                }
                if (settings.limit && /^\d+$/.test(attr[key])) attr[key] =
                    attr[key] <= 0 ? 0 : Math.min(attr[key], max);
                if (!i && settings.axis.length > 1)
                    if (prev === attr[key]) attr = {};
                    else if (queue) {
                    animate(settings.onAfterFirst);
                    attr = {}
                }
            });
            animate(settings.onAfter);

            function animate(callback) {
                var opts = $.extend({}, settings, {
                    queue: true,
                    duration: duration,
                    complete: callback && function() {
                        callback.call(elem, targ, settings)
                    }
                });
                $elem.animate(attr, opts)
            }
        })
    };
    $scrollTo.max = function(elem, axis) {
        var Dim = axis === "x" ? "Width" : "Height",
            scroll = "scroll" + Dim;
        if (!isWin(elem)) return elem[scroll] - $(elem)[Dim.toLowerCase()]();
        var size = "client" + Dim,
            doc = elem.ownerDocument || elem.document,
            html = doc.documentElement,
            body = doc.body;
        return Math.max(html[scroll], body[scroll]) - Math.min(html[size], body[size])
    };

    function both(val) {
        return $.isFunction(val) || $.isPlainObject(val) ? val : {
            top: val,
            left: val
        }
    }
    $.Tween.propHooks.scrollLeft = $.Tween.propHooks.scrollTop = {
        get: function(t) {
            return $(t.elem)[t.prop]()
        },
        set: function(t) {
            var curr = this.get(t);
            if (t.options.interrupt && t._last && t._last !== curr) return $(t.elem).stop();
            var next = Math.round(t.now);
            if (curr !== next) {
                $(t.elem)[t.prop](next);
                t._last = this.get(t)
            }
        }
    };
    return $scrollTo
});
(function() {
    var Sugar = {};
    var object = Object;
    var globalContext = typeof global !== "undefined" ? global : window;
    var hasExports = typeof module !== "undefined" && module.exports;
    var noConflict = hasExports && typeof process !== "undefined" ? process.env["SUGAR_NO_CONFLICT"] : false;
    var internalHasOwnProperty = object.prototype.hasOwnProperty;
    var propertyDescriptorSupport = !!(object.defineProperty && object.defineProperties);
    var natives = "Boolean,Number,String,Array,Date,RegExp,Function".split(",");
    var proxies = {};

    function initializeGlobal() {
        Sugar = {
            "extend": extend,
            "restore": restore,
            "revert": revert,
            "noConflict": noConflict
        };
        if (hasExports) module.exports = Sugar;
        else globalContext.Sugar = Sugar
    }

    function initializeNatives() {
        iterateOverObject(natives.concat("Object"), function(i, name) {
            proxies[globalContext[name]] = name;
            Sugar[name] = {}
        })
    }

    function extend(klass, methods, instance, polyfill, override) {
        var extendee;
        instance = instance !== false;
        extendee = instance ? klass.prototype : klass;
        iterateOverObject(methods, function(name, prop) {
            var existing = checkGlobal("fn", klass,
                    name, extendee),
                original = checkGlobal("original", klass, name, extendee),
                existed = name in extendee;
            if (typeof polyfill === "function" && existing) prop = wrapExisting(existing, prop, polyfill);
            defineMethodOnNamespace(klass, name, instance, original, prop, existed, polyfill);
            if (canDefineOnNative(klass, polyfill, existing, override)) setProperty(extendee, name, prop)
        })
    }

    function alias(klass, target, source) {
        var method = getProxy(klass)[source];
        var obj = {};
        obj[target] = method.fn;
        extend(klass, obj, method.instance)
    }

    function restore(klass,
        methods) {
        if (noConflict) return;
        return batchMethodExecute(klass, methods, function(target, name, m) {
            setProperty(target, name, m.fn)
        })
    }

    function revert(klass, methods) {
        return batchMethodExecute(klass, methods, function(target, name, m) {
            if (m.existed) setProperty(target, name, m.original);
            else delete target[name]
        })
    }

    function batchMethodExecute(klass, methods, fn) {
        var all = !methods,
            changed = false;
        if (typeof methods === "string") methods = [methods];
        iterateOverObject(getProxy(klass), function(name, m) {
            if (all || methods.indexOf(name) !==
                -1) {
                changed = true;
                fn(m.instance ? klass.prototype : klass, name, m)
            }
        });
        return changed
    }

    function checkGlobal(type, klass, name, extendee) {
        var proxy = getProxy(klass),
            methodExists;
        methodExists = proxy && hasOwnProperty(proxy, name) && !proxy[name].polyfill;
        if (methodExists) return proxy[name][type];
        else return extendee[name]
    }

    function canDefineOnNative(klass, polyfill, existing, override) {
        if (override) return true;
        else if (polyfill === true) return !existing;
        return !noConflict || !proxies[klass]
    }

    function wrapExisting(originalFn, extendedFn,
        condition) {
        return function(a) {
            return condition.apply(this, arguments) ? extendedFn.apply(this, arguments) : originalFn.apply(this, arguments)
        }
    }

    function wrapInstanceMethod(fn) {
        return function(obj) {
            var args = arguments,
                newArgs = [],
                i;
            for (i = 1; i < args.length; i++) newArgs.push(args[i]);
            return fn.apply(obj, newArgs)
        }
    }

    function defineMethodOnNamespace(klass, name, instance, original, prop, existed, polyfill) {
        var proxy = getProxy(klass),
            result;
        if (!proxy) return;
        result = instance ? wrapInstanceMethod(prop) : prop;
        setProperty(proxy, name,
            result, true);
        if (typeof prop === "function") {
            setProperty(result, "fn", prop);
            setProperty(result, "original", original);
            setProperty(result, "existed", existed);
            setProperty(result, "instance", instance);
            setProperty(result, "polyfill", polyfill)
        }
    }

    function getProxy(klass) {
        return Sugar[proxies[klass]]
    }

    function setProperty(target, name, property, enumerable) {
        if (propertyDescriptorSupport) object.defineProperty(target, name, {
            value: property,
            enumerable: !!enumerable,
            configurable: true,
            writable: true
        });
        else target[name] = property
    }

    function iterateOverObject(obj, fn) {
        var key;
        for (key in obj) {
            if (!hasOwnProperty(obj, key)) continue;
            if (fn.call(obj, key, obj[key], obj) === false) break
        }
    }

    function hasOwnProperty(obj, prop) {
        return !!obj && internalHasOwnProperty.call(obj, prop)
    }
    initializeGlobal();
    initializeNatives();
    var object = Object,
        array = Array,
        regexp = RegExp,
        date = Date,
        string = String,
        number = Number,
        func = Function,
        math = Math,
        Undefined;
    var sugarObject = Sugar.Object,
        sugarArray = Sugar.Array,
        sugarDate = Sugar.Date,
        sugarString = Sugar.String,
        sugarNumber = Sugar.Number;
    var internalToString = object.prototype.toString;
    var regexIsFunction = typeof regexp() === "function";
    var noKeysInStringObjects = !("0" in new string("a"));
    var typeChecks = {};
    var matchedByValueReg = /^\[object Date|Array|String|Number|RegExp|Boolean|Arguments\]$/;
    var isBoolean = buildPrimitiveClassCheck("boolean", natives[0]);
    var isNumber = buildPrimitiveClassCheck("number", natives[1]);
    var isString = buildPrimitiveClassCheck("string", natives[2]);
    var isArray = buildClassCheck(natives[3]);
    var isDate = buildClassCheck(natives[4]);
    var isRegExp = buildClassCheck(natives[5]);
    var isFunction = buildClassCheck(natives[6]);

    function isClass(obj, klass, cached) {
        var k = cached || className(obj);
        return k === "[object " + klass + "]"
    }

    function buildClassCheck(klass) {
        var fn = klass === "Array" && array.isArray || function(obj, cached) {
            return isClass(obj, klass, cached)
        };
        typeChecks[klass] = fn;
        return fn
    }

    function buildPrimitiveClassCheck(type, klass) {
        var fn = function(obj) {
            if (isObjectType(obj)) return isClass(obj, klass);
            return typeof obj === type
        };
        typeChecks[klass] = fn;
        return fn
    }

    function className(obj) {
        return internalToString.call(obj)
    }

    function extendSimilar(klass, set, fn, instance, polyfill, override) {
        var methods = {};
        set = isString(set) ? set.split(",") : set;
        set.forEach(function(name, i) {
            fn(methods, name, i)
        });
        extend(klass, methods, instance, polyfill, override)
    }

    function isArgumentsObject(obj, klass) {
        klass = klass || className(obj);
        return hasProperty(obj, "length") && (klass === "[object Arguments]" || !!obj.callee)
    }

    function multiArgs(args, fn, from) {
        var result = [],
            i = from || 0,
            len;
        for (len = args.length; i <
            len; i++) {
            result.push(args[i]);
            if (fn) fn.call(args, args[i], i)
        }
        return result
    }

    function flattenedArgs(args, fn, from) {
        var arg = args[from || 0];
        if (isArray(arg)) {
            args = arg;
            from = 0
        }
        return multiArgs(args, fn, from)
    }

    function checkCallback(fn) {
        if (!fn || !fn.call) throw new TypeError("Callback is not callable");
    }

    function isDefined(o) {
        return o !== Undefined
    }

    function isUndefined(o) {
        return o === Undefined
    }

    function hasProperty(obj, prop) {
        return !isPrimitiveType(obj) && prop in obj
    }

    function isObjectType(obj) {
        return !!obj && (typeof obj ===
            "object" || regexIsFunction && isRegExp(obj))
    }

    function isPrimitiveType(obj) {
        var type = typeof obj;
        return obj == null || type === "string" || type === "number" || type === "boolean"
    }

    function isPlainObject(obj, klass) {
        klass = klass || className(obj);
        try {
            if (obj && obj.constructor && !hasOwnProperty(obj, "constructor") && !hasOwnProperty(obj.constructor.prototype, "isPrototypeOf")) return false
        } catch (e) {
            return false
        }
        return !!obj && klass === "[object Object]" && "hasOwnProperty" in obj
    }

    function simpleRepeat(n, fn) {
        for (var i = 0; i < n; i++) fn(i)
    }

    function simpleMerge(target,
        source) {
        iterateOverObject(source, function(key) {
            target[key] = source[key]
        });
        return target
    }

    function coercePrimitiveToObject(obj) {
        if (isPrimitiveType(obj)) obj = object(obj);
        if (noKeysInStringObjects && isString(obj)) forceStringCoercion(obj);
        return obj
    }

    function forceStringCoercion(obj) {
        var i = 0,
            chr;
        while (chr = obj.charAt(i)) obj[i++] = chr
    }

    function Hash(obj) {
        simpleMerge(this, coercePrimitiveToObject(obj))
    }
    Hash.prototype.constructor = object;
    var abs = math.abs;
    var pow = math.pow;
    var ceil = math.ceil;
    var floor = math.floor;
    var round =
        math.round;
    var min = math.min;
    var max = math.max;

    function withPrecision(val, precision, fn) {
        var multiplier = pow(10, abs(precision || 0));
        fn = fn || round;
        if (precision < 0) multiplier = 1 / multiplier;
        return fn(val * multiplier) / multiplier
    }
    var HalfWidthZeroCode = 48;
    var HalfWidthNineCode = 57;
    var FullWidthZeroCode = 65296;
    var FullWidthNineCode = 65305;
    var HalfWidthPeriod = ".";
    var FullWidthPeriod = "．";
    var HalfWidthComma = ",";
    var FullWidthDigits = "";
    var NumberNormalizeMap = {};
    var NumberNormalizeReg;

    function codeIsNumeral(code) {
        return code >=
            HalfWidthZeroCode && code <= HalfWidthNineCode || code >= FullWidthZeroCode && code <= FullWidthNineCode
    }

    function buildNumberHelpers() {
        var digit, i;
        for (i = 0; i <= 9; i++) {
            digit = chr(i + FullWidthZeroCode);
            FullWidthDigits += digit;
            NumberNormalizeMap[digit] = chr(i + HalfWidthZeroCode)
        }
        NumberNormalizeMap[HalfWidthComma] = "";
        NumberNormalizeMap[FullWidthPeriod] = HalfWidthPeriod;
        NumberNormalizeMap[HalfWidthPeriod] = HalfWidthPeriod;
        NumberNormalizeReg = regexp("[" + FullWidthDigits + FullWidthPeriod + HalfWidthComma + HalfWidthPeriod + "]", "g")
    }

    function chr(num) {
        return string.fromCharCode(num)
    }

    function getTrimmableCharacters() {
        return "\t\n\x0B\f\r   ᠎             \u2028\u2029　﻿"
    }

    function repeatString(str, num) {
        var result = "";
        str = str.toString();
        while (num > 0) {
            if (num & 1) result += str;
            if (num >>= 1) str += str
        }
        return result
    }

    function stringToNumber(str, base) {
        var sanitized, isDecimal;
        sanitized = str.replace(NumberNormalizeReg, function(chr) {
            var replacement = NumberNormalizeMap[chr];
            if (replacement === HalfWidthPeriod) isDecimal = true;
            return replacement
        });
        return isDecimal ?
            parseFloat(sanitized) : parseInt(sanitized, base || 10)
    }

    function padNumber(num, place, sign, base) {
        var str = abs(num).toString(base || 10);
        str = repeatString("0", place - str.replace(/\.\d+/, "").length) + str;
        if (sign || num < 0) str = (num < 0 ? "-" : "+") + str;
        return str
    }

    function getOrdinalizedSuffix(num) {
        if (num >= 11 && num <= 13) return "th";
        else switch (num % 10) {
            case 1:
                return "st";
            case 2:
                return "nd";
            case 3:
                return "rd";
            default:
                return "th"
        }
    }

    function getRegExpFlags(reg, add) {
        var flags = "";
        add = add || "";

        function checkFlag(prop, flag) {
            if (prop || add.indexOf(flag) >
                -1) flags += flag
        }
        checkFlag(reg.multiline, "m");
        checkFlag(reg.ignoreCase, "i");
        checkFlag(reg.global, "g");
        checkFlag(reg.sticky, "y");
        return flags
    }

    function escapeRegExp(str) {
        if (!isString(str)) str = string(str);
        return str.replace(/([\\\/\'*+?|()\[\]{}.^$-])/g, "\\$1")
    }

    function callDateGet(d, method) {
        return d["get" + (d._utc ? "UTC" : "") + method]()
    }

    function callDateSet(d, method, value) {
        return d["set" + (d._utc ? "UTC" : "") + method](value)
    }

    function stringify(thing, stack) {
        var type = typeof thing,
            isObject, isArrayLike, klass, value,
            arr, key, i, len;
        if (type === "string") return thing;
        klass = internalToString.call(thing);
        isObject = isPlainObject(thing, klass);
        isArrayLike = isArray(thing, klass) || isArgumentsObject(thing, klass);
        if (thing != null && isObject || isArrayLike) {
            if (!stack) stack = [];
            if (stack.length > 1) {
                i = stack.length;
                while (i--)
                    if (stack[i] === thing) return "CYC"
            }
            stack.push(thing);
            value = thing.valueOf() + string(thing.constructor);
            arr = isArrayLike ? thing : object.keys(thing).sort();
            for (i = 0, len = arr.length; i < len; i++) {
                key = isArrayLike ? i : arr[i];
                value += key + stringify(thing[key],
                    stack)
            }
            stack.pop()
        } else if (1 / thing === -Infinity) value = "-0";
        else value = string(thing && thing.valueOf ? thing.valueOf() : thing);
        return type + klass + value
    }

    function isEqual(a, b) {
        if (a === b) return a !== 0 || 1 / a === 1 / b;
        else if (objectIsMatchedByValue(a) && objectIsMatchedByValue(b)) return stringify(a) === stringify(b);
        return false
    }

    function objectIsMatchedByValue(obj) {
        var klass = className(obj);
        return matchedByValueReg.test(klass) || isPlainObject(obj, klass)
    }

    function getEntriesForIndexes(obj, args, isString) {
        var result, length = obj.length,
            argsLen = args.length,
            overshoot = args[argsLen - 1] !== false,
            multiple = argsLen > (overshoot ? 1 : 2);
        if (!multiple) return entryAtIndex(obj, length, args[0], overshoot, isString);
        result = [];
        multiArgs(args, function(index) {
            if (isBoolean(index)) return false;
            result.push(entryAtIndex(obj, length, index, overshoot, isString))
        });
        return result
    }

    function entryAtIndex(obj, length, index, overshoot, isString) {
        if (overshoot) {
            index = index % length;
            if (index < 0) index = length + index
        }
        return isString ? obj.charAt(index) : obj[index]
    }

    function transformArgument(el,
        map, context, mapArgs) {
        if (!map) return el;
        else if (map.apply) return map.apply(context, mapArgs || []);
        else if (isFunction(el[map])) return el[map].call(el);
        else return el[map]
    }

    function keysWithObjectCoercion(obj) {
        return object.keys(coercePrimitiveToObject(obj))
    }

    function buildObjectInstanceMethods(set, target) {
        set.forEach(function(name) {
            var key = name === "equals" ? "equal" : name;
            var classFn = sugarObject[key] || object[key];
            var fn = function() {
                var args = arguments,
                    newArgs = [this],
                    i;
                for (i = 0; i < args.length; i++) newArgs.push(args[i]);
                return classFn.apply(null, newArgs)
            };
            setProperty(target.prototype, name, fn)
        })
    }
    buildNumberHelpers();
    extend(object, {
        "keys": function(obj) {
            var keys = [];
            if (!isObjectType(obj) && !isRegExp(obj) && !isFunction(obj)) throw new TypeError("Object required");
            iterateOverObject(obj, function(key, value) {
                keys.push(key)
            });
            return keys
        }
    }, false, true);

    function arrayIndexOf(arr, search, fromIndex, increment) {
        var length = arr.length,
            fromRight = increment == -1,
            start = fromRight ? length - 1 : 0,
            index = toIntegerWithDefault(fromIndex, start);
        if (index <
            0) index = length + index;
        if (!fromRight && index < 0 || fromRight && index >= length) index = start;
        while (fromRight && index >= 0 || !fromRight && index < length) {
            if (arr[index] === search) return index;
            index += increment
        }
        return -1
    }

    function arrayReduce(arr, fn, initialValue, fromRight) {
        var length = arr.length,
            count = 0,
            defined = isDefined(initialValue),
            result, index;
        checkCallback(fn);
        if (length == 0 && !defined) throw new TypeError("Reduce called on empty array with no initial value");
        else if (defined) result = initialValue;
        else {
            result = arr[fromRight ?
                length - 1 : count];
            count++
        }
        while (count < length) {
            index = fromRight ? length - count - 1 : count;
            if (index in arr) result = fn(result, arr[index], index, arr);
            count++
        }
        return result
    }

    function toIntegerWithDefault(i, d) {
        if (isNaN(i)) return d;
        else return parseInt(i >> 0)
    }

    function checkFirstArgumentExists(args) {
        if (args.length === 0) throw new TypeError("First argument must be defined");
    }
    extend(array, {
        "isArray": function(obj) {
            return isArray(obj)
        }
    }, false, true);
    extend(array, {
        "every": function(fn, scope) {
            var length = this.length,
                index = 0;
            checkFirstArgumentExists(arguments);
            while (index < length) {
                if (index in this && !fn.call(scope, this[index], index, this)) return false;
                index++
            }
            return true
        },
        "some": function(fn, scope) {
            var length = this.length,
                index = 0;
            checkFirstArgumentExists(arguments);
            while (index < length) {
                if (index in this && fn.call(scope, this[index], index, this)) return true;
                index++
            }
            return false
        },
        "map": function(fn, scope) {
            var scope = arguments[1],
                length = this.length,
                index = 0,
                result = new Array(length);
            checkFirstArgumentExists(arguments);
            while (index < length) {
                if (index in this) result[index] =
                    fn.call(scope, this[index], index, this);
                index++
            }
            return result
        },
        "filter": function(fn) {
            var scope = arguments[1];
            var length = this.length,
                index = 0,
                result = [];
            checkFirstArgumentExists(arguments);
            while (index < length) {
                if (index in this && fn.call(scope, this[index], index, this)) result.push(this[index]);
                index++
            }
            return result
        },
        "indexOf": function(search) {
            var fromIndex = arguments[1];
            if (isString(this)) return this.indexOf(search, fromIndex);
            return arrayIndexOf(this, search, fromIndex, 1)
        },
        "lastIndexOf": function(search) {
            var fromIndex =
                arguments[1];
            if (isString(this)) return this.lastIndexOf(search, fromIndex);
            return arrayIndexOf(this, search, fromIndex, -1)
        },
        "forEach": function(fn) {
            var length = this.length,
                index = 0,
                scope = arguments[1];
            checkCallback(fn);
            while (index < length) {
                if (index in this) fn.call(scope, this[index], index, this);
                index++
            }
        },
        "reduce": function(fn) {
            return arrayReduce(this, fn, arguments[1])
        },
        "reduceRight": function(fn) {
            return arrayReduce(this, fn, arguments[1], true)
        }
    }, true, true);
    var TrimRegExp = regexp("^[" + getTrimmableCharacters() + "]+|[" +
        getTrimmableCharacters() + "]+$", "g");
    extend(string, {
        "trim": function() {
            return this.toString().replace(TrimRegExp, "")
        }
    }, true, true);
    extend(func, {
        "bind": function(scope) {
            var fn = this,
                args = multiArgs(arguments, null, 1),
                bound;
            if (!isFunction(this)) throw new TypeError("Function.prototype.bind called on a non-function");
            bound = function() {
                return fn.apply(fn.prototype && this instanceof fn ? this : scope, args.concat(multiArgs(arguments)))
            };
            bound.prototype = this.prototype;
            return bound
        }
    }, true, true);

    function hasISOStringSupport() {
        var d =
            new date(date.UTC(2E3, 0)),
            expected = "2000-01-01T00:00:00.000Z";
        return !!d.toISOString && d.toISOString() === expected
    }
    extend(date, {
        "now": function() {
            return (new date).getTime()
        }
    }, false, true);
    extendSimilar(date, "toISOString,toJSON", function(methods, name) {
        methods[name] = function() {
            return padNumber(this.getUTCFullYear(), 4) + "-" + padNumber(this.getUTCMonth() + 1, 2) + "-" + padNumber(this.getUTCDate(), 2) + "T" + padNumber(this.getUTCHours(), 2) + ":" + padNumber(this.getUTCMinutes(), 2) + ":" + padNumber(this.getUTCSeconds(), 2) + "." +
                padNumber(this.getUTCMilliseconds(), 3) + "Z"
        }
    }, true, true, !hasISOStringSupport());

    function regexMatcher(reg) {
        reg = regexp(reg);
        return function(el) {
            return reg.test(el)
        }
    }

    function dateMatcher(d) {
        var ms = d.getTime();
        return function(el) {
            return !!(el && el.getTime) && el.getTime() === ms
        }
    }

    function functionMatcher(fn) {
        return function(el, i, arr) {
            return el === fn || fn.call(this, el, i, arr)
        }
    }

    function invertedArgsFunctionMatcher(fn) {
        return function(value, key, obj) {
            return value === fn || fn.call(obj, key, value, obj)
        }
    }

    function fuzzyMatcher(obj,
        isObject) {
        var matchers = {};
        return function(el, i, arr) {
            var key;
            if (!isObjectType(el)) return false;
            for (key in obj) {
                matchers[key] = matchers[key] || getMatcher(obj[key], isObject);
                if (matchers[key].call(arr, el[key], i, arr) === false) return false
            }
            return true
        }
    }

    function defaultMatcher(f) {
        return function(el) {
            return el === f || isEqual(el, f)
        }
    }

    function getMatcher(f, isObject) {
        if (isPrimitiveType(f));
        else if (isRegExp(f)) return regexMatcher(f);
        else if (isDate(f)) return dateMatcher(f);
        else if (isFunction(f))
            if (isObject) return invertedArgsFunctionMatcher(f);
            else return functionMatcher(f);
        else if (isPlainObject(f)) return fuzzyMatcher(f, isObject);
        return defaultMatcher(f)
    }

    function transformArgument(el, map, context, mapArgs) {
        if (!map) return el;
        else if (map.apply) return map.apply(context, mapArgs || []);
        else if (isArray(map)) return map.map(function(m) {
            return transformArgument(el, m, context, mapArgs)
        });
        else if (isFunction(el[map])) return el[map].call(el);
        else return el[map]
    }

    function compareValue(aVal, bVal) {
        var cmp, i;
        if (isString(aVal) && isString(bVal)) return collateStrings(aVal,
            bVal);
        else if (isArray(aVal) && isArray(bVal))
            if (aVal.length < bVal.length) return -1;
            else if (aVal.length > bVal.length) return 1;
        else {
            for (i = 0; i < aVal.length; i++) {
                cmp = compareValue(aVal[i], bVal[i]);
                if (cmp !== 0) return cmp
            }
            return 0
        } else if (aVal < bVal) return -1;
        else if (aVal > bVal) return 1;
        else return 0
    }

    function arrayEach(arr, fn, startIndex, loop) {
        var index, i, length = +arr.length;
        if (startIndex < 0) startIndex = arr.length + startIndex;
        i = isNaN(startIndex) ? 0 : startIndex;
        if (loop === true) length += i;
        while (i < length) {
            index = i % arr.length;
            if (!(index in arr)) return iterateOverSparseArray(arr, fn, i, loop);
            else if (fn.call(arr, arr[index], index, arr) === false) break;
            i++
        }
    }

    function iterateOverSparseArray(arr, fn, fromIndex, loop) {
        var indexes = [],
            i;
        for (i in arr)
            if (isArrayIndex(arr, i) && i >= fromIndex) indexes.push(parseInt(i));
        arrayEach(indexes.sort(), function(index) {
            return fn.call(arr, arr[index], index, arr)
        });
        return arr
    }

    function isArrayIndex(arr, i) {
        return i in arr && toUInt32(i) == i && i != 4294967295
    }

    function toUInt32(i) {
        return i >>> 0
    }

    function arrayFind(arr,
        f, startIndex, loop, returnIndex, context) {
        var result, index, matcher;
        if (arr.length > 0) {
            matcher = getMatcher(f);
            arrayEach(arr, function(el, i) {
                if (matcher.call(context, el, i, arr)) {
                    result = el;
                    index = i;
                    return false
                }
            }, startIndex, loop)
        }
        return returnIndex ? index : result
    }

    function arrayFindAll(arr, f, index, loop) {
        var result = [],
            matcher;
        if (arr.length > 0) {
            matcher = getMatcher(f);
            arrayEach(arr, function(el, i, arr) {
                if (matcher(el, i, arr)) result.push(el)
            }, index, loop)
        }
        return result
    }

    function arrayAdd(arr, el, index) {
        if (!isNumber(number(index)) ||
            isNaN(index)) index = arr.length;
        array.prototype.splice.apply(arr, [index, 0].concat(el));
        return arr
    }

    function arrayRemove(arr, args) {
        multiArgs(args, function(f) {
            var i = 0,
                matcher = getMatcher(f);
            while (i < arr.length)
                if (matcher(arr[i], i, arr)) arr.splice(i, 1);
                else i++
        });
        return arr
    }

    function arrayUnique(arr, map) {
        var result = [],
            o = {},
            transformed;
        arrayEach(arr, function(el, i) {
            transformed = map ? transformArgument(el, map, arr, [el, i, arr]) : el;
            if (!checkForElementInHashAndSet(o, transformed)) result.push(el)
        });
        return result
    }

    function arrayIntersect(arr1,
        arr2, subtract) {
        var result = [],
            o = {};
        arrayEach(arr2, function(el) {
            checkForElementInHashAndSet(o, el)
        });
        arrayEach(arr1, function(el) {
            var stringified = stringify(el),
                isReference = !objectIsMatchedByValue(el);
            if (elementExistsInHash(o, stringified, el, isReference) !== subtract) {
                discardElementFromHash(o, stringified, el, isReference);
                result.push(el)
            }
        });
        return result
    }

    function arrayFlatten(arr, level, current) {
        level = level || Infinity;
        current = current || 0;
        var result = [];
        arrayEach(arr, function(el) {
            if (isArray(el) && current < level) result =
                result.concat(arrayFlatten(el, level, current + 1));
            else result.push(el)
        });
        return result
    }

    function arrayGroupBy(arr, map, fn) {
        var result = {},
            key;
        arrayEach(arr, function(el, index) {
            key = transformArgument(el, map, arr, [el, index, arr]);
            if (!result[key]) result[key] = [];
            result[key].push(el)
        });
        if (fn) iterateOverObject(result, fn);
        return result
    }

    function arraySum(arr, map) {
        if (map) arr = sugarArray.map(arr, map);
        return arr.length > 0 ? arr.reduce(function(a, b) {
            return a + b
        }) : 0
    }

    function arrayCompact(arr, all) {
        var result = [];
        arrayEach(arr,
            function(el, i) {
                if (isArray(el)) result.push(arrayCompact(el));
                else if (all && el) result.push(el);
                else if (!all && el != null && el.valueOf() === el.valueOf()) result.push(el)
            });
        return result
    }

    function arrayRandomize(arr) {
        arr = arrayClone(arr);
        var i = arr.length,
            j, x;
        while (i) {
            j = math.random() * i | 0;
            x = arr[--i];
            arr[i] = arr[j];
            arr[j] = x
        }
        return arr
    }

    function arrayClone(arr) {
        return simpleMerge([], arr)
    }

    function isArrayLike(obj) {
        return hasProperty(obj, "length") && !isString(obj) && !isPlainObject(obj)
    }

    function flatArguments(args) {
        var result = [];
        multiArgs(args, function(arg) {
            result = result.concat(arg)
        });
        return result
    }

    function elementExistsInHash(hash, key, element, isReference) {
        var exists = hasOwnProperty(hash, key);
        if (isReference) {
            if (!hash[key]) hash[key] = [];
            exists = hash[key].indexOf(element) !== -1
        }
        return exists
    }

    function checkForElementInHashAndSet(hash, element) {
        var stringified = stringify(element),
            isReference = !objectIsMatchedByValue(element),
            exists = elementExistsInHash(hash, stringified, element, isReference);
        if (isReference) hash[stringified].push(element);
        else hash[stringified] = element;
        return exists
    }

    function discardElementFromHash(hash, key, element, isReference) {
        var arr, i = 0;
        if (isReference) {
            arr = hash[key];
            while (i < arr.length)
                if (arr[i] === element) arr.splice(i, 1);
                else i += 1
        } else delete hash[key]
    }

    function getMinOrMax(obj, map, which, all) {
        var el, key, edge, test, result = [],
            max = which === "max",
            min = which === "min",
            isArray = array.isArray(obj);
        for (key in obj) {
            if (!obj.hasOwnProperty(key)) continue;
            el = obj[key];
            test = transformArgument(el, map, obj, isArray ? [el, parseInt(key), obj] : []);
            if (isUndefined(test)) throw new TypeError("Cannot compare with undefined");
            if (test === edge) result.push(el);
            else if (isUndefined(edge) || max && test > edge || min && test < edge) {
                result = [el];
                edge = test
            }
        }
        if (!isArray) result = arrayFlatten(result, 1);
        return all ? result : result[0]
    }

    function collateStrings(a, b) {
        var aValue, bValue, aChar, bChar, aEquiv, bEquiv, index = 0,
            tiebreaker = 0;
        var sortIgnore = sugarArray[AlphanumericSortIgnore];
        var sortIgnoreCase = sugarArray[AlphanumericSortIgnoreCase];
        var sortEquivalents = sugarArray[AlphanumericSortEquivalents];
        var sortOrder = sugarArray[AlphanumericSortOrder];
        var naturalSort = sugarArray[AlphanumericSortNatural];
        a = getCollationReadyString(a, sortIgnore, sortIgnoreCase);
        b = getCollationReadyString(b, sortIgnore, sortIgnoreCase);
        do {
            aChar = getCollationCharacter(a, index, sortEquivalents);
            bChar = getCollationCharacter(b, index, sortEquivalents);
            aValue = getSortOrderIndex(aChar, sortOrder);
            bValue = getSortOrderIndex(bChar, sortOrder);
            if (aValue === -1 || bValue === -1) {
                aValue = a.charCodeAt(index) || null;
                bValue = b.charCodeAt(index) || null;
                if (naturalSort &&
                    codeIsNumeral(aValue) && codeIsNumeral(bValue)) {
                    aValue = stringToNumber(a.slice(index));
                    bValue = stringToNumber(b.slice(index))
                }
            } else {
                aEquiv = aChar !== a.charAt(index);
                bEquiv = bChar !== b.charAt(index);
                if (aEquiv !== bEquiv && tiebreaker === 0) tiebreaker = aEquiv - bEquiv
            }
            index += 1
        } while (aValue != null && bValue != null && aValue === bValue);
        if (aValue === bValue) return tiebreaker;
        return aValue - bValue
    }

    function getCollationReadyString(str, sortIgnore, sortIgnoreCase) {
        if (!isString(str)) str = string(str);
        if (sortIgnoreCase) str = str.toLowerCase();
        if (sortIgnore) str = str.replace(sortIgnore, "");
        return str
    }

    function getCollationCharacter(str, index, sortEquivalents) {
        var chr = str.charAt(index);
        return sortEquivalents[chr] || chr
    }

    function getSortOrderIndex(chr, sortOrder) {
        if (!chr) return null;
        else return sortOrder.indexOf(chr)
    }
    var AlphanumericSort = "AlphanumericSort";
    var AlphanumericSortOrder = "AlphanumericSortOrder";
    var AlphanumericSortIgnore = "AlphanumericSortIgnore";
    var AlphanumericSortIgnoreCase = "AlphanumericSortIgnoreCase";
    var AlphanumericSortEquivalents =
        "AlphanumericSortEquivalents";
    var AlphanumericSortNatural = "AlphanumericSortNatural";

    function buildEnhancements() {
        var nativeMap = array.prototype.map;
        var callbackCheck = function() {
            var args = arguments;
            return args.length > 0 && !isFunction(args[0])
        };
        extendSimilar(array, "every,some,filter,find,findIndex", function(methods, name) {
            var nativeFn = array.prototype[name];
            methods[name] = function(f) {
                var matcher = getMatcher(f);
                return nativeFn.call(this, function(el, index, arr) {
                    return matcher(el, index, arr)
                })
            }
        }, true, callbackCheck);
        extend(array, {
            "map": function(map, context) {
                var arr = this;
                if (arguments.length < 2) context = arr;
                return nativeMap.call(arr, function(el, index) {
                    return transformArgument(el, map, context, [el, index, arr])
                })
            }
        }, true, callbackCheck)
    }

    function buildAlphanumericSort() {
        var order = "AÁÀÂÃĄBCĆČÇDĎÐEÉÈĚÊËĘFGĞHıIÍÌİÎÏJKLŁMNŃŇÑOÓÒÔPQRŘSŚŠŞTŤUÚÙŮÛÜVWXYÝZŹŻŽÞÆŒØÕÅÄÖ";
        var equiv = "AÁÀÂÃÄ,CÇ,EÉÈÊË,IÍÌİÎÏ,OÓÒÔÕÖ,Sß,UÚÙÛÜ";
        sugarArray[AlphanumericSortOrder] = order.split("").map(function(str) {
            return str + str.toLowerCase()
        }).join("");
        var equivalents = {};
        arrayEach(equiv.split(","), function(set) {
            var equivalent = set.charAt(0);
            arrayEach(set.slice(1).split(""), function(chr) {
                equivalents[chr] = equivalent;
                equivalents[chr.toLowerCase()] = equivalent.toLowerCase()
            })
        });
        sugarArray[AlphanumericSortNatural] = true;
        sugarArray[AlphanumericSortIgnoreCase] = true;
        sugarArray[AlphanumericSortEquivalents] = equivalents
    }
    extend(array, {
        "create": function() {
            var result = [];
            multiArgs(arguments, function(a) {
                if (isArgumentsObject(a) || isArrayLike(a)) a = multiArgs(a);
                result = result.concat(a)
            });
            return result
        }
    }, false);
    extend(array, {
        "find": function(f) {
            var context = arguments[1];
            checkCallback(f);
            return arrayFind(this, f, 0, false, false, context)
        },
        "findIndex": function(f) {
            var index, context = arguments[1];
            checkCallback(f);
            index = arrayFind(this, f, 0, false, true, context);
            return isUndefined(index) ? -1 : index
        }
    }, true, true);
    extend(array, {
        "findFrom": function(f, index, loop) {
            return arrayFind(this, f, index, loop)
        },
        "findIndexFrom": function(f, index, loop) {
            var index = arrayFind(this, f, index, loop, true);
            return isUndefined(index) ?
                -1 : index
        },
        "findAll": function(f, index, loop) {
            return arrayFindAll(this, f, index, loop)
        },
        "count": function(f) {
            if (isUndefined(f)) return this.length;
            return arrayFindAll(this, f).length
        },
        "removeAt": function(start, end) {
            if (isUndefined(start)) return this;
            if (isUndefined(end)) end = start;
            this.splice(start, end - start + 1);
            return this
        },
        "include": function(el, index) {
            return arrayAdd(arrayClone(this), el, index)
        },
        "exclude": function() {
            return arrayRemove(arrayClone(this), arguments)
        },
        "clone": function() {
            return arrayClone(this)
        },
        "unique": function(map) {
            return arrayUnique(this, map)
        },
        "flatten": function(limit) {
            return arrayFlatten(this, limit)
        },
        "union": function() {
            return arrayUnique(this.concat(flatArguments(arguments)))
        },
        "intersect": function() {
            return arrayIntersect(this, flatArguments(arguments), false)
        },
        "subtract": function(a) {
            return arrayIntersect(this, flatArguments(arguments), true)
        },
        "at": function() {
            return getEntriesForIndexes(this, arguments)
        },
        "first": function(num) {
            if (isUndefined(num)) return this[0];
            if (num < 0) num = 0;
            return this.slice(0,
                num)
        },
        "last": function(num) {
            if (isUndefined(num)) return this[this.length - 1];
            var start = this.length - num < 0 ? 0 : this.length - num;
            return this.slice(start)
        },
        "from": function(num) {
            return this.slice(num)
        },
        "to": function(num) {
            if (isUndefined(num)) num = this.length;
            return this.slice(0, num)
        },
        "min": function(map, all) {
            return getMinOrMax(this, map, "min", all)
        },
        "max": function(map, all) {
            return getMinOrMax(this, map, "max", all)
        },
        "least": function(map, all) {
            return getMinOrMax(arrayGroupBy(this, map), "length", "min", all)
        },
        "most": function(map,
            all) {
            return getMinOrMax(arrayGroupBy(this, map), "length", "max", all)
        },
        "sum": function(map) {
            return arraySum(this, map)
        },
        "average": function(map) {
            return this.length > 0 ? arraySum(this, map) / this.length : 0
        },
        "inGroups": function(num, padding) {
            var pad = arguments.length > 1;
            var arr = this;
            var result = [];
            var divisor = ceil(this.length / num);
            simpleRepeat(num, function(i) {
                var index = i * divisor;
                var group = arr.slice(index, index + divisor);
                if (pad && group.length < divisor) simpleRepeat(divisor - group.length, function() {
                    group.push(padding)
                });
                result.push(group)
            });
            return result
        },
        "inGroupsOf": function(num, padding) {
            var result = [],
                len = this.length,
                arr = this,
                group;
            if (len === 0 || num === 0) return arr;
            if (isUndefined(num)) num = 1;
            if (isUndefined(padding)) padding = null;
            simpleRepeat(ceil(len / num), function(i) {
                group = arr.slice(num * i, num * i + num);
                while (group.length < num) group.push(padding);
                result.push(group)
            });
            return result
        },
        "isEmpty": function() {
            return arrayCompact(this).length == 0
        },
        "sortBy": function(map, desc) {
            var arr = arrayClone(this);
            arr.sort(function(a, b) {
                var aProperty =
                    transformArgument(a, map, arr, [a]);
                var bProperty = transformArgument(b, map, arr, [b]);
                return compareValue(aProperty, bProperty) * (desc ? -1 : 1)
            });
            return arr
        },
        "randomize": function() {
            return arrayRandomize(this)
        },
        "zip": function() {
            var args = multiArgs(arguments);
            return this.map(function(el, i) {
                return [el].concat(args.map(function(k) {
                    return i in k ? k[i] : null
                }))
            })
        },
        "sample": function(num) {
            var arr = arrayRandomize(this);
            return arguments.length > 0 ? arr.slice(0, num) : arr[0]
        },
        "each": function(fn, index, loop) {
            arrayEach(this, fn, index,
                loop);
            return this
        },
        "add": function(el, index) {
            return arrayAdd(this, el, index)
        },
        "remove": function() {
            return arrayRemove(this, arguments)
        },
        "compact": function(all) {
            return arrayCompact(this, all)
        },
        "groupBy": function(map, fn) {
            return arrayGroupBy(this, map, fn)
        },
        "none": function(f) {
            var args = multiArgs(arguments);
            return !sugarArray.some.apply(this, [this].concat(args))
        }
    });

    function buildAliases() {
        alias(array, "all", "every");
        alias(array, "any", "some");
        alias(array, "insert", "add")
    }

    function buildEnumerableMethods(names, mapping) {
        extendSimilar(object,
            names,
            function(methods, name) {
                var unwrapped = sugarArray[name].fn;
                methods[name] = function(obj, arg1, arg2) {
                    var result, coerced = keysWithObjectCoercion(obj),
                        matcher;
                    if (!mapping) matcher = getMatcher(arg1, true);
                    result = unwrapped.call(coerced, function(key) {
                        var value = obj[key];
                        if (mapping) return transformArgument(value, arg1, obj, [key, value, obj]);
                        else return matcher(value, key, obj)
                    }, arg2);
                    if (isArray(result)) result = result.reduce(function(o, key, i) {
                        o[key] = obj[key];
                        return o
                    }, {});
                    return result
                }
            }, false);
        buildObjectInstanceMethods(names,
            Hash)
    }

    function exportSortAlgorithm() {
        sugarArray[AlphanumericSort] = collateStrings
    }
    var EnumerableFindingMethods = "any,all,none,count,find,findAll,isEmpty".split(",");
    var EnumerableMappingMethods = "sum,average,min,max,least,most".split(",");
    buildEnhancements();
    buildAliases();
    buildAlphanumericSort();
    buildEnumerableMethods(EnumerableFindingMethods);
    buildEnumerableMethods(EnumerableMappingMethods, true);
    exportSortAlgorithm();
    var English;
    var CurrentLocalization;
    var TimeFormat = ["ampm", "hour", "minute", "second",
        "ampm", "utc", "offsetSign", "offsetHours", "offsetMinutes", "ampm"
    ];
    var DecimalReg = "(?:[,.]\\d+)?";
    var HoursReg = "\\d{1,2}" + DecimalReg;
    var SixtyReg = "[0-5]\\d" + DecimalReg;
    var RequiredTime = "({t})?\\s*(" + HoursReg + ")(?:{h}(" + SixtyReg + ")?{m}(?::?(" + SixtyReg + "){s})?\\s*(?:({t})|(Z)|(?:([+-])(\\d{2,2})(?::?(\\d{2,2}))?)?)?|\\s*({t}))";
    var KanjiDigits = "〇一二三四五六七八九十百千万";
    var AsianDigitMap = {};
    var AsianDigitReg;
    var DateArgumentUnits;
    var DateUnitsReversed;
    var CoreDateFormats = [];
    var CompiledOutputFormats = {};
    var DateFormatTokens = {
        "yyyy": function(d) {
            return callDateGet(d, "FullYear")
        },
        "yy": function(d) {
            return callDateGet(d, "FullYear") % 100
        },
        "ord": function(d) {
            var date = callDateGet(d, "Date");
            return date + getOrdinalizedSuffix(date)
        },
        "tz": function(d) {
            return getUTCOffset(d)
        },
        "isotz": function(d) {
            return getUTCOffset(d, true)
        },
        "Z": function(d) {
            return getUTCOffset(d)
        },
        "ZZ": function(d) {
            return getUTCOffset(d).replace(/(\d{2})$/, ":$1")
        }
    };
    var DateUnits = [{
        name: "year",
        method: "FullYear",
        ambiguous: true,
        multiplier: 365.25 * 24 * 60 * 60 * 1E3
    }, {
        name: "month",
        method: "Month",
        ambiguous: true,
        multiplier: 30.4375 * 24 * 60 * 60 * 1E3
    }, {
        name: "week",
        method: "ISOWeek",
        multiplier: 7 * 24 * 60 * 60 * 1E3
    }, {
        name: "day",
        method: "Date",
        ambiguous: true,
        multiplier: 24 * 60 * 60 * 1E3
    }, {
        name: "hour",
        method: "Hours",
        multiplier: 60 * 60 * 1E3
    }, {
        name: "minute",
        method: "Minutes",
        multiplier: 60 * 1E3
    }, {
        name: "second",
        method: "Seconds",
        multiplier: 1E3
    }, {
        name: "millisecond",
        method: "Milliseconds",
        multiplier: 1
    }];
    var Localizations = {};

    function Localization(l) {
        simpleMerge(this, l);
        this.compiledFormats = CoreDateFormats.concat()
    }
    Localization.prototype = {
        get: function(prop) {
            return this[prop] || ""
        },
        getMonth: function(n) {
            if (isNumber(n)) return n - 1;
            else return this.months.indexOf(n) % 12
        },
        getWeekday: function(n) {
            return this.weekdays.indexOf(n) % 7
        },
        getNumber: function(n, digit) {
            var mapped = this.ordinalNumberMap[n];
            if (mapped) {
                if (digit) mapped = mapped % 10;
                return mapped
            }
            return isNumber(n) ? n : 1
        },
        getNumericDate: function(n) {
            var self = this;
            return n.replace(regexp(this.num, "g"), function(d) {
                var num = self.getNumber(d, true);
                return num || ""
            })
        },
        getUnitIndex: function(n) {
            return this.units.indexOf(n) %
                8
        },
        getRelativeFormat: function(adu) {
            return this.convertAdjustedToFormat(adu, adu[2] > 0 ? "future" : "past")
        },
        getDuration: function(ms) {
            return this.convertAdjustedToFormat(getAdjustedUnitForNumber(ms), "duration")
        },
        hasVariant: function(code) {
            code = code || this.code;
            return code === "en" || code === "en-US" ? true : this.variant
        },
        matchAM: function(str) {
            return str === this.get("ampm")[0]
        },
        matchPM: function(str) {
            return str && str === this.get("ampm")[1]
        },
        convertAdjustedToFormat: function(adu, mode) {
            var sign, unit, mult, num = adu[0],
                u = adu[1],
                ms = adu[2],
                format = this[mode] || this.relative;
            if (isFunction(format)) return format.call(this, num, u, ms, mode);
            mult = !this.plural || num === 1 ? 0 : 1;
            unit = this.units[mult * 8 + u] || this.units[u];
            if (this.capitalizeUnit) unit = simpleCapitalize(unit);
            sign = this.modifiers.filter(function(m) {
                return m.name == "sign" && m.value == (ms > 0 ? 1 : -1)
            })[0];
            return format.replace(/\{(.*?)\}/g, function(full, match) {
                switch (match) {
                    case "num":
                        return num;
                    case "unit":
                        return unit;
                    case "sign":
                        return sign.src
                }
            })
        },
        getFormats: function() {
            return this.cachedFormat ? [this.cachedFormat].concat(this.compiledFormats) : this.compiledFormats
        },
        addFormat: function(src, allowsTime, match, variant, iso) {
            var to = match || [],
                loc = this,
                time, timeMarkers, lastIsNumeral;
            src = src.replace(/\s+/g, "[,. ]*");
            src = src.replace(/\{([^,]+?)\}/g, function(all, k) {
                var value, arr, result, opt = k.match(/\?$/),
                    nc = k.match(/^(\d+)\??$/),
                    slice = k.match(/(\d)(?:-(\d))?/),
                    key = k.replace(/[^a-z]+$/, "");
                if (nc) value = loc.get("tokens")[nc[1]];
                else if (loc[key]) value = loc[key];
                else if (loc[key + "s"]) {
                    value = loc[key + "s"];
                    if (slice) {
                        arr = [];
                        value.forEach(function(m, i) {
                            var mod = i % (loc.units ? 8 : value.length);
                            if (mod >= slice[1] && mod <= (slice[2] || slice[1])) arr.push(m)
                        });
                        value = arr
                    }
                    value = arrayToAlternates(value)
                }
                if (!value) return "";
                if (nc) result = "(?:" + value + ")";
                else {
                    if (!match) to.push(key);
                    result = "(" + value + ")"
                }
                if (opt) result += "?";
                return result
            });
            if (allowsTime) {
                time = prepareTime(RequiredTime, loc, iso);
                timeMarkers = ["t", "[\\s\\u3000]"].concat(loc.get("timeMarker"));
                lastIsNumeral = src.match(/\\d\{\d,\d\}\)+\??$/);
                addDateInputFormat(loc, "(?:" + time + ")[,\\s\\u3000]+?" +
                    src, TimeFormat.concat(to), variant);
                addDateInputFormat(loc, src + "(?:[,\\s]*(?:" + timeMarkers.join("|") + (lastIsNumeral ? "+" : "*") + ")" + time + ")?", to.concat(TimeFormat), variant)
            } else addDateInputFormat(loc, src, to, variant)
        }
    };

    function getLocalization(localeCode, fallback) {
        var loc;
        if (!isString(localeCode)) localeCode = "";
        loc = Localizations[localeCode] || Localizations[localeCode.slice(0, 2)];
        if (fallback === false && !loc) throw new TypeError("Invalid locale.");
        return loc || CurrentLocalization
    }

    function setLocalization(localeCode,
        set) {
        var loc;

        function initializeField(name) {
            var val = loc[name];
            if (isString(val)) loc[name] = val.split(",");
            else if (!val) loc[name] = []
        }

        function eachAlternate(str, fn) {
            str = str.split("+").map(function(split) {
                return split.replace(/(.+):(.+)$/, function(full, base, suffixes) {
                    return suffixes.split("|").map(function(suffix) {
                        return base + suffix
                    }).join("|")
                })
            }).join("|");
            return str.split("|").forEach(fn)
        }

        function setArray(name, abbreviationSize, multiple) {
            var arr = [];
            loc[name].forEach(function(full, i) {
                if (abbreviationSize) full +=
                    "+" + full.slice(0, abbreviationSize);
                eachAlternate(full, function(alt, j) {
                    arr[j * multiple + i] = alt.toLowerCase()
                })
            });
            loc[name] = arr
        }

        function getDigit(start, stop, allowNumbers) {
            var str = "\\d{" + start + "," + stop + "}";
            if (allowNumbers) str += "|(?:" + arrayToAlternates(loc.get("numbers")) + ")+";
            return str
        }

        function getNum() {
            var numbers = loc.get("numbers");
            var arr = ["-?\\d+"].concat(loc.get("articles"));
            if (numbers) arr = arr.concat(numbers);
            return arrayToAlternates(arr)
        }

        function getAbbreviationSize(type) {
            var hasMonthSuffix = !!loc.monthSuffix;
            return loc[type + "Abbreviate"] || (hasMonthSuffix ? null : 3)
        }

        function setDefault(name, value) {
            loc[name] = loc[name] || value
        }

        function buildNumbers() {
            var map = loc.ordinalNumberMap = {},
                all = [];
            loc.numbers.forEach(function(full, i) {
                eachAlternate(full, function(alt) {
                    all.push(alt);
                    map[alt] = i + 1
                })
            });
            loc.numbers = all
        }

        function buildModifiers() {
            var arr = [];
            loc.modifiersByName = {};
            loc.modifiers.push({
                name: "day",
                src: "yesterday",
                value: -1
            });
            loc.modifiers.push({
                name: "day",
                src: "today",
                value: 0
            });
            loc.modifiers.push({
                name: "day",
                src: "tomorrow",
                value: 1
            });
            loc.modifiers.forEach(function(modifier) {
                var name = modifier.name;
                eachAlternate(modifier.src, function(t) {
                    var locEntry = loc[name];
                    loc.modifiersByName[t] = modifier;
                    arr.push({
                        name: name,
                        src: t,
                        value: modifier.value
                    });
                    loc[name] = locEntry ? locEntry + "|" + t : t
                })
            });
            loc.day += "|" + arrayToAlternates(loc.weekdays);
            loc.modifiers = arr
        }
        loc = new Localization(set);
        initializeField("modifiers");
        "months,weekdays,units,numbers,articles,tokens,timeMarker,ampm,timeSuffixes,dateParse,timeParse".split(",").forEach(initializeField);
        buildNumbers();
        setArray("months", getAbbreviationSize("month"), 12);
        setArray("weekdays", getAbbreviationSize("weekday"), 7);
        setArray("units", false, 8);
        setDefault("code", localeCode);
        setDefault("date", getDigit(1, 2, loc.digitDate));
        setDefault("year", "'\\d{2}|" + getDigit(4, 4));
        setDefault("num", getNum());
        buildModifiers();
        if (loc.monthSuffix) {
            loc.month = getDigit(1, 2);
            loc.months = "1,2,3,4,5,6,7,8,9,10,11,12".split(",").map(function(n) {
                return n + loc.monthSuffix
            })
        }
        loc.fullMonth = getDigit(1, 2) + "|" + arrayToAlternates(loc.months);
        if (loc.timeSuffixes.length > 0) loc.addFormat(prepareTime(RequiredTime, loc), false, TimeFormat);
        loc.addFormat("{day}", true);
        loc.addFormat("{month}" + (loc.monthSuffix || ""));
        loc.addFormat("{year}" + (loc.yearSuffix || ""));
        loc.timeParse.forEach(function(src) {
            loc.addFormat(src, true)
        });
        loc.dateParse.forEach(function(src) {
            loc.addFormat(src)
        });
        return Localizations[localeCode] = loc
    }

    function addDateInputFormat(locale, format, match, variant) {
        locale.compiledFormats.unshift({
            variant: !!variant,
            locale: locale,
            reg: regexp("^" +
                format + "$", "i"),
            to: match
        })
    }

    function simpleCapitalize(str) {
        return str.slice(0, 1).toUpperCase() + str.slice(1)
    }

    function arrayToAlternates(arr) {
        return arr.filter(function(el) {
            return !!el
        }).join("|")
    }

    function getNewDate() {
        var fn = sugarDate.newDateInternal;
        return fn ? fn() : new date
    }

    function cloneDate(d) {
        var cloned = new date(d.getTime());
        setUTC(cloned, !!d._utc);
        return cloned
    }

    function callDateSetWithWeek(d, method, value) {
        if (method === "ISOWeek") return setWeekNumber(d, value);
        else return callDateSet(d, method, value)
    }

    function isValid(d) {
        return !isNaN(d.getTime())
    }

    function isLeapYear(d) {
        var year = callDateGet(d, "FullYear");
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0
    }

    function setUTC(d, force) {
        setProperty(d, "_utc", !!force);
        return d
    }

    function isUTC(d) {
        return !!d._utc || d.getTimezoneOffset() === 0
    }

    function getUTCOffset(d, iso) {
        var offset = d._utc ? 0 : d.getTimezoneOffset();
        var colon = iso === true ? ":" : "";
        if (!offset && iso) return "Z";
        return padNumber(floor(-offset / 60), 2, true) + colon + padNumber(abs(offset % 60), 2)
    }

    function collectDateArguments(args,
        allowDuration) {
        var obj;
        if (isObjectType(args[0])) return args;
        else if (isNumber(args[0]) && !isNumber(args[1])) return [args[0]];
        else if (isString(args[0]) && allowDuration) return [getDateParamsFromString(args[0]), args[1]];
        obj = {};
        DateArgumentUnits.forEach(function(u, i) {
            obj[u.name] = args[i]
        });
        return [obj]
    }

    function getDateParamsFromString(str, num) {
        var match, num, params = {};
        match = str.match(/^(-?\d+)?\s?(\w+?)s?$/i);
        if (match) {
            if (isUndefined(num)) {
                num = parseInt(match[1]);
                if (isNaN(num)) num = 1
            }
            params[match[2].toLowerCase()] =
                num
        }
        return params
    }

    function iterateOverDateUnits(fn, from, to) {
        var i, unit;
        if (isUndefined(to)) to = DateUnitsReversed.length;
        for (i = from || 0; i < to; i++) {
            unit = DateUnitsReversed[i];
            if (fn(unit.name, unit, i) === false) break
        }
    }

    function advanceDate(d, args) {
        var set = collectDateArguments(args, true);
        return updateDate(d, set[0], set[1], 1)
    }

    function setDate(d, args) {
        var set = collectDateArguments(args);
        return updateDate(d, set[0], set[1])
    }

    function resetDate(d, unit) {
        var params = {},
            recognized;
        unit = unit || "hours";
        if (unit === "date") unit =
            "days";
        recognized = DateUnits.some(function(u) {
            return unit === u.name || unit === u.name + "s"
        });
        params[unit] = unit.match(/^days?/) ? 1 : 0;
        return recognized ? setDate(d, [params, true]) : d
    }

    function setWeekday(d, dow, forward) {
        if (isUndefined(dow)) return;
        if (forward && dow % 7 < d.getDay()) dow += 7;
        return callDateSet(d, "Date", callDateGet(d, "Date") + dow - callDateGet(d, "Day"))
    }

    function moveToBeginningOfUnit(d, unit) {
        var set = {};
        switch (unit) {
            case "year":
                set.year = callDateGet(d, "FullYear");
                break;
            case "month":
                set.month = callDateGet(d, "Month");
                break;
            case "day":
                set.day = callDateGet(d, "Date");
                break;
            case "week":
                set.weekday = 0;
                break
        }
        return setDate(d, [set, true])
    }

    function moveToEndOfUnit(d, unit) {
        var set = {
            hours: 23,
            minutes: 59,
            seconds: 59,
            milliseconds: 999
        };
        switch (unit) {
            case "year":
                set.month = 11;
                set.day = 31;
                break;
            case "month":
                set.day = getDaysInMonth(d);
                break;
            case "week":
                set.weekday = 6;
                break
        }
        return setDate(d, [set, true])
    }

    function getFormatMatch(match, arr) {
        var obj = {},
            value, num;
        arr.forEach(function(key, i) {
            value = match[i + 1];
            if (isUndefined(value) || value === "") return;
            if (key === "year") obj.yearAsString = value.replace(/'/, "");
            num = parseFloat(value.replace(/'/, "").replace(/,/, "."));
            obj[key] = !isNaN(num) ? num : value.toLowerCase()
        });
        return obj
    }

    function cleanDateInput(str) {
        str = str.trim().replace(/^just (?=now)|\.+$/i, "");
        return convertAsianDigits(str)
    }

    function convertAsianDigits(str) {
        return str.replace(AsianDigitReg, function(full, disallowed, match) {
            var sum = 0,
                place = 1,
                lastWasHolder, lastHolder;
            if (disallowed) return full;
            match.split("").reverse().forEach(function(letter) {
                var value =
                    AsianDigitMap[letter],
                    holder = value > 9;
                if (holder) {
                    if (lastWasHolder) sum += place;
                    place *= value / (lastHolder || 1);
                    lastHolder = value
                } else {
                    if (lastWasHolder === false) place *= 10;
                    sum += place * value
                }
                lastWasHolder = holder
            });
            if (lastWasHolder) sum += place;
            return sum
        })
    }

    function getExtendedDate(contextDate, f, localeCode, prefer, forceUTC) {
        var d, relative, baseLocalization, afterCallbacks, loc, set, unit, unitIndex, weekday, num, tmp, weekdayForward;
        afterCallbacks = [];

        function afterDateSet(fn) {
            afterCallbacks.push(fn)
        }

        function fireCallbacks() {
            afterCallbacks.forEach(function(fn) {
                fn.call()
            })
        }

        function getWeekdayWithMultiplier(w) {
            var num = set.num && !set.unit ? set.num : 1;
            return 7 * (num - 1) + w
        }

        function setWeekdayOfMonth() {
            setWeekday(d, set.weekday, true)
        }

        function setUnitEdge() {
            var modifier = loc.modifiersByName[set.edge];
            iterateOverDateUnits(function(name) {
                if (isDefined(set[name])) {
                    unit = name;
                    return false
                }
            }, 4);
            if (unit === "year") set.specificity = "month";
            else if (unit === "month" || unit === "week") set.specificity = "day";
            if (modifier.value < 0) moveToEndOfUnit(d, unit);
            else moveToBeginningOfUnit(d, unit);
            if (modifier.value ===
                -2) resetDate(d)
        }

        function separateAbsoluteUnits() {
            var params;
            iterateOverDateUnits(function(name, u, i) {
                if (name === "day") name = "date";
                if (isDefined(set[name])) {
                    if (i >= unitIndex) {
                        invalidateDate(d);
                        return false
                    }
                    params = params || {};
                    params[name] = set[name];
                    delete set[name]
                }
            });
            if (params) afterDateSet(function() {
                setDate(d, [params, true])
            })
        }
        if (contextDate && f) d = cloneDate(contextDate);
        else d = getNewDate();
        setUTC(d, forceUTC);
        if (isDate(f)) setUTC(d, isUTC(f)).setTime(f.getTime());
        else if (isNumber(f) || f === null) d.setTime(f);
        else if (isObjectType(f)) {
            setDate(d, [f, true]);
            set = f
        } else if (isString(f)) {
            baseLocalization = getLocalization(localeCode);
            f = cleanDateInput(f);
            if (baseLocalization) iterateOverObject(baseLocalization.getFormats(), function(i, dif) {
                var match = f.match(dif.reg);
                if (match) {
                    loc = dif.locale;
                    set = getFormatMatch(match, dif.to, loc);
                    loc.cachedFormat = dif;
                    if (set.utc) setUTC(d, true);
                    if (set.timestamp) {
                        set = set.timestamp;
                        return false
                    }
                    if (dif.variant && !isString(set.month) && (isString(set.date) || baseLocalization.hasVariant(localeCode))) {
                        tmp =
                            set.month;
                        set.month = set.date;
                        set.date = tmp
                    }
                    if (hasAbbreviatedYear(set)) set.year = getYearFromAbbreviation(set.year);
                    if (set.month) {
                        set.month = loc.getMonth(set.month);
                        if (set.shift && !set.unit) set.unit = loc.units[7]
                    }
                    if (set.weekday && set.date) delete set.weekday;
                    else if (set.weekday) {
                        set.weekday = loc.getWeekday(set.weekday);
                        if (set.shift && !set.unit) set.unit = loc.units[5]
                    }
                    if (set.day && (tmp = loc.modifiersByName[set.day])) {
                        set.day = tmp.value;
                        resetDate(d);
                        relative = true
                    } else if (set.day && (weekday = loc.getWeekday(set.day)) >
                        -1) {
                        delete set.day;
                        set.weekday = getWeekdayWithMultiplier(weekday);
                        if (set.num && set.month) weekdayForward = true
                    }
                    if (set.date && !isNumber(set.date)) set.date = loc.getNumericDate(set.date);
                    if (loc.matchPM(set.ampm) && set.hour < 12) set.hour += 12;
                    else if (loc.matchAM(set.ampm) && set.hour === 12) set.hour = 0;
                    if (isNumber(set.offsetHours) || isNumber(set.offsetMinutes)) {
                        setUTC(d, true);
                        set.offsetMinutes = set.offsetMinutes || 0;
                        set.offsetMinutes += set.offsetHours * 60;
                        if (set.offsetSign === "-") set.offsetMinutes *= -1;
                        set.minute -= set.offsetMinutes
                    }
                    if (set.unit) {
                        relative =
                            true;
                        num = loc.getNumber(set.num);
                        unitIndex = loc.getUnitIndex(set.unit);
                        unit = English.units[unitIndex];
                        separateAbsoluteUnits();
                        if (set.shift) num *= (tmp = loc.modifiersByName[set.shift]) ? tmp.value : 0;
                        if (set.sign && (tmp = loc.modifiersByName[set.sign])) num *= tmp.value;
                        if (isDefined(set.weekday)) {
                            setDate(d, [{
                                weekday: set.weekday
                            }, true]);
                            delete set.weekday
                        }
                        set[unit] = (set[unit] || 0) + num
                    }
                    if (set.edge) afterDateSet(setUnitEdge);
                    if (set.yearSign === "-") set.year *= -1;
                    iterateOverDateUnits(function(name, unit, i) {
                        var value = set[name],
                            fraction = value % 1;
                        if (fraction) {
                            set[DateUnitsReversed[i - 1].name] = round(fraction * (name === "second" ? 1E3 : 60));
                            set[name] = floor(value)
                        }
                    }, 1, 4);
                    return false
                }
            });
            if (!set) {
                if (!/^now$/i.test(f)) d = new date(f);
                if (forceUTC) d.addMinutes(-d.getTimezoneOffset())
            } else if (relative) advanceDate(d, [set]);
            else {
                if (d._utc) resetDate(d);
                updateDate(d, set, true, false, prefer, weekdayForward)
            }
            fireCallbacks();
            setUTC(d, false)
        }
        return {
            date: d,
            set: set
        }
    }

    function hasAbbreviatedYear(obj) {
        return obj.yearAsString && obj.yearAsString.length === 2
    }

    function getYearFromAbbreviation(year) {
        return round(callDateGet(getNewDate(), "FullYear") / 100) * 100 - round(year / 100) * 100 + year
    }

    function getShortHour(d) {
        var hours = callDateGet(d, "Hours");
        return hours === 0 ? 12 : hours - floor(hours / 13) * 12
    }

    function getWeekNumber(date) {
        date = cloneDate(date);
        var dow = callDateGet(date, "Day") || 7;
        resetDate(advanceDate(date, [4 - dow + " days"]));
        return 1 + floor(sugarDate.daysSince(date, moveToBeginningOfUnit(cloneDate(date), "year")) / 7)
    }

    function setWeekNumber(date, num) {
        var weekday = callDateGet(date,
            "Day") || 7;
        if (isUndefined(num)) return;
        setDate(date, [{
            month: 0,
            date: 4
        }]);
        setDate(date, [{
            weekday: 1
        }]);
        if (num > 1) advanceDate(date, [{
            weeks: num - 1
        }]);
        if (weekday !== 1) advanceDate(date, [{
            days: weekday - 1
        }]);
        return date.getTime()
    }

    function getDaysInMonth(d) {
        return 32 - callDateGet(new date(callDateGet(d, "FullYear"), callDateGet(d, "Month"), 32), "Date")
    }

    function getAdjustedUnit(ms, fn) {
        var unitIndex = 0,
            value = 0;
        iterateOverObject(DateUnits, function(i, unit) {
            value = abs(fn(unit));
            if (value >= 1) {
                unitIndex = 7 - i;
                return false
            }
        });
        return [value,
            unitIndex, ms
        ]
    }

    function getAdjustedUnitForNumber(ms) {
        return getAdjustedUnit(ms, function(unit) {
            return floor(withPrecision(ms / unit.multiplier, 1))
        })
    }

    function getAdjustedUnitForDate(d) {
        var ms = sugarDate.millisecondsFromNow(d);
        if (d.getTime() > date.now()) d = new date(d.getTime() + 10);
        return getAdjustedUnit(ms, function(unit) {
            return abs(sugarDate[unit.name + "sFromNow"](d))
        })
    }

    function createMeridianTokens(slice, caps) {
        var fn = function(d, localeCode) {
            var hours = callDateGet(d, "Hours");
            return getLocalization(localeCode).get("ampm")[floor(hours /
                12)] || ""
        };
        createFormatToken("t", fn, 1);
        createFormatToken("tt", fn);
        createFormatToken("T", fn, 1, 1);
        createFormatToken("TT", fn, null, 2)
    }

    function createWeekdayTokens(slice, caps) {
        var fn = function(d, localeCode) {
            var dow = callDateGet(d, "Day");
            return getLocalization(localeCode).weekdays[dow]
        };
        createFormatToken("do", fn, 2);
        createFormatToken("Do", fn, 2, 1);
        createFormatToken("dow", fn, 3);
        createFormatToken("Dow", fn, 3, 1);
        createFormatToken("weekday", fn);
        createFormatToken("Weekday", fn, null, 1)
    }

    function createMonthTokens(slice,
        caps) {
        createMonthToken("mon", 0, 3);
        createMonthToken("month", 0);
        createMonthToken("month2", 1);
        createMonthToken("month3", 2)
    }

    function createMonthToken(token, multiplier, slice) {
        var fn = function(d, localeCode) {
            var month = callDateGet(d, "Month");
            return getLocalization(localeCode).months[month + multiplier * 12]
        };
        createFormatToken(token, fn, slice);
        createFormatToken(simpleCapitalize(token), fn, slice, 1)
    }

    function createFormatToken(t, fn, slice, caps) {
        DateFormatTokens[t] = function(d, localeCode) {
            var str = fn(d, localeCode);
            if (slice) str =
                str.slice(0, slice);
            if (caps) str = str.slice(0, caps).toUpperCase() + str.slice(caps);
            return str
        }
    }

    function createPaddedToken(t, fn, ms) {
        DateFormatTokens[t] = fn;
        DateFormatTokens[t + t] = function(d, localeCode) {
            return padNumber(fn(d, localeCode), 2)
        };
        if (ms) {
            DateFormatTokens[t + t + t] = function(d, localeCode) {
                return padNumber(fn(d, localeCode), 3)
            };
            DateFormatTokens[t + t + t + t] = function(d, localeCode) {
                return padNumber(fn(d, localeCode), 4)
            }
        }
    }

    function buildCompiledOutputFormat(format) {
        var match = format.match(/(\{\w+\})|[^{}]+/g);
        CompiledOutputFormats[format] =
            match.map(function(p) {
                p.replace(/\{(\w+)\}/, function(full, token) {
                    p = DateFormatTokens[token] || token;
                    return token
                });
                return p
            })
    }

    function executeCompiledOutputFormat(date, format, localeCode) {
        var compiledFormat, length, i, t, result = "";
        compiledFormat = CompiledOutputFormats[format];
        for (i = 0, length = compiledFormat.length; i < length; i++) {
            t = compiledFormat[i];
            result += isFunction(t) ? t(date, localeCode) : t
        }
        return result
    }

    function formatDate(date, format, relative, localeCode) {
        var adu;
        if (!isValid(date)) return "Invalid Date";
        else if (isString(sugarDate[format])) format =
            sugarDate[format];
        else if (isFunction(format)) {
            adu = getAdjustedUnitForDate(date);
            format = format.apply(date, adu.concat(getLocalization(localeCode)))
        }
        if (!format && relative) {
            adu = adu || getAdjustedUnitForDate(date);
            if (adu[1] === 0) {
                adu[1] = 1;
                adu[0] = 1
            }
            return getLocalization(localeCode).getRelativeFormat(adu)
        }
        format = format || "long";
        if (format === "short" || format === "long" || format === "full") format = getLocalization(localeCode)[format];
        if (!CompiledOutputFormats[format]) buildCompiledOutputFormat(format);
        return executeCompiledOutputFormat(date,
            format, localeCode)
    }

    function fullCompareDate(d, f, margin, utc) {
        var tmp, comp;
        if (!isValid(d)) return;
        if (isString(f)) {
            f = f.trim().toLowerCase();
            comp = setUTC(cloneDate(d), utc);
            switch (true) {
                case f === "future":
                    return d.getTime() > getNewDate().getTime();
                case f === "past":
                    return d.getTime() < getNewDate().getTime();
                case f === "weekday":
                    return callDateGet(comp, "Day") > 0 && callDateGet(comp, "Day") < 6;
                case f === "weekend":
                    return callDateGet(comp, "Day") === 0 || callDateGet(comp, "Day") === 6;
                case (tmp = English.weekdays.indexOf(f) % 7) > -1:
                    return callDateGet(comp,
                        "Day") === tmp;
                case (tmp = English.months.indexOf(f) % 12) > -1:
                    return callDateGet(comp, "Month") === tmp
            }
        }
        return compareDate(d, f, null, margin, utc)
    }

    function compareDate(d, find, localeCode, buffer, forceUTC) {
        var p, t, min, max, override, accuracy = 0,
            loBuffer = 0,
            hiBuffer = 0;
        p = getExtendedDate(null, find, localeCode, null, forceUTC);
        if (buffer > 0) {
            loBuffer = hiBuffer = buffer;
            override = true
        }
        if (!isValid(p.date)) return false;
        if (p.set && p.set.specificity) {
            if (p.set.edge || p.set.shift) moveToBeginningOfUnit(p.date, p.set.specificity);
            if (p.set.specificity ===
                "month") max = moveToEndOfUnit(cloneDate(p.date), p.set.specificity).getTime();
            else max = advanceDate(cloneDate(p.date), ["1 " + p.set.specificity]).getTime() - 1;
            if (!override && p.set.sign && p.set.specificity !== "millisecond") {
                loBuffer = 50;
                hiBuffer = -50
            }
        }
        t = d.getTime();
        min = p.date.getTime();
        max = max || min + accuracy;
        max = compensateForTimezoneTraversal(d, min, max);
        return t >= min - loBuffer && t <= max + hiBuffer
    }

    function compensateForTimezoneTraversal(d, min, max) {
        var dMin, dMax, minOffset, maxOffset;
        dMin = new date(min);
        dMax = setUTC(new date(max),
            isUTC(d));
        if (callDateGet(dMax, "Hours") !== 23) {
            minOffset = dMin.getTimezoneOffset();
            maxOffset = dMax.getTimezoneOffset();
            if (minOffset !== maxOffset) max += (maxOffset - minOffset).minutes()
        }
        return max
    }

    function updateDate(d, params, reset, advance, prefer, weekdayForward) {
        var specificityIndex;

        function getParam(key) {
            return isDefined(params[key]) ? params[key] : params[key + "s"]
        }

        function paramExists(key) {
            return isDefined(getParam(key))
        }

        function uniqueParamExists(key, isDay) {
            return paramExists(key) || isDay && paramExists("weekday") &&
                !paramExists("month")
        }

        function canDisambiguate() {
            switch (prefer) {
                case -1:
                    return d > getNewDate();
                case 1:
                    return d < getNewDate()
            }
        }
        if (isNumber(params) && advance) params = {
            milliseconds: params
        };
        else if (isNumber(params)) {
            d.setTime(params);
            return d
        }
        if (isDefined(params.date)) params.day = params.date;
        iterateOverDateUnits(function(name, unit, i) {
            var isDay = name === "day";
            if (uniqueParamExists(name, isDay)) {
                params.specificity = name;
                specificityIndex = +i;
                return false
            } else if (reset && name !== "week" && (!isDay || !paramExists("week"))) callDateSet(d,
                unit.method, isDay ? 1 : 0)
        });
        DateUnits.forEach(function(u, i) {
            var name = u.name,
                method = u.method,
                higherUnit = DateUnits[i - 1],
                value;
            value = getParam(name);
            if (isUndefined(value)) return;
            if (advance) {
                if (name === "week") {
                    value *= 7;
                    method = "Date"
                }
                value = value * advance + callDateGet(d, method)
            } else if (name === "month" && paramExists("day")) callDateSet(d, "Date", 15);
            callDateSetWithWeek(d, method, value);
            if (advance && name === "month") checkMonthTraversal(d, value)
        });
        if (!advance && !paramExists("day") && paramExists("weekday")) setWeekday(d, getParam("weekday"),
            weekdayForward);
        if (canDisambiguate()) iterateOverDateUnits(function(name, u) {
            var ambiguous = u.ambiguous || name === "week" && paramExists("weekday");
            if (ambiguous && !uniqueParamExists(name, name === "day")) {
                sugarDate[u.addMethod](d, prefer);
                return false
            } else if (name === "year" && hasAbbreviatedYear(params)) advanceDate(d, [{
                years: 100 * prefer
            }])
        }, specificityIndex + 1);
        return d
    }

    function prepareTime(format, loc, iso) {
        var timeSuffixMapping = {
                "h": 0,
                "m": 1,
                "s": 2
            },
            add;
        loc = loc || English;
        return format.replace(/{([a-z])}/g, function(full,
            token) {
            var separators = [],
                isHours = token === "h",
                tokenIsRequired = isHours && !iso;
            if (token === "t") return loc.get("ampm").join("|");
            else {
                if (isHours) separators.push(":");
                if (add = loc.timeSuffixes[timeSuffixMapping[token]]) separators.push(add + "\\s*");
                return separators.length === 0 ? "" : "(?:" + separators.join("|") + ")" + (tokenIsRequired ? "" : "?")
            }
        })
    }

    function checkMonthTraversal(date, targetMonth) {
        if (targetMonth < 0) targetMonth = targetMonth % 12 + 12;
        if (targetMonth % 12 !== callDateGet(date, "Month")) callDateSet(date, "Date", 0)
    }

    function createDateFromArgs(contextDate,
        args, prefer, forceUTC) {
        var f, localeCode;
        if (isNumber(args[1])) f = collectDateArguments(args)[0];
        else {
            f = args[0];
            localeCode = args[1]
        }
        return createDate(contextDate, f, localeCode, prefer, forceUTC)
    }

    function createDate(contextDate, f, localeCode, prefer, forceUTC) {
        return getExtendedDate(contextDate, f, localeCode, prefer, forceUTC).date
    }

    function invalidateDate(d) {
        d.setTime(NaN)
    }

    function buildDateUnits() {
        DateUnitsReversed = DateUnits.concat().reverse();
        DateArgumentUnits = DateUnits.concat();
        DateArgumentUnits.splice(2, 1)
    }

    function buildDateMethods() {
        extendSimilar(date,
            DateUnits,
            function(methods, u, i) {
                var name = u.name,
                    caps = simpleCapitalize(name),
                    since, until;
                u.addMethod = "add" + caps + "s";

                function add(num, reset) {
                    var set = {};
                    set[name] = num;
                    return advanceDate(this, [set, reset])
                }

                function timeDistanceNumeric(d1, d2) {
                    var n = (d1.getTime() - d2.getTime()) / u.multiplier;
                    return n < 0 ? ceil(n) : floor(n)
                }

                function addUnit(d, n, dsc) {
                    var d2;
                    add.call(d, n);
                    if (dsc && callDateGet(d, "Date") !== dsc) {
                        d2 = cloneDate(d);
                        callDateSet(d2, "Date", dsc);
                        if (callDateGet(d2, "Date") === dsc) return d2
                    }
                    return d
                }

                function timeDistanceTraversal(d1,
                    d2) {
                    var d, inc, n, dsc, count = 0;
                    d = cloneDate(d1);
                    inc = d1 < d2;
                    n = inc ? 1 : -1;
                    dsc = name === "month" && callDateGet(d, "Date");
                    d = addUnit(d, n, dsc);
                    while (inc ? d <= d2 : d >= d2) {
                        count += -n;
                        d = addUnit(d, n, dsc)
                    }
                    return count
                }

                function compareSince(fn, d, args) {
                    return fn(d, createDateFromArgs(d, args, 0, false))
                }

                function compareUntil(fn, d, args) {
                    return fn(createDateFromArgs(d, args, 0, false), d)
                }
                if (i < 3)["Last", "This", "Next"].forEach(function(shift) {
                    methods["is" + shift + caps] = function() {
                        return compareDate(this, shift + " " + name, "en")
                    }
                });
                if (i < 4) {
                    methods["beginningOf" +
                        caps] = function() {
                        return moveToBeginningOfUnit(this, name)
                    };
                    methods["endOf" + caps] = function() {
                        return moveToEndOfUnit(this, name)
                    };
                    since = function() {
                        return compareSince(timeDistanceTraversal, this, arguments)
                    };
                    until = function() {
                        return compareUntil(timeDistanceTraversal, this, arguments)
                    }
                } else {
                    since = function() {
                        return compareSince(timeDistanceNumeric, this, arguments)
                    };
                    until = function() {
                        return compareUntil(timeDistanceNumeric, this, arguments)
                    }
                }
                methods[name + "sAgo"] = until;
                methods[name + "sUntil"] = until;
                methods[name + "sSince"] =
                    since;
                methods[name + "sFromNow"] = since;
                methods[u.addMethod] = add;
                buildNumberToDateAlias(u, u.multiplier)
            })
    }

    function buildCoreInputFormats() {
        English.addFormat("([+-])?(\\d{4,4})[-.\\/]?{fullMonth}[-.]?(\\d{1,2})?", true, ["yearSign", "year", "month", "date"], false, true);
        English.addFormat("(\\d{1,2})[-.\\/]{fullMonth}(?:[-.\\/](\\d{2,4}))?", true, ["date", "month", "year"], true);
        English.addFormat("{fullMonth}[-.](\\d{4,4})", false, ["month", "year"]);
        English.addFormat("\\/Date\\((\\d+(?:[+-]\\d{4,4})?)\\)\\/", false, ["timestamp"]);
        English.addFormat(prepareTime(RequiredTime, English), false, TimeFormat);
        CoreDateFormats = English.compiledFormats.slice(0, 7).reverse();
        English.compiledFormats = English.compiledFormats.slice(7).concat(CoreDateFormats)
    }

    function buildFormatTokens() {
        createPaddedToken("f", function(d) {
            return callDateGet(d, "Milliseconds")
        }, true);
        createPaddedToken("s", function(d) {
            return callDateGet(d, "Seconds")
        });
        createPaddedToken("m", function(d) {
            return callDateGet(d, "Minutes")
        });
        createPaddedToken("h", function(d) {
            return callDateGet(d,
                "Hours") % 12 || 12
        });
        createPaddedToken("H", function(d) {
            return callDateGet(d, "Hours")
        });
        createPaddedToken("d", function(d) {
            return callDateGet(d, "Date")
        });
        createPaddedToken("M", function(d) {
            return callDateGet(d, "Month") + 1
        });
        createMeridianTokens();
        createWeekdayTokens();
        createMonthTokens();
        DateFormatTokens["ms"] = DateFormatTokens["f"];
        DateFormatTokens["milliseconds"] = DateFormatTokens["f"];
        DateFormatTokens["seconds"] = DateFormatTokens["s"];
        DateFormatTokens["minutes"] = DateFormatTokens["m"];
        DateFormatTokens["hours"] =
            DateFormatTokens["h"];
        DateFormatTokens["24hr"] = DateFormatTokens["H"];
        DateFormatTokens["12hr"] = DateFormatTokens["h"];
        DateFormatTokens["date"] = DateFormatTokens["d"];
        DateFormatTokens["day"] = DateFormatTokens["d"];
        DateFormatTokens["year"] = DateFormatTokens["yyyy"]
    }

    function buildFormatShortcuts() {
        extendSimilar(date, "short,long,full", function(methods, name) {
            methods[name] = function(localeCode) {
                return formatDate(this, name, false, localeCode)
            }
        })
    }

    function buildAsianDigits() {
        KanjiDigits.split("").forEach(function(digit,
            value) {
            var holder;
            if (value > 9) value = pow(10, value - 9);
            AsianDigitMap[digit] = value
        });
        simpleMerge(AsianDigitMap, NumberNormalizeMap);
        AsianDigitReg = regexp("([期週周])?([" + KanjiDigits + FullWidthDigits + "]+)(?!昨)", "g")
    }

    function buildRelativeAliases() {
        var special = "today,yesterday,tomorrow,weekday,weekend,future,past".split(",");
        var weekdays = English.weekdays.slice(0, 7);
        var months = English.months.slice(0, 12);
        extendSimilar(date, special.concat(weekdays).concat(months), function(methods, name) {
            methods["is" + simpleCapitalize(name)] =
                function(utc) {
                    return fullCompareDate(this, name, 0, utc)
                }
        })
    }

    function buildUTCAliases() {
        extend(date, {
            "utc": {
                "create": function() {
                    return createDateFromArgs(null, arguments, 0, true)
                },
                "past": function() {
                    return createDateFromArgs(null, arguments, -1, true)
                },
                "future": function() {
                    return createDateFromArgs(null, arguments, 1, true)
                }
            }
        }, false)
    }

    function setDateProperties() {
        extend(date, {
            "RFC1123": "{Dow}, {dd} {Mon} {yyyy} {HH}:{mm}:{ss} {tz}",
            "RFC1036": "{Weekday}, {dd}-{Mon}-{yy} {HH}:{mm}:{ss} {tz}",
            "ISO8601_DATE": "{yyyy}-{MM}-{dd}",
            "ISO8601_DATETIME": "{yyyy}-{MM}-{dd}T{HH}:{mm}:{ss}.{fff}{isotz}"
        }, false)
    }
    extend(date, {
        "create": function() {
            return createDateFromArgs(null, arguments)
        },
        "past": function() {
            return createDateFromArgs(null, arguments, -1)
        },
        "future": function() {
            return createDateFromArgs(null, arguments, 1)
        },
        "addLocale": function(localeCode, set) {
            return setLocalization(localeCode, set)
        },
        "setLocale": function(localeCode, set) {
            var loc = getLocalization(localeCode, false);
            CurrentLocalization = loc;
            if (localeCode && localeCode !== loc.code) loc.code =
                localeCode;
            return loc
        },
        "getLocale": function(localeCode) {
            return !localeCode ? CurrentLocalization : getLocalization(localeCode, false)
        },
        "addFormat": function(format, match, localeCode) {
            addDateInputFormat(getLocalization(localeCode), format, match)
        }
    }, false);
    extend(date, {
        "get": function(s) {
            return createDateFromArgs(this, arguments)
        },
        "set": function() {
            return setDate(this, arguments)
        },
        "setWeekday": function(dow) {
            return setWeekday(this, dow)
        },
        "setISOWeek": function(num) {
            return setWeekNumber(this, num)
        },
        "getISOWeek": function() {
            return getWeekNumber(this)
        },
        "beginningOfISOWeek": function() {
            var day = this.getDay();
            if (day === 0) day = -6;
            else if (day !== 1) day = 1;
            setWeekday(this, day);
            return resetDate(this)
        },
        "endOfISOWeek": function() {
            if (this.getDay() !== 0) setWeekday(this, 7);
            return moveToEndOfUnit(this, "day")
        },
        "getUTCOffset": function(iso) {
            return getUTCOffset(this, iso)
        },
        "setUTC": function(set) {
            return setUTC(this, set)
        },
        "isUTC": function() {
            return isUTC(this)
        },
        "advance": function() {
            return advanceDate(this, arguments)
        },
        "rewind": function() {
            var args = collectDateArguments(arguments,
                true);
            return updateDate(this, args[0], args[1], -1)
        },
        "isValid": function() {
            return isValid(this)
        },
        "isAfter": function(d, margin, utc) {
            return this.getTime() > createDate(null, d).getTime() - (margin || 0)
        },
        "isBefore": function(d, margin) {
            return this.getTime() < createDate(null, d).getTime() + (margin || 0)
        },
        "isBetween": function(d1, d2, margin) {
            var t = this.getTime();
            var t1 = createDate(null, d1).getTime();
            var t2 = createDate(null, d2).getTime();
            var lo = min(t1, t2);
            var hi = max(t1, t2);
            margin = margin || 0;
            return lo - margin < t && hi + margin > t
        },
        "isLeapYear": function() {
            return isLeapYear(this)
        },
        "daysInMonth": function() {
            return getDaysInMonth(this)
        },
        "format": function(f, localeCode) {
            return formatDate(this, f, false, localeCode)
        },
        "relative": function(fn, localeCode) {
            if (isString(fn)) {
                localeCode = fn;
                fn = null
            }
            return formatDate(this, fn, true, localeCode)
        },
        "is": function(f, margin, utc) {
            return fullCompareDate(this, f, margin, utc)
        },
        "reset": function(unit) {
            return resetDate(this, unit)
        },
        "clone": function() {
            return cloneDate(this)
        },
        "iso": function() {
            return this.toISOString()
        },
        "getWeekday": function() {
            return this.getDay()
        },
        "getUTCWeekday": function() {
            return this.getUTCDay()
        }
    });

    function buildNumberToDateAlias(u, multiplier) {
        var name = u.name,
            methods = {};

        function base() {
            return round(this * multiplier)
        }

        function after() {
            return sugarDate[u.addMethod](createDateFromArgs(null, arguments), this)
        }

        function before() {
            return sugarDate[u.addMethod](createDateFromArgs(null, arguments), -this)
        }
        methods[name] = base;
        methods[name + "s"] = base;
        methods[name + "Before"] = before;
        methods[name + "sBefore"] = before;
        methods[name + "Ago"] = before;
        methods[name + "sAgo"] =
            before;
        methods[name + "After"] = after;
        methods[name + "sAfter"] = after;
        methods[name + "FromNow"] = after;
        methods[name + "sFromNow"] = after;
        extend(number, methods)
    }
    extend(number, {
        "duration": function(localeCode) {
            return getLocalization(localeCode).getDuration(this)
        }
    });
    English = CurrentLocalization = sugarDate.addLocale("en", {
        "plural": true,
        "timeMarker": "at",
        "ampm": "am,pm",
        "months": "January,February,March,April,May,June,July,August,September,October,November,December",
        "weekdays": "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday",
        "units": "millisecond:|s,second:|s,minute:|s,hour:|s,day:|s,week:|s,month:|s,year:|s",
        "numbers": "one,two,three,four,five,six,seven,eight,nine,ten",
        "articles": "a,an,the",
        "tokens": "the,st|nd|rd|th,of",
        "short": "{Month} {d}, {yyyy}",
        "long": "{Month} {d}, {yyyy} {h}:{mm}{tt}",
        "full": "{Weekday} {Month} {d}, {yyyy} {h}:{mm}:{ss}{tt}",
        "past": "{num} {unit} {sign}",
        "future": "{num} {unit} {sign}",
        "duration": "{num} {unit}",
        "modifiers": [{
            "name": "sign",
            "src": "ago|before",
            "value": -1
        }, {
            "name": "sign",
            "src": "from now|after|from|in|later",
            "value": 1
        }, {
            "name": "edge",
            "src": "last day",
            "value": -2
        }, {
            "name": "edge",
            "src": "end",
            "value": -1
        }, {
            "name": "edge",
            "src": "first day|beginning",
            "value": 1
        }, {
            "name": "shift",
            "src": "last",
            "value": -1
        }, {
            "name": "shift",
            "src": "the|this",
            "value": 0
        }, {
            "name": "shift",
            "src": "next",
            "value": 1
        }],
        "dateParse": ["{month} {year}", "{shift} {unit=5-7}", "{0?} {date}{1}", "{0?} {edge} of {shift?} {unit=4-7?} {month?} {year?}"],
        "timeParse": ["{num} {unit} {sign}", "{sign} {num} {unit}", "{0} {num}{1} {day} of {month} {year?}", "{weekday?} {month} {date}{1?} {year?}",
            "{date} {month} {year}", "{date} {month}", "{shift} {weekday}", "{shift} week {weekday}", "{weekday} {2?} {shift} week", "{num} {unit=4-5} {sign} {day}", "{0?} {date}{1} of {month}", "{0?}{month?} {date?}{1?} of {shift} {unit=6-7}", "{edge} of {day}"
        ]
    });
    buildDateUnits();
    buildDateMethods();
    buildCoreInputFormats();
    buildFormatTokens();
    buildFormatShortcuts();
    buildAsianDigits();
    buildRelativeAliases();
    buildUTCAliases();
    setDateProperties();
    var DATE_UNITS = "year|month|week|day|hour|minute|(?:milli)?second";
    var FULL_CAPTURED_DURATION =
        "((?:\\d+)?\\s*(?:" + DATE_UNITS + "))s?";
    var RANGE_REG = /(?:from)?\s*(.+)\s+(?:to|until)\s+(.+)$/i;
    var DURATION_REG = regexp("(\\d+)?\\s*(" + DATE_UNITS + ")s?", "i");
    var RANGE_REG_FRONT_DURATION = regexp("(?:for)?\\s*" + FULL_CAPTURED_DURATION + "\\s*(?:starting)?\\s*at\\s*(.+)", "i");
    var RANGE_REG_REAR_DURATION = regexp("(.+)\\s*for\\s*" + FULL_CAPTURED_DURATION, "i");

    function Range(start, end) {
        this.start = cloneRangeMember(start);
        this.end = cloneRangeMember(end)
    }

    function getRangeMemberNumericValue(m) {
        return isString(m) ? m.charCodeAt(0) :
            m
    }

    function getRangeMemberPrimitiveValue(m) {
        if (m == null) return m;
        return isDate(m) ? m.getTime() : m.valueOf()
    }

    function getPrecision(n) {
        var split = n.toString().split(".");
        return split[1] ? split[1].length : 0
    }

    function getGreaterPrecision(n1, n2) {
        return max(getPrecision(n1), getPrecision(n2))
    }

    function getSimpleDate(str) {
        return str == null ? new date : new date(str)
    }

    function getSugarExtendedDate(d) {
        return sugarDate.create(d)
    }

    function dateConstructorIsExtended() {
        return !!sugarDate.create
    }

    function createDateRangeFromString(str) {
        var match,
            datetime, duration, dio, start, end;
        if (match = str.match(RANGE_REG)) return DateRangeConstructor(match[1], match[2]);
        if (match = str.match(RANGE_REG_FRONT_DURATION)) {
            duration = match[1];
            datetime = match[2]
        }
        if (match = str.match(RANGE_REG_REAR_DURATION)) {
            datetime = match[1];
            duration = match[2]
        }
        if (datetime && duration) {
            start = getSugarExtendedDate(datetime);
            dio = getDateIncrementObject(duration);
            end = incrementDate(start, dio[0], dio[1])
        }
        return DateRangeConstructor(start, end)
    }

    function cloneRangeMember(m) {
        if (isDate(m)) return new date(m.getTime());
        else return getRangeMemberPrimitiveValue(m)
    }

    function isValidRangeMember(m) {
        var val = getRangeMemberPrimitiveValue(m);
        return (!!val || val === 0) && valueIsNotInfinite(m)
    }

    function valueIsNotInfinite(m) {
        return m !== -Infinity && m !== Infinity
    }

    function getDateIncrementObject(amt) {
        var match, val, unit;
        if (isNumber(amt)) return [amt, "Milliseconds"];
        match = amt.match(DURATION_REG);
        val = parseInt(match[1]) || 1;
        unit = match[2].slice(0, 1).toUpperCase() + match[2].slice(1).toLowerCase();
        if (unit.match(/hour|minute|second/i)) unit += "s";
        else if (unit === "Year") unit = "FullYear";
        else if (unit === "Day") unit = "Date";
        return [val, unit]
    }

    function incrementDate(current, amount, unit) {
        var val = callDateGet(current, unit);
        var d = new date(current.getTime());
        callDateSet(d, unit, val + amount);
        return d
    }

    function incrementString(current, amount) {
        return string.fromCharCode(current.charCodeAt(0) + amount)
    }

    function incrementNumber(current, amount, precision) {
        return withPrecision(current + amount, precision)
    }
    Range.prototype.toString = function() {
        return this.isValid() ? this.start +
            ".." + this.end : "Invalid Range"
    };
    extend(Range, {
        "isValid": function() {
            return isValidRangeMember(this.start) && isValidRangeMember(this.end) && typeof this.start === typeof this.end
        },
        "span": function() {
            return this.isValid() ? abs(getRangeMemberNumericValue(this.end) - getRangeMemberNumericValue(this.start)) + 1 : NaN
        },
        "contains": function(obj) {
            var self = this,
                arr;
            if (obj == null) return false;
            if (obj.start && obj.end) return obj.start >= this.start && obj.start <= this.end && obj.end >= this.start && obj.end <= this.end;
            else return obj >= this.start &&
                obj <= this.end
        },
        "every": function(amount, fn) {
            var increment, precision, dio, unit, start = this.start,
                end = this.end,
                inverse = end < start,
                current = start,
                index = 0,
                result = [];
            if (!this.isValid()) return [];
            if (isFunction(amount)) {
                fn = amount;
                amount = null
            }
            amount = amount || 1;
            if (isNumber(start)) {
                precision = getGreaterPrecision(start, amount);
                increment = function() {
                    return incrementNumber(current, amount, precision)
                }
            } else if (isString(start)) increment = function() {
                return incrementString(current, amount)
            };
            else if (isDate(start)) {
                dio = getDateIncrementObject(amount);
                amount = dio[0];
                unit = dio[1];
                increment = function() {
                    return incrementDate(current, amount, unit)
                }
            }
            if (inverse && amount > 0) amount *= -1;
            while (inverse ? current >= end : current <= end) {
                result.push(current);
                if (fn) fn(current, index);
                current = increment();
                index++
            }
            return result
        },
        "union": function(range) {
            return new Range(this.start < range.start ? this.start : range.start, this.end > range.end ? this.end : range.end)
        },
        "intersect": function(range) {
            if (range.start > this.end || range.end < this.start) return new Range(NaN, NaN);
            return new Range(this.start >
                range.start ? this.start : range.start, this.end < range.end ? this.end : range.end)
        },
        "clone": function(range) {
            return new Range(this.start, this.end)
        },
        "clamp": function(obj) {
            var clamped, start = this.start,
                end = this.end,
                min = end < start ? end : start,
                max = start > end ? start : end;
            if (obj < min) clamped = min;
            else if (obj > max) clamped = max;
            else clamped = obj;
            return cloneRangeMember(clamped)
        }
    });

    function extendRangeConstructor(klass, constructor) {
        extend(klass, {
            "range": constructor
        }, false)
    }
    var PrimitiveRangeConstructor = function(start, end) {
        return new Range(start,
            end)
    };
    var DateRangeConstructor = function(start, end) {
        if (dateConstructorIsExtended()) {
            if (arguments.length === 1 && isString(start)) return createDateRangeFromString(start);
            start = getSugarExtendedDate(start);
            end = getSugarExtendedDate(end)
        } else {
            start = getSimpleDate(start);
            end = getSimpleDate(end)
        }
        return new Range(start, end)
    };
    extendRangeConstructor(number, PrimitiveRangeConstructor);
    extendRangeConstructor(string, PrimitiveRangeConstructor);
    extendRangeConstructor(date, DateRangeConstructor);
    extend(number, {
        "upto": function(num,
            fn, step) {
            return (new Range(this, num)).every(step, fn)
        },
        "clamp": function(start, end) {
            return (new Range(start, end)).clamp(this)
        },
        "cap": function(max) {
            return (new Range(Undefined, max)).clamp(this)
        }
    });
    alias(number, "downto", "upto");
    extend(array, {
        "create": function(range) {
            return range.every()
        }
    }, false, function(a) {
        return a instanceof Range
    });

    function setDelay(fn, ms, after, scope, args) {
        if (ms === Infinity) return;
        if (!fn.timers) fn.timers = [];
        if (!isNumber(ms)) ms = 1;
        fn._canceled = false;
        fn.timers.push(setTimeout(function() {
            if (!fn._canceled) after.apply(scope,
                args || [])
        }, ms))
    }

    function cancelFunction(fn) {
        var timers = fn.timers,
            timer;
        if (isArray(timers))
            while (timer = timers.shift()) clearTimeout(timer);
        fn._canceled = true;
        return fn
    }

    function createLazyFunction(fn, ms, immediate, limit) {
        var queue = [],
            locked = false,
            execute, rounded, perExecution, result;
        ms = ms || 1;
        limit = limit || Infinity;
        rounded = ceil(ms);
        perExecution = round(rounded / ms) || 1;
        execute = function() {
            var queueLength = queue.length,
                maxPerRound;
            if (queueLength == 0) return;
            maxPerRound = max(queueLength - perExecution, 0);
            while (queueLength >
                maxPerRound) {
                result = func.prototype.apply.apply(fn, queue.shift());
                queueLength--
            }
            setDelay(lazy, rounded, function() {
                locked = false;
                execute()
            })
        };

        function lazy() {
            if (queue.length < limit - (locked && immediate ? 1 : 0)) queue.push([this, arguments]);
            if (!locked) {
                locked = true;
                if (immediate) execute();
                else setDelay(lazy, rounded, execute)
            }
            return result
        }
        return lazy
    }

    function stringifyArguments() {
        return stringify(arguments)
    }

    function createMemoizedFunction(fn, hashFn) {
        var cache = {};
        if (!hashFn) hashFn = stringifyArguments;
        return function memoized() {
            var key =
                hashFn.apply(this, arguments);
            if (hasOwnProperty(cache, key)) return cache[key];
            return cache[key] = fn.apply(this, arguments)
        }
    }
    extend(func, {
        "lazy": function(ms, immediate, limit) {
            return createLazyFunction(this, ms, immediate, limit)
        },
        "throttle": function(ms) {
            return createLazyFunction(this, ms, true, 1)
        },
        "debounce": function(ms) {
            var fn = this;

            function debounced() {
                cancelFunction(debounced);
                setDelay(debounced, ms, fn, this, arguments)
            }
            return debounced
        },
        "delay": function(ms) {
            var fn = this;
            var args = multiArgs(arguments, null, 1);
            setDelay(fn,
                ms, fn, fn, args);
            return fn
        },
        "every": function(ms) {
            var fn = this,
                args = arguments;
            args = args.length > 1 ? multiArgs(args, null, 1) : [];

            function execute() {
                setDelay(fn, ms, execute);
                fn.apply(fn, args)
            }
            setDelay(fn, ms, execute);
            return fn
        },
        "cancel": function() {
            return cancelFunction(this)
        },
        "after": function(num) {
            var fn = this,
                counter = 0,
                storedArguments = [];
            if (!isNumber(num)) num = 1;
            else if (num === 0) {
                fn.call();
                return fn
            }
            return function() {
                var ret;
                storedArguments.push(multiArgs(arguments));
                counter++;
                if (counter == num) {
                    ret = fn.call(this,
                        storedArguments);
                    counter = 0;
                    storedArguments = [];
                    return ret
                }
            }
        },
        "once": function() {
            return createMemoizedFunction(this, function() {})
        },
        "memoize": function(fn) {
            return createMemoizedFunction(this, fn)
        },
        "fill": function() {
            var fn = this,
                curried = multiArgs(arguments);
            return function() {
                var args = multiArgs(arguments);
                curried.forEach(function(arg, index) {
                    if (arg != null || index >= args.length) args.splice(index, 0, arg)
                });
                return fn.apply(this, args)
            }
        }
    });

    function getThousands() {
        var str = sugarNumber.thousands;
        return isString(str) ? str :
            ","
    }

    function getDecimal() {
        var str = sugarNumber.decimal;
        return isString(str) ? str : "."
    }

    function abbreviateNumber(num, roundTo, str, mid, limit, bytes) {
        var fixed = num.toFixed(20),
            decimalPlace = fixed.search(/\./),
            numeralPlace = fixed.search(/[1-9]/),
            significant = decimalPlace - numeralPlace,
            unit, i, divisor;
        if (significant > 0) significant -= 1;
        i = max(min(floor(significant / 3), limit === false ? str.length : limit), -mid);
        unit = str.charAt(i + mid - 1);
        if (significant < -9) {
            i = -3;
            roundTo = abs(significant) - 9;
            unit = str.slice(0, 1)
        }
        divisor = bytes ? pow(2,
            10 * i) : pow(10, i * 3);
        return formatNumber(withPrecision(num / divisor, roundTo || 0)) + unit.trim()
    }

    function formatNumber(num, place) {
        var i, str, split, integer, fraction, result = "";
        var thousands = getThousands();
        var decimal = getDecimal();
        str = (isNumber(place) ? withPrecision(num, place || 0).toFixed(max(place, 0)) : num.toString()).replace(/^-/, "");
        split = str.split(".");
        integer = split[0];
        fraction = split[1];
        for (i = integer.length; i > 0; i -= 3) {
            if (i < integer.length) result = thousands + result;
            result = integer.slice(max(0, i - 3), i) + result
        }
        if (fraction) result +=
            decimal + repeatString("0", (place || 0) - fraction.length) + fraction;
        return (num < 0 ? "-" : "") + result
    }

    function isInteger(n) {
        return n % 1 === 0
    }

    function isMultiple(n1, n2) {
        return n1 % n2 === 0
    }
    extend(number, {
        "random": function(n1, n2) {
            var minNum, maxNum;
            if (arguments.length == 1) n2 = n1, n1 = 0;
            minNum = min(n1 || 0, isUndefined(n2) ? 1 : n2);
            maxNum = max(n1 || 0, isUndefined(n2) ? 1 : n2) + 1;
            return floor(math.random() * (maxNum - minNum) + minNum)
        }
    }, false);
    extend(number, {
        "isNaN": function(value) {
            return value !== value
        }
    }, false, true);
    extend(number, {
        "log": function(base) {
            return math.log(this) /
                (base ? math.log(base) : 1)
        },
        "abbr": function(precision) {
            return abbreviateNumber(this, precision, "kmbt", 0, 4)
        },
        "metric": function(precision, limit) {
            return abbreviateNumber(this, precision, "nμm kMGTPE", 4, isUndefined(limit) ? 1 : limit)
        },
        "bytes": function(precision, limit, si) {
            return abbreviateNumber(this, precision, "kMGTPE", 0, isUndefined(limit) ? 4 : limit, si !== true) + "B"
        },
        "isInteger": function() {
            return isInteger(this)
        },
        "isOdd": function() {
            return isInteger(this) && !isMultiple(this, 2)
        },
        "isEven": function() {
            return isMultiple(this,
                2)
        },
        "isMultipleOf": function(num) {
            return isMultiple(this, num)
        },
        "format": function(place) {
            return formatNumber(this, place)
        },
        "hex": function(pad) {
            return padNumber(this, pad || 1, false, 16)
        },
        "times": function(fn) {
            if (fn)
                for (var i = 0; i < this; i++) fn.call(this, i);
            return +this
        },
        "chr": function() {
            return string.fromCharCode(this)
        },
        "pad": function(place, sign, base) {
            return padNumber(this, place, sign, base)
        },
        "ordinalize": function() {
            var suffix, num = abs(this),
                last = parseInt(num.toString().slice(-2));
            return this + getOrdinalizedSuffix(last)
        },
        "toNumber": function() {
            return parseFloat(this, 10)
        }
    });

    function buildNumber() {
        function createRoundingFunction(fn) {
            return function(precision) {
                return precision ? withPrecision(this, precision, fn) : fn(this)
            }
        }
        extend(number, {
            "ceil": createRoundingFunction(ceil),
            "round": createRoundingFunction(round),
            "floor": createRoundingFunction(floor)
        });
        extendSimilar(number, "abs,pow,sin,asin,cos,acos,tan,atan,exp,pow,sqrt", function(methods, name) {
            methods[name] = function(a, b) {
                return math[name](this.valueOf(), a, b)
            }
        })
    }
    buildNumber();
    var ObjectTypeMethods = "isObject,isNaN".split(",");
    var ObjectHashMethods = "equals,keys,values,select,reject,each,map,size,merge,clone,watch,tap,has,toQueryString".split(",");

    function setParamsObject(obj, param, value, castBoolean) {
        var reg = /^(.+?)(\[.*\])$/,
            paramIsArray, match, allKeys, key;
        if (match = param.match(reg)) {
            key = match[1];
            allKeys = match[2].replace(/^\[|\]$/g, "").split("][");
            allKeys.forEach(function(k) {
                paramIsArray = !k || k.match(/^\d+$/);
                if (!key && isArray(obj)) key = obj.length;
                if (!hasOwnProperty(obj, key)) obj[key] =
                    paramIsArray ? [] : {};
                obj = obj[key];
                key = k
            });
            if (!key && paramIsArray) key = obj.length.toString();
            setParamsObject(obj, key, value, castBoolean)
        } else if (castBoolean && value === "true") obj[param] = true;
        else if (castBoolean && value === "false") obj[param] = false;
        else obj[param] = value
    }

    function objectToQueryString(base, obj) {
        var tmp;
        if (isArray(obj) || isObjectType(obj) && obj.toString === internalToString) {
            tmp = [];
            iterateOverObject(obj, function(key, value) {
                if (base) key = base + "[" + key + "]";
                tmp.push(objectToQueryString(key, value))
            });
            return tmp.join("&")
        } else {
            if (!base) return "";
            return sanitizeURIComponent(base) + "=" + (isDate(obj) ? obj.getTime() : sanitizeURIComponent(obj))
        }
    }

    function sanitizeURIComponent(obj) {
        return !obj && obj !== false && obj !== 0 ? "" : encodeURIComponent(obj).replace(/%20/g, "+")
    }

    function matchInObject(match, key, value) {
        if (isRegExp(match)) return match.test(key);
        else if (isObjectType(match)) return match[key] === value;
        else return key === string(match)
    }

    function selectFromObject(obj, args, select) {
        var match, result = obj instanceof Hash ? new Hash : {};
        iterateOverObject(obj, function(key,
            value) {
            match = false;
            flattenedArgs(args, function(arg) {
                if (matchInObject(arg, key, value)) match = true
            }, 1);
            if (match === select) result[key] = value
        });
        return result
    }
    var getOwnPropertyNames = object.getOwnPropertyNames;
    var defineProperty = propertyDescriptorSupport ? object.defineProperty : definePropertyShim;
    var getOwnPropertyDescriptor = propertyDescriptorSupport ? object.getOwnPropertyDescriptor : getOwnPropertyDescriptorShim;
    var iterateOverProperties = propertyDescriptorSupport ? iterateOverPropertyNames : iterateOverObject;

    function iterateOverPropertyNames(obj,
        fn) {
        getOwnPropertyNames(obj).forEach(fn)
    }

    function getOwnPropertyDescriptorShim(obj, prop) {
        return obj.hasOwnProperty(prop) ? {
            value: obj[prop]
        } : Undefined
    }

    function definePropertyShim(obj, prop, descriptor) {
        obj[prop] = descriptor.value
    }

    function mergeObject(target, source, deep, resolve) {
        if (!isObjectType(source)) return target;
        iterateOverProperties(source, function(prop) {
            var resolved;
            var sourceDescriptor = getOwnPropertyDescriptor(source, prop);
            var targetDescriptor = getOwnPropertyDescriptor(target, prop);
            var sourceVal =
                sourceDescriptor && sourceDescriptor.value;
            var targetVal = targetDescriptor && targetDescriptor.value;
            var sourceIsObject = isObjectType(sourceVal);
            var goingDeep = deep && sourceIsObject;
            var conflict = isDefined(targetDescriptor) && targetDescriptor.value != null;
            if (conflict)
                if (!goingDeep && resolve === false) return;
                else if (isFunction(resolve)) {
                resolved = resolve.call(source, prop, targetVal, sourceVal);
                if (isDefined(resolved)) {
                    sourceDescriptor.value = resolved;
                    goingDeep = false
                }
            }
            if (goingDeep) sourceDescriptor.value = handleDeepMerge(targetVal,
                sourceVal, deep, resolve);
            defineProperty(target, prop, sourceDescriptor)
        });
        return target
    }

    function handleDeepMerge(targetVal, sourceVal, deep, resolve) {
        if (isDate(sourceVal)) return new date(sourceVal.getTime());
        else if (isRegExp(sourceVal)) return new regexp(sourceVal.source, getRegExpFlags(sourceVal));
        else {
            if (!isObjectType(targetVal)) targetVal = isArray(sourceVal) ? [] : {};
            return mergeObject(targetVal, sourceVal, deep, resolve)
        }
    }

    function mapAllObject() {
        buildObjectInstanceMethods(getObjectInstanceMethods(), object)
    }

    function unmapAllObject() {
        var objProto =
            object.prototype,
            methods = getObjectInstanceMethods();
        methods.forEach(function(name) {
            if (objProto[name]) delete objProto[name]
        })
    }

    function getObjectInstanceMethods() {
        return ObjectTypeMethods.concat(ObjectHashMethods)
    }

    function buildTypeMethods() {
        extendSimilar(object, natives, function(methods, name) {
            var method = "is" + name;
            ObjectTypeMethods.push(method);
            methods[method] = typeChecks[name]
        }, false)
    }
    extend(object, {
        "watch": function(obj, prop, fn) {
            var value, descriptor;
            if (!propertyDescriptorSupport) return false;
            descriptor =
                getOwnPropertyDescriptor(obj, prop);
            if (descriptor && (!descriptor.configurable || descriptor.get || descriptor.set)) return false;
            value = obj[prop];
            defineProperty(obj, prop, {
                configurable: true,
                enumerable: !descriptor || descriptor.enumerable,
                get: function() {
                    return value
                },
                set: function(to) {
                    value = fn.call(obj, prop, value, to)
                }
            });
            return true
        },
        "unwatch": function(obj, prop) {
            var descriptor;
            if (!propertyDescriptorSupport) return false;
            descriptor = getOwnPropertyDescriptor(obj, prop);
            if (!descriptor || !descriptor.configurable || !descriptor.get ||
                !descriptor.set) return false;
            defineProperty(obj, prop, {
                writable: true,
                configurable: true,
                enumerable: descriptor.enumerable,
                value: obj[prop]
            });
            return true
        }
    }, false, true, true);
    extend(object, {
        "keys": function(obj, fn) {
            var keys = object.keys(obj);
            keys.forEach(function(key) {
                fn.call(obj, key, obj[key])
            });
            return keys
        }
    }, false, function() {
        return arguments.length > 1
    });
    extend(object, {
        "isArguments": function(obj) {
            return isArgumentsObject(obj)
        },
        "isObject": function(obj) {
            return isPlainObject(obj)
        },
        "isNaN": function(obj) {
            return isNumber(obj) &&
                obj.valueOf() !== obj.valueOf()
        },
        "equal": function(a, b) {
            return isEqual(a, b)
        },
        "extended": function(obj) {
            return new Hash(obj)
        },
        "merge": function(target, source, deep, resolve) {
            return mergeObject(target, source, deep, resolve)
        },
        "values": function(obj, fn) {
            var values = [];
            iterateOverObject(obj, function(k, v) {
                values.push(v);
                if (fn) fn.call(obj, v)
            });
            return values
        },
        "clone": function(obj, deep) {
            var target, klass;
            if (!isObjectType(obj)) return obj;
            klass = className(obj);
            if (isDate(obj, klass) && sugarDate.clone) return sugarDate.clone(obj);
            else if (isDate(obj, klass) || isRegExp(obj, klass)) return new obj.constructor(obj);
            else if (obj instanceof Hash) target = new Hash;
            else if (isArray(obj, klass)) target = [];
            else if (isPlainObject(obj, klass)) target = {};
            else throw new TypeError("Clone must be a basic data type.");
            return mergeObject(target, obj, deep)
        },
        "fromQueryString": function(str, castBoolean) {
            var result = new Hash,
                split;
            str = str && str.toString ? str.toString() : "";
            str.replace(/^.*?\?/, "").split("&").forEach(function(p) {
                var split = p.split("=");
                if (split.length !==
                    2) return;
                setParamsObject(result, split[0], decodeURIComponent(split[1]), castBoolean)
            });
            return result
        },
        "toQueryString": function(obj, namespace) {
            return objectToQueryString(namespace, obj)
        },
        "tap": function(obj, arg) {
            var fn = arg;
            if (!isFunction(arg)) fn = function() {
                if (arg) obj[arg]()
            };
            fn.call(obj, obj);
            return obj
        },
        "has": function(obj, key) {
            return hasOwnProperty(obj, key)
        },
        "select": function(obj) {
            return selectFromObject(obj, arguments, true)
        },
        "reject": function(obj) {
            return selectFromObject(obj, arguments, false)
        },
        "map": function(obj,
            map) {
            var result = {},
                key, value;
            for (key in obj) {
                if (!hasOwnProperty(obj, key)) continue;
                value = obj[key];
                result[key] = transformArgument(value, map, obj, [key, value, obj])
            }
            return result
        },
        "each": function(obj, fn) {
            checkCallback(fn);
            iterateOverObject(obj, fn);
            return obj
        },
        "size": function(obj) {
            return keysWithObjectCoercion(obj).length
        }
    }, false);
    extend(Sugar, {
        "extendObject": function(on) {
            if (on !== false) mapAllObject();
            else unmapAllObject();
            return true
        }
    }, false);
    buildTypeMethods();
    buildObjectInstanceMethods(ObjectHashMethods,
        Hash);
    extend(regexp, {
        "escape": function(str) {
            return escapeRegExp(str)
        }
    }, false);
    extend(regexp, {
        "getFlags": function() {
            return getRegExpFlags(this)
        },
        "setFlags": function(flags) {
            return regexp(this.source, flags)
        },
        "addFlag": function(flag) {
            return regexp(this.source, getRegExpFlags(this, flag))
        },
        "removeFlag": function(flag) {
            return regexp(this.source, getRegExpFlags(this).replace(flag, ""))
        }
    });
    var HTML_CODE_MATCH = /&#(x)?([\w\d]{0,5});/i;
    var HTML_VOID_ELEMENTS = ["area", "base", "br", "col", "command", "embed", "hr", "img",
        "input", "keygen", "link", "meta", "param", "source", "track", "wbr"
    ];

    function getInflector() {
        return sugarString.Inflector
    }

    function getAcronym(word) {
        var inflector = getInflector();
        var word = inflector && inflector.acronyms[word];
        if (isString(word)) return word
    }

    function checkRepeatRange(num) {
        num = +num;
        if (num < 0 || num === Infinity) throw new RangeError("Invalid number");
        return num
    }

    function padString(num, padding) {
        return repeatString(isDefined(padding) ? padding : " ", num)
    }

    function truncateString(str, length, from, ellipsis, split) {
        var str1,
            str2, len1, len2;
        if (str.length <= length) return str.toString();
        ellipsis = isUndefined(ellipsis) ? "..." : ellipsis;
        switch (from) {
            case "left":
                str2 = split ? truncateOnWord(str, length, true) : str.slice(str.length - length);
                return ellipsis + str2;
            case "middle":
                len1 = ceil(length / 2);
                len2 = floor(length / 2);
                str1 = split ? truncateOnWord(str, len1) : str.slice(0, len1);
                str2 = split ? truncateOnWord(str, len2, true) : str.slice(str.length - len2);
                return str1 + ellipsis + str2;
            default:
                str1 = split ? truncateOnWord(str, length) : str.slice(0, length);
                return str1 +
                    ellipsis
        }
    }

    function stringEach(str, search, fn) {
        var i, len, result, chunks;
        if (isFunction(search)) {
            fn = search;
            search = /[\s\S]/g
        } else if (!search) search = /[\s\S]/g;
        else if (isString(search)) search = regexp(escapeRegExp(search), "gi");
        else if (isRegExp(search)) search = regexp(search.source, getRegExpFlags(search, "g"));
        chunks = str.match(search) || [];
        if (fn)
            for (i = 0, len = chunks.length; i < len; i++) {
                result = fn.call(str, chunks[i], i, chunks);
                if (result === false) {
                    chunks.length = i + 1;
                    break
                } else if (isDefined(result)) chunks[i] = result
            }
        return chunks
    }

    function eachWord(str, fn) {
        return stringEach(str.trim(), /\S+/g, fn)
    }

    function stringCodes(str, fn) {
        var codes = [],
            i, len;
        for (i = 0, len = str.length; i < len; i++) {
            var code = str.charCodeAt(i);
            codes.push(code);
            if (fn) fn.call(str, code, i)
        }
        return codes
    }

    function shiftChar(str, n) {
        var result = "";
        n = n || 0;
        stringCodes(str, function(c) {
            result += chr(c + n)
        });
        return result
    }

    function underscore(str) {
        var inflector = getInflector();
        return str.replace(/[-\s]+/g, "_").replace(inflector && inflector.acronymRegExp, function(acronym, index) {
            return (index >
                0 ? "_" : "") + acronym.toLowerCase()
        }).replace(/([A-Z\d]+)([A-Z][a-z])/g, "$1_$2").replace(/([a-z\d])([A-Z])/g, "$1_$2").toLowerCase()
    }

    function spacify(str) {
        return underscore(str).replace(/_/g, " ")
    }

    function capitalize(str, all) {
        var lastResponded;
        return str.toLowerCase().replace(all ? /[^']/g : /^\S/, function(lower) {
            var upper = lower.toUpperCase(),
                result;
            result = lastResponded ? lower : upper;
            lastResponded = upper !== lower;
            return result
        })
    }

    function reverseString(str) {
        return str.split("").reverse().join("")
    }

    function stringFirst(str,
        num) {
        if (isUndefined(num)) num = 1;
        return str.substr(0, num)
    }

    function stringLast(str, num) {
        if (isUndefined(num)) num = 1;
        var start = str.length - num < 0 ? 0 : str.length - num;
        return str.substr(start)
    }

    function stringFrom(str, from) {
        return str.slice(numberOrIndex(str, from, true))
    }

    function stringTo(str, to) {
        if (isUndefined(to)) to = str.length;
        return str.slice(0, numberOrIndex(str, to))
    }

    function stringAssign(str, args) {
        var obj = {};
        flattenedArgs(args, function(a, i) {
            if (isObjectType(a)) simpleMerge(obj, a);
            else obj[i + 1] = a
        });
        return str.replace(/\{([^{]+?)\}/g,
            function(m, key) {
                return hasOwnProperty(obj, key) ? obj[key] : m
            })
    }

    function isBlank(str) {
        return str.trim().length === 0
    }

    function truncateOnWord(str, limit, fromLeft) {
        if (fromLeft) return reverseString(truncateOnWord(reverseString(str), limit));
        var reg = regexp("(?=[" + getTrimmableCharacters() + "])");
        var words = str.split(reg);
        var count = 0;
        return words.filter(function(word) {
            count += word.length;
            return count <= limit
        }).join("")
    }

    function convertHTMLCodes(str) {
        return str.replace(HTML_CODE_MATCH, function(full, hex, code) {
            return string.fromCharCode(parseInt(code,
                hex ? 16 : 10))
        })
    }

    function tagIsVoid(tag) {
        return HTML_VOID_ELEMENTS.indexOf(tag.toLowerCase()) !== -1
    }

    function replaceTags(str, args, strip) {
        var lastIndex = args.length - 1,
            lastArg = args[lastIndex],
            replacementFn, tags, reg;
        if (isFunction(lastArg)) {
            replacementFn = lastArg;
            args.length = lastIndex
        }
        tags = flattenedArgs(args).map(function(tag) {
            return escapeRegExp(tag)
        }).join("|");
        reg = regexp("<(\\/)?(" + (tags || "[^\\s>]+") + ")(\\s+[^<>]*?)?\\s*(\\/)?>", "gi");
        return runTagReplacements(str.toString(), reg, strip, replacementFn)
    }

    function runTagReplacements(str,
        reg, strip, replacementFn, fullString) {
        var match;
        var result = "";
        var currentIndex = 0;
        var currentlyOpenTagName;
        var currentlyOpenTagAttributes;
        var currentlyOpenTagCount = 0;

        function processTag(index, tagName, attributes, tagLength) {
            var content = str.slice(currentIndex, index),
                replacement;
            if (replacementFn) {
                replacement = replacementFn.call(fullString, tagName, content, attributes, fullString);
                if (isDefined(replacement)) content = replacement;
                else if (!strip) content = ""
            } else if (!strip) content = "";
            result += runTagReplacements(content,
                reg, strip, replacementFn, fullString);
            currentIndex = index + (tagLength || 0)
        }
        fullString = fullString || str;
        reg = regexp(reg.source, "gi");
        while (match = reg.exec(str)) {
            var tagName = match[2];
            var attributes = (match[3] || "").slice(1);
            var isClosingTag = !!match[1];
            var isSelfClosing = !!match[4];
            var tagLength = match[0].length;
            var isOpeningTag = !isClosingTag && !isSelfClosing && !tagIsVoid(tagName);
            var isSameAsCurrent = tagName === currentlyOpenTagName;
            if (!currentlyOpenTagName) {
                result += str.slice(currentIndex, match.index);
                currentIndex =
                    match.index
            }
            if (isOpeningTag)
                if (!currentlyOpenTagName) {
                    currentlyOpenTagName = tagName;
                    currentlyOpenTagAttributes = attributes;
                    currentlyOpenTagCount++;
                    currentIndex += tagLength
                } else {
                    if (isSameAsCurrent) currentlyOpenTagCount++
                } else if (isClosingTag && isSameAsCurrent) {
                currentlyOpenTagCount--;
                if (currentlyOpenTagCount === 0) {
                    processTag(match.index, currentlyOpenTagName, currentlyOpenTagAttributes, tagLength);
                    currentlyOpenTagName = null;
                    currentlyOpenTagAttributes = null
                }
            } else if (!currentlyOpenTagName) processTag(match.index,
                tagName, attributes, tagLength)
        }
        if (currentlyOpenTagName) processTag(str.length, currentlyOpenTagName, currentlyOpenTagAttributes);
        result += str.slice(currentIndex);
        return result
    }

    function numberOrIndex(str, n, from) {
        if (isString(n)) {
            n = str.indexOf(n);
            if (n === -1) n = from ? str.length : 0
        }
        return n
    }
    var encodeBase64, decodeBase64;

    function buildBase64(key) {
        var encodeAscii, decodeAscii;

        function catchEncodingError(fn) {
            return function(str) {
                try {
                    return fn(str)
                } catch (e) {
                    return ""
                }
            }
        }
        if (typeof Buffer !== "undefined") {
            encodeBase64 = function(str) {
                return (new Buffer(str)).toString("base64")
            };
            decodeBase64 = function(str) {
                return (new Buffer(str, "base64")).toString("utf8")
            };
            return
        }
        if (typeof btoa !== "undefined") {
            encodeAscii = catchEncodingError(btoa);
            decodeAscii = catchEncodingError(atob)
        } else {
            var base64reg = /[^A-Za-z0-9\+\/\=]/g;
            encodeAscii = function(str) {
                var output = "";
                var chr1, chr2, chr3;
                var enc1, enc2, enc3, enc4;
                var i = 0;
                do {
                    chr1 = str.charCodeAt(i++);
                    chr2 = str.charCodeAt(i++);
                    chr3 = str.charCodeAt(i++);
                    enc1 = chr1 >> 2;
                    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
                    enc3 = (chr2 & 15) << 2 | chr3 >> 6;
                    enc4 = chr3 & 63;
                    if (isNaN(chr2)) enc3 = enc4 =
                        64;
                    else if (isNaN(chr3)) enc4 = 64;
                    output = output + key.charAt(enc1) + key.charAt(enc2) + key.charAt(enc3) + key.charAt(enc4);
                    chr1 = chr2 = chr3 = "";
                    enc1 = enc2 = enc3 = enc4 = ""
                } while (i < str.length);
                return output
            };
            decodeAscii = function(input) {
                var output = "";
                var chr1, chr2, chr3;
                var enc1, enc2, enc3, enc4;
                var i = 0;
                if (input.match(base64reg)) return "";
                input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                do {
                    enc1 = key.indexOf(input.charAt(i++));
                    enc2 = key.indexOf(input.charAt(i++));
                    enc3 = key.indexOf(input.charAt(i++));
                    enc4 = key.indexOf(input.charAt(i++));
                    chr1 = enc1 << 2 | enc2 >> 4;
                    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
                    chr3 = (enc3 & 3) << 6 | enc4;
                    output = output + chr(chr1);
                    if (enc3 != 64) output = output + chr(chr2);
                    if (enc4 != 64) output = output + chr(chr3);
                    chr1 = chr2 = chr3 = "";
                    enc1 = enc2 = enc3 = enc4 = ""
                } while (i < input.length);
                return output
            }
        }
        encodeBase64 = function(str) {
            return encodeAscii(unescape(encodeURIComponent(str)))
        };
        decodeBase64 = function(str) {
            return decodeURIComponent(escape(decodeAscii(str)))
        }
    }

    function getCoercedStringSubject(obj) {
        if (obj == null) throw new TypeError;
        return string(obj)
    }

    function getCoercedSearchString(obj,
        errorOnRegex) {
        if (errorOnRegex && isRegExp(obj)) throw new TypeError;
        return string(obj)
    }

    function buildStartEndsWith() {
        var override = true;
        try {
            "".startsWith(/./)
        } catch (e) {
            override = false
        }
        extend(string, {
            "startsWith": function(searchString) {
                var str, start, pos, len, searchLength, position = arguments[1];
                str = getCoercedStringSubject(this);
                searchString = getCoercedSearchString(searchString, true);
                pos = number(position) || 0;
                len = str.length;
                start = min(max(pos, 0), len);
                searchLength = searchString.length;
                if (searchLength + start > len) return false;
                if (str.substr(start, searchLength) === searchString) return true;
                return false
            },
            "endsWith": function(searchString) {
                var str, start, end, pos, len, searchLength, endPosition = arguments[1];
                str = getCoercedStringSubject(this);
                searchString = getCoercedSearchString(searchString, true);
                len = str.length;
                pos = len;
                if (isDefined(endPosition)) pos = number(endPosition) || 0;
                end = min(max(pos, 0), len);
                searchLength = searchString.length;
                start = end - searchLength;
                if (start < 0) return false;
                if (str.substr(start, searchLength) === searchString) return true;
                return false
            }
        }, true, true, override)
    }
    extend(string, {
        "contains": function(searchString, position) {
            var str = getCoercedStringSubject(this);
            return str.indexOf(searchString, position) > -1
        },
        "repeat": function(num) {
            num = checkRepeatRange(num);
            return repeatString(this, num)
        }
    }, true, true);
    extend(string, {
        "escapeURL": function(param) {
            return param ? encodeURIComponent(this) : encodeURI(this)
        },
        "unescapeURL": function(param) {
            return param ? decodeURI(this) : decodeURIComponent(this)
        },
        "escapeHTML": function() {
            return this.replace(/&/g,
                "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/\//g, "&#x2f;")
        },
        "unescapeHTML": function() {
            return convertHTMLCodes(this).replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&nbsp;/g, " ").replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/&amp;/g, "&")
        },
        "encodeBase64": function() {
            return encodeBase64(this)
        },
        "decodeBase64": function() {
            return decodeBase64(this)
        },
        "each": function(search, fn) {
            return stringEach(this, search, fn)
        },
        "map": function(map, scope) {
            var str =
                this.toString();
            if (isFunction(map)) {
                var fn = map;
                map = function(letter, i, arr) {
                    return fn.call(scope, letter, i, str)
                }
            }
            return str.split("").map(map, scope).join("")
        },
        "shift": function(n) {
            return shiftChar(this, n)
        },
        "codes": function(fn) {
            return stringCodes(this, fn)
        },
        "chars": function(fn) {
            return stringEach(this, fn)
        },
        "words": function(fn) {
            return eachWord(this, fn)
        },
        "lines": function(fn) {
            return stringEach(this.trim(), /^.*$/gm, fn)
        },
        "paragraphs": function(fn) {
            var paragraphs = this.trim().split(/[\r\n]{2,}/);
            paragraphs = paragraphs.map(function(p) {
                if (fn) var s =
                    fn.call(p);
                return s ? s : p
            });
            return paragraphs
        },
        "isBlank": function() {
            return isBlank(this)
        },
        "add": function(str, index) {
            index = isUndefined(index) ? this.length : index;
            return this.slice(0, index) + str + this.slice(index)
        },
        "remove": function(f) {
            return this.replace(f, "")
        },
        "reverse": function() {
            return reverseString(this)
        },
        "compact": function() {
            return this.trim().replace(/([\r\n\s　])+/g, function(match, whitespace) {
                return whitespace === "　" ? whitespace : " "
            })
        },
        "at": function() {
            return getEntriesForIndexes(this, arguments, true)
        },
        "from": function(from) {
            return stringFrom(this, from)
        },
        "to": function(to) {
            return stringTo(this, to)
        },
        "dasherize": function() {
            return underscore(this).replace(/_/g, "-")
        },
        "underscore": function() {
            return underscore(this)
        },
        "camelize": function(first) {
            return underscore(this).replace(/(^|_)([^_]+)/g, function(match, pre, word, index) {
                var acronym = getAcronym(word),
                    cap = first !== false || index > 0;
                if (acronym) return cap ? acronym : acronym.toLowerCase();
                return cap ? capitalize(word) : word
            })
        },
        "spacify": function() {
            return spacify(this)
        },
        "stripTags": function() {
            return replaceTags(this, arguments, true)
        },
        "removeTags": function() {
            return replaceTags(this, arguments, false)
        },
        "truncate": function(length, from, ellipsis) {
            return truncateString(this, length, from, ellipsis)
        },
        "truncateOnWord": function(length, from, ellipsis) {
            return truncateString(this, length, from, ellipsis, true)
        },
        "pad": function(num, padding) {
            var half, front, back;
            num = checkRepeatRange(num);
            half = max(0, num - this.length) / 2;
            front = floor(half);
            back = ceil(half);
            return padString(front, padding) + this + padString(back,
                padding)
        },
        "padLeft": function(num, padding) {
            num = checkRepeatRange(num);
            return padString(max(0, num - this.length), padding) + this
        },
        "padRight": function(num, padding) {
            num = checkRepeatRange(num);
            return this + padString(max(0, num - this.length), padding)
        },
        "first": function(num) {
            return stringFirst(this, num)
        },
        "last": function(num) {
            return stringLast(this, num)
        },
        "toNumber": function(base) {
            return stringToNumber(this, base)
        },
        "capitalize": function(all) {
            return capitalize(this, all)
        },
        "assign": function() {
            return stringAssign(this, arguments)
        },
        "trimLeft": function() {
            return this.replace(regexp("^[" + getTrimmableCharacters() + "]+"), "")
        },
        "trimRight": function() {
            return this.replace(regexp("[" + getTrimmableCharacters() + "]+$"), "")
        }
    });
    alias(string, "insert", "add");
    buildStartEndsWith();
    buildBase64("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=")
})();
(function(factory) {
    if (typeof define === "function" && define.amd) define(["jquery"], factory);
    else if (typeof module === "object" && module.exports) module.exports = factory(require("jquery"));
    else factory(window.jQuery)
})(function($) {
    function getElementSelection(that) {
        var position = {};
        if (that.selectionStart === undefined) {
            that.focus();
            var select = document.selection.createRange();
            position.length = select.text.length;
            select.moveStart("character", -that.value.length);
            position.end = select.text.length;
            position.start = position.end -
                position.length
        } else {
            position.start = that.selectionStart;
            position.end = that.selectionEnd;
            position.length = position.end - position.start
        }
        return position
    }

    function setElementSelection(that, start, end) {
        if (that.selectionStart === undefined) {
            that.focus();
            var r = that.createTextRange();
            r.collapse(true);
            r.moveEnd("character", end);
            r.moveStart("character", start);
            r.select()
        } else {
            that.selectionStart = start;
            that.selectionEnd = end
        }
    }

    function throwErr(message, debug) {
        if (debug) {
            var err = new Error(message);
            throw err;
        }
    }

    function runCallbacks($this,
        settings) {
        $.each(settings, function(k, val) {
            if (typeof val === "function") settings[k] = val($this, settings, k);
            else if (typeof $this.autoNumeric[val] === "function") settings[k] = $this.autoNumeric[val]($this, settings, k)
        })
    }

    function autoCode($this, settings) {
        runCallbacks($this, settings);
        var vmax = settings.vMax.toString().split("."),
            vmin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split(".");
        settings.aNeg = settings.vMin < 0 ? "-" : "";
        vmax[0] = vmax[0].replace("-", "");
        vmin[0] = vmin[0].replace("-", "");
        settings.mIntPos =
            Math.max(vmax[0].length, 1);
        settings.mIntNeg = Math.max(vmin[0].length, 1);
        if (settings.mDec === null) {
            var vmaxLength = 0,
                vminLength = 0;
            if (vmax[1]) vmaxLength = vmax[1].length;
            if (vmin[1]) vminLength = vmin[1].length;
            settings.mDec = Math.max(vmaxLength, vminLength);
            settings.oDec = settings.mDec
        } else settings.mDec = Number(settings.mDec);
        if (settings.altDec === null && settings.mDec > 0)
            if (settings.aDec === "." && settings.aSep !== ",") settings.altDec = ",";
            else if (settings.aDec === "," && settings.aSep !== ".") settings.altDec = ".";
        var aNegReg =
            settings.aNeg ? "([-\\" + settings.aNeg + "]?)" : "(-?)";
        settings.aNegRegAutoStrip = aNegReg;
        settings.skipFirstAutoStrip = new RegExp(aNegReg + "[^-" + (settings.aNeg ? "\\" + settings.aNeg : "") + "\\" + settings.aDec + "\\d]" + ".*?(\\d|\\" + settings.aDec + "\\d)");
        settings.skipLastAutoStrip = new RegExp("(\\d\\" + settings.aDec + "?)[^\\" + settings.aDec + "\\d]\\D*$");
        var allowed = "-" + settings.aNum + "\\" + settings.aDec;
        settings.allowedAutoStrip = new RegExp("[^" + allowed + "]", "gi");
        settings.numRegAutoStrip = new RegExp(aNegReg + "(?:\\" + settings.aDec +
            "?(\\d+\\" + settings.aDec + "\\d+)|(\\d*(?:\\" + settings.aDec + "\\d*)?))");
        return settings
    }

    function autoStrip(s, settings) {
        if (settings.aSign !== "") s = s.replace(settings.aSign, "");
        if (settings.aSuffix)
            while (s.indexOf(settings.aSuffix) > -1) s = s.replace(settings.aSuffix, "");
        s = s.replace(settings.skipFirstAutoStrip, "$1$2");
        if ((settings.pNeg === "s" || settings.pSign === "s" && settings.pNeg !== "p") && s.indexOf("-") > -1 && s !== "") settings.trailingNegative = true;
        s = s.replace(settings.skipLastAutoStrip, "$1");
        s = s.replace(settings.allowedAutoStrip,
            "");
        if (settings.altDec) s = s.replace(settings.altDec, settings.aDec);
        var m = s.match(settings.numRegAutoStrip);
        s = m ? [m[1], m[2], m[3]].join("") : "";
        if (settings.lZero === "allow" || settings.lZero === "keep") {
            var parts = [],
                nSign = "";
            parts = s.split(settings.aDec);
            if (parts[0].indexOf(settings.aNeg) !== -1) {
                nSign = settings.aNeg;
                parts[0] = parts[0].replace(settings.aNeg, "")
            }
            if (nSign === "" && parts[0].length > settings.mIntPos && parts[0].charAt(0) === "0") parts[0] = parts[0].slice(1);
            if (nSign !== "" && parts[0].length > settings.mIntNeg && parts[0].charAt(0) ===
                "0") parts[0] = parts[0].slice(1);
            s = nSign + parts.join(settings.aDec)
        }
        if (settings.onOff && settings.lZero === "deny" || settings.lZero === "allow" && settings.onOff === false) {
            var strip_reg = "^" + settings.aNegRegAutoStrip + "0*(\\d|$)";
            strip_reg = new RegExp(strip_reg);
            s = s.replace(strip_reg, "$1$2")
        }
        return s
    }

    function negativeBracket(s, settings) {
        if (settings.pSign === "p" && settings.pNeg === "l" || settings.pSign === "s" && settings.pNeg === "p") {
            var brackets = settings.nBracket.split(",");
            if (!settings.onOff) {
                s = s.replace(settings.aNeg, "");
                s = brackets[0] + s + brackets[1]
            } else if (settings.onOff && s.charAt(0) === brackets[0]) {
                s = s.replace(brackets[0], settings.aNeg);
                s = s.replace(brackets[1], "")
            }
        }
        return s
    }

    function convertLocale(s) {
        s = s.replace(",", ".");
        if (s.lastIndexOf("-") !== -1 && s.lastIndexOf("-") === s.length - 1) {
            s = s.replace("-", "");
            s = "-" + s
        }
        return s
    }

    function fixNumber(s, aDec, aNeg) {
        if (aDec && aDec !== ".") s = s.replace(aDec, ".");
        if (aNeg && aNeg !== "-") s = s.replace(aNeg, "-");
        if (!s.match(/\d/)) s += "0";
        return s
    }

    function presentNumber(s, aDec, aNeg) {
        if (aNeg && aNeg !==
            "-") s = s.replace("-", aNeg);
        if (aDec && aDec !== ".") s = s.replace(".", aDec);
        return s
    }

    function checkEmpty(iv, settings, signOnEmpty) {
        if (iv === "" || iv === settings.aNeg) {
            if (settings.wEmpty === "always" || signOnEmpty) return settings.pNeg === "l" ? iv + settings.aSign + settings.aSuffix : settings.aSign + iv + settings.aSuffix;
            return iv
        }
        return null
    }

    function autoGroup(iv, settings) {
        iv = autoStrip(iv, settings);
        if (settings.trailingNegative && iv.indexOf("-") === -1) iv = "-" + iv;
        var empty = checkEmpty(iv, settings, true),
            isNeg = iv.indexOf("-") > -1;
        if (isNeg) iv =
            iv.replace("-", "");
        if (empty !== null) return empty;
        var digitalGroup = "";
        settings.dGroup = settings.dGroup.toString();
        if (settings.dGroup === "2") digitalGroup = /(\d)((\d)(\d{2}?)+)$/;
        else if (settings.dGroup === "2s") digitalGroup = /(\d)((?:\d{2}){0,2}\d{3}(?:(?:\d{2}){2}\d{3})*?)$/;
        else if (settings.dGroup === "4") digitalGroup = /(\d)((\d{4}?)+)$/;
        else digitalGroup = /(\d)((\d{3}?)+)$/;
        var ivSplit = iv.split(settings.aDec);
        if (settings.altDec && ivSplit.length === 1) ivSplit = iv.split(settings.altDec);
        var s = ivSplit[0];
        if (settings.aSep !==
            "")
            while (digitalGroup.test(s)) s = s.replace(digitalGroup, "$1" + settings.aSep + "$2");
        if (settings.mDec !== 0 && ivSplit.length > 1) {
            if (ivSplit[1].length > settings.mDec) ivSplit[1] = ivSplit[1].substring(0, settings.mDec);
            iv = s + settings.aDec + ivSplit[1]
        } else iv = s;
        if (settings.pSign === "p") {
            if (isNeg && settings.pNeg === "l") iv = settings.aNeg + settings.aSign + iv;
            if (isNeg && settings.pNeg === "r") iv = settings.aSign + settings.aNeg + iv;
            if (isNeg && settings.pNeg === "s") iv = settings.aSign + iv + settings.aNeg;
            if (!isNeg) iv = settings.aSign + iv
        }
        if (settings.pSign ===
            "s") {
            if (isNeg && settings.pNeg === "r") iv = iv + settings.aSign + settings.aNeg;
            if (isNeg && settings.pNeg === "l") iv = iv + settings.aNeg + settings.aSign;
            if (isNeg && settings.pNeg === "p") iv = settings.aNeg + iv + settings.aSign;
            if (!isNeg) iv = iv + settings.aSign
        }
        if (settings.rawValue < 0 && settings.nBracket !== null) iv = negativeBracket(iv, settings);
        settings.trailingNegative = false;
        return iv + settings.aSuffix
    }

    function autoRound(iv, settings) {
        iv = iv === "" ? "0" : iv.toString();
        if (settings.mRound === "N05" || settings.mRound === "U05" || settings.mRound ===
            "D05") {
            iv = settings.mRound === "N05" ? (Math.round(iv * 20) / 20).toString() : settings.mRound === "U05" ? (Math.ceil(iv * 20) / 20).toString() : (Math.floor(iv * 20) / 20).toString();
            return iv.indexOf(".") === -1 ? iv + ".00" : iv.length - iv.indexOf(".") < 3 ? iv + "0" : iv
        }
        var ivRounded = "",
            i = 0,
            nSign = "",
            rDec = typeof settings.aPad === "boolean" || settings.aPad === null ? settings.aPad ? settings.mDec : 0 : Number(settings.aPad);
        var truncateZeros = function(ivRounded) {
            var regex = rDec === 0 ? /(\.(?:\d*[1-9])?)0*$/ : rDec === 1 ? /(\.\d(?:\d*[1-9])?)0*$/ : new RegExp("(\\.\\d{" +
                rDec + "}(?:\\d*[1-9])?)0*");
            ivRounded = ivRounded.replace(regex, "$1");
            if (rDec === 0) ivRounded = ivRounded.replace(/\.$/, "");
            return ivRounded
        };
        if (iv.charAt(0) === "-") {
            nSign = "-";
            iv = iv.replace("-", "")
        }
        if (!iv.match(/^\d/)) iv = "0" + iv;
        if (nSign === "-" && Number(iv) === 0) nSign = "";
        if (Number(iv) > 0 && settings.lZero !== "keep" || iv.length > 0 && settings.lZero === "allow") iv = iv.replace(/^0*(\d)/, "$1");
        var dPos = iv.lastIndexOf("."),
            vdPos = dPos === -1 ? iv.length - 1 : dPos,
            cDec = iv.length - 1 - vdPos;
        if (cDec <= settings.mDec) {
            ivRounded = iv;
            if (cDec < rDec) {
                if (dPos ===
                    -1) ivRounded += settings.aDec;
                var zeros = "000000";
                while (cDec < rDec) {
                    zeros = zeros.substring(0, rDec - cDec);
                    ivRounded += zeros;
                    cDec += zeros.length
                }
            } else if (cDec > rDec) ivRounded = truncateZeros(ivRounded);
            else if (cDec === 0 && rDec === 0) ivRounded = ivRounded.replace(/\.$/, "");
            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded
        }
        var rLength = dPos + settings.mDec,
            tRound = Number(iv.charAt(rLength + 1)),
            ivArray = iv.substring(0, rLength + 1).split(""),
            odd = iv.charAt(rLength) === "." ? iv.charAt(rLength - 1) % 2 : iv.charAt(rLength) % 2;
        if (tRound >
            4 && settings.mRound === "S" || tRound > 4 && settings.mRound === "A" && nSign === "" || tRound > 5 && settings.mRound === "A" && nSign === "-" || tRound > 5 && settings.mRound === "s" || tRound > 5 && settings.mRound === "a" && nSign === "" || tRound > 4 && settings.mRound === "a" && nSign === "-" || tRound > 5 && settings.mRound === "B" || tRound === 5 && settings.mRound === "B" && odd === 1 || tRound > 0 && settings.mRound === "C" && nSign === "" || tRound > 0 && settings.mRound === "F" && nSign === "-" || tRound > 0 && settings.mRound === "U")
            for (i = ivArray.length - 1; i >= 0; i -= 1)
                if (ivArray[i] !== ".") {
                    ivArray[i] = +ivArray[i] + 1;
                    if (ivArray[i] < 10) break;
                    if (i > 0) ivArray[i] = "0"
                }
        ivArray = ivArray.slice(0, rLength + 1);
        ivRounded = truncateZeros(ivArray.join(""));
        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded
    }

    function truncateDecimal(s, settings, paste) {
        var aDec = settings.aDec,
            mDec = settings.mDec;
        s = paste === "paste" ? autoRound(s, settings) : s;
        if (aDec && mDec) {
            var parts = s.split(aDec);
            if (parts[1] && parts[1].length > mDec)
                if (mDec > 0) {
                    parts[1] = parts[1].substring(0, mDec);
                    s = parts.join(aDec)
                } else s = parts[0]
        }
        return s
    }

    function parseStr(n) {
        var x = {},
            e, i, nL, j;
        if (n === 0 && 1 / n < 0) n = "-0";
        if (n.charAt(0) === "-") {
            n = n.slice(1);
            x.s = -1
        } else x.s = 1;
        e = n.indexOf(".");
        if (e > -1) n = n.replace(".", "");
        if (e < 0) e = n.length;
        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);
        nL = n.length;
        if (i === nL) {
            x.e = 0;
            x.c = [0]
        } else {
            for (j = nL - 1; n.charAt(j) === "0"; j -= 1) nL -= 1;
            nL -= 1;
            x.e = e - i - 1;
            x.c = [];
            for (e = 0; i <= nL; i += 1) {
                x.c[e] = +n.charAt(i);
                e += 1
            }
        }
        return x
    }

    function testMinMax(y, x) {
        var xNeg, xc = x.c,
            yc = y.c,
            i = x.s,
            j = y.s,
            k = x.e,
            l = y.e;
        if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;
        if (i !== j) return i;
        xNeg =
            i < 0;
        if (k !== l) return k > l ^ xNeg ? 1 : -1;
        i = -1;
        k = xc.length;
        l = yc.length;
        j = k < l ? k : l;
        for (i += 1; i < j; i += 1)
            if (xc[i] !== yc[i]) return xc[i] > yc[i] ^ xNeg ? 1 : -1;
        return k === l ? 0 : k > l ^ xNeg ? 1 : -1
    }

    function autoCheck(s, settings) {
        s = s.toString();
        s = s.replace(",", ".");
        var minParse = parseStr(settings.vMin),
            maxParse = parseStr(settings.vMax),
            valParse = parseStr(s);
        return testMinMax(minParse, valParse) > -1 && testMinMax(maxParse, valParse) < 1
    }

    function AutoNumericHolder(that, settings) {
        this.settings = settings;
        this.that = that;
        this.$that = $(that);
        this.formatted =
            false;
        this.settingsClone = autoCode(this.$that, this.settings);
        this.value = that.value
    }
    AutoNumericHolder.prototype = {
        init: function(e) {
            this.value = this.that.value;
            this.settingsClone = autoCode(this.$that, this.settings);
            this.ctrlKey = e.ctrlKey;
            this.cmdKey = e.metaKey;
            this.shiftKey = e.shiftKey;
            this.selection = getElementSelection(this.that);
            if (e.type === "keydown" || e.type === "keyup") this.kdCode = e.keyCode;
            this.which = e.which;
            this.processed = false;
            this.formatted = false
        },
        setSelection: function(start, end, setReal) {
            start = Math.max(start,
                0);
            end = Math.min(end, this.that.value.length);
            this.selection = {
                start: start,
                end: end,
                length: end - start
            };
            if (setReal === undefined || setReal) setElementSelection(this.that, start, end)
        },
        setPosition: function(pos, setReal) {
            this.setSelection(pos, pos, setReal)
        },
        getBeforeAfter: function() {
            var value = this.value,
                left = value.substring(0, this.selection.start),
                right = value.substring(this.selection.end, value.length);
            return [left, right]
        },
        getBeforeAfterStriped: function() {
            var settingsClone = this.settingsClone,
                parts = this.getBeforeAfter();
            parts[0] = autoStrip(parts[0], this.settingsClone);
            parts[1] = autoStrip(parts[1], this.settingsClone);
            if (settingsClone.trailingNegative && parts[0].indexOf("-") === -1) {
                parts[0] = "-" + parts[0];
                parts[1] = parts[1] === "-" ? "" : parts[1]
            }
            settingsClone.trailingNegative = false;
            return parts
        },
        normalizeParts: function(left, right) {
            var settingsClone = this.settingsClone;
            left = autoStrip(left, settingsClone);
            right = autoStrip(right, settingsClone);
            if (settingsClone.trailingNegative && left.indexOf("-") === -1) {
                left = "-" + left;
                settingsClone.trailingNegative =
                    false
            }
            if ((left === "" || left === settingsClone.aNeg) && settingsClone.lZero === "deny")
                if (right > "") right = right.replace(/^0*(\d)/, "$1");
            var new_value = left + right;
            if (settingsClone.aDec) {
                var m = new_value.match(new RegExp("^" + settingsClone.aNegRegAutoStrip + "\\" + settingsClone.aDec));
                if (m) {
                    left = left.replace(m[1], m[1] + "0");
                    new_value = left + right
                }
            }
            return [left, right]
        },
        setValueParts: function(left, right, paste) {
            var settingsClone = this.settingsClone,
                parts = this.normalizeParts(left, right),
                new_value = parts.join(""),
                position = parts[0].length;
            if (autoCheck(new_value, settingsClone)) {
                new_value = truncateDecimal(new_value, settingsClone, paste);
                var test_value = new_value.indexOf(",") !== -1 ? new_value.replace(",", ".") : new_value,
                    text_value = test_value;
                if (test_value === "" || test_value === settingsClone.aNeg) settingsClone.rawValue = "";
                else settingsClone.rawValue = text_value;
                if (position > new_value.length) position = new_value.length;
                this.value = new_value;
                this.setPosition(position, false);
                return true
            }
            return false
        },
        signPosition: function() {
            var settingsClone = this.settingsClone,
                aSign = settingsClone.aSign,
                that = this.that;
            if (aSign) {
                var aSignLen = aSign.length;
                if (settingsClone.pSign === "p") {
                    var hasNeg = settingsClone.aNeg && that.value && that.value.charAt(0) === settingsClone.aNeg;
                    return hasNeg ? [1, aSignLen + 1] : [0, aSignLen]
                }
                var valueLen = that.value.length;
                return [valueLen - aSignLen, valueLen]
            }
            return [1E3, -1]
        },
        expandSelectionOnSign: function(setReal) {
            var sign_position = this.signPosition(),
                selection = this.selection;
            if (selection.start < sign_position[1] && selection.end > sign_position[0])
                if ((selection.start <
                        sign_position[0] || selection.end > sign_position[1]) && this.value.substring(Math.max(selection.start, sign_position[0]), Math.min(selection.end, sign_position[1])).match(/^\s*$/))
                    if (selection.start < sign_position[0]) this.setSelection(selection.start, sign_position[0], setReal);
                    else this.setSelection(sign_position[1], selection.end, setReal);
            else this.setSelection(Math.min(selection.start, sign_position[0]), Math.max(selection.end, sign_position[1]), setReal)
        },
        checkPaste: function() {
            if (this.valuePartsBeforePaste !==
                undefined) {
                var parts = this.getBeforeAfter(),
                    oldParts = this.valuePartsBeforePaste;
                delete this.valuePartsBeforePaste;
                parts[0] = parts[0].substr(0, oldParts[0].length) + autoStrip(parts[0].substr(oldParts[0].length), this.settingsClone);
                if (!this.setValueParts(parts[0], parts[1], "paste")) {
                    this.value = oldParts.join("");
                    this.setPosition(oldParts[0].length, false)
                }
            }
        },
        skipAllways: function(e) {
            var kdCode = this.kdCode,
                which = this.which,
                ctrlKey = this.ctrlKey,
                cmdKey = this.cmdKey,
                shiftKey = this.shiftKey;
            if ((ctrlKey || cmdKey) &&
                e.type === "keyup" && this.valuePartsBeforePaste !== undefined || shiftKey && kdCode === 45) {
                this.checkPaste();
                return false
            }
            if (kdCode >= 112 && kdCode <= 123 || kdCode >= 91 && kdCode <= 93 || kdCode >= 9 && kdCode <= 31 || kdCode < 8 && (which === 0 || which === kdCode) || kdCode === 144 || kdCode === 145 || kdCode === 45 || kdCode === 224) return true;
            if ((ctrlKey || cmdKey) && kdCode === 65) {
                if (this.settings.sNumber) {
                    e.preventDefault();
                    var valueLen = this.that.value.length,
                        aSignLen = this.settings.aSign.length,
                        negLen = this.that.value.indexOf("-") === -1 ? 0 : 1,
                        aSuffixLen =
                        this.settings.aSuffix.length,
                        pSign = this.settings.pSign,
                        pNeg = this.settings.pNeg,
                        start = pSign === "s" ? 0 : pNeg === "l" && negLen === 1 && aSignLen > 0 ? aSignLen + 1 : aSignLen,
                        end = pSign === "p" ? valueLen - aSuffixLen : pNeg === "l" ? valueLen - (aSuffixLen + aSignLen) : pNeg === "r" ? aSignLen > 0 ? valueLen - (aSignLen + negLen + aSuffixLen) : valueLen - (aSignLen + aSuffixLen) : valueLen - (aSignLen + aSuffixLen);
                    setElementSelection(this.that, start, end)
                }
                return true
            }
            if ((ctrlKey || cmdKey) && (kdCode === 67 || kdCode === 86 || kdCode === 88)) {
                if (e.type === "keydown") this.expandSelectionOnSign();
                if (kdCode === 86 || kdCode === 45)
                    if (e.type === "keydown" || e.type === "keypress") {
                        if (this.valuePartsBeforePaste === undefined) this.valuePartsBeforePaste = this.getBeforeAfter()
                    } else this.checkPaste();
                return e.type === "keydown" || e.type === "keypress" || kdCode === 67
            }
            if (ctrlKey || cmdKey) return true;
            if (kdCode === 37 || kdCode === 39) {
                var aSep = this.settingsClone.aSep,
                    aDec = this.settingsClone.aDec,
                    startJump = this.selection.start,
                    value = this.that.value;
                if (e.type === "keydown" && !this.shiftKey)
                    if (kdCode === 37 && (value.charAt(startJump - 2) ===
                            aSep || value.charAt(startJump - 2) === aDec)) this.setPosition(startJump - 1);
                    else if (kdCode === 39 && (value.charAt(startJump + 1) === aSep || value.charAt(startJump + 1) === aDec)) this.setPosition(startJump + 1);
                return true
            }
            if (kdCode >= 34 && kdCode <= 40) return true;
            return false
        },
        processTrailing: function(parts) {
            var settingsClone = this.settingsClone;
            if (settingsClone.pSign === "p" && settingsClone.pNeg === "s")
                if (this.kdCode === 8) {
                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !==
                        "" ? true : false;
                    if (this.value.charAt(this.selection.start - 1) === "-") parts[0] = parts[0].substring(1);
                    else if (this.selection.start <= this.value.length - settingsClone.aSuffix.length) parts[0] = parts[0].substring(0, parts[0].length - 1)
                } else {
                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== "" ? true : false;
                    if (this.selection.start >= this.value.indexOf(settingsClone.aSign) + settingsClone.aSign.length) parts[1] = parts[1].substring(1, parts[1].length);
                    if (parts[0].indexOf("-") >
                        -1 && this.value.charAt(this.selection.start) === "-") parts[0] = parts[0].substring(1)
                }
            if (settingsClone.pSign === "s" && settingsClone.pNeg === "l") {
                settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length ? true : false;
                if (this.kdCode === 8)
                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length && this.value.indexOf(settingsClone.aNeg) !== -1) parts[0] = parts[0].substring(1);
                    else {
                        if (parts[0] !== "-" && (this.selection.start <= this.value.indexOf(settingsClone.aNeg) ||
                                this.value.indexOf(settingsClone.aNeg) === -1)) parts[0] = parts[0].substring(0, parts[0].length - 1)
                    } else {
                    if (parts[0][0] === "-") parts[1] = parts[1].substring(1);
                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) && this.value.indexOf(settingsClone.aNeg) !== -1) parts[0] = parts[0].substring(1)
                }
            }
            if (settingsClone.pSign === "s" && settingsClone.pNeg === "r") {
                settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length ? true : false;
                if (this.kdCode === 8)
                    if (this.selection.start ===
                        this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length) parts[0] = parts[0].substring(1);
                    else if (parts[0] !== "-" && this.selection.start <= this.value.indexOf(settingsClone.aNeg) - settingsClone.aSign.length) parts[0] = parts[0].substring(0, parts[0].length - 1);
                else {
                    if (parts[0] !== "" && this.value.indexOf(settingsClone.aNeg) === -1) parts[0] = parts[0].substring(0, parts[0].length - 1)
                } else {
                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aSign) && settingsClone.aSign !== "" ? true : false;
                    if (this.selection.start ===
                        this.value.indexOf(settingsClone.aNeg)) parts[0] = parts[0].substring(1);
                    parts[1] = parts[1].substring(1)
                }
            }
            return parts
        },
        processAllways: function() {
            var settingsClone = this.settingsClone,
                parts = [];
            if (this.kdCode === 8 || this.kdCode === 46) {
                if (!this.selection.length) {
                    parts = this.getBeforeAfterStriped();
                    if (parts[0] === "" && parts[1] === "") settingsClone.throwInput = false;
                    if ((settingsClone.pSign === "p" && settingsClone.pNeg === "s" || settingsClone.pSign === "s" && (settingsClone.pNeg === "l" || settingsClone.pNeg === "r")) && this.value.indexOf("-") !==
                        -1) parts = this.processTrailing(parts);
                    else if (this.kdCode === 8) parts[0] = parts[0].substring(0, parts[0].length - 1);
                    else parts[1] = parts[1].substring(1, parts[1].length);
                    this.setValueParts(parts[0], parts[1])
                } else {
                    this.expandSelectionOnSign(false);
                    parts = this.getBeforeAfterStriped();
                    this.setValueParts(parts[0], parts[1])
                }
                return true
            }
            return false
        },
        processKeypress: function() {
            var settingsClone = this.settingsClone,
                cCode = String.fromCharCode(this.which),
                parts = this.getBeforeAfterStriped(),
                left = parts[0],
                right = parts[1];
            settingsClone.throwInput = true;
            if (cCode === settingsClone.aDec || settingsClone.altDec && cCode === settingsClone.altDec || (cCode === "." || cCode === ",") && this.kdCode === 110) {
                if (!settingsClone.mDec || !settingsClone.aDec) return true;
                if (settingsClone.aNeg && right.indexOf(settingsClone.aNeg) > -1) return true;
                if (left.indexOf(settingsClone.aDec) > -1) return true;
                if (right.indexOf(settingsClone.aDec) > 0) return true;
                if (right.indexOf(settingsClone.aDec) === 0) right = right.substr(1);
                this.setValueParts(left + settingsClone.aDec, right,
                    null);
                return true
            }
            if ((cCode === "-" || cCode === "+") && settingsClone.aNeg === "-") {
                if (!settingsClone) return true;
                if (settingsClone.pSign === "p" && settingsClone.pNeg === "s" || settingsClone.pSign === "s" && settingsClone.pNeg !== "p") {
                    if (left === "" && right.indexOf(settingsClone.aNeg) > -1) {
                        left = settingsClone.aNeg;
                        right = right.substring(1, right.length)
                    }
                    if (left.charAt(0) === "-" || left.indexOf(settingsClone.aNeg) !== -1) left = left.substring(1, left.length);
                    else left = cCode === "-" ? settingsClone.aNeg + left : left
                } else {
                    if (left === "" && right.indexOf(settingsClone.aNeg) >
                        -1) {
                        left = settingsClone.aNeg;
                        right = right.substring(1, right.length)
                    }
                    if (left.charAt(0) === settingsClone.aNeg) left = left.substring(1, left.length);
                    else left = cCode === "-" ? settingsClone.aNeg + left : left
                }
                this.setValueParts(left, right, null);
                return true
            }
            if (cCode >= "0" && cCode <= "9") {
                if (settingsClone.aNeg && left === "" && right.indexOf(settingsClone.aNeg) > -1) {
                    left = settingsClone.aNeg;
                    right = right.substring(1, right.length)
                }
                if (settingsClone.vMax <= 0 && settingsClone.vMin < settingsClone.vMax && this.value.indexOf(settingsClone.aNeg) ===
                    -1 && cCode !== "0") left = settingsClone.aNeg + left;
                this.setValueParts(left + cCode, right, null);
                return true
            }
            settingsClone.throwInput = false;
            return true
        },
        formatQuick: function(e) {
            var settingsClone = this.settingsClone,
                parts = this.getBeforeAfterStriped(),
                leftLength = this.value,
                kuCode = e.keyCode;
            if ((settingsClone.aSep === "" || settingsClone.aSep !== "" && leftLength.indexOf(settingsClone.aSep) === -1) && (settingsClone.aSign === "" || settingsClone.aSign !== "" && leftLength.indexOf(settingsClone.aSign) === -1)) {
                var subParts = [],
                    nSign = "";
                subParts = leftLength.split(settingsClone.aDec);
                if (subParts[0].indexOf("-") > -1) {
                    nSign = "-";
                    subParts[0] = subParts[0].replace("-", "");
                    parts[0] = parts[0].replace("-", "")
                }
                if (nSign === "" && subParts[0].length > settingsClone.mIntPos && parts[0].charAt(0) === "0") parts[0] = parts[0].slice(1);
                if (nSign === "-" && subParts[0].length > settingsClone.mIntNeg && parts[0].charAt(0) === "0") parts[0] = parts[0].slice(1);
                parts[0] = nSign + parts[0]
            }
            var value = autoGroup(this.value, this.settingsClone);
            var position = value.length;
            if (value) {
                var left_ar =
                    parts[0].split(""),
                    i = 0;
                if ((settingsClone.pNeg === "s" || settingsClone.pSign === "s" && settingsClone.pNeg !== "p") && left_ar[0] === "-" && settingsClone.aNeg !== "") {
                    left_ar.shift();
                    if (settingsClone.pSign === "s" && settingsClone.pNeg === "l" && (kuCode === 8 || this.kdCode === 8 || kuCode === 46 || this.kdCode === 46) && settingsClone.caretFix) {
                        left_ar.push("-");
                        settingsClone.caretFix = e.type === "keydown" ? true : false
                    }
                    if (settingsClone.pSign === "p" && settingsClone.pNeg === "s" && (kuCode === 8 || this.kdCode === 8 || kuCode === 46 || this.kdCode === 46) && settingsClone.caretFix) {
                        left_ar.push("-");
                        settingsClone.caretFix = e.type === "keydown" ? true : false
                    }
                    if (settingsClone.pSign === "s" && settingsClone.pNeg === "r" && (kuCode === 8 || this.kdCode === 8 || kuCode === 46 || this.kdCode === 46) && settingsClone.caretFix) {
                        var signParts = settingsClone.aSign.split(""),
                            escapeChr = ["\\", "^", "$", ".", "|", "?", "*", "+", "(", ")", "["],
                            escapedParts = [],
                            escapedSign = "";
                        $.each(signParts, function(i, miniParts) {
                            miniParts = signParts[i];
                            if ($.inArray(miniParts, escapeChr) !== -1) escapedParts.push("\\" + miniParts);
                            else escapedParts.push(miniParts)
                        });
                        if (kuCode ===
                            8 || this.kdCode === 8) escapedParts.push("-");
                        escapedSign = escapedParts.join("");
                        left_ar.push(escapedSign);
                        settingsClone.caretFix = e.type === "keydown" ? true : false
                    }
                }
                for (i; i < left_ar.length; i += 1)
                    if (!left_ar[i].match("\\d")) left_ar[i] = "\\" + left_ar[i];
                var leftReg = new RegExp("^.*?" + left_ar.join(".*?")),
                    newLeft = value.match(leftReg);
                if (newLeft) {
                    position = newLeft[0].length;
                    if ((position === 0 && value.charAt(0) !== settingsClone.aNeg || position === 1 && value.charAt(0) === settingsClone.aNeg) && settingsClone.aSign && settingsClone.pSign ===
                        "p") position = this.settingsClone.aSign.length + (value.charAt(0) === "-" ? 1 : 0)
                } else {
                    if (settingsClone.aSign && settingsClone.pSign === "s") position -= settingsClone.aSign.length;
                    if (settingsClone.aSuffix) position -= settingsClone.aSuffix.length
                }
            }
            this.that.value = value;
            this.setPosition(position);
            this.formatted = true
        }
    };

    function autoGet(obj) {
        if (typeof obj === "string") {
            obj = obj.replace(/\[/g, "\\[").replace(/\]/g, "\\]");
            obj = "#" + obj.replace(/(:|\.)/g, "\\$1")
        }
        return $(obj)
    }

    function getHolder($that, settings, update) {
        var data =
            $that.data("autoNumeric");
        if (!data) {
            data = {};
            $that.data("autoNumeric", data)
        }
        var holder = data.holder;
        if (holder === undefined && settings || update) {
            holder = new AutoNumericHolder($that.get(0), settings);
            data.holder = holder
        }
        return holder
    }

    function originalSettings(settings) {
        settings.oDec = settings.mDec;
        settings.oPad = settings.aPad;
        settings.oBracket = settings.nBracket;
        settings.oSep = settings.aSep;
        settings.oSign = settings.aSign;
        return settings
    }

    function readCookie(name) {
        var nameEQ = name + "=",
            ca = document.cookie.split(";"),
            i = 0,
            c = "";
        for (i; i < ca.length; i += 1) {
            c = ca[i];
            while (c.charAt(0) === " ") c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length)
        }
        return null
    }

    function storageTest() {
        var mod = "modernizr";
        try {
            sessionStorage.setItem(mod, mod);
            sessionStorage.removeItem(mod);
            return true
        } catch (e) {
            return false
        }
    }

    function autoSave($this, settings, toDo) {
        if (settings.aStor) {
            var storedName = $this[0].name !== "" && $this[0].name !== undefined ? "AUTO_" + decodeURIComponent($this[0].name) : "AUTO_" + $this[0].id;
            if (storageTest() ===
                false) {
                if (toDo === "get") return readCookie(storedName);
                if (toDo === "set") document.cookie = storedName + "=" + settings.rawValue + "; expires= ; path=/";
                if (toDo === "wipe") {
                    var date = new Date;
                    date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1E3);
                    var expires = "; expires=" + date.toGMTString();
                    document.cookie = storedName + '="" ;' + expires + "; path=/"
                }
            } else {
                if (toDo === "get") return sessionStorage.getItem(storedName);
                if (toDo === "set") sessionStorage.setItem(storedName, settings.rawValue);
                if (toDo === "wipe") sessionStorage.removeItem(storedName)
            }
        }
        return
    }
    var methods = {
        init: function(options) {
            return this.each(function() {
                var $this = $(this),
                    settings = $this.data("autoNumeric"),
                    tagData = $this.data(),
                    $input = $this.is("input[type=text], input[type=hidden], input[type=tel], input:not([type])");
                $.each(tagData, function(key, value) {
                    if (typeof value === "number") tagData[key] = value.toString()
                });
                if (typeof settings !== "object") {
                    settings = $.extend({}, $.fn.autoNumeric.defaults, tagData, options, {
                        aNum: "0123456789",
                        onOff: false,
                        runOnce: false,
                        rawValue: "",
                        trailingNegative: false,
                        caretFix: false,
                        throwInput: true,
                        tagList: ["b", "caption", "cite", "code", "dd", "del", "div", "dfn", "dt", "em", "h1", "h2", "h3", "h4", "h5", "h6", "ins", "kdb", "label", "li", "option", "output", "p", "q", "s", "sample", "span", "strong", "td", "th", "u", "var"]
                    });
                    if (settings.aDec === settings.aSep) throwErr('autoNumeric will not function properly when the decimal character aDec: "' + settings.aDec + '" and thousand separator aSep: "' + settings.aSep + '" are the same character', settings.debug);
                    $.each(settings, function(key, value) {
                        if (value === "true" || value ===
                            "false") settings[key] = value === "true" ? true : false
                    });
                    $this.data("autoNumeric", settings)
                } else return this;
                settings = originalSettings(settings);
                var holder = getHolder($this, settings);
                if (!$input && $this.prop("tagName").toLowerCase() === "input") throwErr('The input type "' + $this.prop("type") + '" is not supported by autoNumeric()', settings.debug);
                if ($.inArray($this.prop("tagName").toLowerCase(), settings.tagList) === -1 && $this.prop("tagName").toLowerCase() !== "input") throwErr('The "<' + $this.prop("tagName").toLowerCase() +
                    '>" is not supported by autoNumeric()', settings.debug);
                if (settings.aDec === settings.aSep) throwErr('autoNumeric will not function properly when the decimal character aDec: "' + settings.aDec + '" and thousand separator aSep: "' + settings.aSep + '" are the same character', settings.debug);
                if (settings.eDec < settings.mDec && settings.eDec !== null) throwErr('autoNumeric will not function properly when the extended decimal places "eDec: ' + settings.eDec + '" is greater than mDec: "' + settings.mDec + '" value', settings.debug);
                if (settings.runOnce === false && settings.aForm) {
                    var setValue = true;
                    if ($input) {
                        if (settings.anDefault !== null && settings.anDefault.toString() !== $this.val() || settings.anDefault === null && $this.val() !== "" && $this.val() !== $this.attr("value") || $this.val() !== "" && $this.attr("type") === "hidden" && !$.isNumeric($this.val().replace(",", "."))) {
                            if (settings.eDec !== null && settings.aStor) settings.rawValue = autoSave($this, settings, "get");
                            if (!settings.aStor) {
                                var toStrip = "";
                                if (settings.nBracket !== null && settings.aNeg !== "") {
                                    settings.onOff =
                                        true;
                                    toStrip = negativeBracket($this.val(), settings)
                                } else toStrip = $this.val();
                                settings.rawValue = (settings.pNeg === "s" || settings.pSign === "s" && settings.pNeg !== "p") && settings.aNeg !== "" && $this.val().indexOf("-") > -1 ? "-" + autoStrip(toStrip, settings) : autoStrip(toStrip, settings)
                            }
                            setValue = false
                        }
                        if ($this.val() === "" && settings.wEmpty === "focus") setValue = false;
                        if ($this.val() === "" && settings.wEmpty === "always") {
                            $this.val(settings.aSign);
                            setValue = false
                        }
                        if (setValue && $this.val() !== "" && $this.val() === $this.attr("value")) $this.autoNumeric("set",
                            $this.val())
                    }
                    if ($.inArray($this.prop("tagName").toLowerCase(), settings.tagList) !== -1 && $this.text() !== "")
                        if (settings.anDefault !== null) {
                            if (settings.anDefault === $this.text()) $this.autoNumeric("set", $this.text())
                        } else $this.autoNumeric("set", $this.text())
                }
                settings.runOnce = true;
                if ($input) {
                    $this.on("focusin.autoNumeric", function() {
                        holder = getHolder($this);
                        var $settings = holder.settingsClone;
                        $settings.onOff = true;
                        if ($settings.nBracket !== null && $settings.aNeg !== "") $this.val(negativeBracket($this.val(), $settings));
                        if ($settings.nSep === true) {
                            $settings.aSep = "";
                            $settings.aSign = ""
                        }
                        if ($settings.eDec !== null) {
                            $settings.mDec = $settings.eDec;
                            $this.autoNumeric("set", $settings.rawValue)
                        } else $this.autoNumeric("set", $settings.rawValue);
                        holder.inVal = $this.val();
                        holder.lastVal = $this.val();
                        var onEmpty = checkEmpty(holder.inVal, $settings, true);
                        if (onEmpty !== null && onEmpty !== "" && $settings.wEmpty === "focus") $this.val(onEmpty)
                    });
                    $this.on("keydown.autoNumeric", function(e) {
                        holder = getHolder($this);
                        if (holder.that.readOnly) {
                            holder.processed =
                                true;
                            return true
                        }
                        holder.init(e);
                        if (holder.skipAllways(e)) {
                            holder.processed = true;
                            return true
                        }
                        if (holder.processAllways()) {
                            holder.processed = true;
                            holder.formatQuick(e);
                            if ($this.val() !== holder.lastVal && holder.settingsClone.throwInput) $this.trigger("input");
                            holder.lastVal = $this.val();
                            holder.settingsClone.throwInput = true;
                            e.preventDefault();
                            return false
                        }
                        holder.formatted = false;
                        return true
                    });
                    $this.on("keypress.autoNumeric", function(e) {
                        if (e.shiftKey && e.keyCode === 45) return;
                        holder = getHolder($this);
                        var processed =
                            holder.processed;
                        holder.init(e);
                        if (holder.skipAllways(e)) return true;
                        if (processed) {
                            e.preventDefault();
                            return false
                        }
                        if (holder.processAllways() || holder.processKeypress()) {
                            holder.formatQuick(e);
                            if ($this.val() !== holder.lastVal && holder.settingsClone.throwInput) $this.trigger("input");
                            holder.lastVal = $this.val();
                            holder.settingsClone.throwInput = true;
                            e.preventDefault();
                            return
                        }
                        holder.formatted = false
                    });
                    $this.on("keyup.autoNumeric", function(e) {
                        holder = getHolder($this);
                        holder.init(e);
                        var skip = holder.skipAllways(e);
                        holder.kdCode = 0;
                        delete holder.valuePartsBeforePaste;
                        if ($this[0].value === holder.settingsClone.aSign)
                            if (holder.settingsClone.pSign === "s") setElementSelection(this, 0, 0);
                            else setElementSelection(this, holder.settingsClone.aSign.length, holder.settingsClone.aSign.length);
                        if ($this[0].value === holder.settingsClone.aSuffix) setElementSelection(this, 0, 0);
                        if (holder.settingsClone.rawValue === "" && holder.settingsClone.aSign !== "" && holder.settingsClone.aSuffix !== "") setElementSelection(this, 0, 0);
                        if (holder.settingsClone.eDec !==
                            null && holder.settingsClone.aStor) autoSave($this, settings, "set");
                        if (skip) return true;
                        if (this.value === "") return true;
                        if (!holder.formatted) holder.formatQuick(e)
                    });
                    $this.on("focusout.autoNumeric", function() {
                        holder = getHolder($this);
                        var value = $this.val(),
                            origValue = value,
                            $settings = holder.settingsClone;
                        $settings.onOff = false;
                        if ($settings.aStor) autoSave($this, $settings, "set");
                        if ($settings.nSep === true) {
                            $settings.aSep = $settings.oSep;
                            $settings.aSign = $settings.oSign
                        }
                        if ($settings.eDec !== null) {
                            $settings.mDec = $settings.oDec;
                            $settings.aPad = $settings.oPad;
                            $settings.nBracket = $settings.oBracket
                        }
                        if (value !== "") {
                            value = autoStrip(value, $settings);
                            if ($settings.trailingNegative) {
                                value = "-" + value;
                                $settings.trailingNegative = false
                            }
                            if (checkEmpty(value, $settings) === null && autoCheck(value, $settings, $this[0])) {
                                value = fixNumber(value, $settings.aDec, $settings.aNeg);
                                $settings.rawValue = value;
                                value = autoRound(value, $settings);
                                value = presentNumber(value, $settings.aDec, $settings.aNeg)
                            } else value = $settings.rawValue
                        } else $settings.rawValue = "";
                        var groupedValue =
                            checkEmpty(value, $settings, false);
                        if (groupedValue === null) groupedValue = autoGroup(value, $settings);
                        if (groupedValue !== origValue) $this.val(groupedValue);
                        if (groupedValue !== holder.inVal) {
                            $this.change();
                            delete holder.inVal
                        }
                    });
                    $this.closest("form").on("submit.autoNumeric", function() {
                        holder = getHolder($this);
                        if (holder) {
                            var $settings = holder.settingsClone;
                            if ($settings.unSetOnSubmit) $this.val($settings.rawValue)
                        }
                    })
                }
            })
        },
        destroy: function() {
            return $(this).each(function() {
                var $this = autoGet($(this)),
                    settings = $this.data("autoNumeric");
                if (typeof settings === "object") {
                    $this.val("");
                    autoSave($this, settings, "wipe");
                    $this.removeData("autoNumeric");
                    $this.off("autoNumeric")
                }
            })
        },
        wipe: function() {
            return $(this).each(function() {
                var $this = autoGet($(this)),
                    settings = $this.data("autoNumeric");
                if (typeof settings === "object") {
                    $this.val("");
                    settings.rawValue = "";
                    autoSave($this, settings, "wipe")
                }
            })
        },
        update: function(options) {
            return $(this).each(function() {
                var $this = autoGet($(this)),
                    settings = $this.data("autoNumeric");
                if (typeof settings !== "object") throwErr('Initializing autoNumeric is required prior to calling the "update" method',
                    true);
                var strip = $this.autoNumeric("get");
                settings = $.extend(settings, options);
                settings = originalSettings(settings);
                getHolder($this, settings, true);
                if (settings.aDec === settings.aSep) throwErr('autoNumeric will not function properly when the decimal character aDec: "' + settings.aDec + '" and thousand separator aSep: "' + settings.aSep + '" are the same character', settings.debug);
                $this.data("autoNumeric", settings);
                if ($this.val() !== "" || $this.text() !== "") return $this.autoNumeric("set", strip);
                return
            })
        },
        set: function(valueIn) {
            return $(this).each(function() {
                if (valueIn ===
                    null || isNaN(valueIn)) return;
                var $this = autoGet($(this)),
                    settings = $this.data("autoNumeric"),
                    value = valueIn.toString(),
                    $input = $this.is("input[type=text], input[type=hidden], input[type=tel], input:not([type])");
                if (typeof settings !== "object") throwErr('Initializing autoNumeric is required prior to calling the "set" method', true);
                value = convertLocale(value);
                if (!$.isNumeric(Number(value))) throwErr('The value "' + value + '" being "set" is not numeric and has caused a error to be thrown', settings.debug);
                if (value !==
                    "")
                    if (autoCheck(value, settings)) {
                        if ($input && settings.eDec !== null) settings.rawValue = value;
                        if ($input || $.inArray($this.prop("tagName").toLowerCase(), settings.tagList) !== -1) {
                            value = autoRound(value, settings);
                            if (settings.eDec === null) settings.rawValue = value;
                            value = presentNumber(value, settings.aDec, settings.aNeg);
                            value = autoGroup(value, settings)
                        }
                        if (settings.aStor && settings.eDec !== null) autoSave($this, settings, "set")
                    } else {
                        settings.rawValue = "";
                        autoSave($this, settings, "wipe");
                        value = "";
                        throwErr('The value being set falls outside the min: "' +
                            settings.vMin + ' max: "' + settings.vMax + '" ) settings for this element', settings.debug);
                        return ""
                    } else return "";
                if ($input) return $this.val(value);
                if ($.inArray($this.prop("tagName").toLowerCase(), settings.tagList) !== -1) return $this.text(value);
                return false
            })
        },
        unSet: function(outPut) {
            return $(this).each(function() {
                var $this = autoGet($(this)),
                    settings = $this.data("autoNumeric");
                if (typeof settings === "object") {
                    settings.onOff = true;
                    $this.val($this.autoNumeric("get", outPut))
                }
            })
        },
        reSet: function() {
            return $(this).each(function() {
                var $this =
                    autoGet($(this)),
                    settings = $this.data("autoNumeric");
                if (typeof settings === "object") $this.autoNumeric("set", $this.val())
            })
        },
        get: function(outPut) {
            var $this = autoGet($(this)),
                settings = $this.data("autoNumeric"),
                $input = $this.is("input[type=text], input[type=hidden], input[type=tel], input:not([type])");
            if (typeof settings !== "object") throwErr('Initializing autoNumeric is required prior to calling the "get" method', true);
            var getValue = "";
            if ($input) getValue = $this.eq(0).val();
            else if ($.inArray($this.prop("tagName").toLowerCase(),
                    settings.tagList) !== -1) getValue = $this.eq(0).text();
            else throwErr('The "<' + $this.prop("tagName").toLowerCase() + '>" is not supported by autoNumeric()', settings.debug);
            if (settings.rawValue !== "") getValue = settings.rawValue;
            if (!(/\d/.test(getValue) || Number(getValue) === 0) && settings.wEmpty === "focus") return "";
            if (getValue !== "" && settings.nBracket !== null) {
                settings.onOff = true;
                getValue = negativeBracket(getValue, settings)
            }
            getValue = fixNumber(getValue, settings.aDec, settings.aNeg);
            if (Number(getValue) === 0 && settings.lZero !==
                "keep") getValue = "0";
            if (outPut === ",") getValue = getValue.replace(".", ",");
            if (outPut === ".-" && getValue.indexOf("-") > -1) getValue = getValue.replace("-", "") + "-";
            if (outPut === ",-" && getValue.indexOf("-") > -1) getValue = getValue.replace(".", ",").replace("-", "") + "-";
            return getValue
        },
        getString: function(outPut) {
            var $this = autoGet($(this)),
                formFields = $this.serialize(),
                formParts = formFields.split("&"),
                formIndex = $("form").index($this),
                allFormElements = $("form:eq(" + formIndex + ")"),
                aiIndex = [],
                scIndex = [],
                rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
                rsubmittable = /^(?:input|select|textarea|keygen)/i,
                rcheckableType = /^(?:checkbox|radio)$/i,
                rnonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i,
                count = 0;
            $.each(allFormElements[0], function(i, field) {
                if (field.name !== "" && rsubmittable.test(field.localName) && !rsubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rcheckableType.test(field.type))) {
                    scIndex.push(count);
                    count = count + 1
                } else scIndex.push(-1)
            });
            count = 0;
            $.each(allFormElements[0], function(i, field) {
                if (field.localName === "input" && (field.type === "" || field.type === "text" || field.type === "hidden" || field.type === "tel")) {
                    aiIndex.push(count);
                    count = count + 1
                } else {
                    aiIndex.push(-1);
                    if (field.localName === "input" && rnonAutoNumericTypes.test(field.type)) count = count + 1
                }
            });
            $.each(formParts, function(i, miniParts) {
                miniParts = formParts[i].split("=");
                var scElement = $.inArray(i, scIndex);
                if (scElement > -1 && aiIndex[scElement] > -1) {
                    var testInput = $("form:eq(" + formIndex + ") input:eq(" +
                            aiIndex[scElement] + ")"),
                        settings = testInput.data("autoNumeric");
                    if (typeof settings === "object")
                        if (miniParts[1] !== null) {
                            miniParts[1] = $("form:eq(" + formIndex + ") input:eq(" + aiIndex[scElement] + ")").autoNumeric("get", outPut).toString();
                            formParts[i] = miniParts.join("=")
                        }
                }
            });
            return formParts.join("&")
        },
        getArray: function(outPut) {
            var $this = autoGet($(this)),
                formFields = $this.serializeArray(),
                formIndex = $("form").index($this),
                allFormElements = $("form:eq(" + formIndex + ")"),
                aiIndex = [],
                scIndex = [],
                rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
                rsubmittable = /^(?:input|select|textarea|keygen)/i,
                rcheckableType = /^(?:checkbox|radio)$/i,
                rnonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i,
                count = 0;
            $.each(allFormElements[0], function(i, field) {
                if (field.name !== "" && rsubmittable.test(field.localName) && !rsubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rcheckableType.test(field.type))) {
                    scIndex.push(count);
                    count = count + 1
                } else scIndex.push(-1)
            });
            count = 0;
            $.each(allFormElements[0], function(i, field) {
                if (field.localName === "input" && (field.type === "" || field.type === "text" || field.type === "hidden" || field.type === "tel")) {
                    aiIndex.push(count);
                    count = count + 1
                } else {
                    aiIndex.push(-1);
                    if (field.localName === "input" && rnonAutoNumericTypes.test(field.type)) count = count + 1
                }
            });
            $.each(formFields, function(i, field) {
                var scElement = $.inArray(i, scIndex);
                if (scElement > -1 && aiIndex[scElement] > -1) {
                    var testInput = $("form:eq(" + formIndex + ") input:eq(" + aiIndex[scElement] + ")"),
                        settings =
                        testInput.data("autoNumeric");
                    if (typeof settings === "object") field.value = $("form:eq(" + formIndex + ") input:eq(" + aiIndex[scElement] + ")").autoNumeric("get", outPut).toString()
                }
            });
            return formFields
        },
        getSettings: function() {
            var $this = autoGet($(this));
            return $this.eq(0).data("autoNumeric")
        }
    };
    $.fn.autoNumeric = function(method) {
        if (methods[method]) return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        if (typeof method === "object" || !method) return methods.init.apply(this, arguments);
        throwErr('Method "' +
            method + '" is not supported by autoNumeric()', true)
    };
    $.fn.autoNumeric.defaults = {
        aSep: ",",
        nSep: false,
        dGroup: "3",
        aDec: ".",
        altDec: null,
        aSign: "",
        pSign: "p",
        pNeg: "l",
        aSuffix: "",
        vMax: "9999999999999.99",
        vMin: "-9999999999999.99",
        mDec: null,
        eDec: null,
        aStor: false,
        mRound: "S",
        aPad: true,
        nBracket: null,
        wEmpty: "focus",
        lZero: "allow",
        aForm: true,
        sNumber: false,
        anDefault: null,
        unSetOnSubmit: false,
        debug: true
    }
});
(function(root, factory) {
    if (typeof define === "function" && define.amd) define(["exports"], factory);
    else if (typeof exports !== "undefined") factory(exports);
    else factory(root.esprima = {})
})(this, function(exports) {
    var Token, TokenName, FnExprTokens, Syntax, PlaceHolders, Messages, Regex, source, strict, index, lineNumber, lineStart, hasLineTerminator, lastIndex, lastLineNumber, lastLineStart, startIndex, startLineNumber, startLineStart, scanning, length, lookahead, state, extra, isBindingElement, isAssignmentTarget, firstCoverInitializedNameError;
    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9,
        Template: 10
    };
    TokenName = {};
    TokenName[Token.BooleanLiteral] = "Boolean";
    TokenName[Token.EOF] = "<end>";
    TokenName[Token.Identifier] = "Identifier";
    TokenName[Token.Keyword] = "Keyword";
    TokenName[Token.NullLiteral] = "Null";
    TokenName[Token.NumericLiteral] = "Numeric";
    TokenName[Token.Punctuator] = "Punctuator";
    TokenName[Token.StringLiteral] = "String";
    TokenName[Token.RegularExpression] = "RegularExpression";
    TokenName[Token.Template] = "Template";
    FnExprTokens = ["(", "{", "[", "in", "typeof", "instanceof", "new", "return", "case", "delete", "throw", "void", "=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "|=", "^=", ",", "+", "-", "*", "/", "%", "++", "--", "<<", ">>", ">>>", "&", "|", "^", "!", "~", "&&", "||", "?", ":", "===", "==", ">=", "<=", "<", ">", "!=", "!=="];
    Syntax = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DoWhileStatement: "DoWhileStatement",
        DebuggerStatement: "DebuggerStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForOfStatement: "ForOfStatement",
        ForInStatement: "ForInStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MetaProperty: "MetaProperty",
        MethodDefinition: "MethodDefinition",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        Program: "Program",
        Property: "Property",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        Super: "Super",
        SwitchCase: "SwitchCase",
        SwitchStatement: "SwitchStatement",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
    };
    PlaceHolders = {
        ArrowParameterPlaceHolder: "ArrowParameterPlaceHolder"
    };
    Messages = {
        UnexpectedToken: "Unexpected token %0",
        UnexpectedNumber: "Unexpected number",
        UnexpectedString: "Unexpected string",
        UnexpectedIdentifier: "Unexpected identifier",
        UnexpectedReserved: "Unexpected reserved word",
        UnexpectedTemplate: "Unexpected quasi %0",
        UnexpectedEOS: "Unexpected end of input",
        NewlineAfterThrow: "Illegal newline after throw",
        InvalidRegExp: "Invalid regular expression",
        UnterminatedRegExp: "Invalid regular expression: missing /",
        InvalidLHSInAssignment: "Invalid left-hand side in assignment",
        InvalidLHSInForIn: "Invalid left-hand side in for-in",
        InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
        MultipleDefaultsInSwitch: "More than one default clause in switch statement",
        NoCatchOrFinally: "Missing catch or finally after try",
        UnknownLabel: "Undefined label '%0'",
        Redeclaration: "%0 '%1' has already been declared",
        IllegalContinue: "Illegal continue statement",
        IllegalBreak: "Illegal break statement",
        IllegalReturn: "Illegal return statement",
        StrictModeWith: "Strict mode code may not include a with statement",
        StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
        StrictVarName: "Variable name may not be eval or arguments in strict mode",
        StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
        StrictParamDupe: "Strict mode function may not have duplicate parameter names",
        StrictFunctionName: "Function name may not be eval or arguments in strict mode",
        StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
        StrictDelete: "Delete of an unqualified identifier in strict mode.",
        StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
        StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
        StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
        StrictReservedWord: "Use of future reserved word in strict mode",
        TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
        ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
        DefaultRestParameter: "Unexpected token =",
        ObjectPatternAsRestParameter: "Unexpected token {",
        DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
        ConstructorSpecialMethod: "Class constructor may not be an accessor",
        DuplicateConstructor: "A class may only have one constructor",
        StaticPrototype: "Classes may not have static property named prototype",
        MissingFromClause: "Unexpected token",
        NoAsAfterImportNamespace: "Unexpected token",
        InvalidModuleSpecifier: "Unexpected token",
        IllegalImportDeclaration: "Unexpected token",
        IllegalExportDeclaration: "Unexpected token",
        DuplicateBinding: "Duplicate binding %0"
    };
    Regex = {
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    function assert(condition, message) {
        if (!condition) throw new Error("ASSERT: " + message);
    }

    function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57
    }

    function isHexDigit(ch) {
        return "0123456789abcdefABCDEF".indexOf(ch) >= 0
    }

    function isOctalDigit(ch) {
        return "01234567".indexOf(ch) >= 0
    }

    function octalToDecimal(ch) {
        var octal = ch !== "0",
            code = "01234567".indexOf(ch);
        if (index < length && isOctalDigit(source[index])) {
            octal = true;
            code = code * 8 + "01234567".indexOf(source[index++]);
            if ("0123".indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) code =
                code * 8 + "01234567".indexOf(source[index++])
        }
        return {
            code: code,
            octal: octal
        }
    }

    function isWhiteSpace(ch) {
        return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(ch) >= 0
    }

    function isLineTerminator(ch) {
        return ch === 10 || ch === 13 || ch === 8232 || ch === 8233
    }

    function fromCodePoint(cp) {
        return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023))
    }

    function isIdentifierStart(ch) {
        return ch ===
            36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch))
    }

    function isIdentifierPart(ch) {
        return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 48 && ch <= 57 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch))
    }

    function isFutureReservedWord(id) {
        switch (id) {
            case "enum":
            case "export":
            case "import":
            case "super":
                return true;
            default:
                return false
        }
    }

    function isStrictModeReservedWord(id) {
        switch (id) {
            case "implements":
            case "interface":
            case "package":
            case "private":
            case "protected":
            case "public":
            case "static":
            case "yield":
            case "let":
                return true;
            default:
                return false
        }
    }

    function isRestrictedWord(id) {
        return id === "eval" || id === "arguments"
    }

    function isKeyword(id) {
        switch (id.length) {
            case 2:
                return id === "if" || id === "in" || id === "do";
            case 3:
                return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
            case 4:
                return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
            case 5:
                return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
            case 6:
                return id === "return" || id === "typeof" ||
                    id === "delete" || id === "switch" || id === "export" || id === "import";
            case 7:
                return id === "default" || id === "finally" || id === "extends";
            case 8:
                return id === "function" || id === "continue" || id === "debugger";
            case 10:
                return id === "instanceof";
            default:
                return false
        }
    }

    function addComment(type, value, start, end, loc) {
        var comment;
        assert(typeof start === "number", "Comment must have valid position");
        state.lastCommentStart = start;
        comment = {
            type: type,
            value: value
        };
        if (extra.range) comment.range = [start, end];
        if (extra.loc) comment.loc = loc;
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment)
        }
        if (extra.tokenize) {
            comment.type = comment.type + "Comment";
            if (extra.delegate) comment = extra.delegate(comment);
            extra.tokens.push(comment)
        }
    }

    function skipSingleLineComment(offset) {
        var start, loc, ch, comment;
        start = index - offset;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - offset
            }
        };
        while (index < length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                hasLineTerminator = true;
                if (extra.comments) {
                    comment =
                        source.slice(start + offset, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment("Line", comment, start, index - 1, loc)
                }
                if (ch === 13 && source.charCodeAt(index) === 10) ++index;
                ++lineNumber;
                lineStart = index;
                return
            }
        }
        if (extra.comments) {
            comment = source.slice(start + offset, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment("Line", comment, start, index, loc)
        }
    }

    function skipMultiLineComment() {
        var start, loc, ch, comment;
        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index -
                        lineStart - 2
                }
            }
        }
        while (index < length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 13 && source.charCodeAt(index + 1) === 10) ++index;
                hasLineTerminator = true;
                ++lineNumber;
                ++index;
                lineStart = index
            } else if (ch === 42) {
                if (source.charCodeAt(index + 1) === 47) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment("Block", comment, start, index, loc)
                    }
                    return
                }++index
            } else ++index
        }
        if (extra.comments) {
            loc.end = {
                line: lineNumber,
                column: index -
                    lineStart
            };
            comment = source.slice(start + 2, index);
            addComment("Block", comment, start, index, loc)
        }
        tolerateUnexpectedToken()
    }

    function skipComment() {
        var ch, start;
        hasLineTerminator = false;
        start = index === 0;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (isWhiteSpace(ch)) ++index;
            else if (isLineTerminator(ch)) {
                hasLineTerminator = true;
                ++index;
                if (ch === 13 && source.charCodeAt(index) === 10) ++index;
                ++lineNumber;
                lineStart = index;
                start = true
            } else if (ch === 47) {
                ch = source.charCodeAt(index + 1);
                if (ch === 47) {
                    ++index;
                    ++index;
                    skipSingleLineComment(2);
                    start = true
                } else if (ch === 42) {
                    ++index;
                    ++index;
                    skipMultiLineComment()
                } else break
            } else if (start && ch === 45)
                if (source.charCodeAt(index + 1) === 45 && source.charCodeAt(index + 2) === 62) {
                    index += 3;
                    skipSingleLineComment(3)
                } else break;
            else if (ch === 60)
                if (source.slice(index + 1, index + 4) === "!--") {
                    ++index;
                    ++index;
                    ++index;
                    ++index;
                    skipSingleLineComment(4)
                } else break;
            else break
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;
        len = prefix === "u" ? 4 : 2;
        for (i = 0; i < len; ++i)
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + "0123456789abcdef".indexOf(ch.toLowerCase())
            } else return "";
        return String.fromCharCode(code)
    }

    function scanUnicodeCodePointEscape() {
        var ch, code;
        ch = source[index];
        code = 0;
        if (ch === "}") throwUnexpectedToken();
        while (index < length) {
            ch = source[index++];
            if (!isHexDigit(ch)) break;
            code = code * 16 + "0123456789abcdef".indexOf(ch.toLowerCase())
        }
        if (code > 1114111 || ch !== "}") throwUnexpectedToken();
        return fromCodePoint(code)
    }

    function codePointAt(i) {
        var cp, first, second;
        cp = source.charCodeAt(i);
        if (cp >= 55296 && cp <= 56319) {
            second =
                source.charCodeAt(i + 1);
            if (second >= 56320 && second <= 57343) {
                first = cp;
                cp = (first - 55296) * 1024 + second - 56320 + 65536
            }
        }
        return cp
    }

    function getComplexIdentifier() {
        var cp, ch, id;
        cp = codePointAt(index);
        id = fromCodePoint(cp);
        index += id.length;
        if (cp === 92) {
            if (source.charCodeAt(index) !== 117) throwUnexpectedToken();
            ++index;
            if (source[index] === "{") {
                ++index;
                ch = scanUnicodeCodePointEscape()
            } else {
                ch = scanHexEscape("u");
                cp = ch.charCodeAt(0);
                if (!ch || ch === "\\" || !isIdentifierStart(cp)) throwUnexpectedToken()
            }
            id = ch
        }
        while (index < length) {
            cp =
                codePointAt(index);
            if (!isIdentifierPart(cp)) break;
            ch = fromCodePoint(cp);
            id += ch;
            index += ch.length;
            if (cp === 92) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 117) throwUnexpectedToken();
                ++index;
                if (source[index] === "{") {
                    ++index;
                    ch = scanUnicodeCodePointEscape()
                } else {
                    ch = scanHexEscape("u");
                    cp = ch.charCodeAt(0);
                    if (!ch || ch === "\\" || !isIdentifierPart(cp)) throwUnexpectedToken()
                }
                id += ch
            }
        }
        return id
    }

    function getIdentifier() {
        var start, ch;
        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch ===
                92) {
                index = start;
                return getComplexIdentifier()
            } else if (ch >= 55296 && ch < 57343) {
                index = start;
                return getComplexIdentifier()
            }
            if (isIdentifierPart(ch)) ++index;
            else break
        }
        return source.slice(start, index)
    }

    function scanIdentifier() {
        var start, id, type;
        start = index;
        id = source.charCodeAt(index) === 92 ? getComplexIdentifier() : getIdentifier();
        if (id.length === 1) type = Token.Identifier;
        else if (isKeyword(id)) type = Token.Keyword;
        else if (id === "null") type = Token.NullLiteral;
        else if (id === "true" || id === "false") type = Token.BooleanLiteral;
        else type = Token.Identifier;
        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        }
    }

    function scanPunctuator() {
        var token, str;
        token = {
            type: Token.Punctuator,
            value: "",
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: index,
            end: index
        };
        str = source[index];
        switch (str) {
            case "(":
                if (extra.tokenize) extra.openParenToken = extra.tokenValues.length;
                ++index;
                break;
            case "{":
                if (extra.tokenize) extra.openCurlyToken = extra.tokenValues.length;
                state.curlyStack.push("{");
                ++index;
                break;
            case ".":
                ++index;
                if (source[index] === "." && source[index + 1] === ".") {
                    index += 2;
                    str = "..."
                }
                break;
            case "}":
                ++index;
                state.curlyStack.pop();
                break;
            case ")":
            case ";":
            case ",":
            case "[":
            case "]":
            case ":":
            case "?":
            case "~":
                ++index;
                break;
            default:
                str = source.substr(index, 4);
                if (str === ">>>=") index += 4;
                else {
                    str = str.substr(0, 3);
                    if (str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=") index += 3;
                    else {
                        str = str.substr(0, 2);
                        if (str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" ||
                            str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>") index += 2;
                        else {
                            str = source[index];
                            if ("<>=!+-*%&|^/".indexOf(str) >= 0) ++index
                        }
                    }
                }
        }
        if (index === token.start) throwUnexpectedToken();
        token.end = index;
        token.value = str;
        return token
    }

    function scanHexLiteral(start) {
        var number = "";
        while (index < length) {
            if (!isHexDigit(source[index])) break;
            number += source[index++]
        }
        if (number.length === 0) throwUnexpectedToken();
        if (isIdentifierStart(source.charCodeAt(index))) throwUnexpectedToken();
        return {
            type: Token.NumericLiteral,
            value: parseInt("0x" + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        }
    }

    function scanBinaryLiteral(start) {
        var ch, number;
        number = "";
        while (index < length) {
            ch = source[index];
            if (ch !== "0" && ch !== "1") break;
            number += source[index++]
        }
        if (number.length === 0) throwUnexpectedToken();
        if (index < length) {
            ch = source.charCodeAt(index);
            if (isIdentifierStart(ch) || isDecimalDigit(ch)) throwUnexpectedToken()
        }
        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 2),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        }
    }

    function scanOctalLiteral(prefix, start) {
        var number, octal;
        if (isOctalDigit(prefix)) {
            octal = true;
            number = "0" + source[index++]
        } else {
            octal = false;
            ++index;
            number = ""
        }
        while (index < length) {
            if (!isOctalDigit(source[index])) break;
            number += source[index++]
        }
        if (!octal && number.length === 0) throwUnexpectedToken();
        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) throwUnexpectedToken();
        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        }
    }

    function isImplicitOctalLiteral() {
        var i, ch;
        for (i = index + 1; i < length; ++i) {
            ch = source[i];
            if (ch === "8" || ch === "9") return false;
            if (!isOctalDigit(ch)) return true
        }
        return true
    }

    function scanNumericLiteral() {
        var number, start, ch;
        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
        start = index;
        number = "";
        if (ch !== ".") {
            number = source[index++];
            ch = source[index];
            if (number === "0") {
                if (ch === "x" || ch === "X") {
                    ++index;
                    return scanHexLiteral(start)
                }
                if (ch === "b" || ch === "B") {
                    ++index;
                    return scanBinaryLiteral(start)
                }
                if (ch === "o" || ch === "O") return scanOctalLiteral(ch, start);
                if (isOctalDigit(ch))
                    if (isImplicitOctalLiteral()) return scanOctalLiteral(ch, start)
            }
            while (isDecimalDigit(source.charCodeAt(index))) number += source[index++];
            ch = source[index]
        }
        if (ch === ".") {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) number += source[index++];
            ch = source[index]
        }
        if (ch === "e" ||
            ch === "E") {
            number += source[index++];
            ch = source[index];
            if (ch === "+" || ch === "-") number += source[index++];
            if (isDecimalDigit(source.charCodeAt(index)))
                while (isDecimalDigit(source.charCodeAt(index))) number += source[index++];
            else throwUnexpectedToken()
        }
        if (isIdentifierStart(source.charCodeAt(index))) throwUnexpectedToken();
        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        }
    }

    function scanStringLiteral() {
        var str = "",
            quote, start, ch, unescaped, octToDec,
            octal = false;
        quote = source[index];
        assert(quote === "'" || quote === '"', "String literal must starts with a quote");
        start = index;
        ++index;
        while (index < length) {
            ch = source[index++];
            if (ch === quote) {
                quote = "";
                break
            } else if (ch === "\\") {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) switch (ch) {
                    case "u":
                    case "x":
                        if (source[index] === "{") {
                            ++index;
                            str += scanUnicodeCodePointEscape()
                        } else {
                            unescaped = scanHexEscape(ch);
                            if (!unescaped) throw throwUnexpectedToken();
                            str += unescaped
                        }
                        break;
                    case "n":
                        str += "\n";
                        break;
                    case "r":
                        str +=
                            "\r";
                        break;
                    case "t":
                        str += "\t";
                        break;
                    case "b":
                        str += "\b";
                        break;
                    case "f":
                        str += "\f";
                        break;
                    case "v":
                        str += "\x0B";
                        break;
                    case "8":
                    case "9":
                        str += ch;
                        tolerateUnexpectedToken();
                        break;
                    default:
                        if (isOctalDigit(ch)) {
                            octToDec = octalToDecimal(ch);
                            octal = octToDec.octal || octal;
                            str += String.fromCharCode(octToDec.code)
                        } else str += ch;
                        break
                } else {
                    ++lineNumber;
                    if (ch === "\r" && source[index] === "\n") ++index;
                    lineStart = index
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) break;
            else str += ch
        }
        if (quote !== "") {
            index = start;
            throwUnexpectedToken()
        }
        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: startLineNumber,
            lineStart: startLineStart,
            start: start,
            end: index
        }
    }

    function scanTemplate() {
        var cooked = "",
            ch, start, rawOffset, terminated, head, tail, restore, unescaped;
        terminated = false;
        tail = false;
        start = index;
        head = source[index] === "`";
        rawOffset = 2;
        ++index;
        while (index < length) {
            ch = source[index++];
            if (ch === "`") {
                rawOffset = 1;
                tail = true;
                terminated = true;
                break
            } else if (ch === "$") {
                if (source[index] === "{") {
                    state.curlyStack.push("${");
                    ++index;
                    terminated = true;
                    break
                }
                cooked += ch
            } else if (ch === "\\") {
                ch =
                    source[index++];
                if (!isLineTerminator(ch.charCodeAt(0))) switch (ch) {
                    case "n":
                        cooked += "\n";
                        break;
                    case "r":
                        cooked += "\r";
                        break;
                    case "t":
                        cooked += "\t";
                        break;
                    case "u":
                    case "x":
                        if (source[index] === "{") {
                            ++index;
                            cooked += scanUnicodeCodePointEscape()
                        } else {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) cooked += unescaped;
                            else {
                                index = restore;
                                cooked += ch
                            }
                        }
                        break;
                    case "b":
                        cooked += "\b";
                        break;
                    case "f":
                        cooked += "\f";
                        break;
                    case "v":
                        cooked += "\v";
                        break;
                    default:
                        if (ch === "0") {
                            if (isDecimalDigit(source.charCodeAt(index))) throwError(Messages.TemplateOctalLiteral);
                            cooked += "\x00"
                        } else if (isOctalDigit(ch)) throwError(Messages.TemplateOctalLiteral);
                        else cooked += ch;
                        break
                } else {
                    ++lineNumber;
                    if (ch === "\r" && source[index] === "\n") ++index;
                    lineStart = index
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                ++lineNumber;
                if (ch === "\r" && source[index] === "\n") ++index;
                lineStart = index;
                cooked += "\n"
            } else cooked += ch
        }
        if (!terminated) throwUnexpectedToken();
        if (!head) state.curlyStack.pop();
        return {
            type: Token.Template,
            value: {
                cooked: cooked,
                raw: source.slice(start + 1, index - rawOffset)
            },
            head: head,
            tail: tail,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        }
    }

    function testRegExp(pattern, flags) {
        var astralSubstitute = "￿",
            tmp = pattern;
        if (flags.indexOf("u") >= 0) tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
            var codePoint = parseInt($1 || $2, 16);
            if (codePoint > 1114111) throwUnexpectedToken(null, Messages.InvalidRegExp);
            if (codePoint <= 65535) return String.fromCharCode(codePoint);
            return astralSubstitute
        }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
        try {
            RegExp(tmp)
        } catch (e) {
            throwUnexpectedToken(null,
                Messages.InvalidRegExp)
        }
        try {
            return new RegExp(pattern, flags)
        } catch (exception) {
            return null
        }
    }

    function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;
        ch = source[index];
        assert(ch === "/", "Regular expression literal must start with a slash");
        str = source[index++];
        classMarker = false;
        terminated = false;
        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === "\\") {
                ch = source[index++];
                if (isLineTerminator(ch.charCodeAt(0))) throwUnexpectedToken(null, Messages.UnterminatedRegExp);
                str += ch
            } else if (isLineTerminator(ch.charCodeAt(0))) throwUnexpectedToken(null,
                Messages.UnterminatedRegExp);
            else if (classMarker) {
                if (ch === "]") classMarker = false
            } else if (ch === "/") {
                terminated = true;
                break
            } else if (ch === "[") classMarker = true
        }
        if (!terminated) throwUnexpectedToken(null, Messages.UnterminatedRegExp);
        body = str.substr(1, str.length - 2);
        return {
            value: body,
            literal: str
        }
    }

    function scanRegExpFlags() {
        var ch, str, flags, restore;
        str = "";
        flags = "";
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) break;
            ++index;
            if (ch === "\\" && index < length) {
                ch = source[index];
                if (ch === "u") {
                    ++index;
                    restore = index;
                    ch = scanHexEscape("u");
                    if (ch) {
                        flags += ch;
                        for (str += "\\u"; restore < index; ++restore) str += source[restore]
                    } else {
                        index = restore;
                        flags += "u";
                        str += "\\u"
                    }
                    tolerateUnexpectedToken()
                } else {
                    str += "\\";
                    tolerateUnexpectedToken()
                }
            } else {
                flags += ch;
                str += ch
            }
        }
        return {
            value: flags,
            literal: str
        }
    }

    function scanRegExp() {
        var start, body, flags, value;
        scanning = true;
        lookahead = null;
        skipComment();
        start = index;
        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);
        scanning = false;
        if (extra.tokenize) return {
            type: Token.RegularExpression,
            value: value,
            regex: {
                pattern: body.value,
                flags: flags.value
            },
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
        return {
            literal: body.literal + flags.literal,
            value: value,
            regex: {
                pattern: body.value,
                flags: flags.value
            },
            start: start,
            end: index
        }
    }

    function collectRegex() {
        var pos, loc, regex, token;
        skipComment();
        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };
        regex = scanRegExp();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };
        if (!extra.tokenize) {
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length -
                    1];
                if (token.range[0] === pos && token.type === "Punctuator")
                    if (token.value === "/" || token.value === "/=") extra.tokens.pop()
            }
            extra.tokens.push({
                type: "RegularExpression",
                value: regex.literal,
                regex: regex.regex,
                range: [pos, index],
                loc: loc
            })
        }
        return regex
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral
    }

    function advanceSlash() {
        var regex, previous, check;

        function testKeyword(value) {
            return value && value.length >
                1 && value[0] >= "a" && value[0] <= "z"
        }
        previous = extra.tokenValues[extra.tokens.length - 1];
        regex = previous !== null;
        switch (previous) {
            case "this":
            case "]":
                regex = false;
                break;
            case ")":
                check = extra.tokenValues[extra.openParenToken - 1];
                regex = check === "if" || check === "while" || check === "for" || check === "with";
                break;
            case "}":
                regex = false;
                if (testKeyword(extra.tokenValues[extra.openCurlyToken - 3])) {
                    check = extra.tokenValues[extra.openCurlyToken - 4];
                    regex = check ? FnExprTokens.indexOf(check) < 0 : false
                } else if (testKeyword(extra.tokenValues[extra.openCurlyToken -
                        4])) {
                    check = extra.tokenValues[extra.openCurlyToken - 5];
                    regex = check ? FnExprTokens.indexOf(check) < 0 : true
                }
        }
        return regex ? collectRegex() : scanPunctuator()
    }

    function advance() {
        var cp, token;
        if (index >= length) return {
            type: Token.EOF,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: index,
            end: index
        };
        cp = source.charCodeAt(index);
        if (isIdentifierStart(cp)) {
            token = scanIdentifier();
            if (strict && isStrictModeReservedWord(token.value)) token.type = Token.Keyword;
            return token
        }
        if (cp === 40 || cp === 41 || cp === 59) return scanPunctuator();
        if (cp ===
            39 || cp === 34) return scanStringLiteral();
        if (cp === 46) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) return scanNumericLiteral();
            return scanPunctuator()
        }
        if (isDecimalDigit(cp)) return scanNumericLiteral();
        if (extra.tokenize && cp === 47) return advanceSlash();
        if (cp === 96 || cp === 125 && state.curlyStack[state.curlyStack.length - 1] === "${") return scanTemplate();
        if (cp >= 55296 && cp < 57343) {
            cp = codePointAt(index);
            if (isIdentifierStart(cp)) return scanIdentifier()
        }
        return scanPunctuator()
    }

    function collectToken() {
        var loc, token, value,
            entry;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };
        token = advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };
        if (token.type !== Token.EOF) {
            value = source.slice(token.start, token.end);
            entry = {
                type: TokenName[token.type],
                value: value,
                range: [token.start, token.end],
                loc: loc
            };
            if (token.regex) entry.regex = {
                pattern: token.regex.pattern,
                flags: token.regex.flags
            };
            if (extra.tokenValues) extra.tokenValues.push(entry.type === "Punctuator" || entry.type === "Keyword" ? entry.value : null);
            if (extra.tokenize) {
                if (!extra.range) delete entry.range;
                if (!extra.loc) delete entry.loc;
                if (extra.delegate) entry = extra.delegate(entry)
            }
            extra.tokens.push(entry)
        }
        return token
    }

    function lex() {
        var token;
        scanning = true;
        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;
        skipComment();
        token = lookahead;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        lookahead = typeof extra.tokens !== "undefined" ? collectToken() : advance();
        scanning = false;
        return token
    }

    function peek() {
        scanning = true;
        skipComment();
        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        lookahead = typeof extra.tokens !== "undefined" ? collectToken() : advance();
        scanning = false
    }

    function Position() {
        this.line = startLineNumber;
        this.column = startIndex - startLineStart
    }

    function SourceLocation() {
        this.start = new Position;
        this.end = null
    }

    function WrappingSourceLocation(startToken) {
        this.start = {
            line: startToken.lineNumber,
            column: startToken.start - startToken.lineStart
        };
        this.end = null
    }

    function Node() {
        if (extra.range) this.range = [startIndex, 0];
        if (extra.loc) this.loc = new SourceLocation
    }

    function WrappingNode(startToken) {
        if (extra.range) this.range = [startToken.start, 0];
        if (extra.loc) this.loc = new WrappingSourceLocation(startToken)
    }
    WrappingNode.prototype = Node.prototype = {
        processComment: function() {
            var lastChild, innerComments, leadingComments, trailingComments, bottomRight = extra.bottomRightStack,
                i, comment, last = bottomRight[bottomRight.length - 1];
            if (this.type === Syntax.Program)
                if (this.body.length > 0) return;
            if (this.type === Syntax.BlockStatement &&
                this.body.length === 0) {
                innerComments = [];
                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
                    comment = extra.leadingComments[i];
                    if (this.range[1] >= comment.range[1]) {
                        innerComments.unshift(comment);
                        extra.leadingComments.splice(i, 1);
                        extra.trailingComments.splice(i, 1)
                    }
                }
                if (innerComments.length) {
                    this.innerComments = innerComments;
                    return
                }
            }
            if (extra.trailingComments.length > 0) {
                trailingComments = [];
                for (i = extra.trailingComments.length - 1; i >= 0; --i) {
                    comment = extra.trailingComments[i];
                    if (comment.range[0] >= this.range[1]) {
                        trailingComments.unshift(comment);
                        extra.trailingComments.splice(i, 1)
                    }
                }
                extra.trailingComments = []
            } else if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
                trailingComments = last.trailingComments;
                delete last.trailingComments
            }
            while (last && last.range[0] >= this.range[0]) {
                lastChild = bottomRight.pop();
                last = bottomRight[bottomRight.length - 1]
            }
            if (lastChild) {
                if (lastChild.leadingComments) {
                    leadingComments = [];
                    for (i = lastChild.leadingComments.length - 1; i >= 0; --i) {
                        comment = lastChild.leadingComments[i];
                        if (comment.range[1] <= this.range[0]) {
                            leadingComments.unshift(comment);
                            lastChild.leadingComments.splice(i, 1)
                        }
                    }
                    if (!lastChild.leadingComments.length) lastChild.leadingComments = undefined
                }
            } else if (extra.leadingComments.length > 0) {
                leadingComments = [];
                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
                    comment = extra.leadingComments[i];
                    if (comment.range[1] <= this.range[0]) {
                        leadingComments.unshift(comment);
                        extra.leadingComments.splice(i, 1)
                    }
                }
            }
            if (leadingComments && leadingComments.length > 0) this.leadingComments = leadingComments;
            if (trailingComments && trailingComments.length > 0) this.trailingComments =
                trailingComments;
            bottomRight.push(this)
        },
        finish: function() {
            if (extra.range) this.range[1] = lastIndex;
            if (extra.loc) {
                this.loc.end = {
                    line: lastLineNumber,
                    column: lastIndex - lastLineStart
                };
                if (extra.source) this.loc.source = extra.source
            }
            if (extra.attachComment) this.processComment()
        },
        finishArrayExpression: function(elements) {
            this.type = Syntax.ArrayExpression;
            this.elements = elements;
            this.finish();
            return this
        },
        finishArrayPattern: function(elements) {
            this.type = Syntax.ArrayPattern;
            this.elements = elements;
            this.finish();
            return this
        },
        finishArrowFunctionExpression: function(params, defaults, body, expression) {
            this.type = Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = false;
            this.expression = expression;
            this.finish();
            return this
        },
        finishAssignmentExpression: function(operator, left, right) {
            this.type = Syntax.AssignmentExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this
        },
        finishAssignmentPattern: function(left, right) {
            this.type = Syntax.AssignmentPattern;
            this.left = left;
            this.right = right;
            this.finish();
            return this
        },
        finishBinaryExpression: function(operator, left, right) {
            this.type = operator === "||" || operator === "&&" ? Syntax.LogicalExpression : Syntax.BinaryExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this
        },
        finishBlockStatement: function(body) {
            this.type = Syntax.BlockStatement;
            this.body = body;
            this.finish();
            return this
        },
        finishBreakStatement: function(label) {
            this.type = Syntax.BreakStatement;
            this.label = label;
            this.finish();
            return this
        },
        finishCallExpression: function(callee, args) {
            this.type = Syntax.CallExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this
        },
        finishCatchClause: function(param, body) {
            this.type = Syntax.CatchClause;
            this.param = param;
            this.body = body;
            this.finish();
            return this
        },
        finishClassBody: function(body) {
            this.type = Syntax.ClassBody;
            this.body = body;
            this.finish();
            return this
        },
        finishClassDeclaration: function(id, superClass, body) {
            this.type = Syntax.ClassDeclaration;
            this.id = id;
            this.superClass = superClass;
            this.body =
                body;
            this.finish();
            return this
        },
        finishClassExpression: function(id, superClass, body) {
            this.type = Syntax.ClassExpression;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
            this.finish();
            return this
        },
        finishConditionalExpression: function(test, consequent, alternate) {
            this.type = Syntax.ConditionalExpression;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this
        },
        finishContinueStatement: function(label) {
            this.type = Syntax.ContinueStatement;
            this.label = label;
            this.finish();
            return this
        },
        finishDebuggerStatement: function() {
            this.type = Syntax.DebuggerStatement;
            this.finish();
            return this
        },
        finishDoWhileStatement: function(body, test) {
            this.type = Syntax.DoWhileStatement;
            this.body = body;
            this.test = test;
            this.finish();
            return this
        },
        finishEmptyStatement: function() {
            this.type = Syntax.EmptyStatement;
            this.finish();
            return this
        },
        finishExpressionStatement: function(expression) {
            this.type = Syntax.ExpressionStatement;
            this.expression = expression;
            this.finish();
            return this
        },
        finishForStatement: function(init, test, update,
            body) {
            this.type = Syntax.ForStatement;
            this.init = init;
            this.test = test;
            this.update = update;
            this.body = body;
            this.finish();
            return this
        },
        finishForOfStatement: function(left, right, body) {
            this.type = Syntax.ForOfStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.finish();
            return this
        },
        finishForInStatement: function(left, right, body) {
            this.type = Syntax.ForInStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.each = false;
            this.finish();
            return this
        },
        finishFunctionDeclaration: function(id, params, defaults,
            body, generator) {
            this.type = Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.finish();
            return this
        },
        finishFunctionExpression: function(id, params, defaults, body, generator) {
            this.type = Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.finish();
            return this
        },
        finishIdentifier: function(name) {
            this.type = Syntax.Identifier;
            this.name = name;
            this.finish();
            return this
        },
        finishIfStatement: function(test, consequent, alternate) {
            this.type = Syntax.IfStatement;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this
        },
        finishLabeledStatement: function(label, body) {
            this.type = Syntax.LabeledStatement;
            this.label = label;
            this.body = body;
            this.finish();
            return this
        },
        finishLiteral: function(token) {
            this.type = Syntax.Literal;
            this.value = token.value;
            this.raw = source.slice(token.start, token.end);
            if (token.regex) this.regex =
                token.regex;
            this.finish();
            return this
        },
        finishMemberExpression: function(accessor, object, property) {
            this.type = Syntax.MemberExpression;
            this.computed = accessor === "[";
            this.object = object;
            this.property = property;
            this.finish();
            return this
        },
        finishMetaProperty: function(meta, property) {
            this.type = Syntax.MetaProperty;
            this.meta = meta;
            this.property = property;
            this.finish();
            return this
        },
        finishNewExpression: function(callee, args) {
            this.type = Syntax.NewExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this
        },
        finishObjectExpression: function(properties) {
            this.type = Syntax.ObjectExpression;
            this.properties = properties;
            this.finish();
            return this
        },
        finishObjectPattern: function(properties) {
            this.type = Syntax.ObjectPattern;
            this.properties = properties;
            this.finish();
            return this
        },
        finishPostfixExpression: function(operator, argument) {
            this.type = Syntax.UpdateExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = false;
            this.finish();
            return this
        },
        finishProgram: function(body, sourceType) {
            this.type = Syntax.Program;
            this.body =
                body;
            this.sourceType = sourceType;
            this.finish();
            return this
        },
        finishProperty: function(kind, key, computed, value, method, shorthand) {
            this.type = Syntax.Property;
            this.key = key;
            this.computed = computed;
            this.value = value;
            this.kind = kind;
            this.method = method;
            this.shorthand = shorthand;
            this.finish();
            return this
        },
        finishRestElement: function(argument) {
            this.type = Syntax.RestElement;
            this.argument = argument;
            this.finish();
            return this
        },
        finishReturnStatement: function(argument) {
            this.type = Syntax.ReturnStatement;
            this.argument = argument;
            this.finish();
            return this
        },
        finishSequenceExpression: function(expressions) {
            this.type = Syntax.SequenceExpression;
            this.expressions = expressions;
            this.finish();
            return this
        },
        finishSpreadElement: function(argument) {
            this.type = Syntax.SpreadElement;
            this.argument = argument;
            this.finish();
            return this
        },
        finishSwitchCase: function(test, consequent) {
            this.type = Syntax.SwitchCase;
            this.test = test;
            this.consequent = consequent;
            this.finish();
            return this
        },
        finishSuper: function() {
            this.type = Syntax.Super;
            this.finish();
            return this
        },
        finishSwitchStatement: function(discriminant,
            cases) {
            this.type = Syntax.SwitchStatement;
            this.discriminant = discriminant;
            this.cases = cases;
            this.finish();
            return this
        },
        finishTaggedTemplateExpression: function(tag, quasi) {
            this.type = Syntax.TaggedTemplateExpression;
            this.tag = tag;
            this.quasi = quasi;
            this.finish();
            return this
        },
        finishTemplateElement: function(value, tail) {
            this.type = Syntax.TemplateElement;
            this.value = value;
            this.tail = tail;
            this.finish();
            return this
        },
        finishTemplateLiteral: function(quasis, expressions) {
            this.type = Syntax.TemplateLiteral;
            this.quasis = quasis;
            this.expressions = expressions;
            this.finish();
            return this
        },
        finishThisExpression: function() {
            this.type = Syntax.ThisExpression;
            this.finish();
            return this
        },
        finishThrowStatement: function(argument) {
            this.type = Syntax.ThrowStatement;
            this.argument = argument;
            this.finish();
            return this
        },
        finishTryStatement: function(block, handler, finalizer) {
            this.type = Syntax.TryStatement;
            this.block = block;
            this.guardedHandlers = [];
            this.handlers = handler ? [handler] : [];
            this.handler = handler;
            this.finalizer = finalizer;
            this.finish();
            return this
        },
        finishUnaryExpression: function(operator, argument) {
            this.type = operator === "++" || operator === "--" ? Syntax.UpdateExpression : Syntax.UnaryExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = true;
            this.finish();
            return this
        },
        finishVariableDeclaration: function(declarations) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = "var";
            this.finish();
            return this
        },
        finishLexicalDeclaration: function(declarations, kind) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = kind;
            this.finish();
            return this
        },
        finishVariableDeclarator: function(id, init) {
            this.type = Syntax.VariableDeclarator;
            this.id = id;
            this.init = init;
            this.finish();
            return this
        },
        finishWhileStatement: function(test, body) {
            this.type = Syntax.WhileStatement;
            this.test = test;
            this.body = body;
            this.finish();
            return this
        },
        finishWithStatement: function(object, body) {
            this.type = Syntax.WithStatement;
            this.object = object;
            this.body = body;
            this.finish();
            return this
        },
        finishExportSpecifier: function(local, exported) {
            this.type = Syntax.ExportSpecifier;
            this.exported = exported || local;
            this.local = local;
            this.finish();
            return this
        },
        finishImportDefaultSpecifier: function(local) {
            this.type = Syntax.ImportDefaultSpecifier;
            this.local = local;
            this.finish();
            return this
        },
        finishImportNamespaceSpecifier: function(local) {
            this.type = Syntax.ImportNamespaceSpecifier;
            this.local = local;
            this.finish();
            return this
        },
        finishExportNamedDeclaration: function(declaration, specifiers, src) {
            this.type = Syntax.ExportNamedDeclaration;
            this.declaration = declaration;
            this.specifiers = specifiers;
            this.source =
                src;
            this.finish();
            return this
        },
        finishExportDefaultDeclaration: function(declaration) {
            this.type = Syntax.ExportDefaultDeclaration;
            this.declaration = declaration;
            this.finish();
            return this
        },
        finishExportAllDeclaration: function(src) {
            this.type = Syntax.ExportAllDeclaration;
            this.source = src;
            this.finish();
            return this
        },
        finishImportSpecifier: function(local, imported) {
            this.type = Syntax.ImportSpecifier;
            this.local = local || imported;
            this.imported = imported;
            this.finish();
            return this
        },
        finishImportDeclaration: function(specifiers,
            src) {
            this.type = Syntax.ImportDeclaration;
            this.specifiers = specifiers;
            this.source = src;
            this.finish();
            return this
        },
        finishYieldExpression: function(argument, delegate) {
            this.type = Syntax.YieldExpression;
            this.argument = argument;
            this.delegate = delegate;
            this.finish();
            return this
        }
    };

    function recordError(error) {
        var e, existing;
        for (e = 0; e < extra.errors.length; e++) {
            existing = extra.errors[e];
            if (existing.index === error.index && existing.message === error.message) return
        }
        extra.errors.push(error)
    }

    function constructError(msg, column) {
        var error =
            new Error(msg);
        try {
            throw error;
        } catch (base) {
            if (Object.create && Object.defineProperty) {
                error = Object.create(base);
                Object.defineProperty(error, "column", {
                    value: column
                })
            }
        } finally {
            return error
        }
    }

    function createError(line, pos, description) {
        var msg, column, error;
        msg = "Line " + line + ": " + description;
        column = pos - (scanning ? lineStart : lastLineStart) + 1;
        error = constructError(msg, column);
        error.lineNumber = line;
        error.description = description;
        error.index = pos;
        return error
    }

    function throwError(messageFormat) {
        var args, msg;
        args = Array.prototype.slice.call(arguments,
            1);
        msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
            assert(idx < args.length, "Message reference must be in range");
            return args[idx]
        });
        throw createError(lastLineNumber, lastIndex, msg);
    }

    function tolerateError(messageFormat) {
        var args, msg, error;
        args = Array.prototype.slice.call(arguments, 1);
        msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
            assert(idx < args.length, "Message reference must be in range");
            return args[idx]
        });
        error = createError(lineNumber, lastIndex, msg);
        if (extra.errors) recordError(error);
        else throw error;
    }

    function unexpectedTokenError(token, message) {
        var value, msg = message || Messages.UnexpectedToken;
        if (token) {
            if (!message) {
                msg = token.type === Token.EOF ? Messages.UnexpectedEOS : token.type === Token.Identifier ? Messages.UnexpectedIdentifier : token.type === Token.NumericLiteral ? Messages.UnexpectedNumber : token.type === Token.StringLiteral ? Messages.UnexpectedString : token.type === Token.Template ? Messages.UnexpectedTemplate : Messages.UnexpectedToken;
                if (token.type === Token.Keyword)
                    if (isFutureReservedWord(token.value)) msg =
                        Messages.UnexpectedReserved;
                    else if (strict && isStrictModeReservedWord(token.value)) msg = Messages.StrictReservedWord
            }
            value = token.type === Token.Template ? token.value.raw : token.value
        } else value = "ILLEGAL";
        msg = msg.replace("%0", value);
        return token && typeof token.lineNumber === "number" ? createError(token.lineNumber, token.start, msg) : createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg)
    }

    function throwUnexpectedToken(token, message) {
        throw unexpectedTokenError(token, message);
    }

    function tolerateUnexpectedToken(token,
        message) {
        var error = unexpectedTokenError(token, message);
        if (extra.errors) recordError(error);
        else throw error;
    }

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) throwUnexpectedToken(token)
    }

    function expectCommaSeparator() {
        var token;
        if (extra.errors) {
            token = lookahead;
            if (token.type === Token.Punctuator && token.value === ",") lex();
            else if (token.type === Token.Punctuator && token.value === ";") {
                lex();
                tolerateUnexpectedToken(token)
            } else tolerateUnexpectedToken(token, Messages.UnexpectedToken)
        } else expect(",")
    }

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) throwUnexpectedToken(token)
    }

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value
    }

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword
    }

    function matchContextualKeyword(keyword) {
        return lookahead.type === Token.Identifier && lookahead.value === keyword
    }

    function matchAssign() {
        var op;
        if (lookahead.type !== Token.Punctuator) return false;
        op = lookahead.value;
        return op === "=" || op === "*=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|="
    }

    function consumeSemicolon() {
        if (source.charCodeAt(startIndex) === 59 || match(";")) {
            lex();
            return
        }
        if (hasLineTerminator) return;
        lastIndex = startIndex;
        lastLineNumber = startLineNumber;
        lastLineStart = startLineStart;
        if (lookahead.type !== Token.EOF && !match("}")) throwUnexpectedToken(lookahead)
    }

    function isolateCoverGrammar(parser) {
        var oldIsBindingElement = isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = true;
        isAssignmentTarget = true;
        firstCoverInitializedNameError = null;
        result = parser();
        if (firstCoverInitializedNameError !== null) throwUnexpectedToken(firstCoverInitializedNameError);
        isBindingElement = oldIsBindingElement;
        isAssignmentTarget = oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;
        return result
    }

    function inheritCoverGrammar(parser) {
        var oldIsBindingElement =
            isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = true;
        isAssignmentTarget = true;
        firstCoverInitializedNameError = null;
        result = parser();
        isBindingElement = isBindingElement && oldIsBindingElement;
        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;
        return result
    }

    function parseArrayPattern(params, kind) {
        var node =
            new Node,
            elements = [],
            rest, restNode;
        expect("[");
        while (!match("]"))
            if (match(",")) {
                lex();
                elements.push(null)
            } else {
                if (match("...")) {
                    restNode = new Node;
                    lex();
                    params.push(lookahead);
                    rest = parseVariableIdentifier(kind);
                    elements.push(restNode.finishRestElement(rest));
                    break
                } else elements.push(parsePatternWithDefault(params, kind));
                if (!match("]")) expect(",")
            }
        expect("]");
        return node.finishArrayPattern(elements)
    }

    function parsePropertyPattern(params, kind) {
        var node = new Node,
            key, keyToken, computed = match("["),
            init;
        if (lookahead.type ===
            Token.Identifier) {
            keyToken = lookahead;
            key = parseVariableIdentifier();
            if (match("=")) {
                params.push(keyToken);
                lex();
                init = parseAssignmentExpression();
                return node.finishProperty("init", key, false, (new WrappingNode(keyToken)).finishAssignmentPattern(key, init), false, true)
            } else if (!match(":")) {
                params.push(keyToken);
                return node.finishProperty("init", key, false, key, false, true)
            }
        } else key = parseObjectPropertyKey();
        expect(":");
        init = parsePatternWithDefault(params, kind);
        return node.finishProperty("init", key, computed,
            init, false, false)
    }

    function parseObjectPattern(params, kind) {
        var node = new Node,
            properties = [];
        expect("{");
        while (!match("}")) {
            properties.push(parsePropertyPattern(params, kind));
            if (!match("}")) expect(",")
        }
        lex();
        return node.finishObjectPattern(properties)
    }

    function parsePattern(params, kind) {
        if (match("[")) return parseArrayPattern(params, kind);
        else if (match("{")) return parseObjectPattern(params, kind);
        else if (matchKeyword("let"))
            if (kind === "const" || kind === "let") tolerateUnexpectedToken(lookahead, Messages.UnexpectedToken);
        params.push(lookahead);
        return parseVariableIdentifier(kind)
    }

    function parsePatternWithDefault(params, kind) {
        var startToken = lookahead,
            pattern, previousAllowYield, right;
        pattern = parsePattern(params, kind);
        if (match("=")) {
            lex();
            previousAllowYield = state.allowYield;
            state.allowYield = true;
            right = isolateCoverGrammar(parseAssignmentExpression);
            state.allowYield = previousAllowYield;
            pattern = (new WrappingNode(startToken)).finishAssignmentPattern(pattern, right)
        }
        return pattern
    }

    function parseArrayInitializer() {
        var elements = [],
            node = new Node,
            restSpread;
        expect("[");
        while (!match("]"))
            if (match(",")) {
                lex();
                elements.push(null)
            } else if (match("...")) {
            restSpread = new Node;
            lex();
            restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));
            if (!match("]")) {
                isAssignmentTarget = isBindingElement = false;
                expect(",")
            }
            elements.push(restSpread)
        } else {
            elements.push(inheritCoverGrammar(parseAssignmentExpression));
            if (!match("]")) expect(",")
        }
        lex();
        return node.finishArrayExpression(elements)
    }

    function parsePropertyFunction(node,
        paramInfo, isGenerator) {
        var previousStrict, body;
        isAssignmentTarget = isBindingElement = false;
        previousStrict = strict;
        body = isolateCoverGrammar(parseFunctionSourceElements);
        if (strict && paramInfo.firstRestricted) tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);
        if (strict && paramInfo.stricted) tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);
        strict = previousStrict;
        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body, isGenerator)
    }

    function parsePropertyMethodFunction() {
        var params,
            method, node = new Node,
            previousAllowYield = state.allowYield;
        state.allowYield = false;
        params = parseParams();
        state.allowYield = previousAllowYield;
        state.allowYield = false;
        method = parsePropertyFunction(node, params, false);
        state.allowYield = previousAllowYield;
        return method
    }

    function parseObjectPropertyKey() {
        var token, node = new Node,
            expr;
        token = lex();
        switch (token.type) {
            case Token.StringLiteral:
            case Token.NumericLiteral:
                if (strict && token.octal) tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
                return node.finishLiteral(token);
            case Token.Identifier:
            case Token.BooleanLiteral:
            case Token.NullLiteral:
            case Token.Keyword:
                return node.finishIdentifier(token.value);
            case Token.Punctuator:
                if (token.value === "[") {
                    expr = isolateCoverGrammar(parseAssignmentExpression);
                    expect("]");
                    return expr
                }
                break
        }
        throwUnexpectedToken(token)
    }

    function lookaheadPropertyName() {
        switch (lookahead.type) {
            case Token.Identifier:
            case Token.StringLiteral:
            case Token.BooleanLiteral:
            case Token.NullLiteral:
            case Token.NumericLiteral:
            case Token.Keyword:
                return true;
            case Token.Punctuator:
                return lookahead.value ===
                    "["
        }
        return false
    }

    function tryParseMethodDefinition(token, key, computed, node) {
        var value, options, methodNode, params, previousAllowYield = state.allowYield;
        if (token.type === Token.Identifier)
            if (token.value === "get" && lookaheadPropertyName()) {
                computed = match("[");
                key = parseObjectPropertyKey();
                methodNode = new Node;
                expect("(");
                expect(")");
                state.allowYield = false;
                value = parsePropertyFunction(methodNode, {
                    params: [],
                    defaults: [],
                    stricted: null,
                    firstRestricted: null,
                    message: null
                }, false);
                state.allowYield = previousAllowYield;
                return node.finishProperty("get",
                    key, computed, value, false, false)
            } else {
                if (token.value === "set" && lookaheadPropertyName()) {
                    computed = match("[");
                    key = parseObjectPropertyKey();
                    methodNode = new Node;
                    expect("(");
                    options = {
                        params: [],
                        defaultCount: 0,
                        defaults: [],
                        firstRestricted: null,
                        paramSet: {}
                    };
                    if (match(")")) tolerateUnexpectedToken(lookahead);
                    else {
                        state.allowYield = false;
                        parseParam(options);
                        state.allowYield = previousAllowYield;
                        if (options.defaultCount === 0) options.defaults = []
                    }
                    expect(")");
                    state.allowYield = false;
                    value = parsePropertyFunction(methodNode,
                        options, false);
                    state.allowYield = previousAllowYield;
                    return node.finishProperty("set", key, computed, value, false, false)
                }
            } else if (token.type === Token.Punctuator && token.value === "*" && lookaheadPropertyName()) {
            computed = match("[");
            key = parseObjectPropertyKey();
            methodNode = new Node;
            state.allowYield = true;
            params = parseParams();
            state.allowYield = previousAllowYield;
            state.allowYield = false;
            value = parsePropertyFunction(methodNode, params, true);
            state.allowYield = previousAllowYield;
            return node.finishProperty("init", key, computed,
                value, true, false)
        }
        if (key && match("(")) {
            value = parsePropertyMethodFunction();
            return node.finishProperty("init", key, computed, value, true, false)
        }
        return null
    }

    function parseObjectProperty(hasProto) {
        var token = lookahead,
            node = new Node,
            computed, key, maybeMethod, proto, value;
        computed = match("[");
        if (match("*")) lex();
        else key = parseObjectPropertyKey();
        maybeMethod = tryParseMethodDefinition(token, key, computed, node);
        if (maybeMethod) return maybeMethod;
        if (!key) throwUnexpectedToken(lookahead);
        if (!computed) {
            proto = key.type ===
                Syntax.Identifier && key.name === "__proto__" || key.type === Syntax.Literal && key.value === "__proto__";
            if (hasProto.value && proto) tolerateError(Messages.DuplicateProtoProperty);
            hasProto.value |= proto
        }
        if (match(":")) {
            lex();
            value = inheritCoverGrammar(parseAssignmentExpression);
            return node.finishProperty("init", key, computed, value, false, false)
        }
        if (token.type === Token.Identifier) {
            if (match("=")) {
                firstCoverInitializedNameError = lookahead;
                lex();
                value = isolateCoverGrammar(parseAssignmentExpression);
                return node.finishProperty("init",
                    key, computed, (new WrappingNode(token)).finishAssignmentPattern(key, value), false, true)
            }
            return node.finishProperty("init", key, computed, key, false, true)
        }
        throwUnexpectedToken(lookahead)
    }

    function parseObjectInitializer() {
        var properties = [],
            hasProto = {
                value: false
            },
            node = new Node;
        expect("{");
        while (!match("}")) {
            properties.push(parseObjectProperty(hasProto));
            if (!match("}")) expectCommaSeparator()
        }
        expect("}");
        return node.finishObjectExpression(properties)
    }

    function reinterpretExpressionAsPattern(expr) {
        var i;
        switch (expr.type) {
            case Syntax.Identifier:
            case Syntax.MemberExpression:
            case Syntax.RestElement:
            case Syntax.AssignmentPattern:
                break;
            case Syntax.SpreadElement:
                expr.type = Syntax.RestElement;
                reinterpretExpressionAsPattern(expr.argument);
                break;
            case Syntax.ArrayExpression:
                expr.type = Syntax.ArrayPattern;
                for (i = 0; i < expr.elements.length; i++)
                    if (expr.elements[i] !== null) reinterpretExpressionAsPattern(expr.elements[i]);
                break;
            case Syntax.ObjectExpression:
                expr.type = Syntax.ObjectPattern;
                for (i = 0; i < expr.properties.length; i++) reinterpretExpressionAsPattern(expr.properties[i].value);
                break;
            case Syntax.AssignmentExpression:
                expr.type = Syntax.AssignmentPattern;
                reinterpretExpressionAsPattern(expr.left);
                break;
            default:
                break
        }
    }

    function parseTemplateElement(option) {
        var node, token;
        if (lookahead.type !== Token.Template || option.head && !lookahead.head) throwUnexpectedToken();
        node = new Node;
        token = lex();
        return node.finishTemplateElement({
            raw: token.value.raw,
            cooked: token.value.cooked
        }, token.tail)
    }

    function parseTemplateLiteral() {
        var quasi, quasis, expressions, node = new Node;
        quasi = parseTemplateElement({
            head: true
        });
        quasis = [quasi];
        expressions = [];
        while (!quasi.tail) {
            expressions.push(parseExpression());
            quasi = parseTemplateElement({
                head: false
            });
            quasis.push(quasi)
        }
        return node.finishTemplateLiteral(quasis, expressions)
    }

    function parseGroupExpression() {
        var expr, expressions, startToken, i, params = [];
        expect("(");
        if (match(")")) {
            lex();
            if (!match("=>")) expect("=>");
            return {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: [],
                rawParams: []
            }
        }
        startToken = lookahead;
        if (match("...")) {
            expr = parseRestElement(params);
            expect(")");
            if (!match("=>")) expect("=>");
            return {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: [expr]
            }
        }
        isBindingElement =
            true;
        expr = inheritCoverGrammar(parseAssignmentExpression);
        if (match(",")) {
            isAssignmentTarget = false;
            expressions = [expr];
            while (startIndex < length) {
                if (!match(",")) break;
                lex();
                if (match("...")) {
                    if (!isBindingElement) throwUnexpectedToken(lookahead);
                    expressions.push(parseRestElement(params));
                    expect(")");
                    if (!match("=>")) expect("=>");
                    isBindingElement = false;
                    for (i = 0; i < expressions.length; i++) reinterpretExpressionAsPattern(expressions[i]);
                    return {
                        type: PlaceHolders.ArrowParameterPlaceHolder,
                        params: expressions
                    }
                }
                expressions.push(inheritCoverGrammar(parseAssignmentExpression))
            }
            expr =
                (new WrappingNode(startToken)).finishSequenceExpression(expressions)
        }
        expect(")");
        if (match("=>")) {
            if (expr.type === Syntax.Identifier && expr.name === "yield") return {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: [expr]
            };
            if (!isBindingElement) throwUnexpectedToken(lookahead);
            if (expr.type === Syntax.SequenceExpression)
                for (i = 0; i < expr.expressions.length; i++) reinterpretExpressionAsPattern(expr.expressions[i]);
            else reinterpretExpressionAsPattern(expr);
            expr = {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: expr.type ===
                    Syntax.SequenceExpression ? expr.expressions : [expr]
            }
        }
        isBindingElement = false;
        return expr
    }

    function parsePrimaryExpression() {
        var type, token, expr, node;
        if (match("(")) {
            isBindingElement = false;
            return inheritCoverGrammar(parseGroupExpression)
        }
        if (match("[")) return inheritCoverGrammar(parseArrayInitializer);
        if (match("{")) return inheritCoverGrammar(parseObjectInitializer);
        type = lookahead.type;
        node = new Node;
        if (type === Token.Identifier) {
            if (state.sourceType === "module" && lookahead.value === "await") tolerateUnexpectedToken(lookahead);
            expr = node.finishIdentifier(lex().value)
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            isAssignmentTarget = isBindingElement = false;
            if (strict && lookahead.octal) tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
            expr = node.finishLiteral(lex())
        } else if (type === Token.Keyword) {
            if (!strict && state.allowYield && matchKeyword("yield")) return parseNonComputedProperty();
            if (!strict && matchKeyword("let")) return node.finishIdentifier(lex().value);
            isAssignmentTarget = isBindingElement = false;
            if (matchKeyword("function")) return parseFunctionExpression();
            if (matchKeyword("this")) {
                lex();
                return node.finishThisExpression()
            }
            if (matchKeyword("class")) return parseClassExpression();
            throwUnexpectedToken(lex())
        } else if (type === Token.BooleanLiteral) {
            isAssignmentTarget = isBindingElement = false;
            token = lex();
            token.value = token.value === "true";
            expr = node.finishLiteral(token)
        } else if (type === Token.NullLiteral) {
            isAssignmentTarget = isBindingElement = false;
            token = lex();
            token.value = null;
            expr = node.finishLiteral(token)
        } else if (match("/") || match("/=")) {
            isAssignmentTarget = isBindingElement =
                false;
            index = startIndex;
            if (typeof extra.tokens !== "undefined") token = collectRegex();
            else token = scanRegExp();
            lex();
            expr = node.finishLiteral(token)
        } else if (type === Token.Template) expr = parseTemplateLiteral();
        else throwUnexpectedToken(lex());
        return expr
    }

    function parseArguments() {
        var args = [],
            expr;
        expect("(");
        if (!match(")"))
            while (startIndex < length) {
                if (match("...")) {
                    expr = new Node;
                    lex();
                    expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression))
                } else expr = isolateCoverGrammar(parseAssignmentExpression);
                args.push(expr);
                if (match(")")) break;
                expectCommaSeparator()
            }
        expect(")");
        return args
    }

    function parseNonComputedProperty() {
        var token, node = new Node;
        token = lex();
        if (!isIdentifierName(token)) throwUnexpectedToken(token);
        return node.finishIdentifier(token.value)
    }

    function parseNonComputedMember() {
        expect(".");
        return parseNonComputedProperty()
    }

    function parseComputedMember() {
        var expr;
        expect("[");
        expr = isolateCoverGrammar(parseExpression);
        expect("]");
        return expr
    }

    function parseNewExpression() {
        var callee, args, node =
            new Node;
        expectKeyword("new");
        if (match(".")) {
            lex();
            if (lookahead.type === Token.Identifier && lookahead.value === "target")
                if (state.inFunctionBody) {
                    lex();
                    return node.finishMetaProperty("new", "target")
                }
            throwUnexpectedToken(lookahead)
        }
        callee = isolateCoverGrammar(parseLeftHandSideExpression);
        args = match("(") ? parseArguments() : [];
        isAssignmentTarget = isBindingElement = false;
        return node.finishNewExpression(callee, args)
    }

    function parseLeftHandSideExpressionAllowCall() {
        var quasi, expr, args, property, startToken, previousAllowIn =
            state.allowIn;
        startToken = lookahead;
        state.allowIn = true;
        if (matchKeyword("super") && state.inFunctionBody) {
            expr = new Node;
            lex();
            expr = expr.finishSuper();
            if (!match("(") && !match(".") && !match("[")) throwUnexpectedToken(lookahead)
        } else expr = inheritCoverGrammar(matchKeyword("new") ? parseNewExpression : parsePrimaryExpression);
        for (;;)
            if (match(".")) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseNonComputedMember();
                expr = (new WrappingNode(startToken)).finishMemberExpression(".", expr, property)
            } else if (match("(")) {
            isBindingElement =
                false;
            isAssignmentTarget = false;
            args = parseArguments();
            expr = (new WrappingNode(startToken)).finishCallExpression(expr, args)
        } else if (match("[")) {
            isBindingElement = false;
            isAssignmentTarget = true;
            property = parseComputedMember();
            expr = (new WrappingNode(startToken)).finishMemberExpression("[", expr, property)
        } else if (lookahead.type === Token.Template && lookahead.head) {
            quasi = parseTemplateLiteral();
            expr = (new WrappingNode(startToken)).finishTaggedTemplateExpression(expr, quasi)
        } else break;
        state.allowIn = previousAllowIn;
        return expr
    }

    function parseLeftHandSideExpression() {
        var quasi, expr, property, startToken;
        assert(state.allowIn, "callee of new expression always allow in keyword.");
        startToken = lookahead;
        if (matchKeyword("super") && state.inFunctionBody) {
            expr = new Node;
            lex();
            expr = expr.finishSuper();
            if (!match("[") && !match(".")) throwUnexpectedToken(lookahead)
        } else expr = inheritCoverGrammar(matchKeyword("new") ? parseNewExpression : parsePrimaryExpression);
        for (;;)
            if (match("[")) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property =
                    parseComputedMember();
                expr = (new WrappingNode(startToken)).finishMemberExpression("[", expr, property)
            } else if (match(".")) {
            isBindingElement = false;
            isAssignmentTarget = true;
            property = parseNonComputedMember();
            expr = (new WrappingNode(startToken)).finishMemberExpression(".", expr, property)
        } else if (lookahead.type === Token.Template && lookahead.head) {
            quasi = parseTemplateLiteral();
            expr = (new WrappingNode(startToken)).finishTaggedTemplateExpression(expr, quasi)
        } else break;
        return expr
    }

    function parsePostfixExpression() {
        var expr,
            token, startToken = lookahead;
        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);
        if (!hasLineTerminator && lookahead.type === Token.Punctuator)
            if (match("++") || match("--")) {
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) tolerateError(Messages.StrictLHSPostfix);
                if (!isAssignmentTarget) tolerateError(Messages.InvalidLHSInAssignment);
                isAssignmentTarget = isBindingElement = false;
                token = lex();
                expr = (new WrappingNode(startToken)).finishPostfixExpression(token.value, expr)
            }
        return expr
    }

    function parseUnaryExpression() {
        var token, expr, startToken;
        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) expr = parsePostfixExpression();
        else if (match("++") || match("--")) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) tolerateError(Messages.StrictLHSPrefix);
            if (!isAssignmentTarget) tolerateError(Messages.InvalidLHSInAssignment);
            expr = (new WrappingNode(startToken)).finishUnaryExpression(token.value,
                expr);
            isAssignmentTarget = isBindingElement = false
        } else if (match("+") || match("-") || match("~") || match("!")) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = (new WrappingNode(startToken)).finishUnaryExpression(token.value, expr);
            isAssignmentTarget = isBindingElement = false
        } else if (matchKeyword("delete") || matchKeyword("void") || matchKeyword("typeof")) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = (new WrappingNode(startToken)).finishUnaryExpression(token.value,
                expr);
            if (strict && expr.operator === "delete" && expr.argument.type === Syntax.Identifier) tolerateError(Messages.StrictDelete);
            isAssignmentTarget = isBindingElement = false
        } else expr = parsePostfixExpression();
        return expr
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;
        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) return 0;
        switch (token.value) {
            case "||":
                prec = 1;
                break;
            case "&&":
                prec = 2;
                break;
            case "|":
                prec = 3;
                break;
            case "^":
                prec = 4;
                break;
            case "&":
                prec = 5;
                break;
            case "==":
            case "!=":
            case "===":
            case "!==":
                prec =
                    6;
                break;
            case "<":
            case ">":
            case "<=":
            case ">=":
            case "instanceof":
                prec = 7;
                break;
            case "in":
                prec = allowIn ? 7 : 0;
                break;
            case "<<":
            case ">>":
            case ">>>":
                prec = 8;
                break;
            case "+":
            case "-":
                prec = 9;
                break;
            case "*":
            case "/":
            case "%":
                prec = 11;
                break;
            default:
                break
        }
        return prec
    }

    function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack, right, operator, left, i;
        marker = lookahead;
        left = inheritCoverGrammar(parseUnaryExpression);
        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) return left;
        isAssignmentTarget =
            isBindingElement = false;
        token.prec = prec;
        lex();
        markers = [marker, lookahead];
        right = isolateCoverGrammar(parseUnaryExpression);
        stack = [left, token, right];
        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {
            while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                markers.pop();
                expr = (new WrappingNode(markers[markers.length - 1])).finishBinaryExpression(operator, left, right);
                stack.push(expr)
            }
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(lookahead);
            expr = isolateCoverGrammar(parseUnaryExpression);
            stack.push(expr)
        }
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
            expr = (new WrappingNode(markers.pop())).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2
        }
        return expr
    }

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, startToken;
        startToken = lookahead;
        expr = inheritCoverGrammar(parseBinaryExpression);
        if (match("?")) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = isolateCoverGrammar(parseAssignmentExpression);
            state.allowIn = previousAllowIn;
            expect(":");
            alternate = isolateCoverGrammar(parseAssignmentExpression);
            expr = (new WrappingNode(startToken)).finishConditionalExpression(expr, consequent, alternate);
            isAssignmentTarget = isBindingElement = false
        }
        return expr
    }

    function parseConciseBody() {
        if (match("{")) return parseFunctionSourceElements();
        return isolateCoverGrammar(parseAssignmentExpression)
    }

    function checkPatternParam(options, param) {
        var i;
        switch (param.type) {
            case Syntax.Identifier:
                validateParam(options, param, param.name);
                break;
            case Syntax.RestElement:
                checkPatternParam(options, param.argument);
                break;
            case Syntax.AssignmentPattern:
                checkPatternParam(options, param.left);
                break;
            case Syntax.ArrayPattern:
                for (i = 0; i < param.elements.length; i++)
                    if (param.elements[i] !== null) checkPatternParam(options, param.elements[i]);
                break;
            case Syntax.YieldExpression:
                break;
            default:
                assert(param.type === Syntax.ObjectPattern, "Invalid type");
                for (i = 0; i < param.properties.length; i++) checkPatternParam(options, param.properties[i].value);
                break
        }
    }

    function reinterpretAsCoverFormalsList(expr) {
        var i,
            len, param, params, defaults, defaultCount, options, token;
        defaults = [];
        defaultCount = 0;
        params = [expr];
        switch (expr.type) {
            case Syntax.Identifier:
                break;
            case PlaceHolders.ArrowParameterPlaceHolder:
                params = expr.params;
                break;
            default:
                return null
        }
        options = {
            paramSet: {}
        };
        for (i = 0, len = params.length; i < len; i += 1) {
            param = params[i];
            switch (param.type) {
                case Syntax.AssignmentPattern:
                    params[i] = param.left;
                    if (param.right.type === Syntax.YieldExpression) {
                        if (param.right.argument) throwUnexpectedToken(lookahead);
                        param.right.type = Syntax.Identifier;
                        param.right.name = "yield";
                        delete param.right.argument;
                        delete param.right.delegate
                    }
                    defaults.push(param.right);
                    ++defaultCount;
                    checkPatternParam(options, param.left);
                    break;
                default:
                    checkPatternParam(options, param);
                    params[i] = param;
                    defaults.push(null);
                    break
            }
        }
        if (strict || !state.allowYield)
            for (i = 0, len = params.length; i < len; i += 1) {
                param = params[i];
                if (param.type === Syntax.YieldExpression) throwUnexpectedToken(lookahead)
            }
        if (options.message === Messages.StrictParamDupe) {
            token = strict ? options.stricted : options.firstRestricted;
            throwUnexpectedToken(token, options.message)
        }
        if (defaultCount === 0) defaults = [];
        return {
            params: params,
            defaults: defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        }
    }

    function parseArrowFunctionExpression(options, node) {
        var previousStrict, previousAllowYield, body;
        if (hasLineTerminator) tolerateUnexpectedToken(lookahead);
        expect("=>");
        previousStrict = strict;
        previousAllowYield = state.allowYield;
        state.allowYield = true;
        body = parseConciseBody();
        if (strict && options.firstRestricted) throwUnexpectedToken(options.firstRestricted,
            options.message);
        if (strict && options.stricted) tolerateUnexpectedToken(options.stricted, options.message);
        strict = previousStrict;
        state.allowYield = previousAllowYield;
        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement)
    }

    function parseYieldExpression() {
        var argument, expr, delegate, previousAllowYield;
        argument = null;
        expr = new Node;
        delegate = false;
        expectKeyword("yield");
        if (!hasLineTerminator) {
            previousAllowYield = state.allowYield;
            state.allowYield = false;
            delegate = match("*");
            if (delegate) {
                lex();
                argument = parseAssignmentExpression()
            } else if (!match(";") && !match("}") && !match(")") && lookahead.type !== Token.EOF) argument = parseAssignmentExpression();
            state.allowYield = previousAllowYield
        }
        return expr.finishYieldExpression(argument, delegate)
    }

    function parseAssignmentExpression() {
        var token, expr, right, list, startToken;
        startToken = lookahead;
        token = lookahead;
        if (!state.allowYield && matchKeyword("yield")) return parseYieldExpression();
        expr = parseConditionalExpression();
        if (expr.type ===
            PlaceHolders.ArrowParameterPlaceHolder || match("=>")) {
            isAssignmentTarget = isBindingElement = false;
            list = reinterpretAsCoverFormalsList(expr);
            if (list) {
                firstCoverInitializedNameError = null;
                return parseArrowFunctionExpression(list, new WrappingNode(startToken))
            }
            return expr
        }
        if (matchAssign()) {
            if (!isAssignmentTarget) tolerateError(Messages.InvalidLHSInAssignment);
            if (strict && expr.type === Syntax.Identifier) {
                if (isRestrictedWord(expr.name)) tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
                if (isStrictModeReservedWord(expr.name)) tolerateUnexpectedToken(token,
                    Messages.StrictReservedWord)
            }
            if (!match("=")) isAssignmentTarget = isBindingElement = false;
            else reinterpretExpressionAsPattern(expr);
            token = lex();
            right = isolateCoverGrammar(parseAssignmentExpression);
            expr = (new WrappingNode(startToken)).finishAssignmentExpression(token.value, expr, right);
            firstCoverInitializedNameError = null
        }
        return expr
    }

    function parseExpression() {
        var expr, startToken = lookahead,
            expressions;
        expr = isolateCoverGrammar(parseAssignmentExpression);
        if (match(",")) {
            expressions = [expr];
            while (startIndex < length) {
                if (!match(",")) break;
                lex();
                expressions.push(isolateCoverGrammar(parseAssignmentExpression))
            }
            expr = (new WrappingNode(startToken)).finishSequenceExpression(expressions)
        }
        return expr
    }

    function parseStatementListItem() {
        if (lookahead.type === Token.Keyword) switch (lookahead.value) {
            case "export":
                if (state.sourceType !== "module") tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);
                return parseExportDeclaration();
            case "import":
                if (state.sourceType !== "module") tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);
                return parseImportDeclaration();
            case "const":
                return parseLexicalDeclaration({
                    inFor: false
                });
            case "function":
                return parseFunctionDeclaration(new Node);
            case "class":
                return parseClassDeclaration()
        }
        if (matchKeyword("let") && isLexicalDeclaration()) return parseLexicalDeclaration({
            inFor: false
        });
        return parseStatement()
    }

    function parseStatementList() {
        var list = [];
        while (startIndex < length) {
            if (match("}")) break;
            list.push(parseStatementListItem())
        }
        return list
    }

    function parseBlock() {
        var block, node = new Node;
        expect("{");
        block = parseStatementList();
        expect("}");
        return node.finishBlockStatement(block)
    }

    function parseVariableIdentifier(kind) {
        var token, node = new Node;
        token = lex();
        if (token.type === Token.Keyword && token.value === "yield") {
            if (strict) tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            if (!state.allowYield) throwUnexpectedToken(token)
        } else if (token.type !== Token.Identifier)
            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            else {
                if (strict ||
                    token.value !== "let" || kind !== "var") throwUnexpectedToken(token)
            } else if (state.sourceType === "module" && token.type === Token.Identifier && token.value === "await") tolerateUnexpectedToken(token);
        return node.finishIdentifier(token.value)
    }

    function parseVariableDeclaration(options) {
        var init = null,
            id, node = new Node,
            params = [];
        id = parsePattern(params, "var");
        if (strict && isRestrictedWord(id.name)) tolerateError(Messages.StrictVarName);
        if (match("=")) {
            lex();
            init = isolateCoverGrammar(parseAssignmentExpression)
        } else if (id.type !==
            Syntax.Identifier && !options.inFor) expect("=");
        return node.finishVariableDeclarator(id, init)
    }

    function parseVariableDeclarationList(options) {
        var opt, list;
        opt = {
            inFor: options.inFor
        };
        list = [parseVariableDeclaration(opt)];
        while (match(",")) {
            lex();
            list.push(parseVariableDeclaration(opt))
        }
        return list
    }

    function parseVariableStatement(node) {
        var declarations;
        expectKeyword("var");
        declarations = parseVariableDeclarationList({
            inFor: false
        });
        consumeSemicolon();
        return node.finishVariableDeclaration(declarations)
    }

    function parseLexicalBinding(kind,
        options) {
        var init = null,
            id, node = new Node,
            params = [];
        id = parsePattern(params, kind);
        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) tolerateError(Messages.StrictVarName);
        if (kind === "const") {
            if (!matchKeyword("in") && !matchContextualKeyword("of")) {
                expect("=");
                init = isolateCoverGrammar(parseAssignmentExpression)
            }
        } else if (!options.inFor && id.type !== Syntax.Identifier || match("=")) {
            expect("=");
            init = isolateCoverGrammar(parseAssignmentExpression)
        }
        return node.finishVariableDeclarator(id, init)
    }

    function parseBindingList(kind,
        options) {
        var list = [parseLexicalBinding(kind, options)];
        while (match(",")) {
            lex();
            list.push(parseLexicalBinding(kind, options))
        }
        return list
    }

    function tokenizerState() {
        return {
            index: index,
            lineNumber: lineNumber,
            lineStart: lineStart,
            hasLineTerminator: hasLineTerminator,
            lastIndex: lastIndex,
            lastLineNumber: lastLineNumber,
            lastLineStart: lastLineStart,
            startIndex: startIndex,
            startLineNumber: startLineNumber,
            startLineStart: startLineStart,
            lookahead: lookahead,
            tokenCount: extra.tokens ? extra.tokens.length : 0
        }
    }

    function resetTokenizerState(ts) {
        index =
            ts.index;
        lineNumber = ts.lineNumber;
        lineStart = ts.lineStart;
        hasLineTerminator = ts.hasLineTerminator;
        lastIndex = ts.lastIndex;
        lastLineNumber = ts.lastLineNumber;
        lastLineStart = ts.lastLineStart;
        startIndex = ts.startIndex;
        startLineNumber = ts.startLineNumber;
        startLineStart = ts.startLineStart;
        lookahead = ts.lookahead;
        if (extra.tokens) extra.tokens.splice(ts.tokenCount, extra.tokens.length)
    }

    function isLexicalDeclaration() {
        var lexical, ts;
        ts = tokenizerState();
        lex();
        lexical = lookahead.type === Token.Identifier || match("[") || match("{") ||
            matchKeyword("let") || matchKeyword("yield");
        resetTokenizerState(ts);
        return lexical
    }

    function parseLexicalDeclaration(options) {
        var kind, declarations, node = new Node;
        kind = lex().value;
        assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
        declarations = parseBindingList(kind, options);
        consumeSemicolon();
        return node.finishLexicalDeclaration(declarations, kind)
    }

    function parseRestElement(params) {
        var param, node = new Node;
        lex();
        if (match("{")) throwError(Messages.ObjectPatternAsRestParameter);
        params.push(lookahead);
        param = parseVariableIdentifier();
        if (match("=")) throwError(Messages.DefaultRestParameter);
        if (!match(")")) throwError(Messages.ParameterAfterRestParameter);
        return node.finishRestElement(param)
    }

    function parseEmptyStatement(node) {
        expect(";");
        return node.finishEmptyStatement()
    }

    function parseExpressionStatement(node) {
        var expr = parseExpression();
        consumeSemicolon();
        return node.finishExpressionStatement(expr)
    }

    function parseIfStatement(node) {
        var test, consequent, alternate;
        expectKeyword("if");
        expect("(");
        test = parseExpression();
        expect(")");
        consequent = parseStatement();
        if (matchKeyword("else")) {
            lex();
            alternate = parseStatement()
        } else alternate = null;
        return node.finishIfStatement(test, consequent, alternate)
    }

    function parseDoWhileStatement(node) {
        var body, test, oldInIteration;
        expectKeyword("do");
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        expectKeyword("while");
        expect("(");
        test = parseExpression();
        expect(")");
        if (match(";")) lex();
        return node.finishDoWhileStatement(body,
            test)
    }

    function parseWhileStatement(node) {
        var test, body, oldInIteration;
        expectKeyword("while");
        expect("(");
        test = parseExpression();
        expect(")");
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        return node.finishWhileStatement(test, body)
    }

    function parseForStatement(node) {
        var init, forIn, initSeq, initStartToken, test, update, left, right, kind, declarations, body, oldInIteration, previousAllowIn = state.allowIn;
        init = test = update = null;
        forIn = true;
        expectKeyword("for");
        expect("(");
        if (match(";")) lex();
        else if (matchKeyword("var")) {
            init = new Node;
            lex();
            state.allowIn = false;
            declarations = parseVariableDeclarationList({
                inFor: true
            });
            state.allowIn = previousAllowIn;
            if (declarations.length === 1 && matchKeyword("in")) {
                init = init.finishVariableDeclaration(declarations);
                lex();
                left = init;
                right = parseExpression();
                init = null
            } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword("of")) {
                init = init.finishVariableDeclaration(declarations);
                lex();
                left = init;
                right = parseAssignmentExpression();
                init = null;
                forIn = false
            } else {
                init = init.finishVariableDeclaration(declarations);
                expect(";")
            }
        } else if (matchKeyword("const") || matchKeyword("let")) {
            init = new Node;
            kind = lex().value;
            if (!strict && lookahead.value === "in") {
                init = init.finishIdentifier(kind);
                lex();
                left = init;
                right = parseExpression();
                init = null
            } else {
                state.allowIn = false;
                declarations = parseBindingList(kind, {
                    inFor: true
                });
                state.allowIn = previousAllowIn;
                if (declarations.length === 1 && declarations[0].init === null && matchKeyword("in")) {
                    init = init.finishLexicalDeclaration(declarations,
                        kind);
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null
                } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword("of")) {
                    init = init.finishLexicalDeclaration(declarations, kind);
                    lex();
                    left = init;
                    right = parseAssignmentExpression();
                    init = null;
                    forIn = false
                } else {
                    consumeSemicolon();
                    init = init.finishLexicalDeclaration(declarations, kind)
                }
            }
        } else {
            initStartToken = lookahead;
            state.allowIn = false;
            init = inheritCoverGrammar(parseAssignmentExpression);
            state.allowIn = previousAllowIn;
            if (matchKeyword("in")) {
                if (!isAssignmentTarget) tolerateError(Messages.InvalidLHSInForIn);
                lex();
                reinterpretExpressionAsPattern(init);
                left = init;
                right = parseExpression();
                init = null
            } else if (matchContextualKeyword("of")) {
                if (!isAssignmentTarget) tolerateError(Messages.InvalidLHSInForLoop);
                lex();
                reinterpretExpressionAsPattern(init);
                left = init;
                right = parseAssignmentExpression();
                init = null;
                forIn = false
            } else {
                if (match(",")) {
                    initSeq = [init];
                    while (match(",")) {
                        lex();
                        initSeq.push(isolateCoverGrammar(parseAssignmentExpression))
                    }
                    init = (new WrappingNode(initStartToken)).finishSequenceExpression(initSeq)
                }
                expect(";")
            }
        }
        if (typeof left ===
            "undefined") {
            if (!match(";")) test = parseExpression();
            expect(";");
            if (!match(")")) update = parseExpression()
        }
        expect(")");
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = isolateCoverGrammar(parseStatement);
        state.inIteration = oldInIteration;
        return typeof left === "undefined" ? node.finishForStatement(init, test, update, body) : forIn ? node.finishForInStatement(left, right, body) : node.finishForOfStatement(left, right, body)
    }

    function parseContinueStatement(node) {
        var label = null,
            key;
        expectKeyword("continue");
        if (source.charCodeAt(startIndex) ===
            59) {
            lex();
            if (!state.inIteration) throwError(Messages.IllegalContinue);
            return node.finishContinueStatement(null)
        }
        if (hasLineTerminator) {
            if (!state.inIteration) throwError(Messages.IllegalContinue);
            return node.finishContinueStatement(null)
        }
        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();
            key = "$" + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) throwError(Messages.UnknownLabel, label.name)
        }
        consumeSemicolon();
        if (label === null && !state.inIteration) throwError(Messages.IllegalContinue);
        return node.finishContinueStatement(label)
    }

    function parseBreakStatement(node) {
        var label = null,
            key;
        expectKeyword("break");
        if (source.charCodeAt(lastIndex) === 59) {
            lex();
            if (!(state.inIteration || state.inSwitch)) throwError(Messages.IllegalBreak);
            return node.finishBreakStatement(null)
        }
        if (hasLineTerminator) {
            if (!(state.inIteration || state.inSwitch)) throwError(Messages.IllegalBreak)
        } else if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();
            key = "$" + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet,
                    key)) throwError(Messages.UnknownLabel, label.name)
        }
        consumeSemicolon();
        if (label === null && !(state.inIteration || state.inSwitch)) throwError(Messages.IllegalBreak);
        return node.finishBreakStatement(label)
    }

    function parseReturnStatement(node) {
        var argument = null;
        expectKeyword("return");
        if (!state.inFunctionBody) tolerateError(Messages.IllegalReturn);
        if (source.charCodeAt(lastIndex) === 32)
            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return node.finishReturnStatement(argument)
            }
        if (hasLineTerminator) return node.finishReturnStatement(null);
        if (!match(";"))
            if (!match("}") && lookahead.type !== Token.EOF) argument = parseExpression();
        consumeSemicolon();
        return node.finishReturnStatement(argument)
    }

    function parseWithStatement(node) {
        var object, body;
        if (strict) tolerateError(Messages.StrictModeWith);
        expectKeyword("with");
        expect("(");
        object = parseExpression();
        expect(")");
        body = parseStatement();
        return node.finishWithStatement(object, body)
    }

    function parseSwitchCase() {
        var test, consequent = [],
            statement, node = new Node;
        if (matchKeyword("default")) {
            lex();
            test = null
        } else {
            expectKeyword("case");
            test = parseExpression()
        }
        expect(":");
        while (startIndex < length) {
            if (match("}") || matchKeyword("default") || matchKeyword("case")) break;
            statement = parseStatementListItem();
            consequent.push(statement)
        }
        return node.finishSwitchCase(test, consequent)
    }

    function parseSwitchStatement(node) {
        var discriminant, cases, clause, oldInSwitch, defaultFound;
        expectKeyword("switch");
        expect("(");
        discriminant = parseExpression();
        expect(")");
        expect("{");
        cases = [];
        if (match("}")) {
            lex();
            return node.finishSwitchStatement(discriminant, cases)
        }
        oldInSwitch =
            state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;
        while (startIndex < length) {
            if (match("}")) break;
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) throwError(Messages.MultipleDefaultsInSwitch);
                defaultFound = true
            }
            cases.push(clause)
        }
        state.inSwitch = oldInSwitch;
        expect("}");
        return node.finishSwitchStatement(discriminant, cases)
    }

    function parseThrowStatement(node) {
        var argument;
        expectKeyword("throw");
        if (hasLineTerminator) throwError(Messages.NewlineAfterThrow);
        argument = parseExpression();
        consumeSemicolon();
        return node.finishThrowStatement(argument)
    }

    function parseCatchClause() {
        var param, params = [],
            paramMap = {},
            key, i, body, node = new Node;
        expectKeyword("catch");
        expect("(");
        if (match(")")) throwUnexpectedToken(lookahead);
        param = parsePattern(params);
        for (i = 0; i < params.length; i++) {
            key = "$" + params[i].value;
            if (Object.prototype.hasOwnProperty.call(paramMap, key)) tolerateError(Messages.DuplicateBinding, params[i].value);
            paramMap[key] = true
        }
        if (strict && isRestrictedWord(param.name)) tolerateError(Messages.StrictCatchVariable);
        expect(")");
        body = parseBlock();
        return node.finishCatchClause(param, body)
    }

    function parseTryStatement(node) {
        var block, handler = null,
            finalizer = null;
        expectKeyword("try");
        block = parseBlock();
        if (matchKeyword("catch")) handler = parseCatchClause();
        if (matchKeyword("finally")) {
            lex();
            finalizer = parseBlock()
        }
        if (!handler && !finalizer) throwError(Messages.NoCatchOrFinally);
        return node.finishTryStatement(block, handler, finalizer)
    }

    function parseDebuggerStatement(node) {
        expectKeyword("debugger");
        consumeSemicolon();
        return node.finishDebuggerStatement()
    }

    function parseStatement() {
        var type = lookahead.type,
            expr, labeledBody, key, node;
        if (type === Token.EOF) throwUnexpectedToken(lookahead);
        if (type === Token.Punctuator && lookahead.value === "{") return parseBlock();
        isAssignmentTarget = isBindingElement = true;
        node = new Node;
        if (type === Token.Punctuator) switch (lookahead.value) {
                case ";":
                    return parseEmptyStatement(node);
                case "(":
                    return parseExpressionStatement(node);
                default:
                    break
            } else if (type === Token.Keyword) switch (lookahead.value) {
                case "break":
                    return parseBreakStatement(node);
                case "continue":
                    return parseContinueStatement(node);
                case "debugger":
                    return parseDebuggerStatement(node);
                case "do":
                    return parseDoWhileStatement(node);
                case "for":
                    return parseForStatement(node);
                case "function":
                    return parseFunctionDeclaration(node);
                case "if":
                    return parseIfStatement(node);
                case "return":
                    return parseReturnStatement(node);
                case "switch":
                    return parseSwitchStatement(node);
                case "throw":
                    return parseThrowStatement(node);
                case "try":
                    return parseTryStatement(node);
                case "var":
                    return parseVariableStatement(node);
                case "while":
                    return parseWhileStatement(node);
                case "with":
                    return parseWithStatement(node);
                default:
                    break
            }
            expr = parseExpression();
        if (expr.type === Syntax.Identifier && match(":")) {
            lex();
            key = "$" + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) throwError(Messages.Redeclaration, "Label", expr.name);
            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return node.finishLabeledStatement(expr, labeledBody)
        }
        consumeSemicolon();
        return node.finishExpressionStatement(expr)
    }

    function parseFunctionSourceElements() {
        var statement, body = [],
            token, directive, firstRestricted, oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, node = new Node;
        expect("{");
        while (startIndex < length) {
            if (lookahead.type !== Token.StringLiteral) break;
            token = lookahead;
            statement = parseStatementListItem();
            body.push(statement);
            if (statement.expression.type !== Syntax.Literal) break;
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === "use strict") {
                strict = true;
                if (firstRestricted) tolerateUnexpectedToken(firstRestricted,
                    Messages.StrictOctalLiteral)
            } else if (!firstRestricted && token.octal) firstRestricted = token
        }
        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        while (startIndex < length) {
            if (match("}")) break;
            body.push(parseStatementListItem())
        }
        expect("}");
        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody =
            oldInFunctionBody;
        return node.finishBlockStatement(body)
    }

    function validateParam(options, param, name) {
        var key = "$" + name;
        if (strict) {
            if (isRestrictedWord(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamName
            }
            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe
            }
        } else if (!options.firstRestricted)
            if (isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamName
            } else if (isStrictModeReservedWord(name)) {
            options.firstRestricted =
                param;
            options.message = Messages.StrictReservedWord
        } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
            options.stricted = param;
            options.message = Messages.StrictParamDupe
        }
        options.paramSet[key] = true
    }

    function parseParam(options) {
        var token, param, params = [],
            i, def;
        token = lookahead;
        if (token.value === "...") {
            param = parseRestElement(params);
            validateParam(options, param.argument, param.argument.name);
            options.params.push(param);
            options.defaults.push(null);
            return false
        }
        param = parsePatternWithDefault(params);
        for (i = 0; i < params.length; i++) validateParam(options, params[i], params[i].value);
        if (param.type === Syntax.AssignmentPattern) {
            def = param.right;
            param = param.left;
            ++options.defaultCount
        }
        options.params.push(param);
        options.defaults.push(def);
        return !match(")")
    }

    function parseParams(firstRestricted) {
        var options;
        options = {
            params: [],
            defaultCount: 0,
            defaults: [],
            firstRestricted: firstRestricted
        };
        expect("(");
        if (!match(")")) {
            options.paramSet = {};
            while (startIndex < length) {
                if (!parseParam(options)) break;
                expect(",")
            }
        }
        expect(")");
        if (options.defaultCount === 0) options.defaults = [];
        return {
            params: options.params,
            defaults: options.defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        }
    }

    function parseFunctionDeclaration(node, identifierIsOptional) {
        var id = null,
            params = [],
            defaults = [],
            body, token, stricted, tmp, firstRestricted, message, previousStrict, isGenerator, previousAllowYield;
        previousAllowYield = state.allowYield;
        expectKeyword("function");
        isGenerator = match("*");
        if (isGenerator) lex();
        if (!identifierIsOptional ||
            !match("(")) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) tolerateUnexpectedToken(token, Messages.StrictFunctionName)
            } else if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName
            } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord
            }
        }
        state.allowYield = !isGenerator;
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted =
            tmp.firstRestricted;
        if (tmp.message) message = tmp.message;
        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) throwUnexpectedToken(firstRestricted, message);
        if (strict && stricted) tolerateUnexpectedToken(stricted, message);
        strict = previousStrict;
        state.allowYield = previousAllowYield;
        return node.finishFunctionDeclaration(id, params, defaults, body, isGenerator)
    }

    function parseFunctionExpression() {
        var token, id = null,
            stricted, firstRestricted, message, tmp, params = [],
            defaults = [],
            body, previousStrict,
            node = new Node,
            isGenerator, previousAllowYield;
        previousAllowYield = state.allowYield;
        expectKeyword("function");
        isGenerator = match("*");
        if (isGenerator) lex();
        state.allowYield = !isGenerator;
        if (!match("(")) {
            token = lookahead;
            id = !strict && !isGenerator && matchKeyword("yield") ? parseNonComputedProperty() : parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) tolerateUnexpectedToken(token, Messages.StrictFunctionName)
            } else if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName
            } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted =
                    token;
                message = Messages.StrictReservedWord
            }
        }
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) message = tmp.message;
        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) throwUnexpectedToken(firstRestricted, message);
        if (strict && stricted) tolerateUnexpectedToken(stricted, message);
        strict = previousStrict;
        state.allowYield = previousAllowYield;
        return node.finishFunctionExpression(id, params,
            defaults, body, isGenerator)
    }

    function parseClassBody() {
        var classBody, token, isStatic, hasConstructor = false,
            body, method, computed, key;
        classBody = new Node;
        expect("{");
        body = [];
        while (!match("}"))
            if (match(";")) lex();
            else {
                method = new Node;
                token = lookahead;
                isStatic = false;
                computed = match("[");
                if (match("*")) lex();
                else {
                    key = parseObjectPropertyKey();
                    if (key.name === "static" && (lookaheadPropertyName() || match("*"))) {
                        token = lookahead;
                        isStatic = true;
                        computed = match("[");
                        if (match("*")) lex();
                        else key = parseObjectPropertyKey()
                    }
                }
                method =
                    tryParseMethodDefinition(token, key, computed, method);
                if (method) {
                    method["static"] = isStatic;
                    if (method.kind === "init") method.kind = "method";
                    if (!isStatic) {
                        if (!method.computed && (method.key.name || method.key.value.toString()) === "constructor") {
                            if (method.kind !== "method" || !method.method || method.value.generator) throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);
                            if (hasConstructor) throwUnexpectedToken(token, Messages.DuplicateConstructor);
                            else hasConstructor = true;
                            method.kind = "constructor"
                        }
                    } else if (!method.computed &&
                        (method.key.name || method.key.value.toString()) === "prototype") throwUnexpectedToken(token, Messages.StaticPrototype);
                    method.type = Syntax.MethodDefinition;
                    delete method.method;
                    delete method.shorthand;
                    body.push(method)
                } else throwUnexpectedToken(lookahead)
            }
        lex();
        return classBody.finishClassBody(body)
    }

    function parseClassDeclaration(identifierIsOptional) {
        var id = null,
            superClass = null,
            classNode = new Node,
            classBody, previousStrict = strict;
        strict = true;
        expectKeyword("class");
        if (!identifierIsOptional || lookahead.type ===
            Token.Identifier) id = parseVariableIdentifier();
        if (matchKeyword("extends")) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall)
        }
        classBody = parseClassBody();
        strict = previousStrict;
        return classNode.finishClassDeclaration(id, superClass, classBody)
    }

    function parseClassExpression() {
        var id = null,
            superClass = null,
            classNode = new Node,
            classBody, previousStrict = strict;
        strict = true;
        expectKeyword("class");
        if (lookahead.type === Token.Identifier) id = parseVariableIdentifier();
        if (matchKeyword("extends")) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall)
        }
        classBody = parseClassBody();
        strict = previousStrict;
        return classNode.finishClassExpression(id, superClass, classBody)
    }

    function parseModuleSpecifier() {
        var node = new Node;
        if (lookahead.type !== Token.StringLiteral) throwError(Messages.InvalidModuleSpecifier);
        return node.finishLiteral(lex())
    }

    function parseExportSpecifier() {
        var exported, local, node = new Node,
            def;
        if (matchKeyword("default")) {
            def = new Node;
            lex();
            local = def.finishIdentifier("default")
        } else local =
            parseVariableIdentifier();
        if (matchContextualKeyword("as")) {
            lex();
            exported = parseNonComputedProperty()
        }
        return node.finishExportSpecifier(local, exported)
    }

    function parseExportNamedDeclaration(node) {
        var declaration = null,
            isExportFromIdentifier, src = null,
            specifiers = [];
        if (lookahead.type === Token.Keyword) switch (lookahead.value) {
            case "let":
            case "const":
                declaration = parseLexicalDeclaration({
                    inFor: false
                });
                return node.finishExportNamedDeclaration(declaration, specifiers, null);
            case "var":
            case "class":
            case "function":
                declaration =
                    parseStatementListItem();
                return node.finishExportNamedDeclaration(declaration, specifiers, null)
        }
        expect("{");
        while (!match("}")) {
            isExportFromIdentifier = isExportFromIdentifier || matchKeyword("default");
            specifiers.push(parseExportSpecifier());
            if (!match("}")) {
                expect(",");
                if (match("}")) break
            }
        }
        expect("}");
        if (matchContextualKeyword("from")) {
            lex();
            src = parseModuleSpecifier();
            consumeSemicolon()
        } else if (isExportFromIdentifier) throwError(lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        else consumeSemicolon();
        return node.finishExportNamedDeclaration(declaration, specifiers, src)
    }

    function parseExportDefaultDeclaration(node) {
        var declaration = null,
            expression = null;
        expectKeyword("default");
        if (matchKeyword("function")) {
            declaration = parseFunctionDeclaration(new Node, true);
            return node.finishExportDefaultDeclaration(declaration)
        }
        if (matchKeyword("class")) {
            declaration = parseClassDeclaration(true);
            return node.finishExportDefaultDeclaration(declaration)
        }
        if (matchContextualKeyword("from")) throwError(Messages.UnexpectedToken,
            lookahead.value);
        if (match("{")) expression = parseObjectInitializer();
        else if (match("[")) expression = parseArrayInitializer();
        else expression = parseAssignmentExpression();
        consumeSemicolon();
        return node.finishExportDefaultDeclaration(expression)
    }

    function parseExportAllDeclaration(node) {
        var src;
        expect("*");
        if (!matchContextualKeyword("from")) throwError(lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        lex();
        src = parseModuleSpecifier();
        consumeSemicolon();
        return node.finishExportAllDeclaration(src)
    }

    function parseExportDeclaration() {
        var node = new Node;
        if (state.inFunctionBody) throwError(Messages.IllegalExportDeclaration);
        expectKeyword("export");
        if (matchKeyword("default")) return parseExportDefaultDeclaration(node);
        if (match("*")) return parseExportAllDeclaration(node);
        return parseExportNamedDeclaration(node)
    }

    function parseImportSpecifier() {
        var local, imported, node = new Node;
        imported = parseNonComputedProperty();
        if (matchContextualKeyword("as")) {
            lex();
            local = parseVariableIdentifier()
        }
        return node.finishImportSpecifier(local,
            imported)
    }

    function parseNamedImports() {
        var specifiers = [];
        expect("{");
        while (!match("}")) {
            specifiers.push(parseImportSpecifier());
            if (!match("}")) {
                expect(",");
                if (match("}")) break
            }
        }
        expect("}");
        return specifiers
    }

    function parseImportDefaultSpecifier() {
        var local, node = new Node;
        local = parseNonComputedProperty();
        return node.finishImportDefaultSpecifier(local)
    }

    function parseImportNamespaceSpecifier() {
        var local, node = new Node;
        expect("*");
        if (!matchContextualKeyword("as")) throwError(Messages.NoAsAfterImportNamespace);
        lex();
        local = parseNonComputedProperty();
        return node.finishImportNamespaceSpecifier(local)
    }

    function parseImportDeclaration() {
        var specifiers = [],
            src, node = new Node;
        if (state.inFunctionBody) throwError(Messages.IllegalImportDeclaration);
        expectKeyword("import");
        if (lookahead.type === Token.StringLiteral) src = parseModuleSpecifier();
        else {
            if (match("{")) specifiers = specifiers.concat(parseNamedImports());
            else if (match("*")) specifiers.push(parseImportNamespaceSpecifier());
            else if (isIdentifierName(lookahead) && !matchKeyword("default")) {
                specifiers.push(parseImportDefaultSpecifier());
                if (match(",")) {
                    lex();
                    if (match("*")) specifiers.push(parseImportNamespaceSpecifier());
                    else if (match("{")) specifiers = specifiers.concat(parseNamedImports());
                    else throwUnexpectedToken(lookahead)
                }
            } else throwUnexpectedToken(lex());
            if (!matchContextualKeyword("from")) throwError(lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
            lex();
            src = parseModuleSpecifier()
        }
        consumeSemicolon();
        return node.finishImportDeclaration(specifiers, src)
    }

    function parseScriptBody() {
        var statement, body = [],
            token, directive, firstRestricted;
        while (startIndex < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) break;
            statement = parseStatementListItem();
            body.push(statement);
            if (statement.expression.type !== Syntax.Literal) break;
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === "use strict") {
                strict = true;
                if (firstRestricted) tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral)
            } else if (!firstRestricted && token.octal) firstRestricted = token
        }
        while (startIndex < length) {
            statement = parseStatementListItem();
            if (typeof statement === "undefined") break;
            body.push(statement)
        }
        return body
    }

    function parseProgram() {
        var body, node;
        peek();
        node = new Node;
        body = parseScriptBody();
        return node.finishProgram(body, state.sourceType)
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];
        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (entry.regex) token.regex = {
                pattern: entry.regex.pattern,
                flags: entry.regex.flags
            };
            if (extra.range) token.range = entry.range;
            if (extra.loc) token.loc =
                entry.loc;
            tokens.push(token)
        }
        extra.tokens = tokens
    }

    function tokenize(code, options, delegate) {
        var toString, tokens;
        toString = String;
        if (typeof code !== "string" && !(code instanceof String)) code = toString(code);
        source = code;
        index = 0;
        lineNumber = source.length > 0 ? 1 : 0;
        lineStart = 0;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            allowYield: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1,
            curlyStack: []
        };
        extra = {};
        options = options || {};
        options.tokens = true;
        extra.tokens = [];
        extra.tokenValues = [];
        extra.tokenize = true;
        extra.delegate = delegate;
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;
        extra.range = typeof options.range === "boolean" && options.range;
        extra.loc = typeof options.loc === "boolean" && options.loc;
        if (typeof options.comment === "boolean" && options.comment) extra.comments = [];
        if (typeof options.tolerant === "boolean" && options.tolerant) extra.errors = [];
        try {
            peek();
            if (lookahead.type === Token.EOF) return extra.tokens;
            lex();
            while (lookahead.type !== Token.EOF) try {
                lex()
            } catch (lexError) {
                if (extra.errors) {
                    recordError(lexError);
                    break
                } else throw lexError;
            }
            tokens = extra.tokens;
            if (typeof extra.errors !== "undefined") tokens.errors = extra.errors
        } catch (e) {
            throw e;
        } finally {
            extra = {}
        }
        return tokens
    }

    function parse(code, options) {
        var program, toString;
        toString = String;
        if (typeof code !== "string" && !(code instanceof String)) code = toString(code);
        source = code;
        index = 0;
        lineNumber = source.length > 0 ? 1 : 0;
        lineStart = 0;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            allowYield: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1,
            curlyStack: [],
            sourceType: "script"
        };
        strict = false;
        extra = {};
        if (typeof options !== "undefined") {
            extra.range = typeof options.range === "boolean" && options.range;
            extra.loc = typeof options.loc === "boolean" && options.loc;
            extra.attachComment = typeof options.attachComment === "boolean" && options.attachComment;
            if (extra.loc && options.source !==
                null && options.source !== undefined) extra.source = toString(options.source);
            if (typeof options.tokens === "boolean" && options.tokens) extra.tokens = [];
            if (typeof options.comment === "boolean" && options.comment) extra.comments = [];
            if (typeof options.tolerant === "boolean" && options.tolerant) extra.errors = [];
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = []
            }
            if (options.sourceType === "module") {
                state.sourceType = options.sourceType;
                strict = true
            }
        }
        try {
            program =
                parseProgram();
            if (typeof extra.comments !== "undefined") program.comments = extra.comments;
            if (typeof extra.tokens !== "undefined") {
                filterTokenLocation();
                program.tokens = extra.tokens
            }
            if (typeof extra.errors !== "undefined") program.errors = extra.errors
        } catch (e) {
            throw e;
        } finally {
            extra = {}
        }
        return program
    }
    exports.version = "2.7.2";
    exports.tokenize = tokenize;
    exports.parse = parse;
    exports.Syntax = function() {
        var name, types = {};
        if (typeof Object.create === "function") types = Object.create(null);
        for (name in Syntax)
            if (Syntax.hasOwnProperty(name)) types[name] =
                Syntax[name];
        if (typeof Object.freeze === "function") Object.freeze(types);
        return types
    }()
});
(function(fn) {
    if (typeof define !== "undefined") define(["bower_components/esprima/esprima"], fn);
    else if (typeof module !== "undefined") module.exports = fn(require("esprima"));
    else if (typeof esprima !== "undefined") window.metaes = fn(esprima);
    else throw new Error("esprima is not loaded.");
})(function(esprima) {
    function clone(from) {
        var to = {};
        for (var i in from)
            if (from.hasOwnProperty(i)) to[i] = from[i];
        return to
    }
    var tokens = {
        VariableDeclaration: function(e, env, c, cerr) {
            delayEvaluate(e.declarations, env, function() {
                    c()
                },
                cerr)
        },
        VariableDeclarator: function(e, env, c, cerr) {
            setValue(env, e.id.name, undefined, true);
            env.variables = env.variables || {};
            env.variables[e.id.name] = e.id;
            if (e.init) delayEvaluate(e.init, env, function(val) {
                setValue(env, e.id.name, val, false);
                c(val, e.id.name)
            }, cerr);
            else c(undefined, e.id.name)
        },
        EmptyStatement: function(e, env, c, cerr) {
            c()
        },
        FunctionExpression: function(e, env, c, cerr) {
            c(new MetaFunction(e, env))
        },
        FunctionDeclaration: function(e, env, c, cerr) {
            c(new MetaFunction(e, env))
        },
        Literal: function(e, env, c, cerr) {
            c(e.value)
        },
        Identifier: function(e, env, c, cerr) {
            try {
                function foundName(pair) {
                    var value = pair[0],
                        container = pair[1];
                    c(value, container, e.name)
                }
                getValue(env, e.name, true, foundName, cerr)
            } catch (error) {
                cerr("Error", error, e)
            }
        },
        BinaryExpression: function(e, env, c, cerr) {
            delayEvaluate(e.left, env, function(left) {
                delayEvaluate(e.right, env, function(right) {
                    try {
                        var value;
                        switch (e.operator) {
                            case "+":
                                value = left + right;
                                break;
                            case "-":
                                value = left - right;
                                break;
                            case "===":
                                value = left === right;
                                break;
                            case "==":
                                value = left == right;
                                break;
                            case "!==":
                                value =
                                    left !== right;
                                break;
                            case "!=":
                                value = left != right;
                                break;
                            case "<":
                                value = left < right;
                                break;
                            case "<=":
                                value = left <= right;
                                break;
                            case ">":
                                value = left > right;
                                break;
                            case ">=":
                                value = left >= right;
                                break;
                            case "*":
                                value = left * right;
                                break;
                            case "/":
                                value = left / right;
                                break;
                            case "instanceof":
                                value = left instanceof right;
                                break;
                            case "in":
                                value = left in right;
                                break;
                            case "^":
                                value = left ^ right;
                                break;
                            case "<<":
                                value = left << right;
                                break;
                            case ">>":
                                value = left >> right;
                                break;
                            case ">>>":
                                value = left >>> right;
                                break;
                            case "%":
                                value = left % right;
                                break;
                            case "&":
                                value = left & right;
                                break;
                            case "|":
                                value = left | right;
                                break;
                            default:
                                throw new Error(e.type + " not implemented " + e.operator);
                        }
                        c(value, left, right)
                    } catch (e) {
                        cerr("Error", e)
                    }
                }, cerr)
            }, cerr)
        },
        LogicalExpression: function(e, env, c, cerr) {
            delayEvaluate(e.left, env, function(left) {
                if (!left && e.operator === "&&") c(left);
                else if (left && e.operator === "||") c(left);
                else delayEvaluate(e.right, env, c, cerr)
            }, cerr)
        },
        UnaryExpression: function(e, env, c, cerr) {
            var noSuchReference = {};

            function success(argument, obj, propName) {
                try {
                    var envCopy =
                        env,
                        foundWithEnvironment;
                    while (envCopy.prev) {
                        if (envCopy.type === "WithStatement") foundWithEnvironment = envCopy;
                        envCopy = envCopy.prev
                    }
                    var global = envCopy,
                        value;
                    switch (e.operator) {
                        case "delete":
                            if (obj && obj === env.arguments && propName !== "length") env.paramsNames[propName] = void 0;
                            if (e.argument.type === "Literal" || e.argument.type === "CallExpression" || e.argument.type === "ObjectExpression" || propName === "this" || argument === noSuchReference) value = true;
                            else if (foundWithEnvironment) {
                                var obj2 = obj;
                                if (propName in foundWithEnvironment.names) obj2 =
                                    foundWithEnvironment.names;
                                value = delete obj2[propName]
                            } else if (obj === global.names || e.argument.type !== "Identifier") value = delete obj[propName];
                            else value = false;
                            break;
                        case "typeof":
                            value = typeof argument;
                            break;
                        case "-":
                            value = -argument;
                            break;
                        case "!":
                            value = !argument;
                            break;
                        case "+":
                            value = +argument;
                            break;
                        case "~":
                            value = ~argument;
                            break;
                        case "void":
                            value = void argument;
                            break;
                        default:
                            throw new Error("not implemented " + e.operator);
                    }
                    c(value)
                } catch (e) {
                    cerr("Error", e)
                }
            }

            function error(argument, obj, propName) {
                switch (e.operator) {
                    case "typeof":
                        c("undefined");
                        break;
                    case "delete":
                        if (e.argument.type === "MemberExpression" && obj instanceof ReferenceError) cerr.apply(null, arguments);
                        else success(noSuchReference, obj, propName);
                        break;
                    default:
                        cerr.apply(null, arguments);
                        break
                }
            }
            delayEvaluate(e.argument, env, success, error)
        },
        LabeledStatement: function(e, env, c, cerr) {
            delayEvaluate(e.body, env, c, function(type, labelName, continuation) {
                if (e.label.name && e.label.name === labelName)
                    if (type === "ContinueStatement") continuation();
                    else {
                        if (type === "BreakStatement") c()
                    } else cerr.apply(null,
                    arguments)
            })
        },
        ForStatement: function(e, env, c, cerr) {
            var bodyResults = [];
            if (e.init) delayEvaluate(e.init, env, loop_, cerr);
            else if (e.type === "WhileStatement") loop_();
            else startBody();

            function bodyC(result) {
                bodyResults.push(result);
                if (e.update) delayEvaluate(e.update, env, loop_, cerr);
                else loop_(e, env)
            }

            function updateAndContinue(c) {
                if (e.update) delayEvaluate(e.update, env, function() {
                    c.apply(null, bodyResults.reverse())
                }, cerr);
                else c.apply(null, bodyResults.reverse())
            }

            function bodyCerr(errorType, value, extra) {
                switch (errorType) {
                    case "BreakStatement":
                        if (typeof value ===
                            "undefined") c.apply(null, extra.length ? extra : [bodyResults.pop()]);
                        else cerr(errorType, value, loop_);
                        break;
                    case "ContinueStatement":
                        if (typeof value === "undefined") updateAndContinue(loop_);
                        else updateAndContinue(function() {
                            cerr(errorType, value, loop_)
                        });
                        break;
                    default:
                        cerr.apply(null, arguments);
                        break
                }
            }

            function evaluateBody() {
                delayEvaluate(e.body, env, bodyC, bodyCerr)
            }

            function loop_() {
                if (e.test) delayEvaluate(e.test, env, function(bool) {
                    if (bool) evaluateBody();
                    else c(bodyResults.reverse())
                }, cerr);
                else evaluateBody()
            }

            function startBody() {
                evaluateBody()
            }
        },
        BreakStatement: function(e, env, c, cerr) {
            cerr(e.type, e.label ? e.label.name : undefined)
        },
        ContinueStatement: function(e, env, c, cerr) {
            cerr(e.type, e.label ? e.label.name : undefined)
        },
        ForInStatement: function(e, env, c, cerr) {
            function rightHandSide() {
                delayEvaluate(e.right, env, function(right) {
                    var leftHandSide = e.left.type === "VariableDeclaration" ? e.left.declarations[0].id : e.left,
                        results = [];
                    for (var i in right) results.push(e.type === "ForOfStatement" ? right[i] : i);

                    function assignment(value) {
                        return {
                            "type": "AssignmentExpression",
                            "operator": "=",
                            "left": leftHandSide,
                            "right": {
                                "type": "Literal",
                                "value": value,
                                "raw": '"' + value + '"'
                            }
                        }
                    }

                    function bodyCerr(errorType, value, extra) {
                        switch (errorType) {
                            case "BreakStatement":
                                if (typeof value === "undefined") c();
                                else cerr(errorType, value);
                                break;
                            case "ContinueStatement":
                                if (typeof value === "undefined") loop_();
                                else cerr(errorType, value);
                                break;
                            default:
                                cerr.apply(null, arguments);
                                break
                        }
                    }
                    var loopResults;

                    function loop_(result) {
                        if (loopResults) loopResults.push(result);
                        else loopResults = [];
                        if (results.length) delayEvaluate(assignment(results.shift()),
                            env,
                            function() {
                                delayEvaluate(e.body, env, loop_, bodyCerr)
                            }, cerr);
                        else c(loopResults.pop())
                    }
                    loop_()
                }, cerr)
            }
            delayEvaluate(e.left, env, rightHandSide, function(errorType, value) {
                if (errorType === "Error" && value instanceof ReferenceError) {
                    setValue(env, e.left.name, undefined, false);
                    rightHandSide()
                } else cerr.apply(null, arguments)
            })
        },
        WhileStatement: function(e, env, c, cerr) {
            tokens.ForStatement(e, env, c, cerr)
        },
        DoWhileStatement: function(e, env, c, cerr) {
            tokens.ForStatement(e, env, c, cerr)
        },
        ExpressionStatement: function(e, env,
            c, cerr) {
            delayEvaluate(e.expression, env, c, cerr)
        },
        ObjectExpression: function(e, env, c, cerr) {
            delayEvaluate(e.properties, env, function(properties) {
                var objectProperties = Object.create(null);
                for (var i = 0; i < properties.length; i++) {
                    var key = properties[i].key,
                        kind = e.properties[i].kind;
                    if (["get", "set"].indexOf(kind) >= 0) {
                        objectProperties[key] = objectProperties[key] || {};
                        objectProperties[key].enumerable = true;
                        objectProperties[key].configurable = true;
                        objectProperties[key][kind] = properties[i].value
                    } else objectProperties[properties[i].key] = {
                        value: properties[i].value,
                        configurable: true,
                        writable: true,
                        enumerable: true
                    }
                }
                c(Object.create(Object.prototype, objectProperties))
            }, cerr)
        },
        Property: function(e, env, c, cerr) {
            function continueToValue(key) {
                key = e.key.name || key;
                delayEvaluate(e.value, env, function(value) {
                    c({
                        key: key,
                        value: value
                    })
                }, cerr)
            }
            delayEvaluate(e.key, env, continueToValue, continueToValue)
        },
        AssignmentExpression: function(e, env, c, cerr) {
            delayEvaluate(e.right, env, function(right) {
                function assignToMemberExpression(obj, propName, c) {
                    var value;
                    switch (e.operator) {
                        case "=":
                            value =
                                obj[propName] = right;
                            break;
                        case "+=":
                            value = obj[propName] += right;
                            break;
                        case "-=":
                            value = obj[propName] -= right;
                            break;
                        case "*=":
                            value = obj[propName] *= right;
                            break;
                        case "/=":
                            value = obj[propName] /= right;
                            break;
                        case "%=":
                            value = obj[propName] %= right;
                            break;
                        case "<<=":
                            value = obj[propName] <<= right;
                            break;
                        case ">>=":
                            value = obj[propName] >>= right;
                            break;
                        case ">>>=":
                            value = obj[propName] >>>= right;
                            break;
                        case "&=":
                            value = obj[propName] &= right;
                            break;
                        case "|=":
                            value = obj[propName] |= right;
                            break;
                        case "^=":
                            value = obj[propName] ^= right;
                            break;
                        default:
                            throw new Error(e.type + " not implemented " + e.operator);
                    }
                    if ("arguments" in env && obj === env.arguments && typeof env.paramsNames[propName] !== "undefined") setValue(env, env.paramsNames[propName], value, false);
                    c(value)
                }
                if (e.left.name) {
                    function foundName(left) {
                        var value;
                        switch (e.operator) {
                            case "=":
                                value = left = right;
                                break;
                            case "+=":
                                value = left += right;
                                break;
                            case "-=":
                                value = left -= right;
                                break;
                            case "*=":
                                value = left *= right;
                                break;
                            case "/=":
                                value = left /= right;
                                break;
                            case "%=":
                                value = left %= right;
                                break;
                            case "<<=":
                                value =
                                    left <<= right;
                                break;
                            case ">>=":
                                value = left >>= right;
                                break;
                            case ">>>=":
                                value = left >>>= right;
                                break;
                            case "&=":
                                value = left &= right;
                                break;
                            case "|=":
                                value = left |= right;
                                break;
                            case "^=":
                                value = left ^= right;
                                break;
                            default:
                                throw new Error(e.type + " not implemented " + e.operator);
                        }
                        setValue(env, e.left.name, value, false);
                        if ("arguments" in env) {
                            var index = env.paramsNames.indexOf(e.left.name);
                            if (index >= 0) env.names.arguments[index] = value
                        }
                        c(value)
                    }

                    function notFoundNameButAssignToGlobal(errorType, error, flag, env) {
                        if (e.operator ===
                            "=") {
                            var global = env;
                            while (global.prev) global = global.prev;
                            assignToMemberExpression(global.names, e.left.name, c)
                        } else cerr.apply(null, arguments)
                    }
                    getValue(env, e.left.name, false, foundName, notFoundNameButAssignToGlobal)
                } else delayEvaluate(e.left, env, function(prop, obj, propName) {
                    assignToMemberExpression(obj, propName, c)
                }, cerr)
            }, cerr)
        },
        UpdateExpression: function(e, env, c, cerr) {
            delayEvaluate(e.argument, env, function(argument, container, propName) {
                try {
                    var value;
                    if (e.prefix) switch (e.operator) {
                        case "++":
                            value = ++container[propName];
                            break;
                        case "--":
                            value = --container[propName];
                            break;
                        default:
                            throw new Error("Implement me, " + e.operator);
                    } else switch (e.operator) {
                        case "++":
                            value = container[propName]++;
                            break;
                        case "--":
                            value = container[propName]--;
                            break;
                        default:
                            throw new Error("Implement me, " + e.operator);
                    }
                    c(value)
                } catch (e) {
                    cerr("Error", e)
                }
            }, cerr)
        },
        ThisExpression: function(e, env, c, cerr) {
            function foundName(pair) {
                var value = pair[0],
                    container = pair[1];
                c(value, container, "this")
            }
            getValue(env, "this", true, foundName, cerr)
        },
        CallExpression: function(e,
            env, c, cerr) {
            delayEvaluate(e.callee, env, function(callee, thisObj, calleeName) {
                delayEvaluate(e.arguments, env, function(args) {
                    if (e.callee.type === "MemberExpression" && typeof callee === "undefined" || typeof callee !== "function") cerr("Error", new TypeError(typeof callee + " is not a function"));
                    else {
                        thisObj = e.callee.type === "MemberExpression" ? thisObj : null;
                        if (env.type === "WithStatement" && env.names[calleeName] === callee) thisObj = env.names;
                        delayApply(e, thisObj, callee, args, c, cerr, env)
                    }
                }, cerr)
            }, cerr)
        },
        MemberExpression: function(e,
            env, c, cerr, pause) {
            delayEvaluate(e.object, env, function(object, name) {
                function extractor(obj, prop, propName) {
                    var value;
                    if (typeof obj === "function" && propName === "caller") value = void 0;
                    else value = obj[prop];
                    applyInterceptor(e.property, value, env, pause);
                    return value
                }
                try {
                    if (e.property.hasOwnProperty("value")) c(extractor(object, e.property.value, e.property.name), object, e.property.value);
                    else if (e.computed) delayEvaluate(e.property, env, function(member, property) {
                            c(extractor(object, member, e.property.name), object, member)
                        },
                        cerr);
                    else c(extractor(object, e.property.name, e.property.name), object, e.property.name)
                } catch (e) {
                    cerr("Error", e)
                }
            }, cerr)
        },
        NewExpression: function(e, env, c, cerr) {
            delayEvaluate(e.arguments, env, function(args) {
                delayEvaluate(e.callee, env, function(ctor) {
                    var obj;
                    if (typeof ctor !== "function") cerr("Error", new TypeError(typeof ctor + " is not a function"));
                    else if (ctor.metaFunction) {
                        if (typeof ctor.prototype === "object" || typeof ctor.prototype === "function") obj = Object.create(ctor.prototype);
                        else obj = Object.create(Object.prototype);
                        delayEvaluate(apply, e, obj, ctor, args, function(result) {
                            c(typeof result === "object" || typeof result === "function" ? result : obj)
                        }, cerr, env)
                    } else try {
                        obj = new(Function.prototype.bind.apply(ctor, [undefined].concat(args)));
                        c(obj)
                    } catch (e) {
                        cerr("Error", e)
                    }
                }, cerr)
            }, cerr)
        },
        ArrayExpression: function(e, env, c, cerr) {
            delayEvaluate(e.elements, env, function(result) {
                result.forEach(function(r, index) {
                    if (typeof result[index] === "undefined") Object.defineProperty(result, index, {
                        enumerable: false
                    })
                });
                c(result)
            }, cerr)
        },
        WithStatement: function(e,
            env, c, cerr) {
            delayEvaluate(e.object, env, function(object) {
                if (typeof object == "undefined" || object === null || typeof object === "number" || object === true || object === false) cerr("Error", new TypeError(object + " has no properties"));
                else {
                    if (typeof object === "string") object = new String(object);
                    var withCfg = clone(env.cfg),
                        withEnv = {
                            names: object,
                            prev: env,
                            cfg: withCfg,
                            type: e.type
                        };
                    delayEvaluate(e.body, withEnv, c, cerr)
                }
            }, cerr)
        },
        BlockStatement: function(e, env, c, cerr) {
            function runHoisting(e) {
                var declarations = [];
                if (e.declarations) declarations =
                    e.declarations;
                else {
                    function isToken(o) {
                        return o && o.type
                    }

                    function search(e) {
                        if (["FunctionDeclaration", "VariableDeclarator"].indexOf(e.type) >= 0) declarations.push(e);
                        else if (["FunctionExpression", "FunctionDeclaration"].indexOf(e.type) === -1) Object.keys(e).forEach(function(key) {
                            var child = e[key];
                            if (child && child.type && key !== "test") search(child);
                            else if (Array.isArray(child)) child.filter(isToken).forEach(search)
                        })
                    }
                    e.forEach(search)
                }
                declarations.forEach(function(e) {
                    var value;
                    switch (e.type) {
                        case "FunctionDeclaration":
                        case "FunctionExpression":
                            value =
                                new MetaFunction(e, env);
                            break
                    }
                    setValue(env, e.id.name, value, true)
                });
                e.declarations = declarations
            }
            runHoisting(e.body);

            function errorHandler(errorType, result, extraParam) {
                switch (errorType) {
                    case "ReturnStatement":
                    case "YieldExpression":
                    case "ContinueStatement":
                    case "BreakStatement":
                    case "ThrowStatement":
                    case "Error":
                        cerr.apply(null, arguments);
                        break;
                    default:
                        c.apply(null, arguments);
                        break
                }
            }
            evaluate(e.body, env, function(results) {
                c(results.reverse()[0])
            }, errorHandler)
        },
        SequenceExpression: function(e, env, c, cerr) {
            delayEvaluate(e.expressions,
                env,
                function(results) {
                    c(results[results.length - 1])
                }, cerr)
        },
        IfStatement: function(e, env, c, cerr) {
            delayEvaluate(e.test, env, function(test) {
                if (test) delayEvaluate(e.consequent, env, c, cerr);
                else if (e.alternate) delayEvaluate(e.alternate, env, c, cerr);
                else c()
            }, cerr)
        },
        ConditionalExpression: function(e, env, c, cerr) {
            tokens.IfStatement(e, env, c, cerr)
        },
        SwitchStatement: function(e, env, c, cerr) {
            function cleanup(c) {
                return function() {
                    env.casePassed = false;
                    c()
                }
            }
            delayEvaluate(e.discriminant, env, function(discriminant) {
                setValue(env,
                    "discriminant", discriminant, true);

                function maybeBreak(value) {
                    if (value === "BreakStatement") c();
                    else cerr.apply(null, arguments)
                }
                env.casePassed = false;
                delayEvaluate(e.cases, env, cleanup(c), maybeBreak)
            }, cleanup(cerr))
        },
        SwitchCase: function(e, env, c, cerr) {
            getValue(env, "discriminant", false, function(discriminant) {
                if (e.test) delayEvaluate(e.test, env, function(test) {
                    if (env.casePassed || test === discriminant) {
                        env.casePassed = true;
                        delayEvaluate(e.consequent, env, c, cerr)
                    } else c()
                }, cerr);
                else if (env.casePassed) delayEvaluate(e.consequent,
                    env, c, cerr)
            }, cerr)
        },
        TryStatement: function(e, env, c, cerr) {
            function finalizer(c) {
                if (e.finalizer) delayEvaluate(e.finalizer, env, c, cerr);
                else c()
            }

            function continueOrFinalize(result) {
                finalizer(c.bind(null, result))
            }

            function maybeCatch(errorType, throwArgument) {
                switch (errorType) {
                    case "ReturnStatement":
                    case "ContinueStatement":
                    case "BreakStatement":
                        var args = arguments;
                        finalizer(function() {
                            cerr.apply(null, args)
                        });
                        break;
                    case "ThrowStatement":
                    case "Error":
                        setValue(env, "throwArgument", throwArgument, true);
                        if (e.handlers.length) delayEvaluate(e.handlers[0],
                            env,
                            function(result) {
                                delete env.names.throwArgument;
                                finalizer(c.bind(null, result))
                            },
                            function() {
                                var args = arguments;
                                finalizer(function() {
                                    cerr.apply(null, args)
                                })
                            });
                        else finalizer(c);
                        break;
                    default:
                        cerr.apply(null, arguments);
                        break
                }
            }
            delayEvaluate(e.block, env, continueOrFinalize, maybeCatch)
        },
        ThrowStatement: function(e, env, c, cerr) {
            delayEvaluate(e.argument, env, function(argument) {
                cerr(e.type, argument)
            }, cerr)
        },
        CatchClause: function(e, env, c, cerr) {
            function foundName(value) {
                var catchEnv = {
                    prev: env,
                    names: {},
                    type: e.type,
                    cfg: env.cfg
                };
                catchEnv.names[e.param.name] = value;
                delayEvaluate(e.body, catchEnv, c, cerr)
            }
            getValue(env, "throwArgument", false, foundName, cerr)
        },
        ReturnStatement: function(e, env, c, cerr, pause) {
            if (e.argument) delayEvaluate(e.argument, env, function(result) {
                applyInterceptor(e, result, env, pause);
                cerr(e.type, result)
            }, cerr);
            else {
                applyInterceptor(e, undefined, env, pause);
                cerr(e.type)
            }
        },
        DebuggerStatement: function(e, env, c, cerr) {
            debugger;
            c()
        },
        Program: function(e, env, c, cerr) {
            tokens.BlockStatement(e, env, c, cerr)
        },
        ArrowFunctionExpression: function(e,
            env, c, cerr) {
            tokens.FunctionExpression(e, env, c, cerr)
        },
        ForOfStatement: function(e, env, c, cerr) {
            tokens.ForInStatement(e, env, c, cerr)
        },
        ComprehensionExpression: function(e, env, c, cerr) {
            var construct = e.blocks.map(function(block) {
                return {
                    left: block.left,
                    right: block.right,
                    body: e.body,
                    type: "ForOfStatement"
                }
            });
            delayEvaluate(construct.reverse(), env, c, cerr)
        },
        YieldExpression: function(e, env, c, cerr) {
            delayEvaluate(e.argument, env, function(result) {
                cerr(e.type, result, c)
            }, cerr)
        }
    };

    function setValue(env, name, value, isDeclaration) {
        if (isDeclaration) {
            while (env.type ===
                "CatchClause" || env.type === "WithStatement") env = env.prev;
            if (!(name in env.names)) Object.defineProperty(env.names, name, {
                value: value,
                configurable: false,
                enumerable: true,
                writable: true
            });
            else if (typeof value !== "undefined") env.names[name] = value;
            return value
        } else {
            function loop_(env) {
                if (!env.prev) return env.names;
                else if (name in env.names) return env.names;
                else return loop_(env.prev)
            }
            return loop_(env)[name] = value
        }
    }

    function getValue(env, name, shouldReturnContainer, c, cerr) {
        var envs = [];

        function getValueHelper(container,
            key) {
            var value = container[key];
            return shouldReturnContainer ? [value, container] : value
        }

        function loop_(env) {
            if (!env) {
                if (cerr) cerr("Error", new ReferenceError(name + " is not defined."), true, envs[0])
            } else {
                envs.push(env);
                if (name in env.names) c(getValueHelper(env.names, name));
                else loop_(env.prev)
            }
        }
        loop_(env)
    }

    function MetaFunction(e, env) {
        this.e = e;
        this.env = env;
        this.cfg = clone(env.cfg);
        var self = this,
            evaluationResult;

        function MetaInvokerInner() {
            self.run(this, arguments, c, cerr, self.env);
            return evaluationResult
        }

        function cerr(errorType,
            e) {
            throw e;
        }

        function c(result) {
            evaluationResult = result
        }
        var functionParamsNames = this.paramsNames = e.params.map(function(param) {
                return param.name
            }),
            functionName = e.id ? e.id.name : "",
            functionSource = "(function " + functionName + "(" + functionParamsNames.join(",") + ") {" + "return MetaInvokerInner.apply(this,arguments)" + "})",
            MetaInvoker = eval(functionSource);
        MetaInvoker.toString = function() {
            return env.cfg.programText.substring(e.range[0], e.range[1])
        };
        MetaInvoker.metaFunction = this;
        Object.defineProperties(MetaInvoker, {
            "toString": {
                enumerable: false
            },
            "metaFunction": {
                enumerable: false
            }
        });
        this.metaInvoker = MetaInvoker;
        return MetaInvoker
    }
    MetaFunction.prototype.run = function(thisObj, args, c, cerr, prevEnv) {
        function buildArgsObject(input) {
            var mockedArgsObject = {};
            for (var i = 0; i < input.length; i++) mockedArgsObject[i] = input[i];
            Object.defineProperties(mockedArgsObject, {
                "length": {
                    enumerable: false,
                    value: input.length
                },
                "callee": {
                    enumerable: false,
                    value: self.metaInvoker
                }
            });
            return mockedArgsObject
        }
        var _this;
        getValue(this.env, "this", false,
            function(value) {
                _this = value
            }, cerr);
        var cfg = prevEnv.cfg,
            self = this,
            argsObject = buildArgsObject(args),
            env = {
                fn: self,
                cfg: cfg,
                names: {
                    "this": thisObj || _this
                },
                closure: this.env,
                prev: prevEnv
            };
        if (this.e.id) setValue(env, this.e.id.name, this.metaInvoker, true);
        Object.defineProperty(env.names, "arguments", {
            configurable: false,
            value: argsObject,
            writable: true
        });
        var functionResult;
        env.variables = env.variables || {};
        this.e.params.forEach(function(param, i) {
            applyInterceptor(param, args[i], env);
            setValue(env, param.name, args[i], true);
            setValue(env, param.name, args[i], false);
            env.variables[param.name] = param
        });
        delayEvaluate(this.e.body, env, function(result) {
            c(undefined)
        }, function(nodeType, result, extraParam) {
            switch (nodeType) {
                case "YieldExpression":
                    throw new Error("Handle properly saving continuation here");
                    break;
                case "ReturnStatement":
                    c.call(null, result, extraParam);
                    break;
                default:
                    cerr.apply(null, arguments);
                    break
            }
        });
        execute();
        applyInterceptor(this.e, this.metaInvoker, env);
        return functionResult
    };

    function apply(e, thisObj, fn, args, c, cerr, env) {
        if (fn ===
            eval)
            if (typeof args[0] === "string") {
                function cc(e, result) {
                    c(result)
                }
                metaEval(e, args, env, cc, cerr)
            } else c(args[0]);
        else if (fn.metaFunction instanceof MetaFunction) fn.metaFunction.run(thisObj, args, c, cerr, env);
        else try {
            c(fn.apply(thisObj, args))
        } catch (e) {
            cerr("Error", e)
        }
    }

    function applyInterceptor(e, val, env, pause) {
        if ("interceptor" in env.cfg && e.type) env.cfg.interceptor(e, val, env, pause)
    }

    function evaluate(e, env, c, cerr) {
        if (Array.isArray(e)) {
            var results = [];

            function next(e) {
                if (e.length) delayEvaluate(e[0], env,
                    function(result) {
                        results.push(result);
                        next(e.slice(1))
                    },
                    function(errorType) {
                        if (errorType === "BreakStatement") cerr.apply(null, [].slice.call(arguments).concat([results]));
                        else cerr.apply(null, arguments)
                    });
                else c(results)
            }
            next(e)
        } else if (e) {
            function success(result) {
                if (arguments.length > 1) c.apply(null, arguments);
                else c(result)
            }
            if (e.type in tokens) {
                if (e.range) e.subProgram = env.cfg.programText.substring(e.range[0], e.range[1]);
                tokens[e.type](e, env, success, cerr)
            } else {
                var error = new Error(e.type + " token is not yet implemented.");
                error.e = e;
                throw error;
            }
        } else c()
    }
    var tasksStack = [];

    function createPausable(fn, c, args) {
        var locked = false,
            delayed = function() {
                if (!locked) {
                    locked = true;
                    if (arguments.length) c.apply(null, arguments);
                    else fn.apply(null, args)
                }
            },
            resume = function() {
                locked = false;
                delayed.apply(null, arguments);
                execute()
            },
            pauser = function() {
                locked = true;
                return function() {
                    resume.apply(null, arguments)
                }
            };
        return {
            pauser: pauser,
            delayed: delayed
        }
    }

    function delayEvaluate(e, env, c, cerr) {
        var _c = c;
        c = function() {
            var continuation = createPausable(_c, _c,
                arguments);
            applyInterceptor(e, arguments, env, continuation.pauser);
            tasksStack.push(continuation.delayed)
        };
        var pausableEvaluate = createPausable(evaluate, c, arguments);
        applyInterceptor(e, undefined, env, pausableEvaluate.pauser);
        pausableEvaluate.delayed();
        tasksStack.push(pausableEvaluate.delayed)
    }

    function delayApply(e, thisObj, callee, args, c, cerr, env) {
        var pausable = createPausable(apply, c, arguments);
        applyInterceptor(e, {
            "this": thisObj,
            callee: callee,
            arguments: args
        }, env, pausable.pauser);
        tasksStack.push(pausable.delayed)
    }

    function execute() {
        while (tasksStack.length) tasksStack.pop()()
    }
    var parseConfig = {
        loc: true,
        range: true
    };

    function metaEval(node, programText, env, c, cerr) {
        programText = programText[0];
        try {
            var e = esprima.parse(programText, parseConfig),
                env2, cfg = clone(env.cfg);
            cfg.programText = programText;
            if (node.callee.name !== "eval")
                while (env.prev) env = env.prev;
            env2 = clone(env);
            env2.cfg = cfg;

            function metaCerr() {
                cerr.apply(null, [].slice.call(arguments, 1))
            }

            function metaC() {
                c.apply(null, arguments)
            }
            runVM(e, env2, metaC, metaCerr)
        } catch (error) {
            if (error.message.indexOf("Invalid left-hand side in assignment") >=
                0) cerr("Error", new ReferenceError(error.message));
            else cerr("Error", new SyntaxError(error.message))
        }
    }
    var VMsCounter = 0;

    function mainEvaluate(text, rootEnvironment, cfg, c, cerr) {
        if (typeof text === "function") text = "(" + text.toString() + ")";
        var evaluationResult;
        cfg = cfg || {};
        cfg.programText = text;
        cfg.name = cfg.name || "VM" + VMsCounter++;
        rootEnvironment = rootEnvironment || {};
        try {
            var e = esprima.parse(text, parseConfig),
                env;
            if ("names" in rootEnvironment) {
                env = rootEnvironment;
                env.cfg = cfg
            } else env = {
                prev: null,
                names: rootEnvironment || {},
                cfg: cfg
            };
            Object.defineProperty(env.names, "this", {
                configurable: false,
                value: env.names
            });

            function wrapResult(continuation) {
                return function(ast, result, result2) {
                    evaluationResult = result2 || result;
                    if (continuation) continuation.apply(null, arguments);
                    else if (result === "Error") throw result2;
                }
            }
            runVM(e, env, wrapResult(c), wrapResult(cerr));
            execute()
        } catch (err) {
            if (cerr) cerr(null, err);
            else throw err;
        }
        return evaluationResult
    }

    function runVM(e, env, c, cerr) {
        evaluate(e, env, c.bind(null, e), cerr.bind(null, e))
    }
    return {
        evaluate: mainEvaluate
    }
});
(function(window, document, exportName, undefined) {
    var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
    var TEST_ELEMENT = document.createElement("div");
    var TYPE_FUNCTION = "function";
    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;

    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout)
    }

    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true
        }
        return false
    }

    function each(obj, iterator, context) {
        var i;
        if (!obj) return;
        if (obj.forEach) obj.forEach(iterator, context);
        else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++
            }
        } else
            for (i in obj) obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj)
    }

    function deprecate(method, name, message) {
        var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
        return function() {
            var e = new Error("get-stack-trace");
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm,
                "{anonymous}()@") : "Unknown Stack Trace";
            var log = window.console && (window.console.warn || window.console.log);
            if (log) log.call(window.console, deprecationMessage, stack);
            return method.apply(this, arguments)
        }
    }
    var assign;
    if (typeof Object.assign !== "function") assign = function assign(target) {
        if (target === undefined || target === null) throw new TypeError("Cannot convert undefined or null to object");
        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined &&
                source !== null)
                for (var nextKey in source)
                    if (source.hasOwnProperty(nextKey)) output[nextKey] = source[nextKey]
        }
        return output
    };
    else assign = Object.assign;
    var extend = deprecate(function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || merge && dest[keys[i]] === undefined) dest[keys[i]] = src[keys[i]];
            i++
        }
        return dest
    }, "extend", "Use `assign`.");
    var merge = deprecate(function merge(dest, src) {
        return extend(dest, src, true)
    }, "merge", "Use `assign`.");

    function inherit(child, base, properties) {
        var baseP =
            base.prototype,
            childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) assign(childP, properties)
    }

    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments)
        }
    }

    function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) return val.apply(args ? args[0] || undefined : undefined, args);
        return val
    }

    function ifUndefined(val1, val2) {
        return val1 === undefined ? val2 : val1
    }

    function addEventListeners(target, types, handler) {
        each(splitStr(types),
            function(type) {
                target.addEventListener(type, handler, false)
            })
    }

    function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.removeEventListener(type, handler, false)
        })
    }

    function hasParent(node, parent) {
        while (node) {
            if (node == parent) return true;
            node = node.parentNode
        }
        return false
    }

    function inStr(str, find) {
        return str.indexOf(find) > -1
    }

    function splitStr(str) {
        return str.trim().split(/\s+/g)
    }

    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) return src.indexOf(find);
        else {
            var i = 0;
            while (i < src.length) {
                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) return i;
                i++
            }
            return -1
        }
    }

    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0)
    }

    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) results.push(src[i]);
            values[i] = val;
            i++
        }
        if (sort)
            if (!key) results = results.sort();
            else results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key]
            });
        return results
    }

    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) return prop;
            i++
        }
        return undefined
    }
    var _uniqueId = 1;

    function uniqueId() {
        return _uniqueId++
    }

    function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window
    }
    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
    var SUPPORT_TOUCH =
        "ontouchstart" in window;
    var SUPPORT_POINTER_EVENTS = prefixed(window, "PointerEvent") !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
    var INPUT_TYPE_TOUCH = "touch";
    var INPUT_TYPE_PEN = "pen";
    var INPUT_TYPE_MOUSE = "mouse";
    var INPUT_TYPE_KINECT = "kinect";
    var COMPUTE_INTERVAL = 25;
    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;
    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;
    var DIRECTION_HORIZONTAL =
        DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
    var PROPS_XY = ["x", "y"];
    var PROPS_CLIENT_XY = ["clientX", "clientY"];

    function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [manager])) self.handler(ev)
        };
        this.init()
    }
    Input.prototype = {
        handler: function() {},
        init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler)
        },
        destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin,
                this.domHandler)
        }
    };

    function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) Type = inputClass;
        else if (SUPPORT_POINTER_EVENTS) Type = PointerEventInput;
        else if (SUPPORT_ONLY_TOUCH) Type = TouchInput;
        else if (!SUPPORT_TOUCH) Type = MouseInput;
        else Type = TouchMouseInput;
        return new Type(manager, inputHandler)
    }

    function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START &&
            pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) manager.session = {};
        input.eventType = eventType;
        computeInputData(manager, input);
        manager.emit("hammer.input", input);
        manager.recognize(input);
        manager.session.prevInput = input
    }

    function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        if (!session.firstInput) session.firstInput =
            simpleCloneInputData(input);
        if (pointersLength > 1 && !session.firstMultiple) session.firstMultiple = simpleCloneInputData(input);
        else if (pointersLength === 1) session.firstMultiple = false;
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter,
            center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) :
            0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input);
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) target = input.srcEvent.target;
        input.target = target
    }

    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType ===
            INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            }
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y)
    }

    function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input,
            deltaTime = input.timeStamp - last.timeStamp,
            velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity ===
                undefined)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input
        } else {
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction
    }

    function simpleCloneInputData(input) {
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++
        }
        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        }
    }

    function getCenter(pointers) {
        var pointersLength = pointers.length;
        if (pointersLength === 1) return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
        var x = 0,
            y = 0,
            i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++
        }
        return {
            x: round(x /
                pointersLength),
            y: round(y / pointersLength)
        }
    }

    function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        }
    }

    function getDirection(x, y) {
        if (x === y) return DIRECTION_NONE;
        if (abs(x) >= abs(y)) return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN
    }

    function getDistance(p1, p2, props) {
        if (!props) props = PROPS_XY;
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y)
    }

    function getAngle(p1, p2, props) {
        if (!props) props = PROPS_XY;
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI
    }

    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY)
    }

    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY)
    }
    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };
    var MOUSE_ELEMENT_EVENTS = "mousedown";
    var MOUSE_WINDOW_EVENTS = "mousemove mouseup";

    function MouseInput() {
        this.evEl =
            MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false;
        Input.apply(this, arguments)
    }
    inherit(MouseInput, Input, {
        handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP[ev.type];
            if (eventType & INPUT_START && ev.button === 0) this.pressed = true;
            if (eventType & INPUT_MOVE && ev.which !== 1) eventType = INPUT_END;
            if (!this.pressed) return;
            if (eventType & INPUT_END) this.pressed = false;
            this.callback(this.manager, eventType, {
                pointers: [ev],
                changedPointers: [ev],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            })
        }
    });
    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT
    };
    var POINTER_ELEMENT_EVENTS = "pointerdown";
    var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
    if (window.MSPointerEvent && !window.PointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel"
    }

    function PointerEventInput() {
        this.evEl =
            POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = []
    }
    inherit(PointerEventInput, Input, {
        handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType == INPUT_TYPE_TOUCH;
            var storeIndex = inArray(store, ev.pointerId,
                "pointerId");
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                if (storeIndex < 0) {
                    store.push(ev);
                    storeIndex = store.length - 1
                }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) removePointer = true;
            if (storeIndex < 0) return;
            store[storeIndex] = ev;
            this.callback(this.manager, eventType, {
                pointers: store,
                changedPointers: [ev],
                pointerType: pointerType,
                srcEvent: ev
            });
            if (removePointer) store.splice(storeIndex, 1)
        }
    });
    var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
    var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";

    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments)
    }
    inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
            if (type === INPUT_START) this.started = true;
            if (!this.started) return;
            var touches = normalizeSingleTouches.call(this, ev, type);
            if (type &
                (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) this.started = false;
            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            })
        }
    });

    function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) all = uniqueArray(all.concat(changed), "identifier", true);
        return [all, changed]
    }
    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";

    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments)
    }
    inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) return;
            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            })
        }
    });

    function getTouches(ev, type) {
        var allTouches =
            toArray(ev.touches);
        var targetIds = this.targetIds;
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches]
        }
        var i, targetTouches, changedTouches = toArray(ev.changedTouches),
            changedTargetTouches = [],
            target = this.target;
        targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target)
        });
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++
            }
        }
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) changedTargetTouches.push(changedTouches[i]);
            if (type & (INPUT_END | INPUT_CANCEL)) delete targetIds[changedTouches[i].identifier];
            i++
        }
        if (!changedTargetTouches.length) return;
        return [uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true), changedTargetTouches]
    }
    var DEDUP_TIMEOUT = 2500;
    var DEDUP_DISTANCE = 25;

    function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = []
    }
    inherit(TouchMouseInput, Input, {
        handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
                isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) return;
            if (isTouch) recordTouches.call(this, inputEvent, inputData);
            else if (isMouse && isSyntheticEvent.call(this, inputData)) return;
            this.callback(manager, inputEvent, inputData)
        },
        destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy()
        }
    });

    function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData)
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) setLastTouch.call(this, eventData)
    }

    function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
            var lastTouch = {
                x: touch.clientX,
                y: touch.clientY
            };
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function() {
                var i = lts.indexOf(lastTouch);
                if (i > -1) lts.splice(i, 1)
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT)
        }
    }

    function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX,
            y = eventData.srcEvent.clientY;
        for (var i = 0; i < this.lastTouches.length; i++) {
            var t = this.lastTouches[i];
            var dx = Math.abs(x - t.x),
                dy = Math.abs(y - t.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) return true
        }
        return false
    }
    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
    var TOUCH_ACTION_COMPUTE = "compute";
    var TOUCH_ACTION_AUTO = "auto";
    var TOUCH_ACTION_MANIPULATION = "manipulation";
    var TOUCH_ACTION_NONE = "none";
    var TOUCH_ACTION_PAN_X = "pan-x";
    var TOUCH_ACTION_PAN_Y = "pan-y";
    var TOUCH_ACTION_MAP = getTouchActionProps();

    function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value)
    }
    TouchAction.prototype = {
        set: function(value) {
            if (value == TOUCH_ACTION_COMPUTE) value = this.compute();
            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) this.manager.element.style[PREFIXED_TOUCH_ACTION] =
                value;
            this.actions = value.toLowerCase().trim()
        },
        update: function() {
            this.set(this.manager.options.touchAction)
        },
        compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
                if (boolOrFn(recognizer.options.enable, [recognizer])) actions = actions.concat(recognizer.getTouchAction())
            });
            return cleanTouchActions(actions.join(" "))
        },
        preventDefaults: function(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            if (this.manager.session.prevented) {
                srcEvent.preventDefault();
                return
            }
            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
            if (hasNone) {
                var isTapPointer = input.pointers.length === 1;
                var isTapMovement = input.distance < 2;
                var isTapTouchTime = input.deltaTime < 250;
                if (isTapPointer && isTapMovement && isTapTouchTime) return
            }
            if (hasPanX && hasPanY) return;
            if (hasNone ||
                hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) return this.preventSrc(srcEvent)
        },
        preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault()
        }
    };

    function cleanTouchActions(actions) {
        if (inStr(actions, TOUCH_ACTION_NONE)) return TOUCH_ACTION_NONE;
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        if (hasPanX && hasPanY) return TOUCH_ACTION_NONE;
        if (hasPanX || hasPanY) return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) return TOUCH_ACTION_MANIPULATION;
        return TOUCH_ACTION_AUTO
    }

    function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) return false;
        var touchMap = {};
        var cssSupports = window.CSS && window.CSS.supports;
        ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
            touchMap[val] = cssSupports ? window.CSS.supports("touch-action", val) : true
        });
        return touchMap
    }
    var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED =
        STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;

    function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});
        this.id = uniqueId();
        this.manager = null;
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = []
    }
    Recognizer.prototype = {
        defaults: {},
        set: function(options) {
            assign(this.options, options);
            this.manager && this.manager.touchAction.update();
            return this
        },
        recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer,
                    "recognizeWith", this)) return this;
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
                simultaneous[otherRecognizer.id] = otherRecognizer;
                otherRecognizer.recognizeWith(this)
            }
            return this
        },
        dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) return this;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this
        },
        requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "requireFailure", this)) return this;
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
                requireFail.push(otherRecognizer);
                otherRecognizer.requireFailure(this)
            }
            return this
        },
        dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) return this;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer,
                this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) this.requireFail.splice(index, 1);
            return this
        },
        hasRequireFailures: function() {
            return this.requireFail.length > 0
        },
        canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id]
        },
        emit: function(input) {
            var self = this;
            var state = this.state;

            function emit(event) {
                self.manager.emit(event, input)
            }
            if (state < STATE_ENDED) emit(self.options.event + stateStr(state));
            emit(self.options.event);
            if (input.additionalEvent) emit(input.additionalEvent);
            if (state >= STATE_ENDED) emit(self.options.event + stateStr(state))
        },
        tryEmit: function(input) {
            if (this.canEmit()) return this.emit(input);
            this.state = STATE_FAILED
        },
        canEmit: function() {
            var i = 0;
            while (i < this.requireFail.length) {
                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) return false;
                i++
            }
            return true
        },
        recognize: function(inputData) {
            var inputDataClone = assign({}, inputData);
            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                this.reset();
                this.state = STATE_FAILED;
                return
            }
            if (this.state & (STATE_RECOGNIZED |
                    STATE_CANCELLED | STATE_FAILED)) this.state = STATE_POSSIBLE;
            this.state = this.process(inputDataClone);
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) this.tryEmit(inputDataClone)
        },
        process: function(inputData) {},
        getTouchAction: function() {},
        reset: function() {}
    };

    function stateStr(state) {
        if (state & STATE_CANCELLED) return "cancel";
        else if (state & STATE_ENDED) return "end";
        else if (state & STATE_CHANGED) return "move";
        else if (state & STATE_BEGAN) return "start";
        return ""
    }

    function directionStr(direction) {
        if (direction ==
            DIRECTION_DOWN) return "down";
        else if (direction == DIRECTION_UP) return "up";
        else if (direction == DIRECTION_LEFT) return "left";
        else if (direction == DIRECTION_RIGHT) return "right";
        return ""
    }

    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) return manager.get(otherRecognizer);
        return otherRecognizer
    }

    function AttrRecognizer() {
        Recognizer.apply(this, arguments)
    }
    inherit(AttrRecognizer, Recognizer, {
        defaults: {
            pointers: 1
        },
        attrTest: function(input) {
            var optionPointers =
                this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers
        },
        process: function(input) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) return state | STATE_CANCELLED;
            else if (isRecognized || isValid) {
                if (eventType & INPUT_END) return state | STATE_ENDED;
                else if (!(state & STATE_BEGAN)) return STATE_BEGAN;
                return state | STATE_CHANGED
            }
            return STATE_FAILED
        }
    });

    function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null
    }
    inherit(PanRecognizer, AttrRecognizer, {
        defaults: {
            event: "pan",
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },
        getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) actions.push(TOUCH_ACTION_PAN_Y);
            if (direction & DIRECTION_VERTICAL) actions.push(TOUCH_ACTION_PAN_X);
            return actions
        },
        directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance =
                input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;
            if (!(direction & options.direction))
                if (options.direction & DIRECTION_HORIZONTAL) {
                    direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs(input.deltaX)
                } else {
                    direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs(input.deltaY)
                }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction
        },
        attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this,
                input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input))
        },
        emit: function(input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);
            if (direction) input.additionalEvent = this.options.event + direction;
            this._super.emit.call(this, input)
        }
    });

    function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments)
    }
    inherit(PinchRecognizer, AttrRecognizer, {
        defaults: {
            event: "pinch",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [TOUCH_ACTION_NONE]
        },
        attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN)
        },
        emit: function(input) {
            if (input.scale !== 1) {
                var inOut = input.scale < 1 ? "in" : "out";
                input.additionalEvent = this.options.event + inOut
            }
            this._super.emit.call(this, input)
        }
    });

    function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null
    }
    inherit(PressRecognizer, Recognizer, {
        defaults: {
            event: "press",
            pointers: 1,
            time: 251,
            threshold: 9
        },
        getTouchAction: function() {
            return [TOUCH_ACTION_AUTO]
        },
        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input;
            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) this.reset();
            else if (input.eventType & INPUT_START) {
                this.reset();
                this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit()
                }, options.time, this)
            } else if (input.eventType & INPUT_END) return STATE_RECOGNIZED;
            return STATE_FAILED
        },
        reset: function() {
            clearTimeout(this._timer)
        },
        emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) return;
            if (input && input.eventType & INPUT_END) this.manager.emit(this.options.event + "up", input);
            else {
                this._input.timeStamp = now();
                this.manager.emit(this.options.event, this._input)
            }
        }
    });

    function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments)
    }
    inherit(RotateRecognizer, AttrRecognizer, {
        defaults: {
            event: "rotate",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [TOUCH_ACTION_NONE]
        },
        attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN)
        }
    });

    function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments)
    }
    inherit(SwipeRecognizer, AttrRecognizer, {
        defaults: {
            event: "swipe",
            threshold: 10,
            velocity: .3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },
        getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this)
        },
        attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;
            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) velocity = input.overallVelocity;
            else if (direction & DIRECTION_HORIZONTAL) velocity = input.overallVelocityX;
            else if (direction & DIRECTION_VERTICAL) velocity = input.overallVelocityY;
            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END
        },
        emit: function(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) this.manager.emit(this.options.event + direction, input);
            this.manager.emit(this.options.event, input)
        }
    });

    function TapRecognizer() {
        Recognizer.apply(this, arguments);
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0
    }
    inherit(TapRecognizer, Recognizer, {
        defaults: {
            event: "tap",
            pointers: 1,
            taps: 1,
            interval: 300,
            time: 250,
            threshold: 9,
            posThreshold: 10
        },
        getTouchAction: function() {
            return [TOUCH_ACTION_MANIPULATION]
        },
        process: function(input) {
            var options = this.options;
            var validPointers =
                input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if (input.eventType & INPUT_START && this.count === 0) return this.failTimeout();
            if (validMovement && validTouchTime && validPointers) {
                if (input.eventType != INPUT_END) return this.failTimeout();
                var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                this.pTime = input.timeStamp;
                this.pCenter = input.center;
                if (!validMultiTap || !validInterval) this.count = 1;
                else this.count += 1;
                this._input = input;
                var tapCount = this.count % options.taps;
                if (tapCount === 0)
                    if (!this.hasRequireFailures()) return STATE_RECOGNIZED;
                    else {
                        this._timer = setTimeoutContext(function() {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit()
                        }, options.interval, this);
                        return STATE_BEGAN
                    }
            }
            return STATE_FAILED
        },
        failTimeout: function() {
            this._timer = setTimeoutContext(function() {
                    this.state = STATE_FAILED
                }, this.options.interval,
                this);
            return STATE_FAILED
        },
        reset: function() {
            clearTimeout(this._timer)
        },
        emit: function() {
            if (this.state == STATE_RECOGNIZED) {
                this._input.tapCount = this.count;
                this.manager.emit(this.options.event, this._input)
            }
        }
    });

    function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options)
    }
    Hammer.VERSION = "2.0.7";
    Hammer.defaults = {
        domEvents: false,
        touchAction: TOUCH_ACTION_COMPUTE,
        enable: true,
        inputTarget: null,
        inputClass: null,
        preset: [
            [RotateRecognizer, {
                enable: false
            }],
            [PinchRecognizer, {
                    enable: false
                },
                ["rotate"]
            ],
            [SwipeRecognizer, {
                direction: DIRECTION_HORIZONTAL
            }],
            [PanRecognizer, {
                    direction: DIRECTION_HORIZONTAL
                },
                ["swipe"]
            ],
            [TapRecognizer],
            [TapRecognizer, {
                    event: "doubletap",
                    taps: 2
                },
                ["tap"]
            ],
            [PressRecognizer]
        ],
        cssProps: {
            userSelect: "none",
            touchSelect: "none",
            touchCallout: "none",
            contentZooming: "none",
            userDrag: "none",
            tapHighlightColor: "rgba(0,0,0,0)"
        }
    };
    var STOP = 1;
    var FORCED_STOP = 2;

    function Manager(element, options) {
        this.options = assign({},
            Hammer.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function(item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3])
        }, this)
    }
    Manager.prototype = {
        set: function(options) {
            assign(this.options, options);
            if (options.touchAction) this.touchAction.update();
            if (options.inputTarget) {
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init()
            }
            return this
        },
        stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP
        },
        recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) return;
            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers;
            var curRecognizer = session.curRecognizer;
            if (!curRecognizer ||
                curRecognizer && curRecognizer.state & STATE_RECOGNIZED) curRecognizer = session.curRecognizer = null;
            var i = 0;
            while (i < recognizers.length) {
                recognizer = recognizers[i];
                if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) recognizer.recognize(inputData);
                else recognizer.reset();
                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) curRecognizer = session.curRecognizer = recognizer;
                i++
            }
        },
        get: function(recognizer) {
            if (recognizer instanceof Recognizer) return recognizer;
            var recognizers = this.recognizers;
            for (var i = 0; i < recognizers.length; i++)
                if (recognizers[i].options.event == recognizer) return recognizers[i];
            return null
        },
        add: function(recognizer) {
            if (invokeArrayArg(recognizer, "add", this)) return this;
            var existing = this.get(recognizer.options.event);
            if (existing) this.remove(existing);
            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer
        },
        remove: function(recognizer) {
            if (invokeArrayArg(recognizer, "remove",
                    this)) return this;
            recognizer = this.get(recognizer);
            if (recognizer) {
                var recognizers = this.recognizers;
                var index = inArray(recognizers, recognizer);
                if (index !== -1) {
                    recognizers.splice(index, 1);
                    this.touchAction.update()
                }
            }
            return this
        },
        on: function(events, handler) {
            if (events === undefined) return;
            if (handler === undefined) return;
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                handlers[event] = handlers[event] || [];
                handlers[event].push(handler)
            });
            return this
        },
        off: function(events, handler) {
            if (events === undefined) return;
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                if (!handler) delete handlers[event];
                else handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1)
            });
            return this
        },
        emit: function(event, data) {
            if (this.options.domEvents) triggerDomEvent(event, data);
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) return;
            data.type = event;
            data.preventDefault = function() {
                data.srcEvent.preventDefault()
            };
            var i = 0;
            while (i < handlers.length) {
                handlers[i](data);
                i++
            }
        },
        destroy: function() {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null
        }
    };

    function toggleCssProps(manager, add) {
        var element = manager.element;
        if (!element.style) return;
        var prop;
        each(manager.options.cssProps, function(value, name) {
            prop = prefixed(element.style, name);
            if (add) {
                manager.oldCssProps[prop] = element.style[prop];
                element.style[prop] = value
            } else element.style[prop] = manager.oldCssProps[prop] || ""
        });
        if (!add) manager.oldCssProps = {}
    }

    function triggerDomEvent(event,
        data) {
        var gestureEvent = document.createEvent("Event");
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent)
    }
    assign(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,
        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,
        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,
        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,
        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,
        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        assign: assign,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    });
    var freeGlobal = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {};
    freeGlobal.Hammer = Hammer;
    if (typeof define === "function" && define.amd) define(function() {
        return Hammer
    });
    else if (typeof module != "undefined" && module.exports) module.exports = Hammer;
    else window[exportName] = Hammer
})(window,
    document, "Hammer");
"use strict";
(function() {
    var global = this,
        isIE8 = global.attachEvent && !global[addEventListener],
        document = global.document,
        addEventListener = "addEventListener",
        removeEventListener = "removeEventListener",
        getBoundingClientRect = "getBoundingClientRect",
        FLOAT_FUDGING = .5,
        calc = function() {
            var el, prefixes = ["", "-webkit-", "-moz-", "-o-"];
            for (var i = 0; i < prefixes.length; i++) {
                el = document.createElement("div");
                el.style.cssText = "width:" + prefixes[i] + "calc(9px)";
                if (el.style.length) return prefixes[i] + "calc"
            }
        }(),
        elementOrSelector = function(el) {
            if (typeof el ===
                "string" || el instanceof String) return document.querySelector(el);
            else return el
        },
        Split = function(ids, options) {
            var dimension, i, clientDimension, clientAxis, position, gutterClass, paddingA, paddingB, pairs = [];
            options = typeof options !== "undefined" ? options : {};
            if (typeof options.gutterSize === "undefined") options.gutterSize = 10;
            if (typeof options.minSize === "undefined") options.minSize = 100;
            if (typeof options.snapOffset === "undefined") options.snapOffset = 30;
            if (typeof options.direction === "undefined") options.direction = "horizontal";
            if (typeof options.elementStyle === "undefined") options.elementStyle = function(dimension, size, gutterSize) {
                var style = {};
                if (typeof size !== "string" && !(size instanceof String))
                    if (!isIE8) style[dimension] = calc + "(" + size + "% - " + gutterSize + "px)";
                    else style[dimension] = size + "%";
                else style[dimension] = size;
                return style
            };
            if (typeof options.gutterStyle === "undefined") options.gutterStyle = function(dimension, gutterSize) {
                var style = {};
                style[dimension] = gutterSize + "px";
                return style
            };
            if (options.direction == "horizontal") {
                dimension =
                    "width";
                clientDimension = "clientWidth";
                clientAxis = "clientX";
                position = "left";
                gutterClass = "gutter gutter-horizontal";
                paddingA = "paddingLeft";
                paddingB = "paddingRight";
                if (!options.cursor) options.cursor = "ew-resize"
            } else if (options.direction == "vertical") {
                dimension = "height";
                clientDimension = "clientHeight";
                clientAxis = "clientY";
                position = "top";
                gutterClass = "gutter gutter-vertical";
                paddingA = "paddingTop";
                paddingB = "paddingBottom";
                if (!options.cursor) options.cursor = "ns-resize"
            }
            var startDragging = function(e) {
                    var self =
                        this,
                        a = self.a,
                        b = self.b;
                    if (!self.dragging && options.onDragStart) options.onDragStart();
                    e.preventDefault();
                    self.dragging = true;
                    self.move = drag.bind(self);
                    self.stop = stopDragging.bind(self);
                    global[addEventListener]("mouseup", self.stop);
                    global[addEventListener]("touchend", self.stop);
                    global[addEventListener]("touchcancel", self.stop);
                    self.parent[addEventListener]("mousemove", self.move);
                    self.parent[addEventListener]("touchmove", self.move);
                    a[addEventListener]("selectstart", noop);
                    a[addEventListener]("dragstart",
                        noop);
                    b[addEventListener]("selectstart", noop);
                    b[addEventListener]("dragstart", noop);
                    a.style.userSelect = "none";
                    a.style.webkitUserSelect = "none";
                    a.style.MozUserSelect = "none";
                    a.style.pointerEvents = "none";
                    b.style.userSelect = "none";
                    b.style.webkitUserSelect = "none";
                    b.style.MozUserSelect = "none";
                    b.style.pointerEvents = "none";
                    self.gutter.style.cursor = options.cursor;
                    self.parent.style.cursor = options.cursor;
                    calculateSizes.call(self)
                },
                stopDragging = function() {
                    var self = this,
                        a = self.a,
                        b = self.b;
                    if (self.dragging && options.onDragEnd) options.onDragEnd();
                    self.dragging = false;
                    global[removeEventListener]("mouseup", self.stop);
                    global[removeEventListener]("touchend", self.stop);
                    global[removeEventListener]("touchcancel", self.stop);
                    self.parent[removeEventListener]("mousemove", self.move);
                    self.parent[removeEventListener]("touchmove", self.move);
                    delete self.stop;
                    delete self.move;
                    a[removeEventListener]("selectstart", noop);
                    a[removeEventListener]("dragstart", noop);
                    b[removeEventListener]("selectstart", noop);
                    b[removeEventListener]("dragstart", noop);
                    a.style.userSelect =
                        "";
                    a.style.webkitUserSelect = "";
                    a.style.MozUserSelect = "";
                    a.style.pointerEvents = "";
                    b.style.userSelect = "";
                    b.style.webkitUserSelect = "";
                    b.style.MozUserSelect = "";
                    b.style.pointerEvents = "";
                    self.gutter.style.cursor = "";
                    self.parent.style.cursor = ""
                },
                drag = function(e) {
                    var offset;
                    if (!this.dragging) return;
                    if ("touches" in e) offset = e.touches[0][clientAxis] - this.start;
                    else offset = e[clientAxis] - this.start;
                    if (offset <= this.aMin + options.snapOffset + this.aGutterSize) offset = this.aMin + this.aGutterSize;
                    else if (offset >= this.size -
                        (this.bMin + options.snapOffset + this.bGutterSize)) offset = this.size - (this.bMin + this.bGutterSize);
                    offset = offset - FLOAT_FUDGING;
                    adjust.call(this, offset);
                    if (options.onDrag) options.onDrag()
                },
                calculateSizes = function() {
                    var computedStyle = global.getComputedStyle(this.parent),
                        parentSize = this.parent[clientDimension] - parseFloat(computedStyle[paddingA]) - parseFloat(computedStyle[paddingB]);
                    this.size = this.a[getBoundingClientRect]()[dimension] + this.b[getBoundingClientRect]()[dimension] + this.aGutterSize + this.bGutterSize;
                    this.percentage = Math.min(this.size / parentSize * 100, 100);
                    this.start = this.a[getBoundingClientRect]()[position]
                },
                adjust = function(offset) {
                    setElementSize(this.a, offset / this.size * this.percentage, this.aGutterSize);
                    setElementSize(this.b, this.percentage - offset / this.size * this.percentage, this.bGutterSize)
                },
                setElementSize = function(el, size, gutterSize) {
                    var style = options.elementStyle(dimension, size, gutterSize),
                        props = Object.keys(style);
                    for (var i = 0; i < props.length; i++) el.style[props[i]] = style[props[i]]
                },
                setGutterSize =
                function(gutter, gutterSize) {
                    var style = options.gutterStyle(dimension, gutterSize),
                        props = Object.keys(style);
                    for (var i = 0; i < props.length; i++) gutter.style[props[i]] = style[props[i]]
                },
                noop = function() {
                    return false
                },
                parent = elementOrSelector(ids[0]).parentNode;
            if (!options.sizes) {
                var percent = 100 / ids.length;
                options.sizes = [];
                for (i = 0; i < ids.length; i++) options.sizes.push(percent)
            }
            if (!Array.isArray(options.minSize)) {
                var minSizes = [];
                for (i = 0; i < ids.length; i++) minSizes.push(options.minSize);
                options.minSize = minSizes
            }
            for (i =
                0; i < ids.length; i++) {
                var el = elementOrSelector(ids[i]),
                    isFirstPair = i == 1,
                    isLastPair = i == ids.length - 1,
                    size = options.sizes[i],
                    gutterSize = options.gutterSize,
                    pair, parentFlexDirection = window.getComputedStyle(parent).flexDirection,
                    temp;
                if (i > 0) {
                    pair = {
                        a: elementOrSelector(ids[i - 1]),
                        b: el,
                        aMin: options.minSize[i - 1],
                        bMin: options.minSize[i],
                        dragging: false,
                        parent: parent,
                        isFirst: isFirstPair,
                        isLast: isLastPair,
                        direction: options.direction
                    };
                    pair.aGutterSize = options.gutterSize;
                    pair.bGutterSize = options.gutterSize;
                    if (isFirstPair) pair.aGutterSize =
                        options.gutterSize / 2;
                    if (isLastPair) pair.bGutterSize = options.gutterSize / 2;
                    if (parentFlexDirection === "row-reverse" || parentFlexDirection === "column-reverse") {
                        temp = pair.a;
                        pair.a = pair.b;
                        pair.b = temp
                    }
                }
                if (!isIE8) {
                    if (i > 0) {
                        var gutter = document.createElement("div");
                        gutter.className = gutterClass;
                        setGutterSize(gutter, gutterSize);
                        gutter[addEventListener]("mousedown", startDragging.bind(pair));
                        gutter[addEventListener]("touchstart", startDragging.bind(pair));
                        parent.insertBefore(gutter, el);
                        pair.gutter = gutter
                    }
                    if (i === 0 ||
                        i == ids.length - 1) gutterSize = options.gutterSize / 2
                }
                setElementSize(el, size, gutterSize);
                if (i > 0) {
                    var aSize = pair.a[getBoundingClientRect]()[dimension],
                        bSize = pair.b[getBoundingClientRect]()[dimension];
                    if (aSize < pair.aMin) pair.aMin = aSize;
                    if (bSize < pair.bMin) pair.bMin = bSize
                }
                if (i > 0) pairs.push(pair)
            }
            return {
                setSizes: function(sizes) {
                    for (var i = 0; i < sizes.length; i++)
                        if (i > 0) {
                            var pair = pairs[i - 1];
                            setElementSize(pair.a, sizes[i - 1], pair.aGutterSize);
                            setElementSize(pair.b, sizes[i], pair.bGutterSize)
                        }
                },
                getSizes: function() {
                    var sizes = [];
                    for (var i = 0; i < pairs.length; i++) {
                        var pair = pairs[i],
                            computedStyle = global.getComputedStyle(pair.parent),
                            parentSize = pair.parent[clientDimension] - parseFloat(computedStyle[paddingA]) - parseFloat(computedStyle[paddingB]);
                        sizes.push((pair.a[getBoundingClientRect]()[dimension] + pair.aGutterSize) / parentSize * 100);
                        if (i === pairs.length - 1) sizes.push((pair.b[getBoundingClientRect]()[dimension] + pair.bGutterSize) / parentSize * 100)
                    }
                    return sizes
                },
                collapse: function(i) {
                    var pair;
                    if (i === pairs.length) {
                        pair = pairs[i - 1];
                        calculateSizes.call(pair);
                        adjust.call(pair, pair.size - pair.bGutterSize)
                    } else {
                        pair = pairs[i];
                        calculateSizes.call(pair);
                        adjust.call(pair, pair.aGutterSize)
                    }
                },
                destroy: function() {
                    for (var i = 0; i < pairs.length; i++) {
                        pairs[i].parent.removeChild(pairs[i].gutter);
                        pairs[i].a.style[dimension] = "";
                        pairs[i].b.style[dimension] = ""
                    }
                }
            }
        };
    if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) exports = module.exports = Split;
        exports.Split = Split
    } else global.Split = Split
}).call(window);
var Spinners = {
    version: "3.0.0"
};
(function($) {
    var _ = {
        scroll: function(array, distance) {
            if (!distance) return array;
            var first = array.slice(0, distance),
                last = array.slice(distance, array.length);
            return last.concat(first)
        },
        isElement: function(object) {
            return object && object.nodeType == 1
        },
        element: {
            isAttached: function() {
                function findTopAncestor(element) {
                    var ancestor = element;
                    while (ancestor && ancestor.parentNode) ancestor = ancestor.parentNode;
                    return ancestor
                }
                return function(element) {
                    var topAncestor = findTopAncestor(element);
                    return !!(topAncestor && topAncestor.body)
                }
            }()
        }
    };

    function getOpacityArray(dashes) {
        var step = 1 / dashes,
            array = [];
        for (var i = 0; i < dashes; i++) array.push((i + 1) * step);
        return array
    }

    function pyth(a, b) {
        return Math.sqrt(a * a + b * b)
    }

    function degrees(radian) {
        return radian * 180 / Math.PI
    }

    function radian(degrees) {
        return degrees * Math.PI / 180
    }
    var Canvas = {
        drawRoundedRectangle: function(ctx) {
            var options = $.extend({
                top: 0,
                left: 0,
                width: 0,
                height: 0,
                radius: 0
            }, arguments[1] || {});
            var o = options,
                left = o.left,
                top = o.top,
                width = o.width,
                height = o.height,
                radius = o.radius;
            ctx.beginPath();
            ctx.moveTo(left +
                radius, top);
            ctx.arc(left + width - radius, top + radius, radius, radian(-90), radian(0), false);
            ctx.arc(left + width - radius, top + height - radius, radius, radian(0), radian(90), false);
            ctx.arc(left + radius, top + height - radius, radius, radian(90), radian(180), false);
            ctx.arc(left + radius, top + radius, radius, radian(-180), radian(-90), false);
            ctx.closePath();
            ctx.fill()
        }
    };
    var Color = function() {
        var hexNumber = "0123456789abcdef",
            hexRegExp = new RegExp("[" + hexNumber + "]", "g");

        function returnRGB(rgb) {
            var result = rgb;
            result.red = rgb[0];
            result.green =
                rgb[1];
            result.blue = rgb[2];
            return result
        }

        function h2d(h) {
            return parseInt(h, 16)
        }

        function hex2rgb(hex) {
            var rgb = [];
            if (hex.indexOf("#") == 0) hex = hex.substring(1);
            hex = hex.toLowerCase();
            if (hex.replace(hexRegExp, "") != "") return null;
            if (hex.length == 3) {
                rgb[0] = hex.charAt(0) + hex.charAt(0);
                rgb[1] = hex.charAt(1) + hex.charAt(1);
                rgb[2] = hex.charAt(2) + hex.charAt(2)
            } else {
                rgb[0] = hex.substring(0, 2);
                rgb[1] = hex.substring(2, 4);
                rgb[2] = hex.substring(4)
            }
            for (var i = 0; i < rgb.length; i++) rgb[i] = h2d(rgb[i]);
            return returnRGB(rgb)
        }

        function hex2rgba(hex,
            opacity) {
            var rgba = hex2rgb(hex);
            rgba[3] = opacity;
            rgba.opacity = opacity;
            return rgba
        }

        function hex2fill(hex, opacity) {
            if (typeof opacity == "undefined") opacity = 1;
            return "rgba(" + hex2rgba(hex, opacity).join() + ")"
        }
        var rgb2hex = function() {
            function toPaddedString(string, length, radix) {
                string = string.toString(radix || 10);
                return (new Array(length - string.length)).join("0") + string
            }
            return function(red, green, blue) {
                return "#" + toPaddedString(red, 2, 16) + toPaddedString(green, 2, 16) + toPaddedString(blue, 2, 16)
            }
        }();
        return {
            hex2rgb: hex2rgb,
            hex2fill: hex2fill,
            rgb2hex: rgb2hex
        }
    }();
    $.extend(Spinners, {
        enabled: false,
        support: {
            canvas: function() {
                var canvas = $("<canvas>")[0];
                return !!(canvas.getContext && canvas.getContext("2d"))
            }()
        },
        init: function() {
            if (!(this.support.canvas || !!window.G_vmlCanvasManager && !!(window.attachEvent && navigator.userAgent.indexOf("Opera") === -1))) return;
            window.G_vmlCanvasManager && window.G_vmlCanvasManager.init_(document);
            this.enabled = true
        },
        create: function(element, options) {
            Collection.create(element, options);
            return this.get(element)
        },
        get: function(element) {
            return new Collection(element)
        },
        play: function(element) {
            this.get(element).play();
            return this
        },
        pause: function(element) {
            this.get(element).pause();
            return this
        },
        toggle: function(element) {
            this.get(element).toggle();
            return this
        },
        stop: function(element) {
            this.get(element).stop();
            return this
        },
        remove: function(element) {
            this.get(element).remove();
            return this
        },
        removeDetached: function(element) {
            All.removeDetached();
            return this
        },
        center: function(element) {
            this.get(element).center();
            return this
        },
        setOptions: function(element, options) {
            this.get(element).setOptions(options);
            return this
        },
        getDimensions: function(element) {
            var spinner = All.get(element)[0],
                diameter = spinner.getLayout().workspace.radius * 2;
            return {
                width: diameter,
                height: diameter
            }
        }
    });
    var All = {
        spinners: [],
        get: function(element) {
            if (!element) return;
            var matched = [];
            $.each(this.spinners, function(i, spinner) {
                if (spinner && (_.isElement(element) ? spinner.element == element : $(spinner.element).is(element))) matched.push(spinner)
            });
            return matched
        },
        add: function(spinner) {
            this.spinners.push(spinner)
        },
        remove: function(element) {
            $($.map(this.spinners, function(spinner, i) {
                if (_.isElement(element) ? spinner.element == element : $(spinner.element).is(element)) return spinner.element
            })).each($.proxy(function(i, e) {
                this.removeByElement(e)
            }, this))
        },
        removeByElement: function(element) {
            var spinner = this.get(element)[0];
            if (spinner) {
                spinner.remove();
                this.spinners = $.grep(this.spinners, function(s) {
                    return s.element != element
                })
            }
        },
        removeDetached: function() {
            $.each(this.spinners, $.proxy(function(i, spinner) {
                if (spinner && spinner.element &&
                    !_.element.isAttached(spinner.element)) this.remove(spinner.element)
            }, this))
        }
    };

    function Collection(element) {
        this.element = element
    }
    $.extend(Collection, {
        create: function(element) {
            if (!element) return;
            var options = arguments[1] || {},
                spinners = [];
            if (_.isElement(element)) spinners.push(new Spinner(element, options));
            else $(element).each(function(i, el) {
                spinners.push(new Spinner(el, options))
            });
            return spinners
        }
    });
    $.extend(Collection.prototype, {
        items: function() {
            return All.get(this.element)
        },
        play: function() {
            $.each(this.items(),
                function(i, s) {
                    s.play()
                });
            return this
        },
        stop: function() {
            $.each(this.items(), function(i, s) {
                s.stop()
            });
            return this
        },
        pause: function() {
            $.each(this.items(), function(i, s) {
                s.pause()
            });
            return this
        },
        toggle: function() {
            $.each(this.items(), function(i, s) {
                s.toggle()
            });
            return this
        },
        center: function() {
            $.each(this.items(), function(i, s) {
                s.center()
            });
            return this
        },
        setOptions: function(options) {
            $.each(this.items(), function(i, s) {
                s.setOptions(options)
            });
            return this
        },
        remove: function() {
            All.remove(this.element);
            return this
        }
    });

    function Spinner(element) {
        if (!element) return;
        this.element = element;
        All.remove(element);
        All.removeDetached();
        this._position = 0;
        this._state = "stopped";
        this.setOptions($.extend({
            color: "#000",
            dashes: 12,
            radius: 5,
            height: 5,
            width: 1.8,
            opacity: 1,
            padding: 3,
            rotation: 700
        }, arguments[1] || {}));
        this.drawPosition(0);
        All.add(this)
    }
    $.extend(Spinner.prototype, {
        setOptions: function(options) {
            this.options = $.extend({}, this.options, options || {});
            if (this.options.radii) {
                var radii = this.options.radii;
                this.options.radius = Math.min(radii[0],
                    radii[1]);
                this.options.height = Math.max(radii[0], radii[1]) - this.options.radius
            }
            if (this.options.dashWidth) this.options.width = this.options.dashWidth;
            if (this.options.speed) this.options.duration = this.options.speed * 1E3;
            var state = this._state,
                position = this._position;
            this._layout = null;
            this.build();
            if (position && position >= this.options.dashes - 1) this._position = this.options.dashes - 1;
            switch (state) {
                case "playing":
                    this.play();
                    break;
                case "paused":
                case "stopped":
                    this.drawPosition(this._position);
                    break
            }
            if (this._centered) this.center()
        },
        remove: function() {
            if (!this.canvas) return;
            this.pause();
            $(this.canvas).remove();
            this.canvas = null;
            this.ctx = null
        },
        build: function() {
            this.remove();
            var radius = this.getLayout().workspace.radius;
            $(document.body).append(this.canvas = $("<canvas>").attr({
                width: radius * 2,
                height: radius * 2
            }).css({
                zoom: 1
            }));
            if (window.G_vmlCanvasManager) G_vmlCanvasManager.initElement(this.canvas[0]);
            this.ctx = this.canvas[0].getContext("2d");
            this.ctx.globalAlpha = this.options.opacity;
            $(this.element).append(this.canvas);
            this.ctx.translate(radius,
                radius);
            return this
        },
        drawPosition: function(position) {
            var workspace = this.getLayout().workspace,
                opacities = _.scroll(workspace.opacities, position * -1),
                radius = workspace.radius,
                dashes = this.options.dashes,
                rotation = radian(360 / dashes);
            this.ctx.clearRect(radius * -1, radius * -1, radius * 2, radius * 2);
            for (var i = 0, len = dashes; i < len; i++) {
                this.drawDash(opacities[i], this.options.color);
                this.ctx.rotate(rotation)
            }
        },
        drawDash: function(opacity, color) {
            this.ctx.fillStyle = Color.hex2fill(color, opacity);
            var layout = this.getLayout(),
                workspaceRadius = layout.workspace.radius,
                dashPosition = layout.dash.position,
                dashDimensions = layout.dash.dimensions;
            Canvas.drawRoundedRectangle(this.ctx, {
                top: dashPosition.top - workspaceRadius,
                left: dashPosition.left - workspaceRadius,
                width: dashDimensions.width,
                height: dashDimensions.height,
                radius: Math.min(dashDimensions.height, dashDimensions.width) / 2
            })
        },
        _nextPosition: function() {
            var ms = this.options.rotation / this.options.dashes;
            this.nextPosition();
            this._playTimer = window.setTimeout($.proxy(this._nextPosition,
                this), ms)
        },
        nextPosition: function() {
            if (this._position == this.options.dashes - 1) this._position = -1;
            this._position++;
            this.drawPosition(this._position)
        },
        play: function() {
            if (this._state == "playing") return;
            this._state = "playing";
            var ms = this.options.rotation / this.options.dashes;
            this._playTimer = window.setTimeout($.proxy(this._nextPosition, this), ms);
            return this
        },
        pause: function() {
            if (this._state == "paused") return;
            this._pause();
            this._state = "paused";
            return this
        },
        _pause: function() {
            if (!this._playTimer) return;
            window.clearTimeout(this._playTimer);
            this._playTimer = null
        },
        stop: function() {
            if (this._state == "stopped") return;
            this._pause();
            this._position = 0;
            this.drawPosition(0);
            this._state = "stopped";
            return this
        },
        toggle: function() {
            this[this._state == "playing" ? "pause" : "play"]();
            return this
        },
        getLayout: function() {
            if (this._layout) return this._layout;
            var options = this.options,
                dashes = options.dashes,
                width = options.width,
                minRadius = options.radius,
                maxRadius = options.radius + options.height,
                maxWorkspaceRadius = Math.max(width, maxRadius),
                radius = Math.ceil(Math.max(maxWorkspaceRadius,
                    pyth(maxRadius, width / 2)));
            radius += options.padding;
            var layout = {
                workspace: {
                    radius: radius,
                    opacities: getOpacityArray(dashes)
                },
                dash: {
                    position: {
                        top: radius - maxRadius,
                        left: radius - width / 2
                    },
                    dimensions: {
                        width: width,
                        height: maxRadius - minRadius
                    }
                }
            };
            this._layout = layout;
            return layout
        },
        center: function() {
            var diameter = this.getLayout().workspace.radius * 2;
            $(this.element.parentNode).css({
                position: "relative"
            });
            $(this.element).css({
                position: "absolute",
                height: diameter + "px",
                width: diameter + "px",
                top: "50%",
                left: "50%",
                marginLeft: -.5 *
                    diameter + "px",
                marginTop: -.5 * diameter + "px"
            });
            this._centered = true
        }
    });
    Spinners.init();
    if (!Spinners.enabled) Collection.create = function() {
        return []
    }
})(jQuery);
(function(window, $, undefined) {
    var JSSOCIALS = "JSSocials",
        JSSOCIALS_DATA_KEY = JSSOCIALS;
    var getOrApply = function(value, context) {
        if ($.isFunction(value)) return value.apply(context, $.makeArray(arguments).slice(2));
        return value
    };
    var IMG_SRC_REGEX = /(\.(jpeg|png|gif|bmp|svg)$|^data:image\/(jpeg|png|gif|bmp|svg\+xml);base64)/i;
    var URL_PARAMS_REGEX = /(&?[a-zA-Z0-9]+=)?\{([a-zA-Z0-9]+)\}/g;
    var MEASURES = {
        "G": 1E9,
        "M": 1E6,
        "K": 1E3
    };
    var shares = {};

    function Socials(element, config) {
        var $element = $(element);
        $element.data(JSSOCIALS_DATA_KEY,
            this);
        this._$element = $element;
        this.shares = [];
        this._init(config);
        this._render()
    }
    Socials.prototype = {
        url: "",
        text: "",
        shareIn: "blank",
        showLabel: function(screenWidth) {
            return this.showCount === false ? screenWidth > this.smallScreenWidth : screenWidth >= this.largeScreenWidth
        },
        showCount: function(screenWidth) {
            return screenWidth <= this.smallScreenWidth ? "inside" : true
        },
        smallScreenWidth: 640,
        largeScreenWidth: 1024,
        resizeTimeout: 200,
        elementClass: "jssocials",
        sharesClass: "jssocials-shares",
        shareClass: "jssocials-share",
        shareButtonClass: "jssocials-share-button",
        shareLinkClass: "jssocials-share-link",
        shareLogoClass: "jssocials-share-logo",
        shareLabelClass: "jssocials-share-label",
        shareLinkCountClass: "jssocials-share-link-count",
        shareCountBoxClass: "jssocials-share-count-box",
        shareCountClass: "jssocials-share-count",
        shareZeroCountClass: "jssocials-share-no-count",
        _init: function(config) {
            this._initDefaults();
            $.extend(this, config);
            this._initShares();
            this._attachWindowResizeCallback()
        },
        _initDefaults: function() {
            this.url = window.location.href;
            this.text = $.trim($("meta[name=description]").attr("content") ||
                $("title").text())
        },
        _initShares: function() {
            this.shares = $.map(this.shares, $.proxy(function(shareConfig) {
                if (typeof shareConfig === "string") shareConfig = {
                    share: shareConfig
                };
                var share = shareConfig.share && shares[shareConfig.share];
                if (!share && !shareConfig.renderer) throw Error("Share '" + shareConfig.share + "' is not found");
                return $.extend({
                    url: this.url,
                    text: this.text
                }, share, shareConfig)
            }, this))
        },
        _attachWindowResizeCallback: function() {
            $(window).on("resize", $.proxy(this._windowResizeHandler, this))
        },
        _detachWindowResizeCallback: function() {
            $(window).off("resize",
                this._windowResizeHandler)
        },
        _windowResizeHandler: function() {
            if ($.isFunction(this.showLabel) || $.isFunction(this.showCount)) {
                window.clearTimeout(this._resizeTimer);
                this._resizeTimer = setTimeout($.proxy(this.refresh, this), this.resizeTimeout)
            }
        },
        _render: function() {
            this._clear();
            this._defineOptionsByScreen();
            this._$element.addClass(this.elementClass);
            this._$shares = $("<div>").addClass(this.sharesClass).appendTo(this._$element);
            this._renderShares()
        },
        _defineOptionsByScreen: function() {
            this._screenWidth = $(window).width();
            this._showLabel = getOrApply(this.showLabel, this, this._screenWidth);
            this._showCount = getOrApply(this.showCount, this, this._screenWidth)
        },
        _renderShares: function() {
            $.each(this.shares, $.proxy(function(_, share) {
                this._renderShare(share)
            }, this))
        },
        _renderShare: function(share) {
            var $share;
            if ($.isFunction(share.renderer)) $share = $(share.renderer());
            else $share = this._createShare(share);
            $share.addClass(this.shareClass).addClass(share.share ? "jssocials-share-" + share.share : "").addClass(share.css).appendTo(this._$shares)
        },
        _createShare: function(share) {
            var $result = $("<div>");
            var $shareLink = this._createShareLink(share).appendTo($result);
            if (this._showCount) {
                var isInsideCount = this._showCount === "inside";
                var $countContainer = isInsideCount ? $shareLink : $("<div>").addClass(this.shareCountBoxClass).appendTo($result);
                $countContainer.addClass(isInsideCount ? this.shareLinkCountClass : this.shareCountBoxClass);
                this._renderShareCount(share, $countContainer)
            }
            return $result
        },
        _createShareLink: function(share) {
            var shareStrategy = this._getShareStrategy(share);
            var $result = shareStrategy.call(share, {
                shareUrl: this._getShareUrl(share)
            });
            $result.addClass(this.shareLinkClass).append(this._createShareLogo(share));
            if (this._showLabel) $result.append(this._createShareLabel(share));
            $.each(this.on || {}, function(event, handler) {
                if ($.isFunction(handler)) $result.on(event, $.proxy(handler, share))
            });
            return $result
        },
        _getShareStrategy: function(share) {
            var result = shareStrategies[share.shareIn || this.shareIn];
            if (!result) throw Error("Share strategy '" + this.shareIn + "' not found");
            return result
        },
        _getShareUrl: function(share) {
            var shareUrl = getOrApply(share.shareUrl, share);
            return this._formatShareUrl(shareUrl, share)
        },
        _createShareLogo: function(share) {
            var logo = share.logo;
            var $result = IMG_SRC_REGEX.test(logo) ? $("<img>").attr("src", share.logo) : $("<i>").addClass(logo);
            $result.addClass(this.shareLogoClass);
            return $result
        },
        _createShareLabel: function(share) {
            return $("<span>").addClass(this.shareLabelClass).text(share.label)
        },
        _renderShareCount: function(share, $container) {
            var $count = $("<span>").addClass(this.shareCountClass);
            $container.addClass(this.shareZeroCountClass).append($count);
            this._loadCount(share).done($.proxy(function(count) {
                if (count) {
                    $container.removeClass(this.shareZeroCountClass);
                    $count.text(count)
                }
            }, this))
        },
        _loadCount: function(share) {
            var deferred = $.Deferred();
            var countUrl = this._getCountUrl(share);
            if (!countUrl) return deferred.resolve(0).promise();
            var handleSuccess = $.proxy(function(response) {
                deferred.resolve(this._getCountValue(response, share))
            }, this);
            $.getJSON(countUrl).done(handleSuccess).fail(function() {
                $.get(countUrl).done(handleSuccess).fail(function() {
                    deferred.resolve(0)
                })
            });
            return deferred.promise()
        },
        _getCountUrl: function(share) {
            var countUrl = getOrApply(share.countUrl, share);
            return this._formatShareUrl(countUrl, share)
        },
        _getCountValue: function(response, share) {
            var count = ($.isFunction(share.getCount) ? share.getCount(response) : response) || 0;
            return typeof count === "string" ? count : this._formatNumber(count)
        },
        _formatNumber: function(number) {
            $.each(MEASURES, function(letter, value) {
                if (number >= value) {
                    number = parseFloat((number / value).toFixed(2)) + letter;
                    return false
                }
            });
            return number
        },
        _formatShareUrl: function(url,
            share) {
            return url.replace(URL_PARAMS_REGEX, function(match, key, field) {
                var value = share[field] || "";
                return value ? (key || "") + window.encodeURIComponent(value) : ""
            })
        },
        _clear: function() {
            window.clearTimeout(this._resizeTimer);
            this._$element.empty()
        },
        _passOptionToShares: function(key, value) {
            var shares = this.shares;
            $.each(["url", "text"], function(_, optionName) {
                if (optionName !== key) return;
                $.each(shares, function(_, share) {
                    share[key] = value
                })
            })
        },
        _normalizeShare: function(share) {
            if ($.isNumeric(share)) return this.shares[share];
            if (typeof share === "string") return $.grep(this.shares, function(s) {
                return s.share === share
            })[0];
            return share
        },
        refresh: function() {
            this._render()
        },
        destroy: function() {
            this._clear();
            this._detachWindowResizeCallback();
            this._$element.removeClass(this.elementClass).removeData(JSSOCIALS_DATA_KEY)
        },
        option: function(key, value) {
            if (arguments.length === 1) return this[key];
            this[key] = value;
            this._passOptionToShares(key, value);
            this.refresh()
        },
        shareOption: function(share, key, value) {
            share = this._normalizeShare(share);
            if (arguments.length ===
                2) return share[key];
            share[key] = value;
            this.refresh()
        }
    };
    $.fn.jsSocials = function(config) {
        var args = $.makeArray(arguments),
            methodArgs = args.slice(1),
            result = this;
        this.each(function() {
            var $element = $(this),
                instance = $element.data(JSSOCIALS_DATA_KEY),
                methodResult;
            if (instance)
                if (typeof config === "string") {
                    methodResult = instance[config].apply(instance, methodArgs);
                    if (methodResult !== undefined && methodResult !== instance) {
                        result = methodResult;
                        return false
                    }
                } else {
                    instance._detachWindowResizeCallback();
                    instance._init(config);
                    instance._render()
                } else new Socials($element, config)
        });
        return result
    };
    var setDefaults = function(config) {
        var component;
        if ($.isPlainObject(config)) component = Socials.prototype;
        else {
            component = shares[config];
            config = arguments[1] || {}
        }
        $.extend(component, config)
    };
    var shareStrategies = {
        popup: function(args) {
            return $("<a>").attr("href", "#").on("click", function() {
                window.open(args.shareUrl, null, "width=600, height=400, location=0, menubar=0, resizeable=0, scrollbars=0, status=0, titlebar=0, toolbar=0");
                return false
            })
        },
        blank: function(args) {
            return $("<a>").attr({
                target: "_blank",
                href: args.shareUrl
            })
        },
        self: function(args) {
            return $("<a>").attr({
                target: "_self",
                href: args.shareUrl
            })
        }
    };
    window.jsSocials = {
        Socials: Socials,
        shares: shares,
        shareStrategies: shareStrategies,
        setDefaults: setDefaults
    }
})(window, jQuery);
(function(window, $, jsSocials, undefined) {
    $.extend(jsSocials.shares, {
        email: {
            label: "E-mail",
            logo: "fa fa-at",
            shareUrl: "mailto:{to}?subject={text}&body={url}",
            countUrl: "",
            shareIn: "self"
        },
        twitter: {
            label: "Tweet",
            logo: "fa fa-twitter",
            shareUrl: "https://twitter.com/share?url={url}&text={text}&via={via}&hashtags={hashtags}",
            countUrl: ""
        },
        facebook: {
            label: "Like",
            logo: "fa fa-facebook",
            shareUrl: "https://facebook.com/sharer/sharer.php?u={url}",
            countUrl: "https://graph.facebook.com/?id={url}",
            getCount: function(data) {
                return data.share &&
                    data.share.share_count || 0
            }
        },
        vkontakte: {
            label: "Like",
            logo: "fa fa-vk",
            shareUrl: "https://vk.com/share.php?url={url}&title={title}&description={text}",
            countUrl: "https://vk.com/share.php?act=count&index=1&url={url}",
            getCount: function(data) {
                return parseInt(data.slice(15, -2).split(", ")[1])
            }
        },
        googleplus: {
            label: "+1",
            logo: "fa fa-google",
            shareUrl: "https://plus.google.com/share?url={url}",
            countUrl: ""
        },
        linkedin: {
            label: "Share",
            logo: "fa fa-linkedin",
            shareUrl: "https://www.linkedin.com/shareArticle?mini=true&url={url}",
            countUrl: "https://www.linkedin.com/countserv/count/share?format=jsonp&url={url}&callback=?",
            getCount: function(data) {
                return data.count
            }
        },
        pinterest: {
            label: "Pin it",
            logo: "fa fa-pinterest",
            shareUrl: "https://pinterest.com/pin/create/bookmarklet/?media={media}&url={url}&description={text}",
            countUrl: "https://api.pinterest.com/v1/urls/count.json?&url={url}&callback=?",
            getCount: function(data) {
                return data.count
            }
        },
        stumbleupon: {
            label: "Share",
            logo: "fa fa-stumbleupon",
            shareUrl: "http://www.stumbleupon.com/submit?url={url}&title={title}",
            countUrl: "https://cors-anywhere.herokuapp.com/https://www.stumbleupon.com/services/1.01/badge.getinfo?url={url}",
            getCount: function(data) {
                return data.result.views
            }
        },
        telegram: {
            label: "Telegram",
            logo: "fa fa-paper-plane",
            shareUrl: "tg://msg?text={url} {text}",
            countUrl: "",
            shareIn: "self"
        },
        whatsapp: {
            label: "WhatsApp",
            logo: "fa fa-whatsapp",
            shareUrl: "whatsapp://send?text={url} {text}",
            countUrl: "",
            shareIn: "self"
        },
        line: {
            label: "LINE",
            logo: "fa fa-comment",
            shareUrl: "http://line.me/R/msg/text/?{text} {url}",
            countUrl: ""
        },
        viber: {
            label: "Viber",
            logo: "fa fa-volume-control-phone",
            shareUrl: "viber://forward?text={url} {text}",
            countUrl: "",
            shareIn: "self"
        },
        pocket: {
            label: "Pocket",
            logo: "fa fa-get-pocket",
            shareUrl: "https://getpocket.com/save?url={url}&title={title}",
            countUrl: ""
        },
        messenger: {
            label: "Share",
            logo: "fa fa-commenting",
            shareUrl: "fb-messenger://share?link={url}",
            countUrl: "",
            shareIn: "self"
        }
    })
})(window, jQuery, window.jsSocials);
(function(window) {
    if (!Object.defineProperty) throw "Font.js requires Object.defineProperty, which this browser does not support.";
    if (!document.createElement("canvas").getContext) throw "Font.js requires <canvas> and the Canvas2D API, which this browser does not support.";
    (function(window) {
        try {
            var a = new Uint8Array(1);
            return
        } catch (e) {}

        function subarray(start, end) {
            return this.slice(start, end)
        }

        function set_(array, offset) {
            var i, n = array.length;
            if (arguments.length < 2) offset = 0;
            for (i = 0; i < n; ++i, ++offset) this[offset] =
                array[i] & 255
        }

        function TypedArray(arg1) {
            var result, i;
            if (typeof arg1 === "number") {
                result = new Array(arg1);
                for (i = 0; i < arg1; ++i) result[i] = 0
            } else result = arg1.slice(0);
            result.subarray = subarray;
            result.buffer = result;
            result.byteLength = result.length;
            result.set = set_;
            if (typeof arg1 === "object" && arg1.buffer) result.buffer = arg1.buffer;
            return result
        }
        window.Uint8Array = TypedArray;
        window.Uint32Array = TypedArray;
        window.Int32Array = TypedArray
    })(window);
    (function(window) {
        if (window.opera) return;
        if ("response" in XMLHttpRequest.prototype ||
            "mozResponseArrayBuffer" in XMLHttpRequest.prototype || "mozResponse" in XMLHttpRequest.prototype || "responseArrayBuffer" in XMLHttpRequest.prototype) return;
        var getter;
        if (window.VBArray) getter = function() {
            return new Uint8Array((new VBArray(this.responseBody)).toArray())
        };
        else getter = function() {
            this.responseBody
        };
        Object.defineProperty(XMLHttpRequest.prototype, "response", {
            get: getter
        })
    })(window);
    if (!window.btoa) window.btoa = function(data) {
        var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
            ac = 0,
            enc = "",
            tmp_arr = [];
        if (!data) return data;
        do {
            o1 = data.charCodeAt(i++);
            o2 = data.charCodeAt(i++);
            o3 = data.charCodeAt(i++);
            bits = o1 << 16 | o2 << 8 | o3;
            h1 = bits >> 18 & 63;
            h2 = bits >> 12 & 63;
            h3 = bits >> 6 & 63;
            h4 = bits & 63;
            tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4)
        } while (i < data.length);
        enc = tmp_arr.join("");
        var r = data.length % 3;
        return (r ? enc.slice(0, r - 3) : enc) + "===".slice(r || 3)
    };

    function Font() {
        this.fontFamily = "fjs" + (999999 * Math.random() | 0)
    }
    Font.prototype.url = "";
    Font.prototype.format =
        "";
    Font.prototype.data = "";
    Font.prototype.base64 = "AAEAAAAKAIAAAwAgT1MvMgAAAAAAAACsAAAAWGNtYXAA" + "AAAAAAABBAAAACxnbHlmAAAAAAAAATAAAAAQaGVhZAAAA" + "AAAAAFAAAAAOGhoZWEAAAAAAAABeAAAACRobXR4AAAAAA" + "AAAZwAAAAIbG9jYQAAAAAAAAGkAAAACG1heHAAAAAAAAA" + "BrAAAACBuYW1lAAAAAAAAAcwAAAAgcG9zdAAAAAAAAAHs" + "AAAAEAAEAAEAZAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAABAAMAAQA" + "AAAwABAAgAAAABAAEAAEAAABB//8AAABB////wAABAAAA" + "AAABAAAAAAAAAAAAAAAAMQAAAQAAAAAAAAAAAABfDzz1A" +
        "AAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAEAAg" + "AAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAQAAAAAAAAAAAAAAAAAIAAAAAQAAAAIAAQAB" + "AAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAIAHgADAAEEC" + "QABAAAAAAADAAEECQACAAIAAAAAAAEAAAAAAAAAAAAAAA" + "AAAA==";
    Font.prototype.metrics = {
        quadsize: 0,
        leading: 0,
        ascent: 0,
        descent: 0,
        weightclass: 400
    };
    Font.prototype.systemfont = false;
    Font.prototype.loaded = false;
    Font.prototype.onload = function() {};
    Font.prototype.onerror = function() {};
    Font.prototype.canvas = false;
    Font.prototype.context =
        false;
    Font.prototype.validate = function(target, zero, mark, font, timeout) {
        if (timeout !== false && timeout < 0) {
            this.onerror("Requested system font '" + this.fontFamily + "' could not be loaded (it may not be installed).");
            return
        }
        var width = getComputedStyle(target, null).getPropertyValue("width").replace("px", "");
        if (width > 0) {
            document.head.removeChild(zero);
            document.body.removeChild(target);
            this.loaded = true;
            this.onload()
        } else {
            console.log("timing out");
            setTimeout(function() {
                font.validate(target, zero, mark, font, timeout ===
                    false ? false : timeout - 50)
            }, 1E3)
        }
    };
    Font.prototype.ondownloaded = function() {
        var instance = this;
        var chr = function(val) {
            return String.fromCharCode(val)
        };
        var chr16 = function(val) {
            if (val < 256) return chr(0) + chr(val);
            var b1 = val >> 8;
            var b2 = val & 255;
            return chr(b1) + chr(b2)
        };
        var dechex = function(val) {
            if (val < 0) val = 4294967295 + val + 1;
            return parseInt(val, 10).toString(16)
        };
        var ushort = function(b1, b2) {
            return 256 * b1 + b2
        };
        var fword = function(b1, b2) {
            var negative = b1 >> 7 === 1,
                val;
            b1 = b1 & 127;
            val = 256 * b1 + b2;
            if (!negative) return val;
            return val -
                32768
        };
        var ulong = function(b1, b2, b3, b4) {
            return 16777216 * b1 + 65536 * b2 + 256 * b3 + b4
        };
        var error = function(msg) {
            instance.onerror(msg)
        };
        var ttf = chr(0) + chr(1) + chr(0) + chr(0);
        var cff = "OTTO";
        var data = this.data;
        var version = chr(data[0]) + chr(data[1]) + chr(data[2]) + chr(data[3]);
        var isTTF = version === ttf;
        var isCFF = isTTF ? false : version === cff;
        if (isTTF) this.format = "truetype";
        else if (isCFF) this.format = "opentype";
        else {
            error("Error: file at " + this.url + " cannot be interpreted as OpenType font.");
            return
        }
        var numTables = ushort(data[4],
                data[5]),
            tagStart = 12,
            ptr, end = tagStart + 16 * numTables,
            tags = {},
            tag;
        for (ptr = tagStart; ptr < end; ptr += 16) {
            tag = chr(data[ptr]) + chr(data[ptr + 1]) + chr(data[ptr + 2]) + chr(data[ptr + 3]);
            tags[tag] = {
                name: tag,
                checksum: ulong(data[ptr + 4], data[ptr + 5], data[ptr + 6], data[ptr + 7]),
                offset: ulong(data[ptr + 8], data[ptr + 9], data[ptr + 10], data[ptr + 11]),
                length: ulong(data[ptr + 12], data[ptr + 13], data[ptr + 14], data[ptr + 15])
            }
        }
        var checkTableError = function(tag) {
            if (!tags[tag]) {
                error("Error: font is missing the required OpenType '" + tag + "' table.");
                return false
            }
            return tag
        };
        tag = checkTableError("head");
        if (tag === false) return;
        ptr = tags[tag].offset;
        tags[tag].version = "" + data[ptr] + data[ptr + 1] + data[ptr + 2] + data[ptr + 3];
        var unitsPerEm = ushort(data[ptr + 18], data[ptr + 19]);
        this.metrics.quadsize = unitsPerEm;
        tag = checkTableError("hhea");
        if (tag === false) return;
        ptr = tags[tag].offset;
        tags[tag].version = "" + data[ptr] + data[ptr + 1] + data[ptr + 2] + data[ptr + 3];
        this.metrics.ascent = fword(data[ptr + 4], data[ptr + 5]) / unitsPerEm;
        this.metrics.descent = fword(data[ptr + 6], data[ptr + 7]) / unitsPerEm;
        this.metrics.leading = fword(data[ptr + 8], data[ptr + 9]) / unitsPerEm;
        tag = checkTableError("OS/2");
        if (tag === false) return;
        ptr = tags[tag].offset;
        tags[tag].version = "" + data[ptr] + data[ptr + 1];
        this.metrics.weightclass = ushort(data[ptr + 4], data[ptr + 5]);
        tag = checkTableError("cmap");
        if (tag === false) return;
        ptr = tags[tag].offset;
        tags[tag].version = "" + data[ptr] + data[ptr + 1];
        numTables = ushort(data[ptr + 2], data[ptr + 3]);
        var encodingRecord, rptr, platformID, encodingID, offset, cmap314 = false;
        for (var encodingRecord = 0; encodingRecord < numTables; encodingRecord++) {
            rptr =
                ptr + 4 + encodingRecord * 8;
            platformID = ushort(data[rptr], data[rptr + 1]);
            encodingID = ushort(data[rptr + 2], data[rptr + 3]);
            offset = ulong(data[rptr + 4], data[rptr + 5], data[rptr + 6], data[rptr + 7]);
            if (platformID === 3 && encodingID === 1) cmap314 = offset
        }
        var printChar = "A";
        if (cmap314 !== false) {
            ptr += cmap314;
            version = ushort(data[ptr], data[ptr + 1]);
            if (version === 4) {
                var segCount = ushort(data[ptr + 6], data[ptr + 7]) / 2;
                var printable = function(chr) {
                    return [9, 10, 11, 12, 13, 32, 127, 128, 129, 141, 142, 143, 144, 149, 157, 158, 160, 8192, 8193, 8194, 8195, 8196, 8197,
                        8198, 8199, 8200, 8201, 8202, 8203, 8204, 8205, 8206, 8207, 8232, 8233, 8234, 8235, 8235, 8236, 8237, 8238, 8239, 8287, 8288, 8289, 8290, 8291, 8292, 12288
                    ].indexOf(chr) === -1
                };
                var i = ptr + 14,
                    e = ptr + 14 + 2 * segCount,
                    endChar = false;
                for (; i < e; i += 2) {
                    endChar = ushort(data[i], data[i + 1]);
                    if (printable(endChar)) break;
                    endChar = false
                }
                if (endChar != false) {
                    printChar = String.fromCharCode(endChar);
                    var delta = (-(endChar - 1) + 65536) % 65536;
                    var newcode = chr(0) + chr16(endChar) + chr16(65535) + chr16(0) + chr16(endChar) + chr16(65535) + chr16(delta) + chr16(1);
                    var newhex =
                        btoa(newcode);
                    this.base64 = this.base64.substring(0, 380) + newhex + this.base64.substring(380 + newhex.length)
                }
            }
        }
        this.bootstrapValidation(printChar, false)
    };
    Font.prototype.bootstrapValidation = function(printChar, timeout) {
        var tfName = this.fontFamily + " testfont";
        var zerowidth = document.createElement("style");
        zerowidth.setAttribute("type", "text/css");
        zerowidth.innerHTML = "@font-face {\n" + "  font-family: '" + tfName + "';\n" + "  src: url('data:application/x-font-ttf;base64," + this.base64 + "')\n" + "       format('truetype');}";
        document.head.appendChild(zerowidth);
        var realfont = false;
        if (!this.systemfont) {
            realfont = this.toStyleNode();
            document.head.appendChild(realfont)
        }
        var para = document.createElement("p");
        para.style.cssText = "position: absolute; top: 0; left: 0; opacity: 0;";
        para.style.fontFamily = "'" + this.fontFamily + "', '" + tfName + "'";
        para.innerHTML = printChar + printChar + printChar + printChar + printChar + printChar + printChar + printChar + printChar + printChar;
        document.body.appendChild(para);
        if (typeof getComputedStyle === "undefined") {
            this.onload();
            error("Error: getComputedStyle is not supported by this browser.\n" + "Consequently, Font.onload() cannot be trusted.")
        } else {
            var quad = this.systemfont ? 1E3 : this.metrics.quadsize;
            var canvas = document.createElement("canvas");
            canvas.width = quad;
            canvas.height = quad;
            this.canvas = canvas;
            var context = canvas.getContext("2d");
            context.font = "1em '" + this.fontFamily + "'";
            context.fillStyle = "white";
            context.fillRect(-1, -1, quad + 2, quad + 2);
            context.fillStyle = "black";
            context.fillText("test text", 50, quad / 2);
            this.context = context;
            var local = this;
            var delayedValidate = function() {
                local.validate(para, zerowidth, realfont, local, timeout)
            };
            setTimeout(delayedValidate, 50)
        }
    };
    Font.prototype.processSystemFont = function() {
        this.systemfont = true;
        this.metrics = false;
        this.bootstrapValidation("A", 1E3)
    };
    Font.prototype.loadFont = function() {
        var font = this;
        if (this.url.indexOf(".") === -1) {
            setTimeout(function() {
                font.processSystemFont()
            }, 10);
            return
        }
        var xhr = new XMLHttpRequest;
        xhr.open("GET", font.url, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = function(evt) {
            var arrayBuffer =
                xhr.response;
            if (arrayBuffer) {
                font.data = new Uint8Array(arrayBuffer);
                font.ondownloaded()
            } else font.onerror("Error downloading font resource from " + font.url)
        };
        xhr.onerror = function(evt) {
            font.onerror("Error downloading font resource from " + font.url)
        };
        xhr.send(null)
    };
    Font.prototype.styleNode = false;
    Font.prototype.toStyleNode = function() {
        if (this.styleNode) return this.styleNode;
        this.styleNode = document.createElement("style");
        this.styleNode.type = "text/css";
        var styletext = "@font-face {\n";
        styletext += "  font-family: '" +
            this.fontFamily + "';\n";
        styletext += "  src: url('" + this.url + "') format('" + this.format + "');\n";
        styletext += "}";
        this.styleNode.innerHTML = styletext;
        return this.styleNode
    };
    Font.prototype.measureText = function(textString, fontSize) {
        if (!this.loaded) {
            this.onerror("measureText() was called while the font was not yet loaded");
            return false
        }
        this.context.font = fontSize + "px '" + this.fontFamily + "'";
        var metrics = this.context.measureText(textString);
        metrics.fontsize = fontSize;
        metrics.ascent = 0;
        metrics.descent = 0;
        metrics.bounds = {
            minx: 0,
            maxx: metrics.width,
            miny: 0,
            maxy: 0
        };
        metrics.height = 0;
        var segments = [],
            minSegments = metrics.width / this.metrics.quadsize;
        if (minSegments <= 1) segments.push(textString);
        else segments.push(textString);
        var segmentLength = segments.length,
            i;
        for (i = 0; i < segmentLength; i++) this.measureSegment(segments[i], fontSize, metrics);
        return metrics
    };
    Font.prototype.measureSegment = function(textSegment, fontSize, metrics) {
        var getCSSValue = function(element, property) {
            return document.defaultView.getComputedStyle(element, null).getPropertyValue(property)
        };
        var i;
        var leadDiv = document.createElement("div");
        leadDiv.style.position = "absolute";
        leadDiv.style.opacity = 0;
        leadDiv.style.font = fontSize + "px '" + this.fontFamily + "'";
        var numLines = 10;
        leadDiv.innerHTML = textSegment;
        for (i = 1; i < numLines; i++) leadDiv.innerHTML += "<br/>" + textSegment;
        document.body.appendChild(leadDiv);
        metrics.leading = 1.2 * fontSize;
        var leadDivHeight = getCSSValue(leadDiv, "height");
        leadDivHeight = leadDivHeight.replace("px", "");
        if (leadDivHeight >= fontSize * numLines) metrics.leading = leadDivHeight / numLines |
            0;
        document.body.removeChild(leadDiv);
        if (/^\s*$/.test(textSegment)) return metrics;
        var canvas = this.canvas,
            ctx = this.context,
            quad = this.systemfont ? 1E3 : this.metrics.quadsize,
            w = quad,
            h = quad,
            baseline = quad / 2,
            padding = 50,
            xpos = (quad - metrics.width) / 2;
        if (xpos !== (xpos | 0)) xpos = xpos | 0;
        ctx.fillStyle = "white";
        ctx.fillRect(-padding, -padding, w + 2 * padding, h + 2 * padding);
        ctx.fillStyle = "black";
        ctx.fillText(textSegment, xpos, baseline);
        var scanwidth = metrics.width + padding | 0,
            scanheight = 4 * fontSize,
            x_offset = xpos - padding / 2,
            y_offset =
            baseline - scanheight / 2,
            pixelData = ctx.getImageData(x_offset, y_offset, scanwidth, scanheight).data;
        var i = 0,
            j = 0,
            w4 = scanwidth * 4,
            len = pixelData.length,
            mid = scanheight / 2;
        while (++i < len && pixelData[i] === 255);
        var ascent = i / w4 | 0;
        i = len - 1;
        while (--i > 0 && pixelData[i] === 255);
        var descent = i / w4 | 0;
        for (i = 0, j = 0; j < scanwidth && pixelData[i] === 255;) {
            i += w4;
            if (i >= len) {
                j++;
                i = i - len + 4
            }
        }
        var minx = j;
        var step = 1;
        for (i = len - 3, j = 0; j < scanwidth && pixelData[i] === 255;) {
            i -= w4;
            if (i < 0) {
                j++;
                i = len - 3 - step++ * 4
            }
        }
        var maxx = scanwidth - j;
        metrics.ascent = mid - ascent;
        metrics.descent = descent - mid;
        metrics.bounds = {
            minx: minx - padding / 2,
            maxx: maxx - padding / 2,
            miny: -metrics.descent,
            maxy: metrics.ascent
        };
        metrics.height = 1 + (descent - ascent);
        return metrics
    };
    Object.defineProperty(Font.prototype, "src", {
        set: function(url) {
            this.url = url;
            this.loadFont()
        }
    });
    if (typeof define !== "undefined") define(function() {
        return Font
    });
    else window.Font = Font
})(window);
(function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === "object" && typeof module === "object") module.exports = factory();
    else if (typeof define === "function" && define.amd) define([], factory);
    else if (typeof exports === "object") exports["Scrollbar"] = factory();
    else root["Scrollbar"] = factory()
})(this, function() {
    return function(modules) {
        var installedModules = {};

        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                exports: {},
                id: moduleId,
                loaded: false
            };
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            module.loaded = true;
            return module.exports
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0)
    }([function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__(1)
        }, function(module, exports, __webpack_require__) {
            var _from = __webpack_require__(2);
            var _from2 = _interopRequireDefault(_from);
            var _iterator =
                __webpack_require__(55);
            var _iterator2 = _interopRequireDefault(_iterator);
            var _symbol = __webpack_require__(62);
            var _symbol2 = _interopRequireDefault(_symbol);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function(obj) {
                return typeof obj
            } : function(obj) {
                return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj
            };

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ?
                    obj : {
                        default: obj
                    }
            }
            var _smoothScrollbar = __webpack_require__(78);
            var _shared = __webpack_require__(89);
            __webpack_require__(129);
            __webpack_require__(145);
            __webpack_require__(158);
            __webpack_require__(173);
            __webpack_require__(187);

            function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                    return arr2
                } else return (0, _from2.default)(arr)
            }
            exports.default = _smoothScrollbar.SmoothScrollbar;
            _smoothScrollbar.SmoothScrollbar.version = "7.2.7";
            _smoothScrollbar.SmoothScrollbar.init =
                function(elem, options) {
                    if (!elem || elem.nodeType !== 1) throw new TypeError("expect element to be DOM Element, but got " + (typeof elem === "undefined" ? "undefined" : _typeof(elem)));
                    if (_shared.sbList.has(elem)) return _shared.sbList.get(elem);
                    elem.setAttribute("data-scrollbar", "");
                    var childNodes = [].concat(_toConsumableArray(elem.childNodes));
                    var div = document.createElement("div");
                    div.innerHTML = '\n        <article class="scroll-content"></article>\n        <aside class="scrollbar-track scrollbar-track-x">\n            <div style="display:none;" class="scrollbar-thumb scrollbar-thumb-x"></div>\n        </aside>\n        <aside class="scrollbar-track scrollbar-track-y">\n            <div class="scrollbar-thumb scrollbar-thumb-y"></div>\n        </aside>\n        <canvas class="overscroll-glow"></canvas>\n    ';
                    var scrollContent = div.querySelector(".scroll-content");
                    [].concat(_toConsumableArray(div.childNodes)).forEach(function(el) {
                        return elem.appendChild(el)
                    });
                    childNodes.forEach(function(el) {
                        return scrollContent.appendChild(el)
                    });
                    return new _smoothScrollbar.SmoothScrollbar(elem, options)
                };
            _smoothScrollbar.SmoothScrollbar.initAll = function(options) {
                return [].concat(_toConsumableArray(document.querySelectorAll(_shared.selectors))).map(function(el) {
                    return _smoothScrollbar.SmoothScrollbar.init(el, options)
                })
            };
            _smoothScrollbar.SmoothScrollbar.has =
                function(elem) {
                    return _shared.sbList.has(elem)
                };
            _smoothScrollbar.SmoothScrollbar.get = function(elem) {
                return _shared.sbList.get(elem)
            };
            _smoothScrollbar.SmoothScrollbar.getAll = function() {
                return [].concat(_toConsumableArray(_shared.sbList.values()))
            };
            _smoothScrollbar.SmoothScrollbar.destroy = function(elem, isRemoval) {
                return _smoothScrollbar.SmoothScrollbar.has(elem) && _smoothScrollbar.SmoothScrollbar.get(elem).destroy(isRemoval)
            };
            _smoothScrollbar.SmoothScrollbar.destroyAll = function(isRemoval) {
                _shared.sbList.forEach(function(sb) {
                    sb.destroy(isRemoval)
                })
            };
            module.exports = exports["default"]
        }, function(module, exports, __webpack_require__) {
            module.exports = {
                "default": __webpack_require__(3),
                __esModule: true
            }
        }, function(module, exports, __webpack_require__) {
            __webpack_require__(4);
            __webpack_require__(48);
            module.exports = __webpack_require__(12).Array.from
        }, function(module, exports, __webpack_require__) {
            var $at = __webpack_require__(5)(true);
            __webpack_require__(8)(String, "String", function(iterated) {
                this._t = String(iterated);
                this._i = 0
            }, function() {
                var O = this._t,
                    index = this._i,
                    point;
                if (index >= O.length) return {
                    value: undefined,
                    done: true
                };
                point = $at(O, index);
                this._i += point.length;
                return {
                    value: point,
                    done: false
                }
            })
        }, function(module, exports, __webpack_require__) {
            var toInteger = __webpack_require__(6),
                defined = __webpack_require__(7);
            module.exports = function(TO_STRING) {
                return function(that, pos) {
                    var s = String(defined(that)),
                        i = toInteger(pos),
                        l = s.length,
                        a, b;
                    if (i < 0 || i >= l) return TO_STRING ? "" : undefined;
                    a = s.charCodeAt(i);
                    return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ?
                        s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536
                }
            }
        }, function(module, exports) {
            var ceil = Math.ceil,
                floor = Math.floor;
            module.exports = function(it) {
                return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it)
            }
        }, function(module, exports) {
            module.exports = function(it) {
                if (it == undefined) throw TypeError("Can't call method on  " + it);
                return it
            }
        }, function(module, exports, __webpack_require__) {
            var LIBRARY = __webpack_require__(9),
                $export = __webpack_require__(10),
                redefine = __webpack_require__(25),
                hide = __webpack_require__(15),
                has = __webpack_require__(26),
                Iterators = __webpack_require__(27),
                $iterCreate = __webpack_require__(28),
                setToStringTag = __webpack_require__(44),
                getPrototypeOf = __webpack_require__(46),
                ITERATOR = __webpack_require__(45)("iterator"),
                BUGGY = !([].keys && "next" in [].keys()),
                FF_ITERATOR = "@@iterator",
                KEYS = "keys",
                VALUES = "values";
            var returnThis = function() {
                return this
            };
            module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
                $iterCreate(Constructor, NAME, next);
                var getMethod = function(kind) {
                    if (!BUGGY && kind in
                        proto) return proto[kind];
                    switch (kind) {
                        case KEYS:
                            return function keys() {
                                return new Constructor(this, kind)
                            };
                        case VALUES:
                            return function values() {
                                return new Constructor(this, kind)
                            }
                    }
                    return function entries() {
                        return new Constructor(this, kind)
                    }
                };
                var TAG = NAME + " Iterator",
                    DEF_VALUES = DEFAULT == VALUES,
                    VALUES_BUG = false,
                    proto = Base.prototype,
                    $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
                    $default = $native || getMethod(DEFAULT),
                    $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : undefined,
                    $anyNative = NAME == "Array" ? proto.entries || $native : $native,
                    methods, key, IteratorPrototype;
                if ($anyNative) {
                    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
                    if (IteratorPrototype !== Object.prototype) {
                        setToStringTag(IteratorPrototype, TAG, true);
                        if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis)
                    }
                }
                if (DEF_VALUES && $native && $native.name !== VALUES) {
                    VALUES_BUG = true;
                    $default = function values() {
                        return $native.call(this)
                    }
                }
                if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) hide(proto,
                    ITERATOR, $default);
                Iterators[NAME] = $default;
                Iterators[TAG] = returnThis;
                if (DEFAULT) {
                    methods = {
                        values: DEF_VALUES ? $default : getMethod(VALUES),
                        keys: IS_SET ? $default : getMethod(KEYS),
                        entries: $entries
                    };
                    if (FORCED)
                        for (key in methods) {
                            if (!(key in proto)) redefine(proto, key, methods[key])
                        } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods)
                }
                return methods
            }
        }, function(module, exports) {
            module.exports = true
        }, function(module, exports, __webpack_require__) {
            var global = __webpack_require__(11),
                core = __webpack_require__(12),
                ctx = __webpack_require__(13),
                hide = __webpack_require__(15),
                PROTOTYPE = "prototype";
            var $export = function(type, name, source) {
                var IS_FORCED = type & $export.F,
                    IS_GLOBAL = type & $export.G,
                    IS_STATIC = type & $export.S,
                    IS_PROTO = type & $export.P,
                    IS_BIND = type & $export.B,
                    IS_WRAP = type & $export.W,
                    exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
                    expProto = exports[PROTOTYPE],
                    target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
                    key, own, out;
                if (IS_GLOBAL) source = name;
                for (key in source) {
                    own = !IS_FORCED && target &&
                        target[key] !== undefined;
                    if (own && key in exports) continue;
                    out = own ? target[key] : source[key];
                    exports[key] = IS_GLOBAL && typeof target[key] != "function" ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function(C) {
                        var F = function(a, b, c) {
                            if (this instanceof C) {
                                switch (arguments.length) {
                                    case 0:
                                        return new C;
                                    case 1:
                                        return new C(a);
                                    case 2:
                                        return new C(a, b)
                                }
                                return new C(a, b, c)
                            }
                            return C.apply(this, arguments)
                        };
                        F[PROTOTYPE] = C[PROTOTYPE];
                        return F
                    }(out) : IS_PROTO && typeof out == "function" ? ctx(Function.call,
                        out) : out;
                    if (IS_PROTO) {
                        (exports.virtual || (exports.virtual = {}))[key] = out;
                        if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out)
                    }
                }
            };
            $export.F = 1;
            $export.G = 2;
            $export.S = 4;
            $export.P = 8;
            $export.B = 16;
            $export.W = 32;
            $export.U = 64;
            $export.R = 128;
            module.exports = $export
        }, function(module, exports) {
            var global = module.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
            if (typeof __g == "number") __g = global
        }, function(module, exports) {
            var core =
                module.exports = {
                    version: "2.4.0"
                };
            if (typeof __e == "number") __e = core
        }, function(module, exports, __webpack_require__) {
            var aFunction = __webpack_require__(14);
            module.exports = function(fn, that, length) {
                aFunction(fn);
                if (that === undefined) return fn;
                switch (length) {
                    case 1:
                        return function(a) {
                            return fn.call(that, a)
                        };
                    case 2:
                        return function(a, b) {
                            return fn.call(that, a, b)
                        };
                    case 3:
                        return function(a, b, c) {
                            return fn.call(that, a, b, c)
                        }
                }
                return function() {
                    return fn.apply(that, arguments)
                }
            }
        }, function(module, exports) {
            module.exports =
                function(it) {
                    if (typeof it != "function") throw TypeError(it + " is not a function!");
                    return it
                }
        }, function(module, exports, __webpack_require__) {
            var dP = __webpack_require__(16),
                createDesc = __webpack_require__(24);
            module.exports = __webpack_require__(20) ? function(object, key, value) {
                return dP.f(object, key, createDesc(1, value))
            } : function(object, key, value) {
                object[key] = value;
                return object
            }
        }, function(module, exports, __webpack_require__) {
            var anObject = __webpack_require__(17),
                IE8_DOM_DEFINE = __webpack_require__(19),
                toPrimitive =
                __webpack_require__(23),
                dP = Object.defineProperty;
            exports.f = __webpack_require__(20) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
                anObject(O);
                P = toPrimitive(P, true);
                anObject(Attributes);
                if (IE8_DOM_DEFINE) try {
                    return dP(O, P, Attributes)
                } catch (e) {}
                if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
                if ("value" in Attributes) O[P] = Attributes.value;
                return O
            }
        }, function(module, exports, __webpack_require__) {
            var isObject = __webpack_require__(18);
            module.exports = function(it) {
                if (!isObject(it)) throw TypeError(it +
                    " is not an object!");
                return it
            }
        }, function(module, exports) {
            module.exports = function(it) {
                return typeof it === "object" ? it !== null : typeof it === "function"
            }
        }, function(module, exports, __webpack_require__) {
            module.exports = !__webpack_require__(20) && !__webpack_require__(21)(function() {
                return Object.defineProperty(__webpack_require__(22)("div"), "a", {
                    get: function() {
                        return 7
                    }
                }).a != 7
            })
        }, function(module, exports, __webpack_require__) {
            module.exports = !__webpack_require__(21)(function() {
                return Object.defineProperty({}, "a", {
                    get: function() {
                        return 7
                    }
                }).a != 7
            })
        }, function(module, exports) {
            module.exports = function(exec) {
                try {
                    return !!exec()
                } catch (e) {
                    return true
                }
            }
        }, function(module, exports, __webpack_require__) {
            var isObject = __webpack_require__(18),
                document = __webpack_require__(11).document,
                is = isObject(document) && isObject(document.createElement);
            module.exports = function(it) {
                return is ? document.createElement(it) : {}
            }
        }, function(module, exports, __webpack_require__) {
            var isObject = __webpack_require__(18);
            module.exports = function(it, S) {
                if (!isObject(it)) return it;
                var fn, val;
                if (S && typeof(fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
                if (typeof(fn = it.valueOf) == "function" && !isObject(val = fn.call(it))) return val;
                if (!S && typeof(fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
                throw TypeError("Can't convert object to primitive value");
            }
        }, function(module, exports) {
            module.exports = function(bitmap, value) {
                return {
                    enumerable: !(bitmap & 1),
                    configurable: !(bitmap & 2),
                    writable: !(bitmap & 4),
                    value: value
                }
            }
        }, function(module, exports, __webpack_require__) {
            module.exports =
                __webpack_require__(15)
        }, function(module, exports) {
            var hasOwnProperty = {}.hasOwnProperty;
            module.exports = function(it, key) {
                return hasOwnProperty.call(it, key)
            }
        }, function(module, exports) {
            module.exports = {}
        }, function(module, exports, __webpack_require__) {
            var create = __webpack_require__(29),
                descriptor = __webpack_require__(24),
                setToStringTag = __webpack_require__(44),
                IteratorPrototype = {};
            __webpack_require__(15)(IteratorPrototype, __webpack_require__(45)("iterator"), function() {
                return this
            });
            module.exports = function(Constructor,
                NAME, next) {
                Constructor.prototype = create(IteratorPrototype, {
                    next: descriptor(1, next)
                });
                setToStringTag(Constructor, NAME + " Iterator")
            }
        }, function(module, exports, __webpack_require__) {
            var anObject = __webpack_require__(17),
                dPs = __webpack_require__(30),
                enumBugKeys = __webpack_require__(42),
                IE_PROTO = __webpack_require__(39)("IE_PROTO"),
                Empty = function() {},
                PROTOTYPE = "prototype";
            var createDict = function() {
                var iframe = __webpack_require__(22)("iframe"),
                    i = enumBugKeys.length,
                    lt = "<",
                    gt = ">",
                    iframeDocument;
                iframe.style.display =
                    "none";
                __webpack_require__(43).appendChild(iframe);
                iframe.src = "javascript:";
                iframeDocument = iframe.contentWindow.document;
                iframeDocument.open();
                iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
                iframeDocument.close();
                createDict = iframeDocument.F;
                while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
                return createDict()
            };
            module.exports = Object.create || function create(O, Properties) {
                var result;
                if (O !== null) {
                    Empty[PROTOTYPE] = anObject(O);
                    result = new Empty;
                    Empty[PROTOTYPE] = null;
                    result[IE_PROTO] =
                        O
                } else result = createDict();
                return Properties === undefined ? result : dPs(result, Properties)
            }
        }, function(module, exports, __webpack_require__) {
            var dP = __webpack_require__(16),
                anObject = __webpack_require__(17),
                getKeys = __webpack_require__(31);
            module.exports = __webpack_require__(20) ? Object.defineProperties : function defineProperties(O, Properties) {
                anObject(O);
                var keys = getKeys(Properties),
                    length = keys.length,
                    i = 0,
                    P;
                while (length > i) dP.f(O, P = keys[i++], Properties[P]);
                return O
            }
        }, function(module, exports, __webpack_require__) {
            var $keys =
                __webpack_require__(32),
                enumBugKeys = __webpack_require__(42);
            module.exports = Object.keys || function keys(O) {
                return $keys(O, enumBugKeys)
            }
        }, function(module, exports, __webpack_require__) {
            var has = __webpack_require__(26),
                toIObject = __webpack_require__(33),
                arrayIndexOf = __webpack_require__(36)(false),
                IE_PROTO = __webpack_require__(39)("IE_PROTO");
            module.exports = function(object, names) {
                var O = toIObject(object),
                    i = 0,
                    result = [],
                    key;
                for (key in O)
                    if (key != IE_PROTO) has(O, key) && result.push(key);
                while (names.length > i)
                    if (has(O,
                            key = names[i++])) ~arrayIndexOf(result, key) || result.push(key);
                return result
            }
        }, function(module, exports, __webpack_require__) {
            var IObject = __webpack_require__(34),
                defined = __webpack_require__(7);
            module.exports = function(it) {
                return IObject(defined(it))
            }
        }, function(module, exports, __webpack_require__) {
            var cof = __webpack_require__(35);
            module.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
                return cof(it) == "String" ? it.split("") : Object(it)
            }
        }, function(module, exports) {
            var toString = {}.toString;
            module.exports =
                function(it) {
                    return toString.call(it).slice(8, -1)
                }
        }, function(module, exports, __webpack_require__) {
            var toIObject = __webpack_require__(33),
                toLength = __webpack_require__(37),
                toIndex = __webpack_require__(38);
            module.exports = function(IS_INCLUDES) {
                return function($this, el, fromIndex) {
                    var O = toIObject($this),
                        length = toLength(O.length),
                        index = toIndex(fromIndex, length),
                        value;
                    if (IS_INCLUDES && el != el)
                        while (length > index) {
                            value = O[index++];
                            if (value != value) return true
                        } else
                            for (; length > index; index++)
                                if (IS_INCLUDES || index in
                                    O)
                                    if (O[index] === el) return IS_INCLUDES || index || 0;
                    return !IS_INCLUDES && -1
                }
            }
        }, function(module, exports, __webpack_require__) {
            var toInteger = __webpack_require__(6),
                min = Math.min;
            module.exports = function(it) {
                return it > 0 ? min(toInteger(it), 9007199254740991) : 0
            }
        }, function(module, exports, __webpack_require__) {
            var toInteger = __webpack_require__(6),
                max = Math.max,
                min = Math.min;
            module.exports = function(index, length) {
                index = toInteger(index);
                return index < 0 ? max(index + length, 0) : min(index, length)
            }
        }, function(module, exports, __webpack_require__) {
            var shared =
                __webpack_require__(40)("keys"),
                uid = __webpack_require__(41);
            module.exports = function(key) {
                return shared[key] || (shared[key] = uid(key))
            }
        }, function(module, exports, __webpack_require__) {
            var global = __webpack_require__(11),
                SHARED = "__core-js_shared__",
                store = global[SHARED] || (global[SHARED] = {});
            module.exports = function(key) {
                return store[key] || (store[key] = {})
            }
        }, function(module, exports) {
            var id = 0,
                px = Math.random();
            module.exports = function(key) {
                return "Symbol(".concat(key === undefined ? "" : key, ")_", (++id + px).toString(36))
            }
        },
        function(module, exports) {
            module.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
        },
        function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__(11).document && document.documentElement
        },
        function(module, exports, __webpack_require__) {
            var def = __webpack_require__(16).f,
                has = __webpack_require__(26),
                TAG = __webpack_require__(45)("toStringTag");
            module.exports = function(it, tag, stat) {
                if (it && !has(it = stat ? it : it.prototype, TAG)) def(it,
                    TAG, {
                        configurable: true,
                        value: tag
                    })
            }
        },
        function(module, exports, __webpack_require__) {
            var store = __webpack_require__(40)("wks"),
                uid = __webpack_require__(41),
                Symbol = __webpack_require__(11).Symbol,
                USE_SYMBOL = typeof Symbol == "function";
            var $exports = module.exports = function(name) {
                return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)("Symbol." + name))
            };
            $exports.store = store
        },
        function(module, exports, __webpack_require__) {
            var has = __webpack_require__(26),
                toObject = __webpack_require__(47),
                IE_PROTO = __webpack_require__(39)("IE_PROTO"),
                ObjectProto = Object.prototype;
            module.exports = Object.getPrototypeOf || function(O) {
                O = toObject(O);
                if (has(O, IE_PROTO)) return O[IE_PROTO];
                if (typeof O.constructor == "function" && O instanceof O.constructor) return O.constructor.prototype;
                return O instanceof Object ? ObjectProto : null
            }
        },
        function(module, exports, __webpack_require__) {
            var defined = __webpack_require__(7);
            module.exports = function(it) {
                return Object(defined(it))
            }
        },
        function(module, exports, __webpack_require__) {
            var ctx =
                __webpack_require__(13),
                $export = __webpack_require__(10),
                toObject = __webpack_require__(47),
                call = __webpack_require__(49),
                isArrayIter = __webpack_require__(50),
                toLength = __webpack_require__(37),
                createProperty = __webpack_require__(51),
                getIterFn = __webpack_require__(52);
            $export($export.S + $export.F * !__webpack_require__(54)(function(iter) {
                Array.from(iter)
            }), "Array", {
                from: function from(arrayLike) {
                    var O = toObject(arrayLike),
                        C = typeof this == "function" ? this : Array,
                        aLen = arguments.length,
                        mapfn = aLen > 1 ? arguments[1] : undefined,
                        mapping = mapfn !== undefined,
                        index = 0,
                        iterFn = getIterFn(O),
                        length, result, step, iterator;
                    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
                    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn)))
                        for (iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++) createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
                    else {
                        length = toLength(O.length);
                        for (result = new C(length); length > index; index++) createProperty(result, index, mapping ? mapfn(O[index], index) :
                            O[index])
                    }
                    result.length = index;
                    return result
                }
            })
        },
        function(module, exports, __webpack_require__) {
            var anObject = __webpack_require__(17);
            module.exports = function(iterator, fn, value, entries) {
                try {
                    return entries ? fn(anObject(value)[0], value[1]) : fn(value)
                } catch (e) {
                    var ret = iterator["return"];
                    if (ret !== undefined) anObject(ret.call(iterator));
                    throw e;
                }
            }
        },
        function(module, exports, __webpack_require__) {
            var Iterators = __webpack_require__(27),
                ITERATOR = __webpack_require__(45)("iterator"),
                ArrayProto = Array.prototype;
            module.exports =
                function(it) {
                    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it)
                }
        },
        function(module, exports, __webpack_require__) {
            var $defineProperty = __webpack_require__(16),
                createDesc = __webpack_require__(24);
            module.exports = function(object, index, value) {
                if (index in object) $defineProperty.f(object, index, createDesc(0, value));
                else object[index] = value
            }
        },
        function(module, exports, __webpack_require__) {
            var classof = __webpack_require__(53),
                ITERATOR = __webpack_require__(45)("iterator"),
                Iterators = __webpack_require__(27);
            module.exports = __webpack_require__(12).getIteratorMethod = function(it) {
                if (it != undefined) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)]
            }
        },
        function(module, exports, __webpack_require__) {
            var cof = __webpack_require__(35),
                TAG = __webpack_require__(45)("toStringTag"),
                ARG = cof(function() {
                    return arguments
                }()) == "Arguments";
            var tryGet = function(it, key) {
                try {
                    return it[key]
                } catch (e) {}
            };
            module.exports = function(it) {
                var O, T, B;
                return it === undefined ? "Undefined" : it === null ? "Null" : typeof(T = tryGet(O = Object(it),
                    TAG)) == "string" ? T : ARG ? cof(O) : (B = cof(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B
            }
        },
        function(module, exports, __webpack_require__) {
            var ITERATOR = __webpack_require__(45)("iterator"),
                SAFE_CLOSING = false;
            try {
                var riter = [7][ITERATOR]();
                riter["return"] = function() {
                    SAFE_CLOSING = true
                };
                Array.from(riter, function() {
                    throw 2;
                })
            } catch (e) {}
            module.exports = function(exec, skipClosing) {
                if (!skipClosing && !SAFE_CLOSING) return false;
                var safe = false;
                try {
                    var arr = [7],
                        iter = arr[ITERATOR]();
                    iter.next = function() {
                        return {
                            done: safe =
                                true
                        }
                    };
                    arr[ITERATOR] = function() {
                        return iter
                    };
                    exec(arr)
                } catch (e) {}
                return safe
            }
        },
        function(module, exports, __webpack_require__) {
            module.exports = {
                "default": __webpack_require__(56),
                __esModule: true
            }
        },
        function(module, exports, __webpack_require__) {
            __webpack_require__(4);
            __webpack_require__(57);
            module.exports = __webpack_require__(61).f("iterator")
        },
        function(module, exports, __webpack_require__) {
            __webpack_require__(58);
            var global = __webpack_require__(11),
                hide = __webpack_require__(15),
                Iterators = __webpack_require__(27),
                TO_STRING_TAG = __webpack_require__(45)("toStringTag");
            for (var collections = ["NodeList", "DOMTokenList", "MediaList", "StyleSheetList", "CSSRuleList"], i = 0; i < 5; i++) {
                var NAME = collections[i],
                    Collection = global[NAME],
                    proto = Collection && Collection.prototype;
                if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
                Iterators[NAME] = Iterators.Array
            }
        },
        function(module, exports, __webpack_require__) {
            var addToUnscopables = __webpack_require__(59),
                step = __webpack_require__(60),
                Iterators = __webpack_require__(27),
                toIObject =
                __webpack_require__(33);
            module.exports = __webpack_require__(8)(Array, "Array", function(iterated, kind) {
                this._t = toIObject(iterated);
                this._i = 0;
                this._k = kind
            }, function() {
                var O = this._t,
                    kind = this._k,
                    index = this._i++;
                if (!O || index >= O.length) {
                    this._t = undefined;
                    return step(1)
                }
                if (kind == "keys") return step(0, index);
                if (kind == "values") return step(0, O[index]);
                return step(0, [index, O[index]])
            }, "values");
            Iterators.Arguments = Iterators.Array;
            addToUnscopables("keys");
            addToUnscopables("values");
            addToUnscopables("entries")
        },
        function(module, exports) {
            module.exports = function() {}
        },
        function(module, exports) {
            module.exports = function(done, value) {
                return {
                    value: value,
                    done: !!done
                }
            }
        },
        function(module, exports, __webpack_require__) {
            exports.f = __webpack_require__(45)
        },
        function(module, exports, __webpack_require__) {
            module.exports = {
                "default": __webpack_require__(63),
                __esModule: true
            }
        },
        function(module, exports, __webpack_require__) {
            __webpack_require__(64);
            __webpack_require__(75);
            __webpack_require__(76);
            __webpack_require__(77);
            module.exports = __webpack_require__(12).Symbol
        },
        function(module, exports, __webpack_require__) {
            var global = __webpack_require__(11),
                has = __webpack_require__(26),
                DESCRIPTORS = __webpack_require__(20),
                $export = __webpack_require__(10),
                redefine = __webpack_require__(25),
                META = __webpack_require__(65).KEY,
                $fails = __webpack_require__(21),
                shared = __webpack_require__(40),
                setToStringTag = __webpack_require__(44),
                uid = __webpack_require__(41),
                wks = __webpack_require__(45),
                wksExt = __webpack_require__(61),
                wksDefine = __webpack_require__(66),
                keyOf = __webpack_require__(67),
                enumKeys =
                __webpack_require__(68),
                isArray = __webpack_require__(71),
                anObject = __webpack_require__(17),
                toIObject = __webpack_require__(33),
                toPrimitive = __webpack_require__(23),
                createDesc = __webpack_require__(24),
                _create = __webpack_require__(29),
                gOPNExt = __webpack_require__(72),
                $GOPD = __webpack_require__(74),
                $DP = __webpack_require__(16),
                $keys = __webpack_require__(31),
                gOPD = $GOPD.f,
                dP = $DP.f,
                gOPN = gOPNExt.f,
                $Symbol = global.Symbol,
                $JSON = global.JSON,
                _stringify = $JSON && $JSON.stringify,
                PROTOTYPE = "prototype",
                HIDDEN = wks("_hidden"),
                TO_PRIMITIVE = wks("toPrimitive"),
                isEnum = {}.propertyIsEnumerable,
                SymbolRegistry = shared("symbol-registry"),
                AllSymbols = shared("symbols"),
                OPSymbols = shared("op-symbols"),
                ObjectProto = Object[PROTOTYPE],
                USE_NATIVE = typeof $Symbol == "function",
                QObject = global.QObject;
            var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
            var setSymbolDesc = DESCRIPTORS && $fails(function() {
                return _create(dP({}, "a", {
                    get: function() {
                        return dP(this, "a", {
                            value: 7
                        }).a
                    }
                })).a != 7
            }) ? function(it, key, D) {
                var protoDesc = gOPD(ObjectProto,
                    key);
                if (protoDesc) delete ObjectProto[key];
                dP(it, key, D);
                if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc)
            } : dP;
            var wrap = function(tag) {
                var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
                sym._k = tag;
                return sym
            };
            var isSymbol = USE_NATIVE && typeof $Symbol.iterator == "symbol" ? function(it) {
                return typeof it == "symbol"
            } : function(it) {
                return it instanceof $Symbol
            };
            var $defineProperty = function defineProperty(it, key, D) {
                if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
                anObject(it);
                key = toPrimitive(key,
                    true);
                anObject(D);
                if (has(AllSymbols, key)) {
                    if (!D.enumerable) {
                        if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
                        it[HIDDEN][key] = true
                    } else {
                        if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
                        D = _create(D, {
                            enumerable: createDesc(0, false)
                        })
                    }
                    return setSymbolDesc(it, key, D)
                }
                return dP(it, key, D)
            };
            var $defineProperties = function defineProperties(it, P) {
                anObject(it);
                var keys = enumKeys(P = toIObject(P)),
                    i = 0,
                    l = keys.length,
                    key;
                while (l > i) $defineProperty(it, key = keys[i++], P[key]);
                return it
            };
            var $create = function create(it,
                P) {
                return P === undefined ? _create(it) : $defineProperties(_create(it), P)
            };
            var $propertyIsEnumerable = function propertyIsEnumerable(key) {
                var E = isEnum.call(this, key = toPrimitive(key, true));
                if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
                return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true
            };
            var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
                it = toIObject(it);
                key = toPrimitive(key, true);
                if (it === ObjectProto && has(AllSymbols,
                        key) && !has(OPSymbols, key)) return;
                var D = gOPD(it, key);
                if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
                return D
            };
            var $getOwnPropertyNames = function getOwnPropertyNames(it) {
                var names = gOPN(toIObject(it)),
                    result = [],
                    i = 0,
                    key;
                while (names.length > i)
                    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
                return result
            };
            var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
                var IS_OP = it === ObjectProto,
                    names = gOPN(IS_OP ? OPSymbols : toIObject(it)),
                    result = [],
                    i = 0,
                    key;
                while (names.length > i)
                    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
                return result
            };
            if (!USE_NATIVE) {
                $Symbol = function Symbol() {
                    if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor!");
                    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
                    var $set = function(value) {
                        if (this === ObjectProto) $set.call(OPSymbols, value);
                        if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
                        setSymbolDesc(this, tag, createDesc(1, value))
                    };
                    if (DESCRIPTORS &&
                        setter) setSymbolDesc(ObjectProto, tag, {
                        configurable: true,
                        set: $set
                    });
                    return wrap(tag)
                };
                redefine($Symbol[PROTOTYPE], "toString", function toString() {
                    return this._k
                });
                $GOPD.f = $getOwnPropertyDescriptor;
                $DP.f = $defineProperty;
                __webpack_require__(73).f = gOPNExt.f = $getOwnPropertyNames;
                __webpack_require__(70).f = $propertyIsEnumerable;
                __webpack_require__(69).f = $getOwnPropertySymbols;
                if (DESCRIPTORS && !__webpack_require__(9)) redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, true);
                wksExt.f = function(name) {
                    return wrap(wks(name))
                }
            }
            $export($export.G +
                $export.W + $export.F * !USE_NATIVE, {
                    Symbol: $Symbol
                });
            for (var symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), i = 0; symbols.length > i;) wks(symbols[i++]);
            for (var symbols = $keys(wks.store), i = 0; symbols.length > i;) wksDefine(symbols[i++]);
            $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
                "for": function(key) {
                    return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key)
                },
                keyFor: function keyFor(key) {
                    if (isSymbol(key)) return keyOf(SymbolRegistry,
                        key);
                    throw TypeError(key + " is not a symbol!");
                },
                useSetter: function() {
                    setter = true
                },
                useSimple: function() {
                    setter = false
                }
            });
            $export($export.S + $export.F * !USE_NATIVE, "Object", {
                create: $create,
                defineProperty: $defineProperty,
                defineProperties: $defineProperties,
                getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
                getOwnPropertyNames: $getOwnPropertyNames,
                getOwnPropertySymbols: $getOwnPropertySymbols
            });
            $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {
                var S = $Symbol();
                return _stringify([S]) != "[null]" ||
                    _stringify({
                        a: S
                    }) != "{}" || _stringify(Object(S)) != "{}"
            })), "JSON", {
                stringify: function stringify(it) {
                    if (it === undefined || isSymbol(it)) return;
                    var args = [it],
                        i = 1,
                        replacer, $replacer;
                    while (arguments.length > i) args.push(arguments[i++]);
                    replacer = args[1];
                    if (typeof replacer == "function") $replacer = replacer;
                    if ($replacer || !isArray(replacer)) replacer = function(key, value) {
                        if ($replacer) value = $replacer.call(this, key, value);
                        if (!isSymbol(value)) return value
                    };
                    args[1] = replacer;
                    return _stringify.apply($JSON, args)
                }
            });
            $Symbol[PROTOTYPE][TO_PRIMITIVE] ||
                __webpack_require__(15)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
            setToStringTag($Symbol, "Symbol");
            setToStringTag(Math, "Math", true);
            setToStringTag(global.JSON, "JSON", true)
        },
        function(module, exports, __webpack_require__) {
            var META = __webpack_require__(41)("meta"),
                isObject = __webpack_require__(18),
                has = __webpack_require__(26),
                setDesc = __webpack_require__(16).f,
                id = 0;
            var isExtensible = Object.isExtensible || function() {
                return true
            };
            var FREEZE = !__webpack_require__(21)(function() {
                return isExtensible(Object.preventExtensions({}))
            });
            var setMeta = function(it) {
                setDesc(it, META, {
                    value: {
                        i: "O" + ++id,
                        w: {}
                    }
                })
            };
            var fastKey = function(it, create) {
                if (!isObject(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
                if (!has(it, META)) {
                    if (!isExtensible(it)) return "F";
                    if (!create) return "E";
                    setMeta(it)
                }
                return it[META].i
            };
            var getWeak = function(it, create) {
                if (!has(it, META)) {
                    if (!isExtensible(it)) return true;
                    if (!create) return false;
                    setMeta(it)
                }
                return it[META].w
            };
            var onFreeze = function(it) {
                if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
                return it
            };
            var meta = module.exports = {
                KEY: META,
                NEED: false,
                fastKey: fastKey,
                getWeak: getWeak,
                onFreeze: onFreeze
            }
        },
        function(module, exports, __webpack_require__) {
            var global = __webpack_require__(11),
                core = __webpack_require__(12),
                LIBRARY = __webpack_require__(9),
                wksExt = __webpack_require__(61),
                defineProperty = __webpack_require__(16).f;
            module.exports = function(name) {
                var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
                if (name.charAt(0) != "_" && !(name in $Symbol)) defineProperty($Symbol, name, {
                    value: wksExt.f(name)
                })
            }
        },
        function(module, exports, __webpack_require__) {
            var getKeys = __webpack_require__(31),
                toIObject = __webpack_require__(33);
            module.exports = function(object, el) {
                var O = toIObject(object),
                    keys = getKeys(O),
                    length = keys.length,
                    index = 0,
                    key;
                while (length > index)
                    if (O[key = keys[index++]] === el) return key
            }
        },
        function(module, exports, __webpack_require__) {
            var getKeys = __webpack_require__(31),
                gOPS = __webpack_require__(69),
                pIE = __webpack_require__(70);
            module.exports = function(it) {
                var result = getKeys(it),
                    getSymbols = gOPS.f;
                if (getSymbols) {
                    var symbols =
                        getSymbols(it),
                        isEnum = pIE.f,
                        i = 0,
                        key;
                    while (symbols.length > i)
                        if (isEnum.call(it, key = symbols[i++])) result.push(key)
                }
                return result
            }
        },
        function(module, exports) {
            exports.f = Object.getOwnPropertySymbols
        },
        function(module, exports) {
            exports.f = {}.propertyIsEnumerable
        },
        function(module, exports, __webpack_require__) {
            var cof = __webpack_require__(35);
            module.exports = Array.isArray || function isArray(arg) {
                return cof(arg) == "Array"
            }
        },
        function(module, exports, __webpack_require__) {
            var toIObject = __webpack_require__(33),
                gOPN = __webpack_require__(73).f,
                toString = {}.toString;
            var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
            var getWindowNames = function(it) {
                try {
                    return gOPN(it)
                } catch (e) {
                    return windowNames.slice()
                }
            };
            module.exports.f = function getOwnPropertyNames(it) {
                return windowNames && toString.call(it) == "[object Window]" ? getWindowNames(it) : gOPN(toIObject(it))
            }
        },
        function(module, exports, __webpack_require__) {
            var $keys = __webpack_require__(32),
                hiddenKeys = __webpack_require__(42).concat("length",
                    "prototype");
            exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
                return $keys(O, hiddenKeys)
            }
        },
        function(module, exports, __webpack_require__) {
            var pIE = __webpack_require__(70),
                createDesc = __webpack_require__(24),
                toIObject = __webpack_require__(33),
                toPrimitive = __webpack_require__(23),
                has = __webpack_require__(26),
                IE8_DOM_DEFINE = __webpack_require__(19),
                gOPD = Object.getOwnPropertyDescriptor;
            exports.f = __webpack_require__(20) ? gOPD : function getOwnPropertyDescriptor(O, P) {
                O = toIObject(O);
                P = toPrimitive(P,
                    true);
                if (IE8_DOM_DEFINE) try {
                    return gOPD(O, P)
                } catch (e) {}
                if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P])
            }
        },
        function(module, exports) {},
        function(module, exports, __webpack_require__) {
            __webpack_require__(66)("asyncIterator")
        },
        function(module, exports, __webpack_require__) {
            __webpack_require__(66)("observable")
        },
        function(module, exports, __webpack_require__) {
            var _defineProperties = __webpack_require__(79);
            var _defineProperties2 = _interopRequireDefault(_defineProperties);
            var _freeze = __webpack_require__(82);
            var _freeze2 =
                _interopRequireDefault(_freeze);
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.SmoothScrollbar = undefined;
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        (0, _defineProperty2.default)(target,
                            descriptor.key, descriptor)
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor
                }
            }();

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _shared = __webpack_require__(89);
            var _utils = __webpack_require__(112);

            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            var SmoothScrollbar = exports.SmoothScrollbar = function() {
                function SmoothScrollbar(container) {
                    var _this = this;
                    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                    _classCallCheck(this, SmoothScrollbar);
                    container.setAttribute("tabindex", "1");
                    container.scrollTop = container.scrollLeft = 0;
                    var content = (0, _utils.findChild)(container, "scroll-content");
                    var canvas = (0, _utils.findChild)(container, "overscroll-glow");
                    var trackX = (0, _utils.findChild)(container, "scrollbar-track-x");
                    var trackY = (0, _utils.findChild)(container,
                        "scrollbar-track-y");
                    (0, _utils.setStyle)(container, {
                        overflow: "hidden",
                        outline: "none"
                    });
                    (0, _utils.setStyle)(canvas, {
                        display: "none",
                        "pointer-events": "none"
                    });
                    this.__readonly("targets", (0, _freeze2.default)({
                        container: container,
                        content: content,
                        canvas: {
                            elem: canvas,
                            context: canvas.getContext("2d")
                        },
                        xAxis: (0, _freeze2.default)({
                            track: trackX,
                            thumb: (0, _utils.findChild)(trackX, "scrollbar-thumb-x")
                        }),
                        yAxis: (0, _freeze2.default)({
                            track: trackY,
                            thumb: (0, _utils.findChild)(trackY, "scrollbar-thumb-y")
                        })
                    })).__readonly("offset", {
                        x: 0,
                        y: 0
                    }).__readonly("thumbOffset", {
                        x: 0,
                        y: 0
                    }).__readonly("limit", {
                        x: Infinity,
                        y: Infinity
                    }).__readonly("movement", {
                        x: 0,
                        y: 0
                    }).__readonly("movementLocked", {
                        x: false,
                        y: false
                    }).__readonly("overscrollRendered", {
                        x: 0,
                        y: 0
                    }).__readonly("overscrollBack", false).__readonly("thumbSize", {
                        x: 0,
                        y: 0,
                        realX: 0,
                        realY: 0
                    }).__readonly("bounding", {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }).__readonly("children", []).__readonly("parents", []).__readonly("size", this.getSize()).__readonly("isNestedScrollbar", false);
                    (0, _defineProperties2.default)(this, {
                        __hideTrackThrottle: {
                            value: (0, _utils.debounce)(this.hideTrack.bind(this), 1E3, false)
                        },
                        __updateThrottle: {
                            value: (0, _utils.debounce)(this.update.bind(this))
                        },
                        __touchRecord: {
                            value: new _utils.TouchRecord
                        },
                        __listeners: {
                            value: []
                        },
                        __handlers: {
                            value: []
                        },
                        __children: {
                            value: []
                        },
                        __timerID: {
                            value: {}
                        }
                    });
                    this.__initOptions(options);
                    this.__initScrollbar();
                    _shared.sbList.set(container, this);
                    if (typeof _shared.GLOBAL_ENV.MutationObserver === "function") {
                        var observer = new _shared.GLOBAL_ENV.MutationObserver(function() {
                            _this.update(true)
                        });
                        observer.observe(content, {
                            childList: true
                        });
                        Object.defineProperty(this, "__observer", {
                            value: observer
                        })
                    }
                }
                _createClass(SmoothScrollbar, [{
                    key: "MAX_OVERSCROLL",
                    get: function get() {
                        var options = this.options;
                        var size = this.size;
                        switch (options.overscrollEffect) {
                            case "bounce":
                                var diagonal = Math.floor(Math.sqrt(Math.pow(size.container.width, 2) + Math.pow(size.container.height, 2)));
                                var touchFactor = this.__isMovementLocked() ? 2 : 10;
                                return _shared.GLOBAL_ENV.TOUCH_SUPPORTED ? (0, _utils.pickInRange)(diagonal / touchFactor, 100,
                                    1E3) : (0, _utils.pickInRange)(diagonal / 10, 25, 50);
                            case "glow":
                                return 150;
                            default:
                                return 0
                        }
                    }
                }, {
                    key: "scrollTop",
                    get: function get() {
                        return this.offset.y
                    }
                }, {
                    key: "scrollLeft",
                    get: function get() {
                        return this.offset.x
                    }
                }]);
                return SmoothScrollbar
            }()
        },
        function(module, exports, __webpack_require__) {
            module.exports = {
                "default": __webpack_require__(80),
                __esModule: true
            }
        },
        function(module, exports, __webpack_require__) {
            __webpack_require__(81);
            var $Object = __webpack_require__(12).Object;
            module.exports = function defineProperties(T,
                D) {
                return $Object.defineProperties(T, D)
            }
        },
        function(module, exports, __webpack_require__) {
            var $export = __webpack_require__(10);
            $export($export.S + $export.F * !__webpack_require__(20), "Object", {
                defineProperties: __webpack_require__(30)
            })
        },
        function(module, exports, __webpack_require__) {
            module.exports = {
                "default": __webpack_require__(83),
                __esModule: true
            }
        },
        function(module, exports, __webpack_require__) {
            __webpack_require__(84);
            module.exports = __webpack_require__(12).Object.freeze
        },
        function(module, exports, __webpack_require__) {
            var isObject =
                __webpack_require__(18),
                meta = __webpack_require__(65).onFreeze;
            __webpack_require__(85)("freeze", function($freeze) {
                return function freeze(it) {
                    return $freeze && isObject(it) ? $freeze(meta(it)) : it
                }
            })
        },
        function(module, exports, __webpack_require__) {
            var $export = __webpack_require__(10),
                core = __webpack_require__(12),
                fails = __webpack_require__(21);
            module.exports = function(KEY, exec) {
                var fn = (core.Object || {})[KEY] || Object[KEY],
                    exp = {};
                exp[KEY] = exec(fn);
                $export($export.S + $export.F * fails(function() {
                    fn(1)
                }), "Object", exp)
            }
        },
        function(module, exports, __webpack_require__) {
            module.exports = {
                "default": __webpack_require__(87),
                __esModule: true
            }
        },
        function(module, exports, __webpack_require__) {
            __webpack_require__(88);
            var $Object = __webpack_require__(12).Object;
            module.exports = function defineProperty(it, key, desc) {
                return $Object.defineProperty(it, key, desc)
            }
        },
        function(module, exports, __webpack_require__) {
            var $export = __webpack_require__(10);
            $export($export.S + $export.F * !__webpack_require__(20), "Object", {
                defineProperty: __webpack_require__(16).f
            })
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            var _keys = __webpack_require__(90);
            var _keys2 = _interopRequireDefault(_keys);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _exportAll = __webpack_require__(93);
            (0, _keys2.default)(_exportAll).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _exportAll[key]
                    }
                })
            })
        },
        function(module, exports, __webpack_require__) {
            module.exports = {
                "default": __webpack_require__(91),
                __esModule: true
            }
        },
        function(module, exports, __webpack_require__) {
            __webpack_require__(92);
            module.exports = __webpack_require__(12).Object.keys
        },
        function(module, exports, __webpack_require__) {
            var toObject = __webpack_require__(47),
                $keys = __webpack_require__(31);
            __webpack_require__(85)("keys", function() {
                return function keys(it) {
                    return $keys(toObject(it))
                }
            })
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            var _keys = __webpack_require__(90);
            var _keys2 = _interopRequireDefault(_keys);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _globalEnv = __webpack_require__(94);
            (0, _keys2.default)(_globalEnv).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _globalEnv[key]
                    }
                })
            });
            var _sbList = __webpack_require__(95);
            (0, _keys2.default)(_sbList).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _sbList[key]
                    }
                })
            });
            var _selectors = __webpack_require__(111);
            (0, _keys2.default)(_selectors).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports,
                    key, {
                        enumerable: true,
                        get: function get() {
                            return _selectors[key]
                        }
                    })
            })
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            var _keys = __webpack_require__(90);
            var _keys2 = _interopRequireDefault(_keys);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var memoize = function memoize(source) {
                var res = {};
                var cache = {};
                (0, _keys2.default)(source).forEach(function(prop) {
                    (0,
                        _defineProperty2.default)(res, prop, {
                        get: function get() {
                            if (!cache.hasOwnProperty(prop)) {
                                var getter = source[prop];
                                cache[prop] = getter()
                            }
                            return cache[prop]
                        }
                    })
                });
                return res
            };
            var getters = {
                MutationObserver: function MutationObserver() {
                    return window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver
                },
                TOUCH_SUPPORTED: function TOUCH_SUPPORTED() {
                    return "ontouchstart" in document
                },
                EASING_MULTIPLIER: function EASING_MULTIPLIER() {
                    return navigator.userAgent.match(/Android/) ? .5 : .25
                },
                WHEEL_EVENT: function WHEEL_EVENT() {
                    return "onwheel" in
                        window ? "wheel" : "mousewheel"
                }
            };
            var GLOBAL_ENV = exports.GLOBAL_ENV = memoize(getters)
        },
        function(module, exports, __webpack_require__) {
            var _map = __webpack_require__(96);
            var _map2 = _interopRequireDefault(_map);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var sbList = new _map2.default;
            var originSet = sbList.set.bind(sbList);
            var originDelete = sbList.delete.bind(sbList);
            sbList.update = function() {
                sbList.forEach(function(sb) {
                    sb.__updateTree()
                })
            };
            sbList.delete = function() {
                var res = originDelete.apply(undefined, arguments);
                sbList.update();
                return res
            };
            sbList.set = function() {
                var res = originSet.apply(undefined, arguments);
                sbList.update();
                return res
            };
            exports.sbList = sbList
        },
        function(module, exports, __webpack_require__) {
            module.exports = {
                "default": __webpack_require__(97),
                __esModule: true
            }
        },
        function(module, exports, __webpack_require__) {
            __webpack_require__(75);
            __webpack_require__(4);
            __webpack_require__(57);
            __webpack_require__(98);
            __webpack_require__(108);
            module.exports =
                __webpack_require__(12).Map
        },
        function(module, exports, __webpack_require__) {
            var strong = __webpack_require__(99);
            module.exports = __webpack_require__(104)("Map", function(get) {
                return function Map() {
                    return get(this, arguments.length > 0 ? arguments[0] : undefined)
                }
            }, {
                get: function get(key) {
                    var entry = strong.getEntry(this, key);
                    return entry && entry.v
                },
                set: function set(key, value) {
                    return strong.def(this, key === 0 ? 0 : key, value)
                }
            }, strong, true)
        },
        function(module, exports, __webpack_require__) {
            var dP = __webpack_require__(16).f,
                create =
                __webpack_require__(29),
                redefineAll = __webpack_require__(100),
                ctx = __webpack_require__(13),
                anInstance = __webpack_require__(101),
                defined = __webpack_require__(7),
                forOf = __webpack_require__(102),
                $iterDefine = __webpack_require__(8),
                step = __webpack_require__(60),
                setSpecies = __webpack_require__(103),
                DESCRIPTORS = __webpack_require__(20),
                fastKey = __webpack_require__(65).fastKey,
                SIZE = DESCRIPTORS ? "_s" : "size";
            var getEntry = function(that, key) {
                var index = fastKey(key),
                    entry;
                if (index !== "F") return that._i[index];
                for (entry = that._f; entry; entry =
                    entry.n)
                    if (entry.k == key) return entry
            };
            module.exports = {
                getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
                    var C = wrapper(function(that, iterable) {
                        anInstance(that, C, NAME, "_i");
                        that._i = create(null);
                        that._f = undefined;
                        that._l = undefined;
                        that[SIZE] = 0;
                        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that)
                    });
                    redefineAll(C.prototype, {
                        clear: function clear() {
                            for (var that = this, data = that._i, entry = that._f; entry; entry = entry.n) {
                                entry.r = true;
                                if (entry.p) entry.p = entry.p.n = undefined;
                                delete data[entry.i]
                            }
                            that._f =
                                that._l = undefined;
                            that[SIZE] = 0
                        },
                        "delete": function(key) {
                            var that = this,
                                entry = getEntry(that, key);
                            if (entry) {
                                var next = entry.n,
                                    prev = entry.p;
                                delete that._i[entry.i];
                                entry.r = true;
                                if (prev) prev.n = next;
                                if (next) next.p = prev;
                                if (that._f == entry) that._f = next;
                                if (that._l == entry) that._l = prev;
                                that[SIZE]--
                            }
                            return !!entry
                        },
                        forEach: function forEach(callbackfn) {
                            anInstance(this, C, "forEach");
                            var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3),
                                entry;
                            while (entry = entry ? entry.n : this._f) {
                                f(entry.v, entry.k, this);
                                while (entry &&
                                    entry.r) entry = entry.p
                            }
                        },
                        has: function has(key) {
                            return !!getEntry(this, key)
                        }
                    });
                    if (DESCRIPTORS) dP(C.prototype, "size", {
                        get: function() {
                            return defined(this[SIZE])
                        }
                    });
                    return C
                },
                def: function(that, key, value) {
                    var entry = getEntry(that, key),
                        prev, index;
                    if (entry) entry.v = value;
                    else {
                        that._l = entry = {
                            i: index = fastKey(key, true),
                            k: key,
                            v: value,
                            p: prev = that._l,
                            n: undefined,
                            r: false
                        };
                        if (!that._f) that._f = entry;
                        if (prev) prev.n = entry;
                        that[SIZE]++;
                        if (index !== "F") that._i[index] = entry
                    }
                    return that
                },
                getEntry: getEntry,
                setStrong: function(C,
                    NAME, IS_MAP) {
                    $iterDefine(C, NAME, function(iterated, kind) {
                        this._t = iterated;
                        this._k = kind;
                        this._l = undefined
                    }, function() {
                        var that = this,
                            kind = that._k,
                            entry = that._l;
                        while (entry && entry.r) entry = entry.p;
                        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
                            that._t = undefined;
                            return step(1)
                        }
                        if (kind == "keys") return step(0, entry.k);
                        if (kind == "values") return step(0, entry.v);
                        return step(0, [entry.k, entry.v])
                    }, IS_MAP ? "entries" : "values", !IS_MAP, true);
                    setSpecies(NAME)
                }
            }
        },
        function(module, exports, __webpack_require__) {
            var hide =
                __webpack_require__(15);
            module.exports = function(target, src, safe) {
                for (var key in src)
                    if (safe && target[key]) target[key] = src[key];
                    else hide(target, key, src[key]);
                return target
            }
        },
        function(module, exports) {
            module.exports = function(it, Constructor, name, forbiddenField) {
                if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) throw TypeError(name + ": incorrect invocation!");
                return it
            }
        },
        function(module, exports, __webpack_require__) {
            var ctx = __webpack_require__(13),
                call = __webpack_require__(49),
                isArrayIter = __webpack_require__(50),
                anObject = __webpack_require__(17),
                toLength = __webpack_require__(37),
                getIterFn = __webpack_require__(52),
                BREAK = {},
                RETURN = {};
            var exports = module.exports = function(iterable, entries, fn, that, ITERATOR) {
                var iterFn = ITERATOR ? function() {
                        return iterable
                    } : getIterFn(iterable),
                    f = ctx(fn, that, entries ? 2 : 1),
                    index = 0,
                    length, step, iterator, result;
                if (typeof iterFn != "function") throw TypeError(iterable + " is not iterable!");
                if (isArrayIter(iterFn))
                    for (length = toLength(iterable.length); length > index; index++) {
                        result =
                            entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
                        if (result === BREAK || result === RETURN) return result
                    } else
                        for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
                            result = call(iterator, f, step.value, entries);
                            if (result === BREAK || result === RETURN) return result
                        }
            };
            exports.BREAK = BREAK;
            exports.RETURN = RETURN
        },
        function(module, exports, __webpack_require__) {
            var global = __webpack_require__(11),
                core = __webpack_require__(12),
                dP = __webpack_require__(16),
                DESCRIPTORS = __webpack_require__(20),
                SPECIES = __webpack_require__(45)("species");
            module.exports = function(KEY) {
                var C = typeof core[KEY] == "function" ? core[KEY] : global[KEY];
                if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
                    configurable: true,
                    get: function() {
                        return this
                    }
                })
            }
        },
        function(module, exports, __webpack_require__) {
            var global = __webpack_require__(11),
                $export = __webpack_require__(10),
                meta = __webpack_require__(65),
                fails = __webpack_require__(21),
                hide = __webpack_require__(15),
                redefineAll = __webpack_require__(100),
                forOf = __webpack_require__(102),
                anInstance =
                __webpack_require__(101),
                isObject = __webpack_require__(18),
                setToStringTag = __webpack_require__(44),
                dP = __webpack_require__(16).f,
                each = __webpack_require__(105)(0),
                DESCRIPTORS = __webpack_require__(20);
            module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
                var Base = global[NAME],
                    C = Base,
                    ADDER = IS_MAP ? "set" : "add",
                    proto = C && C.prototype,
                    O = {};
                if (!DESCRIPTORS || typeof C != "function" || !(IS_WEAK || proto.forEach && !fails(function() {
                        (new C).entries().next()
                    }))) {
                    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
                    redefineAll(C.prototype, methods);
                    meta.NEED = true
                } else {
                    C = wrapper(function(target, iterable) {
                        anInstance(target, C, NAME, "_c");
                        target._c = new Base;
                        if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target)
                    });
                    each("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(KEY) {
                        var IS_ADDER = KEY == "add" || KEY == "set";
                        if (KEY in proto && !(IS_WEAK && KEY == "clear")) hide(C.prototype, KEY, function(a, b) {
                            anInstance(this, C, KEY);
                            if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == "get" ? undefined :
                                false;
                            var result = this._c[KEY](a === 0 ? 0 : a, b);
                            return IS_ADDER ? this : result
                        })
                    });
                    if ("size" in proto) dP(C.prototype, "size", {
                        get: function() {
                            return this._c.size
                        }
                    })
                }
                setToStringTag(C, NAME);
                O[NAME] = C;
                $export($export.G + $export.W + $export.F, O);
                if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
                return C
            }
        },
        function(module, exports, __webpack_require__) {
            var ctx = __webpack_require__(13),
                IObject = __webpack_require__(34),
                toObject = __webpack_require__(47),
                toLength = __webpack_require__(37),
                asc = __webpack_require__(106);
            module.exports =
                function(TYPE, $create) {
                    var IS_MAP = TYPE == 1,
                        IS_FILTER = TYPE == 2,
                        IS_SOME = TYPE == 3,
                        IS_EVERY = TYPE == 4,
                        IS_FIND_INDEX = TYPE == 6,
                        NO_HOLES = TYPE == 5 || IS_FIND_INDEX,
                        create = $create || asc;
                    return function($this, callbackfn, that) {
                        var O = toObject($this),
                            self = IObject(O),
                            f = ctx(callbackfn, that, 3),
                            length = toLength(self.length),
                            index = 0,
                            result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined,
                            val, res;
                        for (; length > index; index++)
                            if (NO_HOLES || index in self) {
                                val = self[index];
                                res = f(val, index, O);
                                if (TYPE)
                                    if (IS_MAP) result[index] =
                                        res;
                                    else if (res) switch (TYPE) {
                                    case 3:
                                        return true;
                                    case 5:
                                        return val;
                                    case 6:
                                        return index;
                                    case 2:
                                        result.push(val)
                                } else if (IS_EVERY) return false
                            }
                        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result
                    }
                }
        },
        function(module, exports, __webpack_require__) {
            var speciesConstructor = __webpack_require__(107);
            module.exports = function(original, length) {
                return new(speciesConstructor(original))(length)
            }
        },
        function(module, exports, __webpack_require__) {
            var isObject = __webpack_require__(18),
                isArray = __webpack_require__(71),
                SPECIES = __webpack_require__(45)("species");
            module.exports = function(original) {
                var C;
                if (isArray(original)) {
                    C = original.constructor;
                    if (typeof C == "function" && (C === Array || isArray(C.prototype))) C = undefined;
                    if (isObject(C)) {
                        C = C[SPECIES];
                        if (C === null) C = undefined
                    }
                }
                return C === undefined ? Array : C
            }
        },
        function(module, exports, __webpack_require__) {
            var $export = __webpack_require__(10);
            $export($export.P + $export.R, "Map", {
                toJSON: __webpack_require__(109)("Map")
            })
        },
        function(module, exports, __webpack_require__) {
            var classof = __webpack_require__(53),
                from = __webpack_require__(110);
            module.exports = function(NAME) {
                return function toJSON() {
                    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
                    return from(this)
                }
            }
        },
        function(module, exports, __webpack_require__) {
            var forOf = __webpack_require__(102);
            module.exports = function(iter, ITERATOR) {
                var result = [];
                forOf(iter, false, result.push, result, ITERATOR);
                return result
            }
        },
        function(module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            var selectors = exports.selectors = "scrollbar, [scrollbar], [data-scrollbar]"
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            var _keys = __webpack_require__(90);
            var _keys2 = _interopRequireDefault(_keys);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _exportAll = __webpack_require__(113);
            (0, _keys2.default)(_exportAll).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _exportAll[key]
                    }
                })
            })
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            var _keys = __webpack_require__(90);
            var _keys2 = _interopRequireDefault(_keys);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _buildCurve = __webpack_require__(114);
            (0, _keys2.default)(_buildCurve).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _buildCurve[key]
                    }
                })
            });
            var _debounce = __webpack_require__(115);
            (0, _keys2.default)(_debounce).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _debounce[key]
                    }
                })
            });
            var _findChild = __webpack_require__(116);
            (0, _keys2.default)(_findChild).forEach(function(key) {
                if (key ===
                    "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _findChild[key]
                    }
                })
            });
            var _getDelta = __webpack_require__(117);
            (0, _keys2.default)(_getDelta).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _getDelta[key]
                    }
                })
            });
            var _getPointerData = __webpack_require__(118);
            (0, _keys2.default)(_getPointerData).forEach(function(key) {
                if (key === "default" ||
                    key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _getPointerData[key]
                    }
                })
            });
            var _getPosition = __webpack_require__(119);
            (0, _keys2.default)(_getPosition).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _getPosition[key]
                    }
                })
            });
            var _getTouchId = __webpack_require__(120);
            (0, _keys2.default)(_getTouchId).forEach(function(key) {
                if (key === "default" ||
                    key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _getTouchId[key]
                    }
                })
            });
            var _isOneOf = __webpack_require__(121);
            (0, _keys2.default)(_isOneOf).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _isOneOf[key]
                    }
                })
            });
            var _pickInRange = __webpack_require__(122);
            (0, _keys2.default)(_pickInRange).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _pickInRange[key]
                    }
                })
            });
            var _setStyle = __webpack_require__(123);
            (0, _keys2.default)(_setStyle).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _setStyle[key]
                    }
                })
            });
            var _touchRecord = __webpack_require__(124);
            (0, _keys2.default)(_touchRecord).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports,
                    key, {
                        enumerable: true,
                        get: function get() {
                            return _touchRecord[key]
                        }
                    })
            })
        },
        function(module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            var buildCurve = exports.buildCurve = function buildCurve(distance, duration) {
                var res = [];
                if (duration <= 0) return res;
                var t = Math.round(duration / 1E3 * 60);
                var a = -distance / Math.pow(t, 2);
                var b = -2 * a * t;
                for (var i = 0; i < t; i++) res.push(a * Math.pow(i, 2) + b * i);
                return res
            }
        },
        function(module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            var RESET_WAIT = 100;
            var debounce = exports.debounce = function debounce(fn) {
                var wait = arguments.length <= 1 || arguments[1] === undefined ? RESET_WAIT : arguments[1];
                var immediate = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
                if (typeof fn !== "function") return;
                var timer = void 0;
                return function() {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    if (!timer && immediate) setTimeout(function() {
                        return fn.apply(undefined, args)
                    });
                    clearTimeout(timer);
                    timer = setTimeout(function() {
                        timer =
                            undefined;
                        fn.apply(undefined, args)
                    }, wait)
                }
            }
        },
        function(module, exports, __webpack_require__) {
            var _from = __webpack_require__(2);
            var _from2 = _interopRequireDefault(_from);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }

            function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                    return arr2
                } else return (0, _from2.default)(arr)
            }
            var findChild = exports.findChild =
                function findChild(parentElem, className) {
                    var children = parentElem.children;
                    var res = null;
                    if (children)[].concat(_toConsumableArray(children)).some(function(elem) {
                        if (elem.className.match(className)) {
                            res = elem;
                            return true
                        }
                    });
                    return res
                }
        },
        function(module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            var DELTA_SCALE = {
                STANDARD: 1,
                OTHERS: -3
            };
            var DELTA_MODE = [1, 28, 500];
            var getDeltaMode = function getDeltaMode(mode) {
                return DELTA_MODE[mode] || DELTA_MODE[0]
            };
            var getDelta = exports.getDelta = function getDelta(evt) {
                if ("deltaX" in
                    evt) {
                    var mode = getDeltaMode(evt.deltaMode);
                    return {
                        x: evt.deltaX / DELTA_SCALE.STANDARD * mode,
                        y: evt.deltaY / DELTA_SCALE.STANDARD * mode
                    }
                }
                if ("wheelDeltaX" in evt) return {
                    x: evt.wheelDeltaX / DELTA_SCALE.OTHERS,
                    y: evt.wheelDeltaY / DELTA_SCALE.OTHERS
                };
                return {
                    x: 0,
                    y: evt.wheelDelta / DELTA_SCALE.OTHERS
                }
            }
        },
        function(module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            var getPointerData = exports.getPointerData = function getPointerData(evt) {
                return evt.touches ? evt.touches[evt.touches.length - 1] : evt
            }
        },
        function(module,
            exports, __webpack_require__) {
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.getPosition = undefined;
            var _getPointerData = __webpack_require__(118);
            var getPosition = exports.getPosition = function getPosition(evt) {
                var data = (0, _getPointerData.getPointerData)(evt);
                return {
                    x: data.clientX,
                    y: data.clientY
                }
            }
        },
        function(module, exports, __webpack_require__) {
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.getTouchID = undefined;
            var _getPointerData = __webpack_require__(118);
            var getTouchID =
                exports.getTouchID = function getTouchID(evt) {
                    var data = (0, _getPointerData.getPointerData)(evt);
                    return data.identifier
                }
        },
        function(module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            var isOneOf = exports.isOneOf = function isOneOf(a) {
                var b = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
                return b.some(function(v) {
                    return a === v
                })
            }
        },
        function(module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            var pickInRange = exports.pickInRange = function pickInRange(value) {
                var min =
                    arguments.length <= 1 || arguments[1] === undefined ? -Infinity : arguments[1];
                var max = arguments.length <= 2 || arguments[2] === undefined ? Infinity : arguments[2];
                return Math.max(min, Math.min(value, max))
            }
        },
        function(module, exports, __webpack_require__) {
            var _keys = __webpack_require__(90);
            var _keys2 = _interopRequireDefault(_keys);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var VENDOR_PREFIX = ["webkit", "moz", "ms", "o"];
            var RE = new RegExp("^-(?!(?:" +
                VENDOR_PREFIX.join("|") + ")-)");
            var autoPrefix = function autoPrefix(styles) {
                var res = {};
                (0, _keys2.default)(styles).forEach(function(prop) {
                    if (!RE.test(prop)) {
                        res[prop] = styles[prop];
                        return
                    }
                    var val = styles[prop];
                    prop = prop.replace(/^-/, "");
                    res[prop] = val;
                    VENDOR_PREFIX.forEach(function(prefix) {
                        res["-" + prefix + "-" + prop] = val
                    })
                });
                return res
            };
            var setStyle = exports.setStyle = function setStyle(elem, styles) {
                styles = autoPrefix(styles);
                (0, _keys2.default)(styles).forEach(function(prop) {
                    var cssProp = prop.replace(/^-/, "").replace(/-([a-z])/g,
                        function(m, $1) {
                            return $1.toUpperCase()
                        });
                    elem.style[cssProp] = styles[prop]
                })
            }
        },
        function(module, exports, __webpack_require__) {
            var _from = __webpack_require__(2);
            var _from2 = _interopRequireDefault(_from);
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            var _assign = __webpack_require__(125);
            var _assign2 = _interopRequireDefault(_assign);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.TouchRecord = undefined;
            var _extends = _assign2.default ||
                function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = arguments[i];
                        for (var key in source)
                            if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key]
                    }
                    return target
                };
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        (0, _defineProperty2.default)(target, descriptor.key, descriptor)
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor
                }
            }();

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _getPosition = __webpack_require__(119);

            function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                    return arr2
                } else return (0, _from2.default)(arr)
            }

            function _classCallCheck(instance,
                Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            var Tracker = function() {
                function Tracker(touch) {
                    _classCallCheck(this, Tracker);
                    this.updateTime = Date.now();
                    this.delta = {
                        x: 0,
                        y: 0
                    };
                    this.velocity = {
                        x: 0,
                        y: 0
                    };
                    this.lastPosition = (0, _getPosition.getPosition)(touch)
                }
                _createClass(Tracker, [{
                    key: "update",
                    value: function update(touch) {
                        var velocity = this.velocity;
                        var updateTime = this.updateTime;
                        var lastPosition = this.lastPosition;
                        var now = Date.now();
                        var position =
                            (0, _getPosition.getPosition)(touch);
                        var delta = {
                            x: -(position.x - lastPosition.x),
                            y: -(position.y - lastPosition.y)
                        };
                        var duration = now - updateTime || 16;
                        var vx = delta.x / duration * 1E3;
                        var vy = delta.y / duration * 1E3;
                        velocity.x = vx * .8 + velocity.x * .2;
                        velocity.y = vy * .8 + velocity.y * .2;
                        this.delta = delta;
                        this.updateTime = now;
                        this.lastPosition = position
                    }
                }]);
                return Tracker
            }();
            var TouchRecord = exports.TouchRecord = function() {
                function TouchRecord() {
                    _classCallCheck(this, TouchRecord);
                    this.touchList = {};
                    this.lastTouch = null;
                    this.activeTouchID =
                        undefined
                }
                _createClass(TouchRecord, [{
                    key: "__add",
                    value: function __add(touch) {
                        if (this.__has(touch)) return null;
                        var tracker = new Tracker(touch);
                        this.touchList[touch.identifier] = tracker;
                        return tracker
                    }
                }, {
                    key: "__renew",
                    value: function __renew(touch) {
                        if (!this.__has(touch)) return null;
                        var tracker = this.touchList[touch.identifier];
                        tracker.update(touch);
                        return tracker
                    }
                }, {
                    key: "__delete",
                    value: function __delete(touch) {
                        return delete this.touchList[touch.identifier]
                    }
                }, {
                    key: "__has",
                    value: function __has(touch) {
                        return this.touchList.hasOwnProperty(touch.identifier)
                    }
                }, {
                    key: "__setActiveID",
                    value: function __setActiveID(touches) {
                        this.activeTouchID = touches[touches.length - 1].identifier;
                        this.lastTouch = this.touchList[this.activeTouchID]
                    }
                }, {
                    key: "__getActiveTracker",
                    value: function __getActiveTracker() {
                        var touchList = this.touchList;
                        var activeTouchID = this.activeTouchID;
                        return touchList[activeTouchID]
                    }
                }, {
                    key: "isActive",
                    value: function isActive() {
                        return this.activeTouchID !== undefined
                    }
                }, {
                    key: "getDelta",
                    value: function getDelta() {
                        var tracker = this.__getActiveTracker();
                        if (!tracker) return this.__primitiveValue;
                        return _extends({}, tracker.delta)
                    }
                }, {
                    key: "getVelocity",
                    value: function getVelocity() {
                        var tracker = this.__getActiveTracker();
                        if (!tracker) return this.__primitiveValue;
                        return _extends({}, tracker.velocity)
                    }
                }, {
                    key: "getLastPosition",
                    value: function getLastPosition() {
                        var coord = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];
                        var tracker = this.__getActiveTracker() || this.lastTouch;
                        var position = tracker ? tracker.lastPosition : this.__primitiveValue;
                        if (!coord) return _extends({}, position);
                        if (!position.hasOwnProperty(coord)) return 0;
                        return position[coord]
                    }
                }, {
                    key: "updatedRecently",
                    value: function updatedRecently() {
                        var tracker = this.__getActiveTracker();
                        return tracker && Date.now() - tracker.updateTime < 30
                    }
                }, {
                    key: "track",
                    value: function track(evt) {
                        var _this = this;
                        var targetTouches = evt.targetTouches;
                        [].concat(_toConsumableArray(targetTouches)).forEach(function(touch) {
                            _this.__add(touch)
                        });
                        return this.touchList
                    }
                }, {
                    key: "update",
                    value: function update(evt) {
                        var _this2 = this;
                        var touches = evt.touches;
                        var changedTouches = evt.changedTouches;
                        [].concat(_toConsumableArray(touches)).forEach(function(touch) {
                            _this2.__renew(touch)
                        });
                        this.__setActiveID(changedTouches);
                        return this.touchList
                    }
                }, {
                    key: "release",
                    value: function release(evt) {
                        var _this3 = this;
                        this.activeTouchID = undefined;
                        [].concat(_toConsumableArray(evt.changedTouches)).forEach(function(touch) {
                            _this3.__delete(touch)
                        });
                        return this.touchList
                    }
                }, {
                    key: "__primitiveValue",
                    get: function get() {
                        return {
                            x: 0,
                            y: 0
                        }
                    }
                }]);
                return TouchRecord
            }()
        },
        function(module, exports, __webpack_require__) {
            module.exports = {
                "default": __webpack_require__(126),
                __esModule: true
            }
        },
        function(module, exports, __webpack_require__) {
            __webpack_require__(127);
            module.exports = __webpack_require__(12).Object.assign
        },
        function(module, exports, __webpack_require__) {
            var $export = __webpack_require__(10);
            $export($export.S + $export.F, "Object", {
                assign: __webpack_require__(128)
            })
        },
        function(module, exports, __webpack_require__) {
            var getKeys = __webpack_require__(31),
                gOPS = __webpack_require__(69),
                pIE = __webpack_require__(70),
                toObject = __webpack_require__(47),
                IObject = __webpack_require__(34),
                $assign = Object.assign;
            module.exports = !$assign || __webpack_require__(21)(function() {
                var A = {},
                    B = {},
                    S = Symbol(),
                    K = "abcdefghijklmnopqrst";
                A[S] = 7;
                K.split("").forEach(function(k) {
                    B[k] = k
                });
                return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join("") != K
            }) ? function assign(target, source) {
                var T = toObject(target),
                    aLen = arguments.length,
                    index = 1,
                    getSymbols = gOPS.f,
                    isEnum = pIE.f;
                while (aLen > index) {
                    var S = IObject(arguments[index++]),
                        keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
                        length = keys.length,
                        j = 0,
                        key;
                    while (length > j)
                        if (isEnum.call(S, key = keys[j++])) T[key] = S[key]
                }
                return T
            } : $assign
        },
        function(module,
            exports, __webpack_require__) {
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            var _keys = __webpack_require__(90);
            var _keys2 = _interopRequireDefault(_keys);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _exportAll = __webpack_require__(130);
            (0, _keys2.default)(_exportAll).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports,
                    key, {
                        enumerable: true,
                        get: function get() {
                            return _exportAll[key]
                        }
                    })
            })
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            var _keys = __webpack_require__(90);
            var _keys2 = _interopRequireDefault(_keys);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _clearMovement = __webpack_require__(131);
            (0, _keys2.default)(_clearMovement).forEach(function(key) {
                if (key ===
                    "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _clearMovement[key]
                    }
                })
            });
            var _destroy = __webpack_require__(132);
            (0, _keys2.default)(_destroy).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _destroy[key]
                    }
                })
            });
            var _getContentElem = __webpack_require__(133);
            (0, _keys2.default)(_getContentElem).forEach(function(key) {
                if (key === "default" ||
                    key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _getContentElem[key]
                    }
                })
            });
            var _getSize = __webpack_require__(134);
            (0, _keys2.default)(_getSize).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _getSize[key]
                    }
                })
            });
            var _infiniteScroll = __webpack_require__(135);
            (0, _keys2.default)(_infiniteScroll).forEach(function(key) {
                if (key === "default" || key ===
                    "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _infiniteScroll[key]
                    }
                })
            });
            var _isVisible = __webpack_require__(136);
            (0, _keys2.default)(_isVisible).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _isVisible[key]
                    }
                })
            });
            var _listener = __webpack_require__(137);
            (0, _keys2.default)(_listener).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _listener[key]
                    }
                })
            });
            var _manageEvents = __webpack_require__(138);
            (0, _keys2.default)(_manageEvents).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _manageEvents[key]
                    }
                })
            });
            var _scrollIntoView = __webpack_require__(139);
            (0, _keys2.default)(_scrollIntoView).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _scrollIntoView[key]
                    }
                })
            });
            var _scrollTo = __webpack_require__(140);
            (0, _keys2.default)(_scrollTo).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _scrollTo[key]
                    }
                })
            });
            var _setOptions = __webpack_require__(141);
            (0, _keys2.default)(_setOptions).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports,
                    key, {
                        enumerable: true,
                        get: function get() {
                            return _setOptions[key]
                        }
                    })
            });
            var _setPosition = __webpack_require__(142);
            (0, _keys2.default)(_setPosition).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _setPosition[key]
                    }
                })
            });
            var _toggleTrack = __webpack_require__(143);
            (0, _keys2.default)(_toggleTrack).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _toggleTrack[key]
                    }
                })
            });
            var _update = __webpack_require__(144);
            (0, _keys2.default)(_update).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _update[key]
                    }
                })
            })
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);
            _smoothScrollbar.SmoothScrollbar.prototype.clearMovement = _smoothScrollbar.SmoothScrollbar.prototype.stop = function() {
                this.movement.x =
                    this.movement.y = 0;
                cancelAnimationFrame(this.__timerID.scrollTo)
            }
        },
        function(module, exports, __webpack_require__) {
            var _from = __webpack_require__(2);
            var _from2 = _interopRequireDefault(_from);

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _smoothScrollbar = __webpack_require__(78);
            var _utils = __webpack_require__(112);
            var _shared = __webpack_require__(89);

            function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                    return arr2
                } else return (0, _from2.default)(arr)
            }
            _smoothScrollbar.SmoothScrollbar.prototype.destroy = function(isRemoval) {
                var __listeners = this.__listeners;
                var __handlers = this.__handlers;
                var __observer = this.__observer;
                var targets = this.targets;
                var container = targets.container;
                var content = targets.content;
                __handlers.forEach(function(_ref) {
                    var evt = _ref.evt;
                    var elem = _ref.elem;
                    var fn = _ref.fn;
                    elem.removeEventListener(evt, fn)
                });
                __handlers.length = __listeners.length = 0;
                this.stop();
                cancelAnimationFrame(this.__timerID.render);
                if (__observer) __observer.disconnect();
                _shared.sbList.delete(container);
                if (isRemoval) return;
                this.scrollTo(0, 0, 300, function() {
                    if (!container.parentNode) return;
                    (0, _utils.setStyle)(container, {
                        overflow: ""
                    });
                    container.scrollTop = container.scrollLeft = 0;
                    var childNodes = [].concat(_toConsumableArray(content.childNodes));
                    container.innerHTML = "";
                    childNodes.forEach(function(el) {
                        return container.appendChild(el)
                    })
                })
            }
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);
            _smoothScrollbar.SmoothScrollbar.prototype.getContentElem =
                function() {
                    return this.targets.content
                }
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);
            _smoothScrollbar.SmoothScrollbar.prototype.getSize = function() {
                var container = this.targets.container;
                var content = this.targets.content;
                return {
                    container: {
                        width: container.clientWidth,
                        height: container.clientHeight
                    },
                    content: {
                        width: content.offsetWidth - content.clientWidth + content.scrollWidth,
                        height: content.offsetHeight - content.clientHeight + content.scrollHeight + (this.options ? this.options.paddingTop :
                            0)
                    }
                }
            }
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);
            _smoothScrollbar.SmoothScrollbar.prototype.infiniteScroll = function(cb) {
                var threshold = arguments.length <= 1 || arguments[1] === undefined ? 50 : arguments[1];
                if (typeof cb !== "function") return;
                var lastOffset = {
                    x: 0,
                    y: 0
                };
                var entered = false;
                this.addListener(function(status) {
                    var offset = status.offset;
                    var limit = status.limit;
                    if (limit.y - offset.y <= threshold && offset.y > lastOffset.y && !entered) {
                        entered = true;
                        setTimeout(function() {
                            return cb(status)
                        })
                    }
                    if (limit.y -
                        offset.y > threshold) entered = false;
                    lastOffset = offset
                })
            }
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);
            _smoothScrollbar.SmoothScrollbar.prototype.isVisible = function(elem) {
                var bounding = this.bounding;
                var targetBounding = elem.getBoundingClientRect();
                var top = Math.max(bounding.top, targetBounding.top);
                var left = Math.max(bounding.left, targetBounding.left);
                var right = Math.min(bounding.right, targetBounding.right);
                var bottom = Math.min(bounding.bottom, targetBounding.bottom);
                return top < bottom && left < right
            }
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);
            _smoothScrollbar.SmoothScrollbar.prototype.addListener = function(cb) {
                if (typeof cb !== "function") return;
                this.__listeners.push(cb)
            };
            _smoothScrollbar.SmoothScrollbar.prototype.removeListener = function(cb) {
                if (typeof cb !== "function") return;
                this.__listeners.some(function(fn, idx, all) {
                    return fn === cb && all.splice(idx, 1)
                })
            }
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty2 =
                __webpack_require__(86);
            var _defineProperty3 = _interopRequireDefault(_defineProperty2);
            var _METHODS;

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _smoothScrollbar = __webpack_require__(78);

            function _defineProperty(obj, key, value) {
                if (key in obj)(0, _defineProperty3.default)(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                });
                else obj[key] = value;
                return obj
            }
            var ACTIONS = {
                REGIESTER: 0,
                UNREGIESTER: 1
            };
            var METHODS = (_METHODS = {}, _defineProperty(_METHODS,
                ACTIONS.REGIESTER, "addEventListener"), _defineProperty(_METHODS, ACTIONS.UNREGIESTER, "removeEventListener"), _METHODS);

            function matchSomeRules(str, rules) {
                return !!rules.length && rules.some(function(regex) {
                    return str.match(regex)
                })
            }

            function manageEvents() {
                var action = arguments.length <= 0 || arguments[0] === undefined ? ACTIONS.REGIESTER : arguments[0];
                var method = METHODS[action];
                return function() {
                    for (var _len = arguments.length, rules = Array(_len), _key = 0; _key < _len; _key++) rules[_key] = arguments[_key];
                    this.__handlers.forEach(function(handler) {
                        var elem =
                            handler.elem;
                        var evt = handler.evt;
                        var fn = handler.fn;
                        var hasRegistered = handler.hasRegistered;
                        if (hasRegistered && action === ACTIONS.REGIESTER || !hasRegistered && action === ACTIONS.UNREGIESTER) return;
                        if (matchSomeRules(evt, rules)) {
                            elem[method](evt, fn);
                            handler.hasRegistered = !hasRegistered
                        }
                    })
                }
            }
            _smoothScrollbar.SmoothScrollbar.prototype.registerEvents = manageEvents(ACTIONS.REGIESTER);
            _smoothScrollbar.SmoothScrollbar.prototype.unregisterEvents = manageEvents(ACTIONS.UNREGIESTER)
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar =
                __webpack_require__(78);
            _smoothScrollbar.SmoothScrollbar.prototype.scrollIntoView = function(elem) {
                var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                var _ref$onlyScrollIfNeed = _ref.onlyScrollIfNeeded;
                var onlyScrollIfNeeded = _ref$onlyScrollIfNeed === undefined ? false : _ref$onlyScrollIfNeed;
                var _ref$offsetTop = _ref.offsetTop;
                var offsetTop = _ref$offsetTop === undefined ? 0 : _ref$offsetTop;
                var _ref$offsetLeft = _ref.offsetLeft;
                var offsetLeft = _ref$offsetLeft === undefined ? 0 : _ref$offsetLeft;
                var targets =
                    this.targets;
                var bounding = this.bounding;
                if (!elem || !targets.container.contains(elem)) return;
                var targetBounding = elem.getBoundingClientRect();
                if (onlyScrollIfNeeded && this.isVisible(elem)) return;
                this.__setMovement(targetBounding.left - bounding.left - offsetLeft, targetBounding.top - bounding.top - offsetTop, true)
            }
        },
        function(module, exports, __webpack_require__) {
            var _utils = __webpack_require__(112);
            var _smoothScrollbar = __webpack_require__(78);
            _smoothScrollbar.SmoothScrollbar.prototype.scrollTo = function() {
                var x = arguments.length <=
                    0 || arguments[0] === undefined ? this.offset.x : arguments[0];
                var y = arguments.length <= 1 || arguments[1] === undefined ? this.offset.y : arguments[1];
                var _this = this;
                var duration = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
                var cb = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
                var options = this.options;
                var offset = this.offset;
                var limit = this.limit;
                var __timerID = this.__timerID;
                cancelAnimationFrame(__timerID.scrollTo);
                cb = typeof cb === "function" ? cb : function() {};
                if (options.renderByPixels) {
                    x =
                        Math.round(x);
                    y = Math.round(y)
                }
                var startX = offset.x;
                var startY = offset.y;
                var disX = (0, _utils.pickInRange)(x, 0, limit.x) - startX;
                var disY = (0, _utils.pickInRange)(y, 0, limit.y) - startY;
                var curveX = (0, _utils.buildCurve)(disX, duration);
                var curveY = (0, _utils.buildCurve)(disY, duration);
                var totalFrame = curveX.length;
                var frame = 0;
                var scroll = function scroll() {
                    if (frame === totalFrame) {
                        _this.setPosition(x, y);
                        return requestAnimationFrame(function() {
                            cb(_this)
                        })
                    }
                    _this.setPosition(startX + curveX[frame], startY + curveY[frame]);
                    frame++;
                    __timerID.scrollTo = requestAnimationFrame(scroll)
                };
                scroll()
            }
        },
        function(module, exports, __webpack_require__) {
            var _keys = __webpack_require__(90);
            var _keys2 = _interopRequireDefault(_keys);

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _smoothScrollbar = __webpack_require__(78);
            _smoothScrollbar.SmoothScrollbar.prototype.setOptions = function() {
                var _this = this;
                var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
                (0, _keys2.default)(options).forEach(function(prop) {
                    if (!_this.options.hasOwnProperty(prop) ||
                        options[prop] === undefined) return;
                    _this.options[prop] = options[prop]
                })
            }
        },
        function(module, exports, __webpack_require__) {
            var _assign = __webpack_require__(125);
            var _assign2 = _interopRequireDefault(_assign);
            var _extends = _assign2.default || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source)
                        if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key]
                }
                return target
            };

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _utils = __webpack_require__(112);
            var _smoothScrollbar = __webpack_require__(78);
            _smoothScrollbar.SmoothScrollbar.prototype.setPosition = function() {
                var x = arguments.length <= 0 || arguments[0] === undefined ? this.offset.x : arguments[0];
                var y = arguments.length <= 1 || arguments[1] === undefined ? this.offset.y : arguments[1];
                var withoutCallbacks = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
                this.__hideTrackThrottle();
                var status = {};
                var options = this.options;
                var offset = this.offset;
                var limit = this.limit;
                var targets = this.targets;
                var __listeners = this.__listeners;
                if (options.renderByPixels) {
                    x = Math.round(x);
                    y = Math.round(y)
                }
                if (Math.abs(x - offset.x) > 1) this.showTrack("x");
                if (Math.abs(y - offset.y) > 1) this.showTrack("y");
                x = (0, _utils.pickInRange)(x, 0, limit.x);
                y = (0, _utils.pickInRange)(y, 0, limit.y);
                if (x === offset.x && y === offset.y) return;
                status.direction = {
                    x: x === offset.x ? "none" : x > offset.x ? "right" : "left",
                    y: y === offset.y ? "none" : y > offset.y ? "down" : "up"
                };
                this.__readonly("offset", {
                    x: x,
                    y: y
                });
                status.limit = _extends({}, limit);
                status.offset = _extends({}, this.offset);
                this.__setThumbPosition();
                (0, _utils.setStyle)(targets.content, {
                    "-transform": "translate3d(" + -x + "px, " + -y + "px, 0)"
                });
                if (withoutCallbacks) return;
                __listeners.forEach(function(fn) {
                    if (options.syncCallbacks) fn(status);
                    else requestAnimationFrame(function() {
                        fn(status)
                    })
                })
            }
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty2 = __webpack_require__(86);
            var _defineProperty3 = _interopRequireDefault(_defineProperty2);
            var _METHODS;

            function _interopRequireDefault(obj) {
                return obj &&
                    obj.__esModule ? obj : {
                        default: obj
                    }
            }
            var _smoothScrollbar = __webpack_require__(78);

            function _defineProperty(obj, key, value) {
                if (key in obj)(0, _defineProperty3.default)(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                });
                else obj[key] = value;
                return obj
            }
            var ACTIONS = {
                SHOW: 0,
                HIDE: 1
            };
            var CLASS_NAMES = {
                TRACK: "show",
                CONTAINER: "scrolling"
            };
            var METHODS = (_METHODS = {}, _defineProperty(_METHODS, ACTIONS.SHOW, "add"), _defineProperty(_METHODS, ACTIONS.HIDE, "remove"), _METHODS);

            function toggleTrack() {
                var action =
                    arguments.length <= 0 || arguments[0] === undefined ? ACTIONS.SHOW : arguments[0];
                var method = METHODS[action];
                return function() {
                    var direction = arguments.length <= 0 || arguments[0] === undefined ? "both" : arguments[0];
                    var options = this.options;
                    var movement = this.movement;
                    var _targets = this.targets;
                    var container = _targets.container;
                    var xAxis = _targets.xAxis;
                    var yAxis = _targets.yAxis;
                    if (movement.x || movement.y) container.classList.add(CLASS_NAMES.CONTAINER);
                    else container.classList.remove(CLASS_NAMES.CONTAINER);
                    if (options.alwaysShowTracks &&
                        action === ACTIONS.HIDE) return;
                    direction = direction.toLowerCase();
                    if (direction === "both") {
                        xAxis.track.classList[method](CLASS_NAMES.TRACK);
                        yAxis.track.classList[method](CLASS_NAMES.TRACK)
                    }
                    if (direction === "x") xAxis.track.classList[method](CLASS_NAMES.TRACK);
                    if (direction === "y") yAxis.track.classList[method](CLASS_NAMES.TRACK)
                }
            }
            _smoothScrollbar.SmoothScrollbar.prototype.showTrack = toggleTrack(ACTIONS.SHOW);
            _smoothScrollbar.SmoothScrollbar.prototype.hideTrack = toggleTrack(ACTIONS.HIDE)
        },
        function(module, exports,
            __webpack_require__) {
            var _utils = __webpack_require__(112);
            var _smoothScrollbar = __webpack_require__(78);

            function updateCanvas() {
                if (this.options.overscrollEffect !== "glow") return;
                var targets = this.targets;
                var size = this.size;
                var _targets$canvas = targets.canvas;
                var elem = _targets$canvas.elem;
                var context = _targets$canvas.context;
                var DPR = window.devicePixelRatio || 1;
                elem.width = size.container.width * DPR;
                elem.height = size.container.height * DPR;
                context.scale(DPR, DPR)
            }

            function updateTrack() {
                var size = this.size;
                var thumbSize =
                    this.thumbSize;
                var _targets = this.targets;
                var xAxis = _targets.xAxis;
                var yAxis = _targets.yAxis;
                (0, _utils.setStyle)(xAxis.track, {
                    "display": size.content.width <= size.container.width ? "none" : "block"
                });
                (0, _utils.setStyle)(yAxis.track, {
                    "display": size.content.height <= size.container.height ? "none" : "block"
                });
                (0, _utils.setStyle)(xAxis.thumb, {
                    "width": thumbSize.x + "px"
                });
                (0, _utils.setStyle)(yAxis.thumb, {
                    "height": thumbSize.y + "px"
                })
            }

            function update() {
                var options = this.options;
                this.__updateBounding();
                var size = this.getSize();
                var newLimit = {
                    x: Math.max(size.content.width - size.container.width, 0),
                    y: Math.max(size.content.height - size.container.height, 0)
                };
                var thumbSize = {
                    realX: size.container.width / size.content.width * size.container.width,
                    realY: size.container.height / size.content.height * size.container.height
                };
                thumbSize.x = Math.max(thumbSize.realX, options.thumbMinSize);
                thumbSize.y = Math.max(thumbSize.realY, options.thumbMinSize);
                this.__readonly("size", size).__readonly("limit", newLimit).__readonly("thumbSize", thumbSize);
                updateTrack.call(this);
                updateCanvas.call(this);
                this.setPosition();
                this.__setThumbPosition()
            }
            _smoothScrollbar.SmoothScrollbar.prototype.update = function(inAsync) {
                if (inAsync) requestAnimationFrame(update.bind(this));
                else update.call(this)
            }
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            var _keys = __webpack_require__(90);
            var _keys2 = _interopRequireDefault(_keys);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            function _interopRequireDefault(obj) {
                return obj &&
                    obj.__esModule ? obj : {
                        default: obj
                    }
            }
            var _exportAll = __webpack_require__(146);
            (0, _keys2.default)(_exportAll).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _exportAll[key]
                    }
                })
            })
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            var _keys = __webpack_require__(90);
            var _keys2 = _interopRequireDefault(_keys);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _addMovement = __webpack_require__(147);
            (0, _keys2.default)(_addMovement).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _addMovement[key]
                    }
                })
            });
            var _movementLock = __webpack_require__(148);
            (0, _keys2.default)(_movementLock).forEach(function(key) {
                if (key === "default" ||
                    key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _movementLock[key]
                    }
                })
            });
            var _renderOverscroll = __webpack_require__(149);
            (0, _keys2.default)(_renderOverscroll).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _renderOverscroll[key]
                    }
                })
            });
            var _render = __webpack_require__(154);
            (0, _keys2.default)(_render).forEach(function(key) {
                if (key === "default" ||
                    key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _render[key]
                    }
                })
            });
            var _setMovement = __webpack_require__(155);
            (0, _keys2.default)(_setMovement).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _setMovement[key]
                    }
                })
            });
            var _shouldPropagateMovement = __webpack_require__(156);
            (0, _keys2.default)(_shouldPropagateMovement).forEach(function(key) {
                if (key ===
                    "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _shouldPropagateMovement[key]
                    }
                })
            });
            var _willOverscroll = __webpack_require__(157);
            (0, _keys2.default)(_willOverscroll).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _willOverscroll[key]
                    }
                })
            })
        },
        function(module, exports, __webpack_require__) {
            var _from = __webpack_require__(2);
            var _from2 =
                _interopRequireDefault(_from);

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _utils = __webpack_require__(112);
            var _smoothScrollbar = __webpack_require__(78);

            function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                    return arr2
                } else return (0, _from2.default)(arr)
            }

            function __addMovement() {
                var deltaX = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
                var deltaY = arguments.length <= 1 || arguments[1] ===
                    undefined ? 0 : arguments[1];
                var noOverscroll = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
                var limit = this.limit;
                var options = this.options;
                var movement = this.movement;
                this.__updateThrottle();
                if (options.renderByPixels) {
                    deltaX = Math.round(deltaX);
                    deltaY = Math.round(deltaY)
                }
                var x = movement.x + deltaX;
                var y = movement.y + deltaY;
                if (limit.x === 0) x = 0;
                if (limit.y === 0) y = 0;
                var deltaLimit = this.__getDeltaLimit(noOverscroll);
                movement.x = _utils.pickInRange.apply(undefined, [x].concat(_toConsumableArray(deltaLimit.x)));
                movement.y = _utils.pickInRange.apply(undefined, [y].concat(_toConsumableArray(deltaLimit.y)))
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__addMovement", {
                value: __addMovement,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);
            var DIRECTIONS = ["x", "y"];

            function __autoLockMovement() {
                var _this = this;
                var movement = this.movement;
                var movementLocked = this.movementLocked;
                DIRECTIONS.forEach(function(dir) {
                    movementLocked[dir] =
                        movement[dir] && _this.__willOverscroll(dir, movement[dir])
                })
            }

            function __unlockMovement() {
                var movementLocked = this.movementLocked;
                DIRECTIONS.forEach(function(dir) {
                    movementLocked[dir] = false
                })
            }

            function __isMovementLocked() {
                var movementLocked = this.movementLocked;
                return movementLocked.x || movementLocked.y
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__autoLockMovement", {
                value: __autoLockMovement,
                writable: true,
                configurable: true
            });
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype,
                "__unlockMovement", {
                    value: __unlockMovement,
                    writable: true,
                    configurable: true
                });
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__isMovementLocked", {
                value: __isMovementLocked,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _assign = __webpack_require__(125);
            var _assign2 = _interopRequireDefault(_assign);
            var _extends = _assign2.default || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source)
                        if (Object.prototype.hasOwnProperty.call(source,
                                key)) target[key] = source[key]
                }
                return target
            };

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _smoothScrollbar = __webpack_require__(78);
            var _overscroll = __webpack_require__(150);
            var _shared = __webpack_require__(89);
            var _utils = __webpack_require__(112);

            function calcNext() {
                var dir = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];
                if (!dir) return;
                var options = this.options;
                var movement = this.movement;
                var overscrollRendered = this.overscrollRendered;
                var MAX_OVERSCROLL =
                    this.MAX_OVERSCROLL;
                var dest = movement[dir] = (0, _utils.pickInRange)(movement[dir], -MAX_OVERSCROLL, MAX_OVERSCROLL);
                var damping = options.overscrollDamping;
                var next = overscrollRendered[dir] + (dest - overscrollRendered[dir]) * damping;
                if (options.renderByPixels) next |= 0;
                if (!this.__isMovementLocked() && Math.abs(next - overscrollRendered[dir]) < .1) next -= dest / Math.abs(dest || 1);
                if (Math.abs(next) < Math.abs(overscrollRendered[dir])) this.__readonly("overscrollBack", true);
                if (next * overscrollRendered[dir] < 0 || Math.abs(next) <= 1) {
                    next =
                        0;
                    this.__readonly("overscrollBack", false)
                }
                overscrollRendered[dir] = next
            }

            function shouldUpdate(lastRendered) {
                var __touchRecord = this.__touchRecord;
                var overscrollRendered = this.overscrollRendered;
                if (overscrollRendered.x !== lastRendered.x || overscrollRendered.y !== lastRendered.y) return true;
                if (_shared.GLOBAL_ENV.TOUCH_SUPPORTED && __touchRecord.updatedRecently()) return true;
                return false
            }

            function __renderOverscroll() {
                var _this = this;
                var dirs = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
                if (!dirs.length ||
                    !this.options.overscrollEffect) return;
                var options = this.options;
                var overscrollRendered = this.overscrollRendered;
                var lastRendered = _extends({}, overscrollRendered);
                dirs.forEach(function(dir) {
                    return calcNext.call(_this, dir)
                });
                if (!shouldUpdate.call(this, lastRendered)) return;
                switch (options.overscrollEffect) {
                    case "bounce":
                        return _overscroll.overscrollBounce.call(this, overscrollRendered.x, overscrollRendered.y);
                    case "glow":
                        return _overscroll.overscrollGlow.call(this, overscrollRendered.x, overscrollRendered.y);
                    default:
                        return
                }
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__renderOverscroll", {
                value: __renderOverscroll,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            var _keys = __webpack_require__(90);
            var _keys2 = _interopRequireDefault(_keys);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ?
                    obj : {
                        default: obj
                    }
            }
            var _exportAll = __webpack_require__(151);
            (0, _keys2.default)(_exportAll).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _exportAll[key]
                    }
                })
            })
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            var _keys = __webpack_require__(90);
            var _keys2 = _interopRequireDefault(_keys);
            Object.defineProperty(exports,
                "__esModule", {
                    value: true
                });

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _bounce = __webpack_require__(152);
            (0, _keys2.default)(_bounce).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _bounce[key]
                    }
                })
            });
            var _glow = __webpack_require__(153);
            (0, _keys2.default)(_glow).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports,
                    key, {
                        enumerable: true,
                        get: function get() {
                            return _glow[key]
                        }
                    })
            })
        },
        function(module, exports, __webpack_require__) {
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.overscrollBounce = overscrollBounce;
            var _utils = __webpack_require__(112);

            function overscrollBounce(x, y) {
                var size = this.size;
                var offset = this.offset;
                var targets = this.targets;
                var thumbOffset = this.thumbOffset;
                var xAxis = targets.xAxis;
                var yAxis = targets.yAxis;
                var content = targets.content;
                (0, _utils.setStyle)(content, {
                    "-transform": "translate3d(" +
                        -(offset.x + x) + "px, " + -(offset.y + y) + "px, 0)"
                });
                if (x) {
                    var ratio = size.container.width / (size.container.width + Math.abs(x));
                    (0, _utils.setStyle)(xAxis.thumb, {
                        "-transform": "translate3d(" + thumbOffset.x + "px, 0, 0) scale3d(" + ratio + ", 1, 1)",
                        "-transform-origin": x < 0 ? "left" : "right"
                    })
                }
                if (y) {
                    var _ratio = size.container.height / (size.container.height + Math.abs(y));
                    (0, _utils.setStyle)(yAxis.thumb, {
                        "-transform": "translate3d(0, " + thumbOffset.y + "px, 0) scale3d(1, " + _ratio + ", 1)",
                        "-transform-origin": y < 0 ? "top" : "bottom"
                    })
                }
            }
        },
        function(module, exports, __webpack_require__) {
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.overscrollGlow = overscrollGlow;
            var _utils = __webpack_require__(112);
            var GLOW_MAX_OPACITY = .75;
            var GLOW_MAX_OFFSET = .25;

            function overscrollGlow(x, y) {
                var size = this.size;
                var targets = this.targets;
                var options = this.options;
                var _targets$canvas = targets.canvas;
                var canvas = _targets$canvas.elem;
                var ctx = _targets$canvas.context;
                if (!x && !y) return (0, _utils.setStyle)(canvas, {
                    display: "none"
                });
                (0, _utils.setStyle)(canvas, {
                    display: "block"
                });
                ctx.clearRect(0, 0, size.content.width, size.container.height);
                ctx.fillStyle = options.overscrollEffectColor;
                renderGlowX.call(this, x);
                renderGlowY.call(this, y)
            }

            function renderGlowX(strength) {
                var size = this.size;
                var targets = this.targets;
                var __touchRecord = this.__touchRecord;
                var MAX_OVERSCROLL = this.MAX_OVERSCROLL;
                var _size$container = size.container;
                var width = _size$container.width;
                var height = _size$container.height;
                var ctx = targets.canvas.context;
                ctx.save();
                if (strength > 0) ctx.transform(-1, 0, 0,
                    1, width, 0);
                var opacity = (0, _utils.pickInRange)(Math.abs(strength) / MAX_OVERSCROLL, 0, GLOW_MAX_OPACITY);
                var startOffset = (0, _utils.pickInRange)(opacity, 0, GLOW_MAX_OFFSET) * width;
                var x = Math.abs(strength);
                var y = __touchRecord.getLastPosition("y") || height / 2;
                ctx.globalAlpha = opacity;
                ctx.beginPath();
                ctx.moveTo(0, -startOffset);
                ctx.quadraticCurveTo(x, y, 0, height + startOffset);
                ctx.fill();
                ctx.closePath();
                ctx.restore()
            }

            function renderGlowY(strength) {
                var size = this.size;
                var targets = this.targets;
                var __touchRecord = this.__touchRecord;
                var MAX_OVERSCROLL = this.MAX_OVERSCROLL;
                var _size$container2 = size.container;
                var width = _size$container2.width;
                var height = _size$container2.height;
                var ctx = targets.canvas.context;
                ctx.save();
                if (strength > 0) ctx.transform(1, 0, 0, -1, 0, height);
                var opacity = (0, _utils.pickInRange)(Math.abs(strength) / MAX_OVERSCROLL, 0, GLOW_MAX_OPACITY);
                var startOffset = (0, _utils.pickInRange)(opacity, 0, GLOW_MAX_OFFSET) * width;
                var x = __touchRecord.getLastPosition("x") || width / 2;
                var y = Math.abs(strength);
                ctx.globalAlpha = opacity;
                ctx.beginPath();
                ctx.moveTo(-startOffset, 0);
                ctx.quadraticCurveTo(x, y, width + startOffset, 0);
                ctx.fill();
                ctx.closePath();
                ctx.restore()
            }
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);
            var _utils = __webpack_require__(112);

            function nextTick(dir) {
                var options = this.options;
                var offset = this.offset;
                var movement = this.movement;
                var __touchRecord = this.__touchRecord;
                var damping = options.damping;
                var renderByPixels = options.renderByPixels;
                var overscrollDamping = options.overscrollDamping;
                var current =
                    offset[dir];
                var remain = movement[dir];
                var renderDamping = damping;
                if (this.__willOverscroll(dir, remain)) renderDamping = overscrollDamping;
                else if (__touchRecord.isActive()) renderDamping = .5;
                if (Math.abs(remain) < 1) {
                    var next = current + remain;
                    return {
                        movement: 0,
                        position: remain > 0 ? Math.ceil(next) : Math.floor(next)
                    }
                }
                var nextMovement = remain * (1 - renderDamping);
                if (renderByPixels) nextMovement |= 0;
                return {
                    movement: nextMovement,
                    position: current + remain - nextMovement
                }
            }

            function __render() {
                var options = this.options;
                var offset = this.offset;
                var limit = this.limit;
                var movement = this.movement;
                var overscrollRendered = this.overscrollRendered;
                var __timerID = this.__timerID;
                if (movement.x || movement.y || overscrollRendered.x || overscrollRendered.y) {
                    var nextX = nextTick.call(this, "x");
                    var nextY = nextTick.call(this, "y");
                    var overflowDir = [];
                    if (options.overscrollEffect) {
                        var destX = (0, _utils.pickInRange)(nextX.position, 0, limit.x);
                        var destY = (0, _utils.pickInRange)(nextY.position, 0, limit.y);
                        if (overscrollRendered.x || destX === offset.x && movement.x) overflowDir.push("x");
                        if (overscrollRendered.y || destY === offset.y && movement.y) overflowDir.push("y")
                    }
                    if (!this.movementLocked.x) movement.x = nextX.movement;
                    if (!this.movementLocked.y) movement.y = nextY.movement;
                    this.setPosition(nextX.position, nextY.position);
                    this.__renderOverscroll(overflowDir)
                }
                __timerID.render = requestAnimationFrame(__render.bind(this))
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__render", {
                value: __render,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _from =
                __webpack_require__(2);
            var _from2 = _interopRequireDefault(_from);

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _utils = __webpack_require__(112);
            var _smoothScrollbar = __webpack_require__(78);

            function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                    return arr2
                } else return (0, _from2.default)(arr)
            }

            function __setMovement() {
                var deltaX = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
                var deltaY =
                    arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
                var noOverscroll = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
                var options = this.options;
                var movement = this.movement;
                this.__updateThrottle();
                var limit = this.__getDeltaLimit(noOverscroll);
                if (options.renderByPixels) {
                    deltaX = Math.round(deltaX);
                    deltaY = Math.round(deltaY)
                }
                movement.x = _utils.pickInRange.apply(undefined, [deltaX].concat(_toConsumableArray(limit.x)));
                movement.y = _utils.pickInRange.apply(undefined, [deltaY].concat(_toConsumableArray(limit.y)))
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__setMovement", {
                value: __setMovement,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);
            var _utils = __webpack_require__(112);

            function __shouldPropagateMovement() {
                var deltaX = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
                var deltaY = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
                var options = this.options;
                var offset = this.offset;
                var limit =
                    this.limit;
                if (!options.continuousScrolling) return false;
                var destX = (0, _utils.pickInRange)(deltaX + offset.x, 0, limit.x);
                var destY = (0, _utils.pickInRange)(deltaY + offset.y, 0, limit.y);
                var res = true;
                res &= destX === offset.x;
                res &= destY === offset.y;
                res &= destX === limit.x || destX === 0 || destY === limit.y || destY === 0;
                return res
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__shouldPropagateMovement", {
                value: __shouldPropagateMovement,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar =
                __webpack_require__(78);
            var _utils = __webpack_require__(112);

            function __willOverscroll() {
                var dir = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];
                var delta = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
                if (!dir) return false;
                var offset = this.offset;
                var limit = this.limit;
                var currentOffset = offset[dir];
                return (0, _utils.pickInRange)(delta + currentOffset, 0, limit[dir]) === currentOffset && (currentOffset === 0 || currentOffset === limit[dir])
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype,
                "__willOverscroll", {
                    value: __willOverscroll,
                    writable: true,
                    configurable: true
                })
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            var _keys = __webpack_require__(90);
            var _keys2 = _interopRequireDefault(_keys);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _exportAll = __webpack_require__(159);
            (0, _keys2.default)(_exportAll).forEach(function(key) {
                if (key ===
                    "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _exportAll[key]
                    }
                })
            })
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            var _keys = __webpack_require__(90);
            var _keys2 = _interopRequireDefault(_keys);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _drag = __webpack_require__(160);
            (0, _keys2.default)(_drag).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _drag[key]
                    }
                })
            });
            var _keyboard = __webpack_require__(161);
            (0, _keys2.default)(_keyboard).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _keyboard[key]
                    }
                })
            });
            var _mouse = __webpack_require__(168);
            (0, _keys2.default)(_mouse).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _mouse[key]
                    }
                })
            });
            var _resize = __webpack_require__(169);
            (0, _keys2.default)(_resize).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _resize[key]
                    }
                })
            });
            var _select = __webpack_require__(170);
            (0, _keys2.default)(_select).forEach(function(key) {
                if (key ===
                    "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _select[key]
                    }
                })
            });
            var _touch = __webpack_require__(171);
            (0, _keys2.default)(_touch).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _touch[key]
                    }
                })
            });
            var _wheel = __webpack_require__(172);
            (0, _keys2.default)(_wheel).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _wheel[key]
                    }
                })
            })
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);
            var _utils = __webpack_require__(112);

            function __dragHandler() {
                var _this = this;
                var _targets = this.targets;
                var container = _targets.container;
                var content = _targets.content;
                var isDrag = false;
                var animation = void 0,
                    padding = void 0;
                Object.defineProperty(this, "__isDrag", {
                    get: function get() {
                        return isDrag
                    },
                    enumerable: false
                });
                var scroll = function scroll(_ref) {
                    var x = _ref.x;
                    var y = _ref.y;
                    if (!x && !y) return;
                    var speed = _this.options.speed;
                    _this.__setMovement(x * speed, y * speed);
                    animation = requestAnimationFrame(function() {
                        scroll({
                            x: x,
                            y: y
                        })
                    })
                };
                this.__addEvent(container, "dragstart", function(evt) {
                    if (_this.__eventFromChildScrollbar(evt)) return;
                    isDrag = true;
                    padding = evt.target.clientHeight;
                    (0, _utils.setStyle)(content, {
                        "pointer-events": "auto"
                    });
                    cancelAnimationFrame(animation);
                    _this.__updateBounding()
                });
                this.__addEvent(document, "dragover mousemove touchmove",
                    function(evt) {
                        if (!isDrag || _this.__eventFromChildScrollbar(evt)) return;
                        cancelAnimationFrame(animation);
                        evt.preventDefault();
                        var dir = _this.__getPointerTrend(evt, padding);
                        scroll(dir)
                    });
                this.__addEvent(document, "dragend mouseup touchend blur", function() {
                    cancelAnimationFrame(animation);
                    isDrag = false
                })
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__dragHandler", {
                value: __dragHandler,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _isIterable2 = __webpack_require__(162);
            var _isIterable3 = _interopRequireDefault(_isIterable2);
            var _getIterator2 = __webpack_require__(165);
            var _getIterator3 = _interopRequireDefault(_getIterator2);
            var _slicedToArray = function() {
                function sliceIterator(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                        for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
                            _arr.push(_s.value);
                            if (i && _arr.length === i) break
                        }
                    } catch (err) {
                        _d = true;
                        _e = err
                    } finally {
                        try {
                            if (!_n && _i["return"]) _i["return"]()
                        } finally {
                            if (_d) throw _e;
                        }
                    }
                    return _arr
                }
                return function(arr, i) {
                    if (Array.isArray(arr)) return arr;
                    else if ((0, _isIterable3.default)(Object(arr))) return sliceIterator(arr, i);
                    else throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
            }();

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _smoothScrollbar = __webpack_require__(78);
            var KEY_CODE = {
                SPACE: 32,
                PAGE_UP: 33,
                PAGE_DOWN: 34,
                END: 35,
                HOME: 36,
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                DOWN: 40
            };

            function __keyboardHandler() {
                var _this = this;
                var targets = this.targets;
                var getKeyDelta = function getKeyDelta(keyCode) {
                    var size = _this.size;
                    var offset = _this.offset;
                    var limit = _this.limit;
                    var movement = _this.movement;
                    switch (keyCode) {
                        case KEY_CODE.SPACE:
                            return [0, 200];
                        case KEY_CODE.PAGE_UP:
                            return [0, -size.container.height + 40];
                        case KEY_CODE.PAGE_DOWN:
                            return [0, size.container.height - 40];
                        case KEY_CODE.END:
                            return [0, Math.abs(movement.y) + limit.y - offset.y];
                        case KEY_CODE.HOME:
                            return [0, -Math.abs(movement.y) - offset.y];
                        case KEY_CODE.LEFT:
                            return [-40, 0];
                        case KEY_CODE.UP:
                            return [0, -40];
                        case KEY_CODE.RIGHT:
                            return [40,
                                0
                            ];
                        case KEY_CODE.DOWN:
                            return [0, 40];
                        default:
                            return null
                    }
                };
                var container = targets.container;
                var isFocused = false;
                this.__addEvent(container, "focus", function() {
                    isFocused = true
                });
                this.__addEvent(container, "blur", function() {
                    isFocused = false
                });
                this.__addEvent(container, "keydown", function(evt) {
                    if (!isFocused) return;
                    var options = _this.options;
                    var parents = _this.parents;
                    var movementLocked = _this.movementLocked;
                    var delta = getKeyDelta(evt.keyCode || evt.which);
                    if (!delta) return;
                    var _delta = _slicedToArray(delta, 2);
                    var x = _delta[0];
                    var y = _delta[1];
                    if (_this.__shouldPropagateMovement(x, y)) {
                        container.blur();
                        if (parents.length) parents[0].focus();
                        return _this.__updateThrottle()
                    }
                    evt.preventDefault();
                    _this.__unlockMovement();
                    if (x && _this.__willOverscroll("x", x)) movementLocked.x = true;
                    if (y && _this.__willOverscroll("y", y)) movementLocked.y = true;
                    var speed = options.speed;
                    _this.__addMovement(x * speed, y * speed)
                });
                this.__addEvent(container, "keyup", function() {
                    _this.__unlockMovement()
                })
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype,
                "__keyboardHandler", {
                    value: __keyboardHandler,
                    writable: true,
                    configurable: true
                })
        },
        function(module, exports, __webpack_require__) {
            module.exports = {
                "default": __webpack_require__(163),
                __esModule: true
            }
        },
        function(module, exports, __webpack_require__) {
            __webpack_require__(57);
            __webpack_require__(4);
            module.exports = __webpack_require__(164)
        },
        function(module, exports, __webpack_require__) {
            var classof = __webpack_require__(53),
                ITERATOR = __webpack_require__(45)("iterator"),
                Iterators = __webpack_require__(27);
            module.exports =
                __webpack_require__(12).isIterable = function(it) {
                    var O = Object(it);
                    return O[ITERATOR] !== undefined || "@@iterator" in O || Iterators.hasOwnProperty(classof(O))
                }
        },
        function(module, exports, __webpack_require__) {
            module.exports = {
                "default": __webpack_require__(166),
                __esModule: true
            }
        },
        function(module, exports, __webpack_require__) {
            __webpack_require__(57);
            __webpack_require__(4);
            module.exports = __webpack_require__(167)
        },
        function(module, exports, __webpack_require__) {
            var anObject = __webpack_require__(17),
                get = __webpack_require__(52);
            module.exports = __webpack_require__(12).getIterator = function(it) {
                var iterFn = get(it);
                if (typeof iterFn != "function") throw TypeError(it + " is not iterable!");
                return anObject(iterFn.call(it))
            }
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);
            var _utils = __webpack_require__(112);

            function __mouseHandler() {
                var _this = this;
                var _targets = this.targets;
                var container = _targets.container;
                var xAxis = _targets.xAxis;
                var yAxis = _targets.yAxis;
                var getDest = function getDest(direction,
                    offsetOnTrack) {
                    var size = _this.size;
                    var thumbSize = _this.thumbSize;
                    if (direction === "x") {
                        var totalWidth = size.container.width - (thumbSize.x - thumbSize.realX);
                        return offsetOnTrack / totalWidth * size.content.width
                    }
                    if (direction === "y") {
                        var totalHeight = size.container.height - (thumbSize.y - thumbSize.realY);
                        return offsetOnTrack / totalHeight * size.content.height
                    }
                    return 0
                };
                var getTrackDir = function getTrackDir(elem) {
                    if ((0, _utils.isOneOf)(elem, [xAxis.track, xAxis.thumb])) return "x";
                    if ((0, _utils.isOneOf)(elem, [yAxis.track, yAxis.thumb])) return "y"
                };
                var isMouseDown = void 0,
                    isMouseMoving = void 0,
                    startOffsetToThumb = void 0,
                    startTrackDirection = void 0,
                    containerRect = void 0;
                this.__addEvent(container, "click", function(evt) {
                    if (isMouseMoving || !(0, _utils.isOneOf)(evt.target, [xAxis.track, yAxis.track])) return;
                    var track = evt.target;
                    var direction = getTrackDir(track);
                    var rect = track.getBoundingClientRect();
                    var clickPos = (0, _utils.getPosition)(evt);
                    var offset = _this.offset;
                    var thumbSize = _this.thumbSize;
                    if (direction === "x") {
                        var offsetOnTrack = clickPos.x - rect.left - thumbSize.x /
                            2;
                        _this.__setMovement(getDest(direction, offsetOnTrack) - offset.x, 0)
                    } else {
                        var _offsetOnTrack = clickPos.y - rect.top - thumbSize.y / 2;
                        _this.__setMovement(0, getDest(direction, _offsetOnTrack) - offset.y)
                    }
                });
                this.__addEvent(container, "mousedown", function(evt) {
                    if (!(0, _utils.isOneOf)(evt.target, [xAxis.thumb, yAxis.thumb])) return;
                    isMouseDown = true;
                    var cursorPos = (0, _utils.getPosition)(evt);
                    var thumbRect = evt.target.getBoundingClientRect();
                    startTrackDirection = getTrackDir(evt.target);
                    startOffsetToThumb = {
                        x: cursorPos.x - thumbRect.left,
                        y: cursorPos.y - thumbRect.top
                    };
                    containerRect = _this.targets.container.getBoundingClientRect()
                });
                this.__addEvent(window, "mousemove", function(evt) {
                    if (!isMouseDown) return;
                    evt.preventDefault();
                    isMouseMoving = true;
                    var offset = _this.offset;
                    var cursorPos = (0, _utils.getPosition)(evt);
                    if (startTrackDirection === "x") {
                        var offsetOnTrack = cursorPos.x - startOffsetToThumb.x - containerRect.left;
                        _this.setPosition(getDest(startTrackDirection, offsetOnTrack), offset.y)
                    }
                    if (startTrackDirection === "y") {
                        var _offsetOnTrack2 = cursorPos.y -
                            startOffsetToThumb.y - containerRect.top;
                        _this.setPosition(offset.x, getDest(startTrackDirection, _offsetOnTrack2))
                    }
                });
                this.__addEvent(window, "mouseup blur", function() {
                    isMouseDown = isMouseMoving = false
                })
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__mouseHandler", {
                value: __mouseHandler,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);

            function __resizeHandler() {
                this.__addEvent(window, "resize", this.__updateThrottle)
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__resizeHandler", {
                value: __resizeHandler,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);
            var _utils = __webpack_require__(112);

            function __selectHandler() {
                var _this = this;
                var isSelected = false;
                var animation = void 0;
                var _targets = this.targets;
                var container = _targets.container;
                var content = _targets.content;
                var scroll = function scroll(_ref) {
                    var x = _ref.x;
                    var y = _ref.y;
                    if (!x &&
                        !y) return;
                    var speed = _this.options.speed;
                    _this.__setMovement(x * speed, y * speed);
                    animation = requestAnimationFrame(function() {
                        scroll({
                            x: x,
                            y: y
                        })
                    })
                };
                var setSelect = function setSelect() {
                    var value = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];
                    (0, _utils.setStyle)(container, {
                        "-user-select": value
                    })
                };
                this.__addEvent(window, "mousemove", function(evt) {
                    if (!isSelected) return;
                    cancelAnimationFrame(animation);
                    var dir = _this.__getPointerTrend(evt);
                    scroll(dir)
                });
                this.__addEvent(content, "selectstart", function(evt) {
                    if (_this.__eventFromChildScrollbar(evt)) return setSelect("none");
                    cancelAnimationFrame(animation);
                    _this.__updateBounding();
                    isSelected = true
                });
                this.__addEvent(window, "mouseup blur", function() {
                    cancelAnimationFrame(animation);
                    setSelect();
                    isSelected = false
                });
                this.__addEvent(container, "scroll", function(evt) {
                    evt.preventDefault();
                    container.scrollTop = container.scrollLeft = 0
                })
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__selectHandler", {
                value: __selectHandler,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar =
                __webpack_require__(78);
            var _shared = __webpack_require__(89);
            var MIN_VELOCITY = 100;
            var activeScrollbar = null;

            function __touchHandler() {
                var _this = this;
                var targets = this.targets;
                var movementLocked = this.movementLocked;
                var __touchRecord = this.__touchRecord;
                var container = targets.container;
                this.__addEvent(container, "touchstart", function(evt) {
                    if (_this.__isDrag) return;
                    if (_this.options.shouldHandleEvent)
                        if (!_this.options.shouldHandleEvent(evt)) return;
                    var __timerID = _this.__timerID;
                    var movement = _this.movement;
                    cancelAnimationFrame(__timerID.scrollTo);
                    if (!_this.__willOverscroll("x")) movement.x = 0;
                    if (!_this.__willOverscroll("y")) movement.y = 0;
                    __touchRecord.track(evt);
                    _this.__autoLockMovement()
                });
                this.__addEvent(container, "touchmove", function(evt) {
                    if (_this.__isDrag) return;
                    if (_this.options.shouldHandleEvent)
                        if (!_this.options.shouldHandleEvent(evt)) return;
                    if (activeScrollbar && activeScrollbar !== _this) return;
                    __touchRecord.update(evt);
                    var _touchRecord$getDelt = __touchRecord.getDelta();
                    var x = _touchRecord$getDelt.x;
                    var y = _touchRecord$getDelt.y;
                    if (_this.__shouldPropagateMovement(x,
                            y)) return _this.__updateThrottle();
                    var movement = _this.movement;
                    var MAX_OVERSCROLL = _this.MAX_OVERSCROLL;
                    var options = _this.options;
                    if (movement.x && _this.__willOverscroll("x", x)) {
                        var factor = 2;
                        if (options.overscrollEffect === "bounce") factor += Math.abs(10 * movement.x / MAX_OVERSCROLL);
                        if (Math.abs(movement.x) >= MAX_OVERSCROLL) x = 0;
                        else x /= factor
                    }
                    if (movement.y && _this.__willOverscroll("y", y)) {
                        var _factor = 2;
                        if (options.overscrollEffect === "bounce") _factor += Math.abs(10 * movement.y / MAX_OVERSCROLL);
                        if (Math.abs(movement.y) >=
                            MAX_OVERSCROLL) y = 0;
                        else y /= _factor
                    }
                    _this.__autoLockMovement();
                    evt.preventDefault();
                    _this.__addMovement(x, y);
                    activeScrollbar = _this
                });
                this.__addEvent(container, "touchcancel touchend", function(evt) {
                    if (_this.__isDrag) return;
                    var speed = _this.options.speed;
                    var _touchRecord$getVelo = __touchRecord.getVelocity();
                    var x = _touchRecord$getVelo.x;
                    var y = _touchRecord$getVelo.y;
                    x = movementLocked.x ? 0 : Math.min(x * _shared.GLOBAL_ENV.EASING_MULTIPLIER, 1E3);
                    y = movementLocked.y ? 0 : Math.min(y * _shared.GLOBAL_ENV.EASING_MULTIPLIER,
                        1E3);
                    _this.__addMovement(Math.abs(x) > MIN_VELOCITY ? x * speed : 0, Math.abs(y) > MIN_VELOCITY ? y * speed : 0);
                    _this.__unlockMovement();
                    __touchRecord.release(evt);
                    activeScrollbar = null
                })
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__touchHandler", {
                value: __touchHandler,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);
            var _utils = __webpack_require__(112);
            var _shared = __webpack_require__(89);

            function __wheelHandler() {
                var _this =
                    this;
                var container = this.targets.container;
                var wheelLocked = false;
                var releaseWheel = (0, _utils.debounce)(function() {
                    wheelLocked = false
                }, 30, false);
                this.__addEvent(container, _shared.GLOBAL_ENV.WHEEL_EVENT, function(evt) {
                    var options = _this.options;
                    var _getDelta = (0, _utils.getDelta)(evt);
                    var x = _getDelta.x;
                    var y = _getDelta.y;
                    if (options.shouldHandleEvent)
                        if (!options.shouldHandleEvent(evt)) return;
                    x *= options.speed;
                    y *= options.speed;
                    if (_this.__shouldPropagateMovement(x, y)) return _this.__updateThrottle();
                    evt.preventDefault();
                    releaseWheel();
                    if (_this.overscrollBack) wheelLocked = true;
                    if (wheelLocked) {
                        if (_this.__willOverscroll("x", x)) x = 0;
                        if (_this.__willOverscroll("y", y)) y = 0
                    }
                    _this.__addMovement(x, y)
                })
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__wheelHandler", {
                value: __wheelHandler,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            var _keys = __webpack_require__(90);
            var _keys2 =
                _interopRequireDefault(_keys);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _exportAll = __webpack_require__(174);
            (0, _keys2.default)(_exportAll).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _exportAll[key]
                    }
                })
            })
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            var _keys = __webpack_require__(90);
            var _keys2 = _interopRequireDefault(_keys);
            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _addEvent = __webpack_require__(175);
            (0, _keys2.default)(_addEvent).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _addEvent[key]
                    }
                })
            });
            var _eventFromChildScrollbar = __webpack_require__(176);
            (0, _keys2.default)(_eventFromChildScrollbar).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _eventFromChildScrollbar[key]
                    }
                })
            });
            var _getDeltaLimit = __webpack_require__(177);
            (0, _keys2.default)(_getDeltaLimit).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _getDeltaLimit[key]
                    }
                })
            });
            var _getPointerTrend = __webpack_require__(178);
            (0, _keys2.default)(_getPointerTrend).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _getPointerTrend[key]
                    }
                })
            });
            var _initOptions = __webpack_require__(179);
            (0, _keys2.default)(_initOptions).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _initOptions[key]
                    }
                })
            });
            var _initScrollbar = __webpack_require__(182);
            (0, _keys2.default)(_initScrollbar).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _initScrollbar[key]
                    }
                })
            });
            var _readonly = __webpack_require__(183);
            (0, _keys2.default)(_readonly).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _readonly[key]
                    }
                })
            });
            var _setThumbPosition =
                __webpack_require__(184);
            (0, _keys2.default)(_setThumbPosition).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _setThumbPosition[key]
                    }
                })
            });
            var _updateBounding = __webpack_require__(185);
            (0, _keys2.default)(_updateBounding).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _updateBounding[key]
                    }
                })
            });
            var _updateTree = __webpack_require__(186);
            (0, _keys2.default)(_updateTree).forEach(function(key) {
                if (key === "default" || key === "__esModule") return;
                (0, _defineProperty2.default)(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _updateTree[key]
                    }
                })
            })
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);

            function __addEvent(elem, events, handler) {
                var _this = this;
                if (!elem || typeof elem.addEventListener !== "function") throw new TypeError("expect elem to be a DOM element, but got " +
                    elem);
                var fn = function fn(evt) {
                    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                    if (!evt.type.match(/drag/) && evt.defaultPrevented) return;
                    handler.apply(undefined, [evt].concat(args))
                };
                events.split(/\s+/g).forEach(function(evt) {
                    _this.__handlers.push({
                        evt: evt,
                        elem: elem,
                        fn: fn,
                        hasRegistered: true
                    });
                    elem.addEventListener(evt, fn)
                })
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__addEvent", {
                value: __addEvent,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);

            function __eventFromChildScrollbar() {
                var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
                var target = _ref.target;
                return this.children.some(function(sb) {
                    return sb.contains(target)
                })
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__eventFromChildScrollbar", {
                value: __eventFromChildScrollbar,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar =
                __webpack_require__(78);

            function __getDeltaLimit() {
                var noOverscroll = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
                var options = this.options;
                var offset = this.offset;
                var limit = this.limit;
                if (!noOverscroll && (options.continuousScrolling || options.overscrollEffect)) return {
                    x: [-Infinity, Infinity],
                    y: [-Infinity, Infinity]
                };
                return {
                    x: [-offset.x, limit.x - offset.x],
                    y: [-offset.y, limit.y - offset.y]
                }
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__getDeltaLimit", {
                value: __getDeltaLimit,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);
            var _utils = __webpack_require__(112);

            function __getPointerTrend(evt) {
                var padding = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
                var _bounding = this.bounding;
                var top = _bounding.top;
                var right = _bounding.right;
                var bottom = _bounding.bottom;
                var left = _bounding.left;
                var _getPosition = (0, _utils.getPosition)(evt);
                var x = _getPosition.x;
                var y = _getPosition.y;
                var res = {
                    x: 0,
                    y: 0
                };
                if (x ===
                    0 && y === 0) return res;
                if (x > right - padding) res.x = x - right + padding;
                else if (x < left + padding) res.x = x - left - padding;
                if (y > bottom - padding) res.y = y - bottom + padding;
                else if (y < top + padding) res.y = y - top - padding;
                return res
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__getPointerTrend", {
                value: __getPointerTrend,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            var _keys =
                __webpack_require__(90);
            var _keys2 = _interopRequireDefault(_keys);
            var _stringify = __webpack_require__(180);
            var _stringify2 = _interopRequireDefault(_stringify);
            var _from = __webpack_require__(2);
            var _from2 = _interopRequireDefault(_from);
            var _iterator = __webpack_require__(55);
            var _iterator2 = _interopRequireDefault(_iterator);
            var _symbol = __webpack_require__(62);
            var _symbol2 = _interopRequireDefault(_symbol);
            var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function(obj) {
                    return typeof obj
                } :
                function(obj) {
                    return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj
                };

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _utils = __webpack_require__(112);
            var _smoothScrollbar = __webpack_require__(78);

            function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                    return arr2
                } else return (0, _from2.default)(arr)
            }

            function __initOptions(userPreference) {
                var scrollbar =
                    this;
                var options = {
                    speed: 1,
                    damping: .1,
                    thumbMinSize: 20,
                    syncCallbacks: false,
                    renderByPixels: true,
                    alwaysShowTracks: false,
                    continuousScrolling: "auto",
                    overscrollEffect: false,
                    overscrollEffectColor: "#87ceeb",
                    paddingTop: 0,
                    shouldHandleEvent: null,
                    overscrollDamping: .2
                };
                var limit = {
                    damping: [0, 1],
                    speed: [0, Infinity],
                    thumbMinSize: [0, Infinity],
                    overscrollEffect: [false, "bounce", "glow"],
                    overscrollDamping: [0, 1]
                };
                var isContinous = function isContinous() {
                    var mode = arguments.length <= 0 || arguments[0] === undefined ? "auto" : arguments[0];
                    if (options.overscrollEffect !== false) return false;
                    switch (mode) {
                        case "auto":
                            return scrollbar.isNestedScrollbar;
                        default:
                            return !!mode
                    }
                };
                var optionAccessors = {set ignoreEvents(v) {
                        console.warn("`options.ignoreEvents` parameter is deprecated, use `instance#unregisterEvents()` method instead. https://github.com/idiotWu/smooth-scrollbar/wiki/Instance-Methods#instanceunregisterevents-regex--regex-regex--")
                    },
                    set friction(v) {
                        console.warn("`options.friction=" + v + "` is deprecated, use `options.damping=" + v / 100 + "` instead.");
                        this.damping = v / 100
                    },
                    get syncCallbacks() {
                        return options.syncCallbacks
                    },
                    set syncCallbacks(v) {
                        options.syncCallbacks = !!v
                    },
                    get renderByPixels() {
                        return options.renderByPixels
                    },
                    set renderByPixels(v) {
                        options.renderByPixels = !!v
                    },
                    get paddingTop() {
                        return options.paddingTop
                    },
                    set paddingTop(v) {
                        options.paddingTop = v
                    },
                    get shouldHandleEvent() {
                        return options.shouldHandleEvent
                    },
                    set shouldHandleEvent(v) {
                        options.shouldHandleEvent = v
                    },
                    get alwaysShowTracks() {
                        return options.alwaysShowTracks
                    },
                    set alwaysShowTracks(v) {
                        v = !!v;
                        options.alwaysShowTracks = v;
                        var container = scrollbar.targets.container;
                        if (v) {
                            scrollbar.showTrack();
                            container.classList.add("sticky")
                        } else {
                            scrollbar.hideTrack();
                            container.classList.remove("sticky")
                        }
                    },
                    get continuousScrolling() {
                        return isContinous(options.continuousScrolling)
                    },
                    set continuousScrolling(v) {
                        if (v === "auto") options.continuousScrolling = v;
                        else options.continuousScrolling = !!v
                    },
                    get overscrollEffect() {
                        return options.overscrollEffect
                    },
                    set overscrollEffect(v) {
                        if (v && !~limit.overscrollEffect.indexOf(v)) {
                            console.warn("`overscrollEffect` should be one of " +
                                (0, _stringify2.default)(limit.overscrollEffect) + ", but got " + (0, _stringify2.default)(v) + ". It will be set to `false` now.");
                            v = false
                        }
                        options.overscrollEffect = v
                    },
                    get overscrollEffectColor() {
                        return options.overscrollEffectColor
                    },
                    set overscrollEffectColor(v) {
                        options.overscrollEffectColor = v
                    }
                };
                (0, _keys2.default)(options).filter(function(prop) {
                    return !optionAccessors.hasOwnProperty(prop)
                }).forEach(function(prop) {
                    (0, _defineProperty2.default)(optionAccessors, prop, {
                        enumerable: true,
                        get: function get() {
                            return options[prop]
                        },
                        set: function set(v) {
                            if (isNaN(parseFloat(v))) throw new TypeError("expect `options." + prop + "` to be a number, but got " + (typeof v === "undefined" ? "undefined" : _typeof(v)));
                            options[prop] = _utils.pickInRange.apply(undefined, [v].concat(_toConsumableArray(limit[prop])))
                        }
                    })
                });
                this.__readonly("options", optionAccessors);
                this.setOptions(userPreference)
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__initOptions", {
                value: __initOptions,
                writable: true,
                configurable: true
            })
        },
        function(module, exports,
            __webpack_require__) {
            module.exports = {
                "default": __webpack_require__(181),
                __esModule: true
            }
        },
        function(module, exports, __webpack_require__) {
            var core = __webpack_require__(12),
                $JSON = core.JSON || (core.JSON = {
                    stringify: JSON.stringify
                });
            module.exports = function stringify(it) {
                return $JSON.stringify.apply($JSON, arguments)
            }
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);

            function __initScrollbar() {
                this.update();
                this.__keyboardHandler();
                this.__resizeHandler();
                this.__selectHandler();
                this.__mouseHandler();
                this.__touchHandler();
                this.__wheelHandler();
                this.__dragHandler();
                this.__render()
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__initScrollbar", {
                value: __initScrollbar,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _defineProperty = __webpack_require__(86);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _smoothScrollbar = __webpack_require__(78);

            function __readonly(prop, value) {
                return (0, _defineProperty2.default)(this, prop, {
                    value: value,
                    enumerable: true,
                    configurable: true
                })
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__readonly", {
                value: __readonly,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _utils = __webpack_require__(112);
            var _smoothScrollbar = __webpack_require__(78);

            function __setThumbPosition() {
                var targets = this.targets;
                var size = this.size;
                var offset = this.offset;
                var thumbOffset = this.thumbOffset;
                var thumbSize = this.thumbSize;
                thumbOffset.x = offset.x / size.content.width * (size.container.width - (thumbSize.x - thumbSize.realX));
                thumbOffset.y = offset.y / size.content.height * (size.container.height - (thumbSize.y - thumbSize.realY));
                (0, _utils.setStyle)(targets.xAxis.thumb, {
                    "-transform": "translate3d(" + thumbOffset.x + "px, 0, 0)"
                });
                (0, _utils.setStyle)(targets.yAxis.thumb, {
                    "-transform": "translate3d(0, " + thumbOffset.y + "px, 0)"
                })
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__setThumbPosition", {
                value: __setThumbPosition,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _smoothScrollbar = __webpack_require__(78);

            function __updateBounding() {
                var container = this.targets.container;
                var _container$getBoundin = container.getBoundingClientRect();
                var top = _container$getBoundin.top;
                var right = _container$getBoundin.right;
                var bottom = _container$getBoundin.bottom;
                var left = _container$getBoundin.left;
                var _window = window;
                var innerHeight = _window.innerHeight;
                var innerWidth = _window.innerWidth;
                this.__readonly("bounding", {
                    top: Math.max(top, 0),
                    right: Math.min(right, innerWidth),
                    bottom: Math.min(bottom, innerHeight),
                    left: Math.max(left, 0)
                })
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__updateBounding", {
                value: __updateBounding,
                writable: true,
                configurable: true
            })
        },
        function(module, exports, __webpack_require__) {
            var _from = __webpack_require__(2);
            var _from2 = _interopRequireDefault(_from);

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }
            var _smoothScrollbar =
                __webpack_require__(78);
            var _shared = __webpack_require__(89);

            function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                    return arr2
                } else return (0, _from2.default)(arr)
            }

            function __updateTree() {
                var _targets = this.targets;
                var container = _targets.container;
                var content = _targets.content;
                this.__readonly("children", [].concat(_toConsumableArray(content.querySelectorAll(_shared.selectors))));
                this.__readonly("isNestedScrollbar", false);
                var parents = [];
                var elem = container;
                while (elem = elem.parentElement)
                    if (_shared.sbList.has(elem)) {
                        this.__readonly("isNestedScrollbar", true);
                        parents.push(elem)
                    }
                this.__readonly("parents", parents)
            }
            Object.defineProperty(_smoothScrollbar.SmoothScrollbar.prototype, "__updateTree", {
                value: __updateTree,
                writable: true,
                configurable: true
            })
        },
        function(module, exports) {}
    ])
});
(function(factory) {
    if (typeof define === "function" && define.amd) define(["jquery"], factory);
    else factory(jQuery)
})(function($) {
    $.ui = $.ui || {};
    var version = $.ui.version = "1.12.1";
    var widgetUuid = 0;
    var widgetSlice = Array.prototype.slice;
    $.cleanData = function(orig) {
        return function(elems) {
            var events, elem, i;
            for (i = 0;
                (elem = elems[i]) != null; i++) try {
                events = $._data(elem, "events");
                if (events && events.remove) $(elem).triggerHandler("remove")
            } catch (e) {}
            orig(elems)
        }
    }($.cleanData);
    $.widget = function(name, base, prototype) {
        var existingConstructor,
            constructor, basePrototype;
        var proxiedPrototype = {};
        var namespace = name.split(".")[0];
        name = name.split(".")[1];
        var fullName = namespace + "-" + name;
        if (!prototype) {
            prototype = base;
            base = $.Widget
        }
        if ($.isArray(prototype)) prototype = $.extend.apply(null, [{}].concat(prototype));
        $.expr[":"][fullName.toLowerCase()] = function(elem) {
            return !!$.data(elem, fullName)
        };
        $[namespace] = $[namespace] || {};
        existingConstructor = $[namespace][name];
        constructor = $[namespace][name] = function(options, element) {
            if (!this._createWidget) return new constructor(options,
                element);
            if (arguments.length) this._createWidget(options, element)
        };
        $.extend(constructor, existingConstructor, {
            version: prototype.version,
            _proto: $.extend({}, prototype),
            _childConstructors: []
        });
        basePrototype = new base;
        basePrototype.options = $.widget.extend({}, basePrototype.options);
        $.each(prototype, function(prop, value) {
            if (!$.isFunction(value)) {
                proxiedPrototype[prop] = value;
                return
            }
            proxiedPrototype[prop] = function() {
                function _super() {
                    return base.prototype[prop].apply(this, arguments)
                }

                function _superApply(args) {
                    return base.prototype[prop].apply(this,
                        args)
                }
                return function() {
                    var __super = this._super;
                    var __superApply = this._superApply;
                    var returnValue;
                    this._super = _super;
                    this._superApply = _superApply;
                    returnValue = value.apply(this, arguments);
                    this._super = __super;
                    this._superApply = __superApply;
                    return returnValue
                }
            }()
        });
        constructor.prototype = $.widget.extend(basePrototype, {
            widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name
        }, proxiedPrototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            widgetFullName: fullName
        });
        if (existingConstructor) {
            $.each(existingConstructor._childConstructors,
                function(i, child) {
                    var childPrototype = child.prototype;
                    $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto)
                });
            delete existingConstructor._childConstructors
        } else base._childConstructors.push(constructor);
        $.widget.bridge(name, constructor);
        return constructor
    };
    $.widget.extend = function(target) {
        var input = widgetSlice.call(arguments, 1);
        var inputIndex = 0;
        var inputLength = input.length;
        var key;
        var value;
        for (; inputIndex < inputLength; inputIndex++)
            for (key in input[inputIndex]) {
                value =
                    input[inputIndex][key];
                if (input[inputIndex].hasOwnProperty(key) && value !== undefined)
                    if ($.isPlainObject(value)) target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value);
                    else target[key] = value
            }
        return target
    };
    $.widget.bridge = function(name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function(options) {
            var isMethodCall = typeof options === "string";
            var args = widgetSlice.call(arguments, 1);
            var returnValue = this;
            if (isMethodCall)
                if (!this.length &&
                    options === "instance") returnValue = undefined;
                else this.each(function() {
                    var methodValue;
                    var instance = $.data(this, fullName);
                    if (options === "instance") {
                        returnValue = instance;
                        return false
                    }
                    if (!instance) return $.error("cannot call methods on " + name + " prior to initialization; " + "attempted to call method '" + options + "'");
                    if (!$.isFunction(instance[options]) || options.charAt(0) === "_") return $.error("no such method '" + options + "' for " + name + " widget instance");
                    methodValue = instance[options].apply(instance, args);
                    if (methodValue !==
                        instance && methodValue !== undefined) {
                        returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
                        return false
                    }
                });
            else {
                if (args.length) options = $.widget.extend.apply(null, [options].concat(args));
                this.each(function() {
                    var instance = $.data(this, fullName);
                    if (instance) {
                        instance.option(options || {});
                        if (instance._init) instance._init()
                    } else $.data(this, fullName, new object(options, this))
                })
            }
            return returnValue
        }
    };
    $.Widget = function() {};
    $.Widget._childConstructors = [];
    $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            classes: {},
            disabled: false,
            create: null
        },
        _createWidget: function(options, element) {
            element = $(element || this.defaultElement || this)[0];
            this.element = $(element);
            this.uuid = widgetUuid++;
            this.eventNamespace = "." + this.widgetName + this.uuid;
            this.bindings = $();
            this.hoverable = $();
            this.focusable = $();
            this.classesElementLookup = {};
            if (element !== this) {
                $.data(element, this.widgetFullName, this);
                this._on(true, this.element, {
                    remove: function(event) {
                        if (event.target ===
                            element) this.destroy()
                    }
                });
                this.document = $(element.style ? element.ownerDocument : element.document || element);
                this.window = $(this.document[0].defaultView || this.document[0].parentWindow)
            }
            this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);
            this._create();
            if (this.options.disabled) this._setOptionDisabled(this.options.disabled);
            this._trigger("create", null, this._getCreateEventData());
            this._init()
        },
        _getCreateOptions: function() {
            return {}
        },
        _getCreateEventData: $.noop,
        _create: $.noop,
        _init: $.noop,
        destroy: function() {
            var that = this;
            this._destroy();
            $.each(this.classesElementLookup, function(key, value) {
                that._removeClass(value, key)
            });
            this.element.off(this.eventNamespace).removeData(this.widgetFullName);
            this.widget().off(this.eventNamespace).removeAttr("aria-disabled");
            this.bindings.off(this.eventNamespace)
        },
        _destroy: $.noop,
        widget: function() {
            return this.element
        },
        option: function(key, value) {
            var options = key;
            var parts;
            var curOption;
            var i;
            if (arguments.length === 0) return $.widget.extend({}, this.options);
            if (typeof key === "string") {
                options = {};
                parts = key.split(".");
                key = parts.shift();
                if (parts.length) {
                    curOption = options[key] = $.widget.extend({}, this.options[key]);
                    for (i = 0; i < parts.length - 1; i++) {
                        curOption[parts[i]] = curOption[parts[i]] || {};
                        curOption = curOption[parts[i]]
                    }
                    key = parts.pop();
                    if (arguments.length === 1) return curOption[key] === undefined ? null : curOption[key];
                    curOption[key] = value
                } else {
                    if (arguments.length === 1) return this.options[key] === undefined ? null : this.options[key];
                    options[key] = value
                }
            }
            this._setOptions(options);
            return this
        },
        _setOptions: function(options) {
            var key;
            for (key in options) this._setOption(key, options[key]);
            return this
        },
        _setOption: function(key, value) {
            if (key === "classes") this._setOptionClasses(value);
            this.options[key] = value;
            if (key === "disabled") this._setOptionDisabled(value);
            return this
        },
        _setOptionClasses: function(value) {
            var classKey, elements, currentElements;
            for (classKey in value) {
                currentElements = this.classesElementLookup[classKey];
                if (value[classKey] === this.options.classes[classKey] || !currentElements ||
                    !currentElements.length) continue;
                elements = $(currentElements.get());
                this._removeClass(currentElements, classKey);
                elements.addClass(this._classes({
                    element: elements,
                    keys: classKey,
                    classes: value,
                    add: true
                }))
            }
        },
        _setOptionDisabled: function(value) {
            this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!value);
            if (value) {
                this._removeClass(this.hoverable, null, "ui-state-hover");
                this._removeClass(this.focusable, null, "ui-state-focus")
            }
        },
        enable: function() {
            return this._setOptions({
                disabled: false
            })
        },
        disable: function() {
            return this._setOptions({
                disabled: true
            })
        },
        _classes: function(options) {
            var full = [];
            var that = this;
            options = $.extend({
                element: this.element,
                classes: this.options.classes || {}
            }, options);

            function processClassString(classes, checkOption) {
                var current, i;
                for (i = 0; i < classes.length; i++) {
                    current = that.classesElementLookup[classes[i]] || $();
                    if (options.add) current = $($.unique(current.get().concat(options.element.get())));
                    else current = $(current.not(options.element).get());
                    that.classesElementLookup[classes[i]] =
                        current;
                    full.push(classes[i]);
                    if (checkOption && options.classes[classes[i]]) full.push(options.classes[classes[i]])
                }
            }
            this._on(options.element, {
                "remove": "_untrackClassesElement"
            });
            if (options.keys) processClassString(options.keys.match(/\S+/g) || [], true);
            if (options.extra) processClassString(options.extra.match(/\S+/g) || []);
            return full.join(" ")
        },
        _untrackClassesElement: function(event) {
            var that = this;
            $.each(that.classesElementLookup, function(key, value) {
                if ($.inArray(event.target, value) !== -1) that.classesElementLookup[key] =
                    $(value.not(event.target).get())
            })
        },
        _removeClass: function(element, keys, extra) {
            return this._toggleClass(element, keys, extra, false)
        },
        _addClass: function(element, keys, extra) {
            return this._toggleClass(element, keys, extra, true)
        },
        _toggleClass: function(element, keys, extra, add) {
            add = typeof add === "boolean" ? add : extra;
            var shift = typeof element === "string" || element === null,
                options = {
                    extra: shift ? keys : extra,
                    keys: shift ? element : keys,
                    element: shift ? this.element : element,
                    add: add
                };
            options.element.toggleClass(this._classes(options),
                add);
            return this
        },
        _on: function(suppressDisabledCheck, element, handlers) {
            var delegateElement;
            var instance = this;
            if (typeof suppressDisabledCheck !== "boolean") {
                handlers = element;
                element = suppressDisabledCheck;
                suppressDisabledCheck = false
            }
            if (!handlers) {
                handlers = element;
                element = this.element;
                delegateElement = this.widget()
            } else {
                element = delegateElement = $(element);
                this.bindings = this.bindings.add(element)
            }
            $.each(handlers, function(event, handler) {
                function handlerProxy() {
                    if (!suppressDisabledCheck && (instance.options.disabled ===
                            true || $(this).hasClass("ui-state-disabled"))) return;
                    return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments)
                }
                if (typeof handler !== "string") handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
                var match = event.match(/^([\w:-]*)\s*(.*)$/);
                var eventName = match[1] + instance.eventNamespace;
                var selector = match[2];
                if (selector) delegateElement.on(eventName, selector, handlerProxy);
                else element.on(eventName, handlerProxy)
            })
        },
        _off: function(element, eventName) {
            eventName =
                (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
            element.off(eventName).off(eventName);
            this.bindings = $(this.bindings.not(element).get());
            this.focusable = $(this.focusable.not(element).get());
            this.hoverable = $(this.hoverable.not(element).get())
        },
        _delay: function(handler, delay) {
            function handlerProxy() {
                return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments)
            }
            var instance = this;
            return setTimeout(handlerProxy, delay || 0)
        },
        _hoverable: function(element) {
            this.hoverable =
                this.hoverable.add(element);
            this._on(element, {
                mouseenter: function(event) {
                    this._addClass($(event.currentTarget), null, "ui-state-hover")
                },
                mouseleave: function(event) {
                    this._removeClass($(event.currentTarget), null, "ui-state-hover")
                }
            })
        },
        _focusable: function(element) {
            this.focusable = this.focusable.add(element);
            this._on(element, {
                focusin: function(event) {
                    this._addClass($(event.currentTarget), null, "ui-state-focus")
                },
                focusout: function(event) {
                    this._removeClass($(event.currentTarget), null, "ui-state-focus")
                }
            })
        },
        _trigger: function(type,
            event, data) {
            var prop, orig;
            var callback = this.options[type];
            data = data || {};
            event = $.Event(event);
            event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();
            event.target = this.element[0];
            orig = event.originalEvent;
            if (orig)
                for (prop in orig)
                    if (!(prop in event)) event[prop] = orig[prop];
            this.element.trigger(event, data);
            return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented())
        }
    };
    $.each({
        show: "fadeIn",
        hide: "fadeOut"
    }, function(method,
        defaultEffect) {
        $.Widget.prototype["_" + method] = function(element, options, callback) {
            if (typeof options === "string") options = {
                effect: options
            };
            var hasOptions;
            var effectName = !options ? method : options === true || typeof options === "number" ? defaultEffect : options.effect || defaultEffect;
            options = options || {};
            if (typeof options === "number") options = {
                duration: options
            };
            hasOptions = !$.isEmptyObject(options);
            options.complete = callback;
            if (options.delay) element.delay(options.delay);
            if (hasOptions && $.effects && $.effects.effect[effectName]) element[method](options);
            else if (effectName !== method && element[effectName]) element[effectName](options.duration, options.easing, callback);
            else element.queue(function(next) {
                $(this)[method]();
                if (callback) callback.call(element[0]);
                next()
            })
        }
    });
    var widget = $.widget;
    (function() {
        var cachedScrollbarWidth, max = Math.max,
            abs = Math.abs,
            rhorizontal = /left|center|right/,
            rvertical = /top|center|bottom/,
            roffset = /[\+\-]\d+(\.[\d]+)?%?/,
            rposition = /^\w+/,
            rpercent = /%$/,
            _position = $.fn.position;

        function getOffsets(offsets, width, height) {
            return [parseFloat(offsets[0]) *
                (rpercent.test(offsets[0]) ? width / 100 : 1), parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)
            ]
        }

        function parseCss(element, property) {
            return parseInt($.css(element, property), 10) || 0
        }

        function getDimensions(elem) {
            var raw = elem[0];
            if (raw.nodeType === 9) return {
                width: elem.width(),
                height: elem.height(),
                offset: {
                    top: 0,
                    left: 0
                }
            };
            if ($.isWindow(raw)) return {
                width: elem.width(),
                height: elem.height(),
                offset: {
                    top: elem.scrollTop(),
                    left: elem.scrollLeft()
                }
            };
            if (raw.preventDefault) return {
                width: 0,
                height: 0,
                offset: {
                    top: raw.pageY,
                    left: raw.pageX
                }
            };
            return {
                width: elem.outerWidth(),
                height: elem.outerHeight(),
                offset: elem.offset()
            }
        }
        $.position = {
            scrollbarWidth: function() {
                if (cachedScrollbarWidth !== undefined) return cachedScrollbarWidth;
                var w1, w2, div = $("<div " + "style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>" + "<div style='height:100px;width:auto;'></div></div>"),
                    innerDiv = div.children()[0];
                $("body").append(div);
                w1 = innerDiv.offsetWidth;
                div.css("overflow", "scroll");
                w2 = innerDiv.offsetWidth;
                if (w1 === w2) w2 = div[0].clientWidth;
                div.remove();
                return cachedScrollbarWidth = w1 - w2
            },
            getScrollInfo: function(within) {
                var overflowX = within.isWindow || within.isDocument ? "" : within.element.css("overflow-x"),
                    overflowY = within.isWindow || within.isDocument ? "" : within.element.css("overflow-y"),
                    hasOverflowX = overflowX === "scroll" || overflowX === "auto" && within.width < within.element[0].scrollWidth,
                    hasOverflowY = overflowY === "scroll" || overflowY === "auto" && within.height < within.element[0].scrollHeight;
                return {
                    width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                    height: hasOverflowX ?
                        $.position.scrollbarWidth() : 0
                }
            },
            getWithinInfo: function(element) {
                var withinElement = $(element || window),
                    isWindow = $.isWindow(withinElement[0]),
                    isDocument = !!withinElement[0] && withinElement[0].nodeType === 9,
                    hasOffset = !isWindow && !isDocument;
                return {
                    element: withinElement,
                    isWindow: isWindow,
                    isDocument: isDocument,
                    offset: hasOffset ? $(element).offset() : {
                        left: 0,
                        top: 0
                    },
                    scrollLeft: withinElement.scrollLeft(),
                    scrollTop: withinElement.scrollTop(),
                    width: withinElement.outerWidth(),
                    height: withinElement.outerHeight()
                }
            }
        };
        $.fn.position =
            function(options) {
                if (!options || !options.of) return _position.apply(this, arguments);
                options = $.extend({}, options);
                var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions, target = $(options.of),
                    within = $.position.getWithinInfo(options.within),
                    scrollInfo = $.position.getScrollInfo(within),
                    collision = (options.collision || "flip").split(" "),
                    offsets = {};
                dimensions = getDimensions(target);
                if (target[0].preventDefault) options.at = "left top";
                targetWidth = dimensions.width;
                targetHeight = dimensions.height;
                targetOffset = dimensions.offset;
                basePosition = $.extend({}, targetOffset);
                $.each(["my", "at"], function() {
                    var pos = (options[this] || "").split(" "),
                        horizontalOffset, verticalOffset;
                    if (pos.length === 1) pos = rhorizontal.test(pos[0]) ? pos.concat(["center"]) : rvertical.test(pos[0]) ? ["center"].concat(pos) : ["center", "center"];
                    pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
                    pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";
                    horizontalOffset = roffset.exec(pos[0]);
                    verticalOffset = roffset.exec(pos[1]);
                    offsets[this] = [horizontalOffset ?
                        horizontalOffset[0] : 0, verticalOffset ? verticalOffset[0] : 0
                    ];
                    options[this] = [rposition.exec(pos[0])[0], rposition.exec(pos[1])[0]]
                });
                if (collision.length === 1) collision[1] = collision[0];
                if (options.at[0] === "right") basePosition.left += targetWidth;
                else if (options.at[0] === "center") basePosition.left += targetWidth / 2;
                if (options.at[1] === "bottom") basePosition.top += targetHeight;
                else if (options.at[1] === "center") basePosition.top += targetHeight / 2;
                atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
                basePosition.left +=
                    atOffset[0];
                basePosition.top += atOffset[1];
                return this.each(function() {
                    var collisionPosition, using, elem = $(this),
                        elemWidth = elem.outerWidth(),
                        elemHeight = elem.outerHeight(),
                        marginLeft = parseCss(this, "marginLeft"),
                        marginTop = parseCss(this, "marginTop"),
                        collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width,
                        collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height,
                        position = $.extend({}, basePosition),
                        myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());
                    if (options.my[0] === "right") position.left -= elemWidth;
                    else if (options.my[0] === "center") position.left -= elemWidth / 2;
                    if (options.my[1] === "bottom") position.top -= elemHeight;
                    else if (options.my[1] === "center") position.top -= elemHeight / 2;
                    position.left += myOffset[0];
                    position.top += myOffset[1];
                    collisionPosition = {
                        marginLeft: marginLeft,
                        marginTop: marginTop
                    };
                    $.each(["left", "top"], function(i, dir) {
                        if ($.ui.position[collision[i]]) $.ui.position[collision[i]][dir](position, {
                            targetWidth: targetWidth,
                            targetHeight: targetHeight,
                            elemWidth: elemWidth,
                            elemHeight: elemHeight,
                            collisionPosition: collisionPosition,
                            collisionWidth: collisionWidth,
                            collisionHeight: collisionHeight,
                            offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],
                            my: options.my,
                            at: options.at,
                            within: within,
                            elem: elem
                        })
                    });
                    if (options.using) using = function(props) {
                        var left = targetOffset.left - position.left,
                            right = left + targetWidth - elemWidth,
                            top = targetOffset.top - position.top,
                            bottom = top + targetHeight - elemHeight,
                            feedback = {
                                target: {
                                    element: target,
                                    left: targetOffset.left,
                                    top: targetOffset.top,
                                    width: targetWidth,
                                    height: targetHeight
                                },
                                element: {
                                    element: elem,
                                    left: position.left,
                                    top: position.top,
                                    width: elemWidth,
                                    height: elemHeight
                                },
                                horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                                vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                            };
                        if (targetWidth < elemWidth && abs(left + right) < targetWidth) feedback.horizontal = "center";
                        if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) feedback.vertical = "middle";
                        if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) feedback.important = "horizontal";
                        else feedback.important =
                            "vertical";
                        options.using.call(this, props, feedback)
                    };
                    elem.offset($.extend(position, {
                        using: using
                    }))
                })
            };
        $.ui.position = {
            fit: {
                left: function(position, data) {
                    var within = data.within,
                        withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                        outerWidth = within.width,
                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                        overLeft = withinOffset - collisionPosLeft,
                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                        newOverRight;
                    if (data.collisionWidth > outerWidth)
                        if (overLeft > 0 && overRight <=
                            0) {
                            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                            position.left += overLeft - newOverRight
                        } else if (overRight > 0 && overLeft <= 0) position.left = withinOffset;
                    else if (overLeft > overRight) position.left = withinOffset + outerWidth - data.collisionWidth;
                    else position.left = withinOffset;
                    else if (overLeft > 0) position.left += overLeft;
                    else if (overRight > 0) position.left -= overRight;
                    else position.left = max(position.left - collisionPosLeft, position.left)
                },
                top: function(position, data) {
                    var within = data.within,
                        withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                        outerHeight = data.within.height,
                        collisionPosTop = position.top - data.collisionPosition.marginTop,
                        overTop = withinOffset - collisionPosTop,
                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                        newOverBottom;
                    if (data.collisionHeight > outerHeight)
                        if (overTop > 0 && overBottom <= 0) {
                            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                            position.top += overTop - newOverBottom
                        } else if (overBottom > 0 && overTop <= 0) position.top =
                        withinOffset;
                    else if (overTop > overBottom) position.top = withinOffset + outerHeight - data.collisionHeight;
                    else position.top = withinOffset;
                    else if (overTop > 0) position.top += overTop;
                    else if (overBottom > 0) position.top -= overBottom;
                    else position.top = max(position.top - collisionPosTop, position.top)
                }
            },
            flip: {
                left: function(position, data) {
                    var within = data.within,
                        withinOffset = within.offset.left + within.scrollLeft,
                        outerWidth = within.width,
                        offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                        collisionPosLeft = position.left -
                        data.collisionPosition.marginLeft,
                        overLeft = collisionPosLeft - offsetLeft,
                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                        myOffset = data.my[0] === "left" ? -data.elemWidth : data.my[0] === "right" ? data.elemWidth : 0,
                        atOffset = data.at[0] === "left" ? data.targetWidth : data.at[0] === "right" ? -data.targetWidth : 0,
                        offset = -2 * data.offset[0],
                        newOverRight, newOverLeft;
                    if (overLeft < 0) {
                        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
                        if (newOverRight < 0 || newOverRight <
                            abs(overLeft)) position.left += myOffset + atOffset + offset
                    } else if (overRight > 0) {
                        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
                        if (newOverLeft > 0 || abs(newOverLeft) < overRight) position.left += myOffset + atOffset + offset
                    }
                },
                top: function(position, data) {
                    var within = data.within,
                        withinOffset = within.offset.top + within.scrollTop,
                        outerHeight = within.height,
                        offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                        collisionPosTop = position.top - data.collisionPosition.marginTop,
                        overTop = collisionPosTop - offsetTop,
                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                        top = data.my[1] === "top",
                        myOffset = top ? -data.elemHeight : data.my[1] === "bottom" ? data.elemHeight : 0,
                        atOffset = data.at[1] === "top" ? data.targetHeight : data.at[1] === "bottom" ? -data.targetHeight : 0,
                        offset = -2 * data.offset[1],
                        newOverTop, newOverBottom;
                    if (overTop < 0) {
                        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                        if (newOverBottom < 0 || newOverBottom < abs(overTop)) position.top +=
                            myOffset + atOffset + offset
                    } else if (overBottom > 0) {
                        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                        if (newOverTop > 0 || abs(newOverTop) < overBottom) position.top += myOffset + atOffset + offset
                    }
                }
            },
            flipfit: {
                left: function() {
                    $.ui.position.flip.left.apply(this, arguments);
                    $.ui.position.fit.left.apply(this, arguments)
                },
                top: function() {
                    $.ui.position.flip.top.apply(this, arguments);
                    $.ui.position.fit.top.apply(this, arguments)
                }
            }
        }
    })();
    var position = $.ui.position;
    var data = $.extend($.expr[":"], {
        data: $.expr.createPseudo ? $.expr.createPseudo(function(dataName) {
            return function(elem) {
                return !!$.data(elem, dataName)
            }
        }) : function(elem, i, match) {
            return !!$.data(elem, match[3])
        }
    });
    var disableSelection = $.fn.extend({
        disableSelection: function() {
            var eventType = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown";
            return function() {
                return this.on(eventType + ".ui-disableSelection", function(event) {
                    event.preventDefault()
                })
            }
        }(),
        enableSelection: function() {
            return this.off(".ui-disableSelection")
        }
    });
    $.ui.focusable = function(element, hasTabindex) {
        var map, mapName, img, focusableIfVisible, fieldset, nodeName = element.nodeName.toLowerCase();
        if ("area" === nodeName) {
            map = element.parentNode;
            mapName = map.name;
            if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") return false;
            img = $("img[usemap='#" + mapName + "']");
            return img.length > 0 && img.is(":visible")
        }
        if (/^(input|select|textarea|button|object)$/.test(nodeName)) {
            focusableIfVisible = !element.disabled;
            if (focusableIfVisible) {
                fieldset = $(element).closest("fieldset")[0];
                if (fieldset) focusableIfVisible = !fieldset.disabled
            }
        } else if ("a" === nodeName) focusableIfVisible = element.href || hasTabindex;
        else focusableIfVisible = hasTabindex;
        return focusableIfVisible && $(element).is(":visible") && visible($(element))
    };

    function visible(element) {
        var visibility = element.css("visibility");
        while (visibility === "inherit") {
            element = element.parent();
            visibility = element.css("visibility")
        }
        return visibility !== "hidden"
    }
    $.extend($.expr[":"], {
        focusable: function(element) {
            return $.ui.focusable(element, $.attr(element,
                "tabindex") != null)
        }
    });
    var focusable = $.ui.focusable;
    var form = $.fn.form = function() {
        return typeof this[0].form === "string" ? this.closest("form") : $(this[0].form)
    };
    var formResetMixin = $.ui.formResetMixin = {
        _formResetHandler: function() {
            var form = $(this);
            setTimeout(function() {
                var instances = form.data("ui-form-reset-instances");
                $.each(instances, function() {
                    this.refresh()
                })
            })
        },
        _bindFormResetHandler: function() {
            this.form = this.element.form();
            if (!this.form.length) return;
            var instances = this.form.data("ui-form-reset-instances") || [];
            if (!instances.length) this.form.on("reset.ui-form-reset", this._formResetHandler);
            instances.push(this);
            this.form.data("ui-form-reset-instances", instances)
        },
        _unbindFormResetHandler: function() {
            if (!this.form.length) return;
            var instances = this.form.data("ui-form-reset-instances");
            instances.splice($.inArray(this, instances), 1);
            if (instances.length) this.form.data("ui-form-reset-instances", instances);
            else this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset")
        }
    };
    if ($.fn.jquery.substring(0,
            3) === "1.7") {
        $.each(["Width", "Height"], function(i, name) {
            var side = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
                type = name.toLowerCase(),
                orig = {
                    innerWidth: $.fn.innerWidth,
                    innerHeight: $.fn.innerHeight,
                    outerWidth: $.fn.outerWidth,
                    outerHeight: $.fn.outerHeight
                };

            function reduce(elem, size, border, margin) {
                $.each(side, function() {
                    size -= parseFloat($.css(elem, "padding" + this)) || 0;
                    if (border) size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
                    if (margin) size -= parseFloat($.css(elem, "margin" + this)) || 0
                });
                return size
            }
            $.fn["inner" + name] = function(size) {
                if (size === undefined) return orig["inner" + name].call(this);
                return this.each(function() {
                    $(this).css(type, reduce(this, size) + "px")
                })
            };
            $.fn["outer" + name] = function(size, margin) {
                if (typeof size !== "number") return orig["outer" + name].call(this, size);
                return this.each(function() {
                    $(this).css(type, reduce(this, size, true, margin) + "px")
                })
            }
        });
        $.fn.addBack = function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector))
        }
    }
    var keycode = $.ui.keyCode = {
        BACKSPACE: 8,
        COMMA: 188,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        HOME: 36,
        LEFT: 37,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        PERIOD: 190,
        RIGHT: 39,
        SPACE: 32,
        TAB: 9,
        UP: 38
    };
    var escapeSelector = $.ui.escapeSelector = function() {
        var selectorEscape = /([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g;
        return function(selector) {
            return selector.replace(selectorEscape, "\\$1")
        }
    }();
    var labels = $.fn.labels = function() {
        var ancestor, selector, id, labels, ancestors;
        if (this[0].labels && this[0].labels.length) return this.pushStack(this[0].labels);
        labels = this.eq(0).parents("label");
        id = this.attr("id");
        if (id) {
            ancestor = this.eq(0).parents().last();
            ancestors = ancestor.add(ancestor.length ? ancestor.siblings() : this.siblings());
            selector = "label[for='" + $.ui.escapeSelector(id) + "']";
            labels = labels.add(ancestors.find(selector).addBack(selector))
        }
        return this.pushStack(labels)
    };
    var scrollParent = $.fn.scrollParent = function(includeHidden) {
        var position = this.css("position"),
            excludeStaticParent = position === "absolute",
            overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
            scrollParent = this.parents().filter(function() {
                var parent =
                    $(this);
                if (excludeStaticParent && parent.css("position") === "static") return false;
                return overflowRegex.test(parent.css("overflow") + parent.css("overflow-y") + parent.css("overflow-x"))
            }).eq(0);
        return position === "fixed" || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent
    };
    var tabbable = $.extend($.expr[":"], {
        tabbable: function(element) {
            var tabIndex = $.attr(element, "tabindex"),
                hasTabindex = tabIndex != null;
            return (!hasTabindex || tabIndex >= 0) && $.ui.focusable(element, hasTabindex)
        }
    });
    var uniqueId = $.fn.extend({
        uniqueId: function() {
            var uuid =
                0;
            return function() {
                return this.each(function() {
                    if (!this.id) this.id = "ui-id-" + ++uuid
                })
            }
        }(),
        removeUniqueId: function() {
            return this.each(function() {
                if (/^ui-id-\d+$/.test(this.id)) $(this).removeAttr("id")
            })
        }
    });
    var ie = $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
    var mouseHandled = false;
    $(document).on("mouseup", function() {
        mouseHandled = false
    });
    var widgetsMouse = $.widget("ui.mouse", {
        version: "1.12.1",
        options: {
            cancel: "input, textarea, button, select, option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function() {
            var that =
                this;
            this.element.on("mousedown." + this.widgetName, function(event) {
                return that._mouseDown(event)
            }).on("click." + this.widgetName, function(event) {
                if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
                    $.removeData(event.target, that.widgetName + ".preventClickEvent");
                    event.stopImmediatePropagation();
                    return false
                }
            });
            this.started = false
        },
        _mouseDestroy: function() {
            this.element.off("." + this.widgetName);
            if (this._mouseMoveDelegate) this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." +
                this.widgetName, this._mouseUpDelegate)
        },
        _mouseDown: function(event) {
            if (mouseHandled) return;
            this._mouseMoved = false;
            this._mouseStarted && this._mouseUp(event);
            this._mouseDownEvent = event;
            var that = this,
                btnIsLeft = event.which === 1,
                elIsCancel = typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false;
            if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) return true;
            this.mouseDelayMet = !this.options.delay;
            if (!this.mouseDelayMet) this._mouseDelayTimer =
                setTimeout(function() {
                    that.mouseDelayMet = true
                }, this.options.delay);
            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted = this._mouseStart(event) !== false;
                if (!this._mouseStarted) {
                    event.preventDefault();
                    return true
                }
            }
            if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) $.removeData(event.target, this.widgetName + ".preventClickEvent");
            this._mouseMoveDelegate = function(event) {
                return that._mouseMove(event)
            };
            this._mouseUpDelegate = function(event) {
                return that._mouseUp(event)
            };
            this.document.on("mousemove." + this.widgetName, this._mouseMoveDelegate).on("mouseup." + this.widgetName, this._mouseUpDelegate);
            event.preventDefault();
            mouseHandled = true;
            return true
        },
        _mouseMove: function(event) {
            if (this._mouseMoved)
                if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) return this._mouseUp(event);
                else if (!event.which)
                if (event.originalEvent.altKey || event.originalEvent.ctrlKey || event.originalEvent.metaKey || event.originalEvent.shiftKey) this.ignoreMissingWhich = true;
                else if (!this.ignoreMissingWhich) return this._mouseUp(event);
            if (event.which || event.button) this._mouseMoved = true;
            if (this._mouseStarted) {
                this._mouseDrag(event);
                return event.preventDefault()
            }
            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== false;
                this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event)
            }
            return !this._mouseStarted
        },
        _mouseUp: function(event) {
            this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate);
            if (this._mouseStarted) {
                this._mouseStarted = false;
                if (event.target === this._mouseDownEvent.target) $.data(event.target, this.widgetName + ".preventClickEvent", true);
                this._mouseStop(event)
            }
            if (this._mouseDelayTimer) {
                clearTimeout(this._mouseDelayTimer);
                delete this._mouseDelayTimer
            }
            this.ignoreMissingWhich = false;
            mouseHandled = false;
            event.preventDefault()
        },
        _mouseDistanceMet: function(event) {
            return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance
        },
        _mouseDelayMet: function() {
            return this.mouseDelayMet
        },
        _mouseStart: function() {},
        _mouseDrag: function() {},
        _mouseStop: function() {},
        _mouseCapture: function() {
            return true
        }
    });
    var plugin = $.ui.plugin = {
        add: function(module, option, set) {
            var i, proto = $.ui[module].prototype;
            for (i in set) {
                proto.plugins[i] = proto.plugins[i] || [];
                proto.plugins[i].push([option, set[i]])
            }
        },
        call: function(instance, name, args, allowDisconnected) {
            var i, set = instance.plugins[name];
            if (!set) return;
            if (!allowDisconnected && (!instance.element[0].parentNode ||
                    instance.element[0].parentNode.nodeType === 11)) return;
            for (i = 0; i < set.length; i++)
                if (instance.options[set[i][0]]) set[i][1].apply(instance.element, args)
        }
    };
    var safeActiveElement = $.ui.safeActiveElement = function(document) {
        var activeElement;
        try {
            activeElement = document.activeElement
        } catch (error) {
            activeElement = document.body
        }
        if (!activeElement) activeElement = document.body;
        if (!activeElement.nodeName) activeElement = document.body;
        return activeElement
    };
    var safeBlur = $.ui.safeBlur = function(element) {
        if (element && element.nodeName.toLowerCase() !==
            "body") $(element).trigger("blur")
    };
    $.widget("ui.draggable", $.ui.mouse, {
        version: "1.12.1",
        widgetEventPrefix: "drag",
        options: {
            addClasses: true,
            appendTo: "parent",
            axis: false,
            connectToSortable: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            grid: false,
            handle: false,
            helper: "original",
            iframeFix: false,
            opacity: false,
            refreshPositions: false,
            revert: false,
            revertDuration: 500,
            scope: "default",
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: false,
            snapMode: "both",
            snapTolerance: 20,
            stack: false,
            zIndex: false,
            drag: null,
            start: null,
            stop: null
        },
        _create: function() {
            if (this.options.helper === "original") this._setPositionRelative();
            if (this.options.addClasses) this._addClass("ui-draggable");
            this._setHandleClassName();
            this._mouseInit()
        },
        _setOption: function(key, value) {
            this._super(key, value);
            if (key === "handle") {
                this._removeHandleClassName();
                this._setHandleClassName()
            }
        },
        _destroy: function() {
            if ((this.helper || this.element).is(".ui-draggable-dragging")) {
                this.destroyOnClear = true;
                return
            }
            this._removeHandleClassName();
            this._mouseDestroy()
        },
        _mouseCapture: function(event) {
            var o = this.options;
            if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) return false;
            this.handle = this._getHandle(event);
            if (!this.handle) return false;
            this._blurActiveElement(event);
            this._blockFrames(o.iframeFix === true ? "iframe" : o.iframeFix);
            return true
        },
        _blockFrames: function(selector) {
            this.iframeBlocks = this.document.find(selector).map(function() {
                var iframe = $(this);
                return $("<div>").css("position", "absolute").appendTo(iframe.parent()).outerWidth(iframe.outerWidth()).outerHeight(iframe.outerHeight()).offset(iframe.offset())[0]
            })
        },
        _unblockFrames: function() {
            if (this.iframeBlocks) {
                this.iframeBlocks.remove();
                delete this.iframeBlocks
            }
        },
        _blurActiveElement: function(event) {
            var activeElement = $.ui.safeActiveElement(this.document[0]),
                target = $(event.target);
            if (target.closest(activeElement).length) return;
            $.ui.safeBlur(activeElement)
        },
        _mouseStart: function(event) {
            var o = this.options;
            this.helper = this._createHelper(event);
            this._addClass(this.helper, "ui-draggable-dragging");
            this._cacheHelperProportions();
            if ($.ui.ddmanager) $.ui.ddmanager.current =
                this;
            this._cacheMargins();
            this.cssPosition = this.helper.css("position");
            this.scrollParent = this.helper.scrollParent(true);
            this.offsetParent = this.helper.offsetParent();
            this.hasFixedAncestor = this.helper.parents().filter(function() {
                return $(this).css("position") === "fixed"
            }).length > 0;
            this.positionAbs = this.element.offset();
            this._refreshOffsets(event);
            this.originalPosition = this.position = this._generatePosition(event, false);
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;
            o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
            this._setContainment();
            if (this._trigger("start", event) === false) {
                this._clear();
                return false
            }
            this._cacheHelperProportions();
            if ($.ui.ddmanager && !o.dropBehaviour) $.ui.ddmanager.prepareOffsets(this, event);
            this._mouseDrag(event, true);
            if ($.ui.ddmanager) $.ui.ddmanager.dragStart(this, event);
            return true
        },
        _refreshOffsets: function(event) {
            this.offset = {
                top: this.positionAbs.top - this.margins.top,
                left: this.positionAbs.left - this.margins.left,
                scroll: false,
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            };
            this.offset.click = {
                left: event.pageX - this.offset.left,
                top: event.pageY - this.offset.top
            }
        },
        _mouseDrag: function(event, noPropagation) {
            if (this.hasFixedAncestor) this.offset.parent = this._getParentOffset();
            this.position = this._generatePosition(event, true);
            this.positionAbs = this._convertPositionTo("absolute");
            if (!noPropagation) {
                var ui = this._uiHash();
                if (this._trigger("drag", event, ui) === false) {
                    this._mouseUp(new $.Event("mouseup", event));
                    return false
                }
                this.position = ui.position
            }
            this.helper[0].style.left = this.position.left +
                "px";
            this.helper[0].style.top = this.position.top + "px";
            if ($.ui.ddmanager) $.ui.ddmanager.drag(this, event);
            return false
        },
        _mouseStop: function(event) {
            var that = this,
                dropped = false;
            if ($.ui.ddmanager && !this.options.dropBehaviour) dropped = $.ui.ddmanager.drop(this, event);
            if (this.dropped) {
                dropped = this.dropped;
                this.dropped = false
            }
            if (this.options.revert === "invalid" && !dropped || this.options.revert === "valid" && dropped || this.options.revert === true || $.isFunction(this.options.revert) && this.options.revert.call(this.element,
                    dropped)) $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
                if (that._trigger("stop", event) !== false) that._clear()
            });
            else if (this._trigger("stop", event) !== false) this._clear();
            return false
        },
        _mouseUp: function(event) {
            this._unblockFrames();
            if ($.ui.ddmanager) $.ui.ddmanager.dragStop(this, event);
            if (this.handleElement.is(event.target)) this.element.trigger("focus");
            return $.ui.mouse.prototype._mouseUp.call(this, event)
        },
        cancel: function() {
            if (this.helper.is(".ui-draggable-dragging")) this._mouseUp(new $.Event("mouseup", {
                target: this.element[0]
            }));
            else this._clear();
            return this
        },
        _getHandle: function(event) {
            return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : true
        },
        _setHandleClassName: function() {
            this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element;
            this._addClass(this.handleElement, "ui-draggable-handle")
        },
        _removeHandleClassName: function() {
            this._removeClass(this.handleElement, "ui-draggable-handle")
        },
        _createHelper: function(event) {
            var o =
                this.options,
                helperIsFunction = $.isFunction(o.helper),
                helper = helperIsFunction ? $(o.helper.apply(this.element[0], [event])) : o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element;
            if (!helper.parents("body").length) helper.appendTo(o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo);
            if (helperIsFunction && helper[0] === this.element[0]) this._setPositionRelative();
            if (helper[0] !== this.element[0] && !/(fixed|absolute)/.test(helper.css("position"))) helper.css("position", "absolute");
            return helper
        },
        _setPositionRelative: function() {
            if (!/^(?:r|a|f)/.test(this.element.css("position"))) this.element[0].style.position = "relative"
        },
        _adjustOffsetFromHelper: function(obj) {
            if (typeof obj === "string") obj = obj.split(" ");
            if ($.isArray(obj)) obj = {
                left: +obj[0],
                top: +obj[1] || 0
            };
            if ("left" in obj) this.offset.click.left = obj.left + this.margins.left;
            if ("right" in obj) this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            if ("top" in obj) this.offset.click.top = obj.top + this.margins.top;
            if ("bottom" in obj) this.offset.click.top =
                this.helperProportions.height - obj.bottom + this.margins.top
        },
        _isRootNode: function(element) {
            return /(html|body)/i.test(element.tagName) || element === this.document[0]
        },
        _getParentOffset: function() {
            var po = this.offsetParent.offset(),
                document = this.document[0];
            if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop()
            }
            if (this._isRootNode(this.offsetParent[0])) po = {
                top: 0,
                left: 0
            };
            return {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            }
        },
        _getRelativeOffset: function() {
            if (this.cssPosition !== "relative") return {
                top: 0,
                left: 0
            };
            var p = this.element.position(),
                scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
            return {
                top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollTop() : 0),
                left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + (!scrollIsRootNode ?
                    this.scrollParent.scrollLeft() : 0)
            }
        },
        _cacheMargins: function() {
            this.margins = {
                left: parseInt(this.element.css("marginLeft"), 10) || 0,
                top: parseInt(this.element.css("marginTop"), 10) || 0,
                right: parseInt(this.element.css("marginRight"), 10) || 0,
                bottom: parseInt(this.element.css("marginBottom"), 10) || 0
            }
        },
        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            }
        },
        _setContainment: function() {
            var isUserScrollable, c, ce, o = this.options,
                document = this.document[0];
            this.relativeContainer = null;
            if (!o.containment) {
                this.containment = null;
                return
            }
            if (o.containment === "window") {
                this.containment = [$(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left, $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
                return
            }
            if (o.containment ===
                "document") {
                this.containment = [0, 0, $(document).width() - this.helperProportions.width - this.margins.left, ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
                return
            }
            if (o.containment.constructor === Array) {
                this.containment = o.containment;
                return
            }
            if (o.containment === "parent") o.containment = this.helper[0].parentNode;
            c = $(o.containment);
            ce = c[0];
            if (!ce) return;
            isUserScrollable = /(scroll|auto)/.test(c.css("overflow"));
            this.containment = [(parseInt(c.css("borderLeftWidth"),
                10) || 0) + (parseInt(c.css("paddingLeft"), 10) || 0), (parseInt(c.css("borderTopWidth"), 10) || 0) + (parseInt(c.css("paddingTop"), 10) || 0), (isUserScrollable ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css("borderRightWidth"), 10) || 0) - (parseInt(c.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (isUserScrollable ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css("borderBottomWidth"), 10) || 0) - (parseInt(c.css("paddingBottom"),
                10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom];
            this.relativeContainer = c
        },
        _convertPositionTo: function(d, pos) {
            if (!pos) pos = this.position;
            var mod = d === "absolute" ? 1 : -1,
                scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
            return {
                top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - (this.cssPosition === "fixed" ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top) * mod,
                left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - (this.cssPosition ===
                    "fixed" ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left) * mod
            }
        },
        _generatePosition: function(event, constrainPosition) {
            var containment, co, top, left, o = this.options,
                scrollIsRootNode = this._isRootNode(this.scrollParent[0]),
                pageX = event.pageX,
                pageY = event.pageY;
            if (!scrollIsRootNode || !this.offset.scroll) this.offset.scroll = {
                top: this.scrollParent.scrollTop(),
                left: this.scrollParent.scrollLeft()
            };
            if (constrainPosition) {
                if (this.containment) {
                    if (this.relativeContainer) {
                        co = this.relativeContainer.offset();
                        containment = [this.containment[0] + co.left, this.containment[1] + co.top, this.containment[2] + co.left, this.containment[3] + co.top]
                    } else containment = this.containment;
                    if (event.pageX - this.offset.click.left < containment[0]) pageX = containment[0] + this.offset.click.left;
                    if (event.pageY - this.offset.click.top < containment[1]) pageY = containment[1] + this.offset.click.top;
                    if (event.pageX - this.offset.click.left > containment[2]) pageX = containment[2] + this.offset.click.left;
                    if (event.pageY - this.offset.click.top > containment[3]) pageY =
                        containment[3] + this.offset.click.top
                }
                if (o.grid) {
                    top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
                    pageY = containment ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3] ? top : top - this.offset.click.top >= containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
                    left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
                    pageX = containment ? left - this.offset.click.left >= containment[0] ||
                        left - this.offset.click.left > containment[2] ? left : left - this.offset.click.left >= containment[0] ? left - o.grid[0] : left + o.grid[0] : left
                }
                if (o.axis === "y") pageX = this.originalPageX;
                if (o.axis === "x") pageY = this.originalPageY
            }
            return {
                top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === "fixed" ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top),
                left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition === "fixed" ?
                    -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left)
            }
        },
        _clear: function() {
            this._removeClass(this.helper, "ui-draggable-dragging");
            if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) this.helper.remove();
            this.helper = null;
            this.cancelHelperRemoval = false;
            if (this.destroyOnClear) this.destroy()
        },
        _trigger: function(type, event, ui) {
            ui = ui || this._uiHash();
            $.ui.plugin.call(this, type, [event, ui, this], true);
            if (/^(drag|start|stop)/.test(type)) {
                this.positionAbs = this._convertPositionTo("absolute");
                ui.offset = this.positionAbs
            }
            return $.Widget.prototype._trigger.call(this, type, event, ui)
        },
        plugins: {},
        _uiHash: function() {
            return {
                helper: this.helper,
                position: this.position,
                originalPosition: this.originalPosition,
                offset: this.positionAbs
            }
        }
    });
    $.ui.plugin.add("draggable", "connectToSortable", {
        start: function(event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
                item: draggable.element
            });
            draggable.sortables = [];
            $(draggable.options.connectToSortable).each(function() {
                var sortable = $(this).sortable("instance");
                if (sortable &&
                    !sortable.options.disabled) {
                    draggable.sortables.push(sortable);
                    sortable.refreshPositions();
                    sortable._trigger("activate", event, uiSortable)
                }
            })
        },
        stop: function(event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
                item: draggable.element
            });
            draggable.cancelHelperRemoval = false;
            $.each(draggable.sortables, function() {
                var sortable = this;
                if (sortable.isOver) {
                    sortable.isOver = 0;
                    draggable.cancelHelperRemoval = true;
                    sortable.cancelHelperRemoval = false;
                    sortable._storedCSS = {
                        position: sortable.placeholder.css("position"),
                        top: sortable.placeholder.css("top"),
                        left: sortable.placeholder.css("left")
                    };
                    sortable._mouseStop(event);
                    sortable.options.helper = sortable.options._helper
                } else {
                    sortable.cancelHelperRemoval = true;
                    sortable._trigger("deactivate", event, uiSortable)
                }
            })
        },
        drag: function(event, ui, draggable) {
            $.each(draggable.sortables, function() {
                var innermostIntersecting = false,
                    sortable = this;
                sortable.positionAbs = draggable.positionAbs;
                sortable.helperProportions = draggable.helperProportions;
                sortable.offset.click = draggable.offset.click;
                if (sortable._intersectsWith(sortable.containerCache)) {
                    innermostIntersecting =
                        true;
                    $.each(draggable.sortables, function() {
                        this.positionAbs = draggable.positionAbs;
                        this.helperProportions = draggable.helperProportions;
                        this.offset.click = draggable.offset.click;
                        if (this !== sortable && this._intersectsWith(this.containerCache) && $.contains(sortable.element[0], this.element[0])) innermostIntersecting = false;
                        return innermostIntersecting
                    })
                }
                if (innermostIntersecting) {
                    if (!sortable.isOver) {
                        sortable.isOver = 1;
                        draggable._parent = ui.helper.parent();
                        sortable.currentItem = ui.helper.appendTo(sortable.element).data("ui-sortable-item",
                            true);
                        sortable.options._helper = sortable.options.helper;
                        sortable.options.helper = function() {
                            return ui.helper[0]
                        };
                        event.target = sortable.currentItem[0];
                        sortable._mouseCapture(event, true);
                        sortable._mouseStart(event, true, true);
                        sortable.offset.click.top = draggable.offset.click.top;
                        sortable.offset.click.left = draggable.offset.click.left;
                        sortable.offset.parent.left -= draggable.offset.parent.left - sortable.offset.parent.left;
                        sortable.offset.parent.top -= draggable.offset.parent.top - sortable.offset.parent.top;
                        draggable._trigger("toSortable",
                            event);
                        draggable.dropped = sortable.element;
                        $.each(draggable.sortables, function() {
                            this.refreshPositions()
                        });
                        draggable.currentItem = draggable.element;
                        sortable.fromOutside = draggable
                    }
                    if (sortable.currentItem) {
                        sortable._mouseDrag(event);
                        ui.position = sortable.position
                    }
                } else if (sortable.isOver) {
                    sortable.isOver = 0;
                    sortable.cancelHelperRemoval = true;
                    sortable.options._revert = sortable.options.revert;
                    sortable.options.revert = false;
                    sortable._trigger("out", event, sortable._uiHash(sortable));
                    sortable._mouseStop(event, true);
                    sortable.options.revert = sortable.options._revert;
                    sortable.options.helper = sortable.options._helper;
                    if (sortable.placeholder) sortable.placeholder.remove();
                    ui.helper.appendTo(draggable._parent);
                    draggable._refreshOffsets(event);
                    ui.position = draggable._generatePosition(event, true);
                    draggable._trigger("fromSortable", event);
                    draggable.dropped = false;
                    $.each(draggable.sortables, function() {
                        this.refreshPositions()
                    })
                }
            })
        }
    });
    $.ui.plugin.add("draggable", "cursor", {
        start: function(event, ui, instance) {
            var t = $("body"),
                o = instance.options;
            if (t.css("cursor")) o._cursor = t.css("cursor");
            t.css("cursor", o.cursor)
        },
        stop: function(event, ui, instance) {
            var o = instance.options;
            if (o._cursor) $("body").css("cursor", o._cursor)
        }
    });
    $.ui.plugin.add("draggable", "opacity", {
        start: function(event, ui, instance) {
            var t = $(ui.helper),
                o = instance.options;
            if (t.css("opacity")) o._opacity = t.css("opacity");
            t.css("opacity", o.opacity)
        },
        stop: function(event, ui, instance) {
            var o = instance.options;
            if (o._opacity) $(ui.helper).css("opacity", o._opacity)
        }
    });
    $.ui.plugin.add("draggable",
        "scroll", {
            start: function(event, ui, i) {
                if (!i.scrollParentNotHidden) i.scrollParentNotHidden = i.helper.scrollParent(false);
                if (i.scrollParentNotHidden[0] !== i.document[0] && i.scrollParentNotHidden[0].tagName !== "HTML") i.overflowOffset = i.scrollParentNotHidden.offset()
            },
            drag: function(event, ui, i) {
                var o = i.options,
                    scrolled = false,
                    scrollParent = i.scrollParentNotHidden[0],
                    document = i.document[0];
                if (scrollParent !== document && scrollParent.tagName !== "HTML") {
                    if (!o.axis || o.axis !== "x")
                        if (i.overflowOffset.top + scrollParent.offsetHeight -
                            event.pageY < o.scrollSensitivity) scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
                        else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
                    if (!o.axis || o.axis !== "y")
                        if (i.overflowOffset.left + scrollParent.offsetWidth - event.pageX < o.scrollSensitivity) scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
                        else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) scrollParent.scrollLeft = scrolled =
                        scrollParent.scrollLeft - o.scrollSpeed
                } else {
                    if (!o.axis || o.axis !== "x")
                        if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                        else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                    if (!o.axis || o.axis !== "y")
                        if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                        else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed)
                }
                if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) $.ui.ddmanager.prepareOffsets(i, event)
            }
        });
    $.ui.plugin.add("draggable", "snap", {
        start: function(event, ui, i) {
            var o = i.options;
            i.snapElements = [];
            $(o.snap.constructor !== String ? o.snap.items || ":data(ui-draggable)" : o.snap).each(function() {
                var $t = $(this),
                    $o = $t.offset();
                if (this !== i.element[0]) i.snapElements.push({
                    item: this,
                    width: $t.outerWidth(),
                    height: $t.outerHeight(),
                    top: $o.top,
                    left: $o.left
                })
            })
        },
        drag: function(event, ui, inst) {
            var ts, bs, ls, rs, l, r, t, b, i, first, o = inst.options,
                d = o.snapTolerance,
                x1 = ui.offset.left,
                x2 = x1 + inst.helperProportions.width,
                y1 = ui.offset.top,
                y2 = y1 + inst.helperProportions.height;
            for (i = inst.snapElements.length - 1; i >= 0; i--) {
                l = inst.snapElements[i].left - inst.margins.left;
                r = l + inst.snapElements[i].width;
                t = inst.snapElements[i].top - inst.margins.top;
                b = t + inst.snapElements[i].height;
                if (x2 < l - d || x1 > r + d || y2 < t - d || y1 >
                    b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item)) {
                    if (inst.snapElements[i].snapping) inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), {
                        snapItem: inst.snapElements[i].item
                    }));
                    inst.snapElements[i].snapping = false;
                    continue
                }
                if (o.snapMode !== "inner") {
                    ts = Math.abs(t - y2) <= d;
                    bs = Math.abs(b - y1) <= d;
                    ls = Math.abs(l - x2) <= d;
                    rs = Math.abs(r - x1) <= d;
                    if (ts) ui.position.top = inst._convertPositionTo("relative", {
                        top: t - inst.helperProportions.height,
                        left: 0
                    }).top;
                    if (bs) ui.position.top = inst._convertPositionTo("relative", {
                        top: b,
                        left: 0
                    }).top;
                    if (ls) ui.position.left = inst._convertPositionTo("relative", {
                        top: 0,
                        left: l - inst.helperProportions.width
                    }).left;
                    if (rs) ui.position.left = inst._convertPositionTo("relative", {
                        top: 0,
                        left: r
                    }).left
                }
                first = ts || bs || ls || rs;
                if (o.snapMode !== "outer") {
                    ts = Math.abs(t - y1) <= d;
                    bs = Math.abs(b - y2) <= d;
                    ls = Math.abs(l - x1) <= d;
                    rs = Math.abs(r - x2) <= d;
                    if (ts) ui.position.top = inst._convertPositionTo("relative", {
                        top: t,
                        left: 0
                    }).top;
                    if (bs) ui.position.top =
                        inst._convertPositionTo("relative", {
                            top: b - inst.helperProportions.height,
                            left: 0
                        }).top;
                    if (ls) ui.position.left = inst._convertPositionTo("relative", {
                        top: 0,
                        left: l
                    }).left;
                    if (rs) ui.position.left = inst._convertPositionTo("relative", {
                        top: 0,
                        left: r - inst.helperProportions.width
                    }).left
                }
                if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), {
                    snapItem: inst.snapElements[i].item
                }));
                inst.snapElements[i].snapping = ts || bs ||
                    ls || rs || first
            }
        }
    });
    $.ui.plugin.add("draggable", "stack", {
        start: function(event, ui, instance) {
            var min, o = instance.options,
                group = $.makeArray($(o.stack)).sort(function(a, b) {
                    return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0)
                });
            if (!group.length) return;
            min = parseInt($(group[0]).css("zIndex"), 10) || 0;
            $(group).each(function(i) {
                $(this).css("zIndex", min + i)
            });
            this.css("zIndex", min + group.length)
        }
    });
    $.ui.plugin.add("draggable", "zIndex", {
        start: function(event, ui, instance) {
            var t = $(ui.helper),
                o = instance.options;
            if (t.css("zIndex")) o._zIndex = t.css("zIndex");
            t.css("zIndex", o.zIndex)
        },
        stop: function(event, ui, instance) {
            var o = instance.options;
            if (o._zIndex) $(ui.helper).css("zIndex", o._zIndex)
        }
    });
    var widgetsDraggable = $.ui.draggable;
    $.widget("ui.droppable", {
        version: "1.12.1",
        widgetEventPrefix: "drop",
        options: {
            accept: "*",
            addClasses: true,
            greedy: false,
            scope: "default",
            tolerance: "intersect",
            activate: null,
            deactivate: null,
            drop: null,
            out: null,
            over: null
        },
        _create: function() {
            var proportions, o = this.options,
                accept =
                o.accept;
            this.isover = false;
            this.isout = true;
            this.accept = $.isFunction(accept) ? accept : function(d) {
                return d.is(accept)
            };
            this.proportions = function() {
                if (arguments.length) proportions = arguments[0];
                else return proportions ? proportions : proportions = {
                    width: this.element[0].offsetWidth,
                    height: this.element[0].offsetHeight
                }
            };
            this._addToManager(o.scope);
            o.addClasses && this._addClass("ui-droppable")
        },
        _addToManager: function(scope) {
            $.ui.ddmanager.droppables[scope] = $.ui.ddmanager.droppables[scope] || [];
            $.ui.ddmanager.droppables[scope].push(this)
        },
        _splice: function(drop) {
            var i = 0;
            for (; i < drop.length; i++)
                if (drop[i] === this) drop.splice(i, 1)
        },
        _destroy: function() {
            var drop = $.ui.ddmanager.droppables[this.options.scope];
            this._splice(drop)
        },
        _setOption: function(key, value) {
            if (key === "accept") this.accept = $.isFunction(value) ? value : function(d) {
                return d.is(value)
            };
            else if (key === "scope") {
                var drop = $.ui.ddmanager.droppables[this.options.scope];
                this._splice(drop);
                this._addToManager(value)
            }
            this._super(key, value)
        },
        _activate: function(event) {
            var draggable = $.ui.ddmanager.current;
            this._addActiveClass();
            if (draggable) this._trigger("activate", event, this.ui(draggable))
        },
        _deactivate: function(event) {
            var draggable = $.ui.ddmanager.current;
            this._removeActiveClass();
            if (draggable) this._trigger("deactivate", event, this.ui(draggable))
        },
        _over: function(event) {
            var draggable = $.ui.ddmanager.current;
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) return;
            if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                this._addHoverClass();
                this._trigger("over",
                    event, this.ui(draggable))
            }
        },
        _out: function(event) {
            var draggable = $.ui.ddmanager.current;
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) return;
            if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                this._removeHoverClass();
                this._trigger("out", event, this.ui(draggable))
            }
        },
        _drop: function(event, custom) {
            var draggable = custom || $.ui.ddmanager.current,
                childrenIntersection = false;
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) return false;
            this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
                var inst = $(this).droppable("instance");
                if (inst.options.greedy && !inst.options.disabled && inst.options.scope === draggable.options.scope && inst.accept.call(inst.element[0], draggable.currentItem || draggable.element) && intersect(draggable, $.extend(inst, {
                        offset: inst.element.offset()
                    }), inst.options.tolerance, event)) {
                    childrenIntersection = true;
                    return false
                }
            });
            if (childrenIntersection) return false;
            if (this.accept.call(this.element[0],
                    draggable.currentItem || draggable.element)) {
                this._removeActiveClass();
                this._removeHoverClass();
                this._trigger("drop", event, this.ui(draggable));
                return this.element
            }
            return false
        },
        ui: function(c) {
            return {
                draggable: c.currentItem || c.element,
                helper: c.helper,
                position: c.position,
                offset: c.positionAbs
            }
        },
        _addHoverClass: function() {
            this._addClass("ui-droppable-hover")
        },
        _removeHoverClass: function() {
            this._removeClass("ui-droppable-hover")
        },
        _addActiveClass: function() {
            this._addClass("ui-droppable-active")
        },
        _removeActiveClass: function() {
            this._removeClass("ui-droppable-active")
        }
    });
    var intersect = $.ui.intersect = function() {
        function isOverAxis(x, reference, size) {
            return x >= reference && x < reference + size
        }
        return function(draggable, droppable, toleranceMode, event) {
            if (!droppable.offset) return false;
            var x1 = (draggable.positionAbs || draggable.position.absolute).left + draggable.margins.left,
                y1 = (draggable.positionAbs || draggable.position.absolute).top + draggable.margins.top,
                x2 = x1 + draggable.helperProportions.width,
                y2 = y1 + draggable.helperProportions.height,
                l = droppable.offset.left,
                t = droppable.offset.top,
                r = l + droppable.proportions().width,
                b = t + droppable.proportions().height;
            switch (toleranceMode) {
                case "fit":
                    return l <= x1 && x2 <= r && t <= y1 && y2 <= b;
                case "intersect":
                    return l < x1 + draggable.helperProportions.width / 2 && x2 - draggable.helperProportions.width / 2 < r && t < y1 + draggable.helperProportions.height / 2 && y2 - draggable.helperProportions.height / 2 < b;
                case "pointer":
                    return isOverAxis(event.pageY, t, droppable.proportions().height) && isOverAxis(event.pageX, l, droppable.proportions().width);
                case "touch":
                    return (y1 >= t && y1 <= b || y2 >=
                        t && y2 <= b || y1 < t && y2 > b) && (x1 >= l && x1 <= r || x2 >= l && x2 <= r || x1 < l && x2 > r);
                default:
                    return false
            }
        }
    }();
    $.ui.ddmanager = {
        current: null,
        droppables: {
            "default": []
        },
        prepareOffsets: function(t, event) {
            var i, j, m = $.ui.ddmanager.droppables[t.options.scope] || [],
                type = event ? event.type : null,
                list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
            droppablesLoop: for (i = 0; i < m.length; i++) {
                if (m[i].options.disabled || t && !m[i].accept.call(m[i].element[0], t.currentItem || t.element)) continue;
                for (j = 0; j < list.length; j++)
                    if (list[j] ===
                        m[i].element[0]) {
                        m[i].proportions().height = 0;
                        continue droppablesLoop
                    }
                m[i].visible = m[i].element.css("display") !== "none";
                if (!m[i].visible) continue;
                if (type === "mousedown") m[i]._activate.call(m[i], event);
                m[i].offset = m[i].element.offset();
                m[i].proportions({
                    width: m[i].element[0].offsetWidth,
                    height: m[i].element[0].offsetHeight
                })
            }
        },
        drop: function(draggable, event) {
            var dropped = false;
            $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {
                if (!this.options) return;
                if (!this.options.disabled &&
                    this.visible && intersect(draggable, this, this.options.tolerance, event)) dropped = this._drop.call(this, event) || dropped;
                if (!this.options.disabled && this.visible && this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                    this.isout = true;
                    this.isover = false;
                    this._deactivate.call(this, event)
                }
            });
            return dropped
        },
        dragStart: function(draggable, event) {
            draggable.element.parentsUntil("body").on("scroll.droppable", function() {
                if (!draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable,
                    event)
            })
        },
        drag: function(draggable, event) {
            if (draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event);
            $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {
                if (this.options.disabled || this.greedyChild || !this.visible) return;
                var parentInstance, scope, parent, intersects = intersect(draggable, this, this.options.tolerance, event),
                    c = !intersects && this.isover ? "isout" : intersects && !this.isover ? "isover" : null;
                if (!c) return;
                if (this.options.greedy) {
                    scope = this.options.scope;
                    parent =
                        this.element.parents(":data(ui-droppable)").filter(function() {
                            return $(this).droppable("instance").options.scope === scope
                        });
                    if (parent.length) {
                        parentInstance = $(parent[0]).droppable("instance");
                        parentInstance.greedyChild = c === "isover"
                    }
                }
                if (parentInstance && c === "isover") {
                    parentInstance.isover = false;
                    parentInstance.isout = true;
                    parentInstance._out.call(parentInstance, event)
                }
                this[c] = true;
                this[c === "isout" ? "isover" : "isout"] = false;
                this[c === "isover" ? "_over" : "_out"].call(this, event);
                if (parentInstance && c === "isout") {
                    parentInstance.isout =
                        false;
                    parentInstance.isover = true;
                    parentInstance._over.call(parentInstance, event)
                }
            })
        },
        dragStop: function(draggable, event) {
            draggable.element.parentsUntil("body").off("scroll.droppable");
            if (!draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event)
        }
    };
    if ($.uiBackCompat !== false) $.widget("ui.droppable", $.ui.droppable, {
        options: {
            hoverClass: false,
            activeClass: false
        },
        _addActiveClass: function() {
            this._super();
            if (this.options.activeClass) this.element.addClass(this.options.activeClass)
        },
        _removeActiveClass: function() {
            this._super();
            if (this.options.activeClass) this.element.removeClass(this.options.activeClass)
        },
        _addHoverClass: function() {
            this._super();
            if (this.options.hoverClass) this.element.addClass(this.options.hoverClass)
        },
        _removeHoverClass: function() {
            this._super();
            if (this.options.hoverClass) this.element.removeClass(this.options.hoverClass)
        }
    });
    var widgetsDroppable = $.ui.droppable;
    $.widget("ui.resizable", $.ui.mouse, {
        version: "1.12.1",
        widgetEventPrefix: "resize",
        options: {
            alsoResize: false,
            animate: false,
            animateDuration: "slow",
            animateEasing: "swing",
            aspectRatio: false,
            autoHide: false,
            classes: {
                "ui-resizable-se": "ui-icon ui-icon-gripsmall-diagonal-se"
            },
            containment: false,
            ghost: false,
            grid: false,
            handles: "e,s,se",
            helper: false,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,
            zIndex: 90,
            resize: null,
            start: null,
            stop: null
        },
        _num: function(value) {
            return parseFloat(value) || 0
        },
        _isNumber: function(value) {
            return !isNaN(parseFloat(value))
        },
        _hasScroll: function(el, a) {
            if ($(el).css("overflow") === "hidden") return false;
            var scroll = a && a === "left" ? "scrollLeft" : "scrollTop",
                has = false;
            if (el[scroll] > 0) return true;
            el[scroll] = 1;
            has = el[scroll] > 0;
            el[scroll] = 0;
            return has
        },
        _create: function() {
            var margins, o = this.options,
                that = this;
            this._addClass("ui-resizable");
            $.extend(this, {
                _aspectRatio: !!o.aspectRatio,
                aspectRatio: o.aspectRatio,
                originalElement: this.element,
                _proportionallyResizeElements: [],
                _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
            });
            if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {
                this.element.wrap($("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                    position: this.element.css("position"),
                    width: this.element.outerWidth(),
                    height: this.element.outerHeight(),
                    top: this.element.css("top"),
                    left: this.element.css("left")
                }));
                this.element = this.element.parent().data("ui-resizable", this.element.resizable("instance"));
                this.elementIsWrapper = true;
                margins = {
                    marginTop: this.originalElement.css("marginTop"),
                    marginRight: this.originalElement.css("marginRight"),
                    marginBottom: this.originalElement.css("marginBottom"),
                    marginLeft: this.originalElement.css("marginLeft")
                };
                this.element.css(margins);
                this.originalElement.css("margin",
                    0);
                this.originalResizeStyle = this.originalElement.css("resize");
                this.originalElement.css("resize", "none");
                this._proportionallyResizeElements.push(this.originalElement.css({
                    position: "static",
                    zoom: 1,
                    display: "block"
                }));
                this.originalElement.css(margins);
                this._proportionallyResize()
            }
            this._setupHandles();
            if (o.autoHide) $(this.element).on("mouseenter", function() {
                if (o.disabled) return;
                that._removeClass("ui-resizable-autohide");
                that._handles.show()
            }).on("mouseleave", function() {
                if (o.disabled) return;
                if (!that.resizing) {
                    that._addClass("ui-resizable-autohide");
                    that._handles.hide()
                }
            });
            this._mouseInit()
        },
        _destroy: function() {
            this._mouseDestroy();
            var wrapper, _destroy = function(exp) {
                $(exp).removeData("resizable").removeData("ui-resizable").off(".resizable").find(".ui-resizable-handle").remove()
            };
            if (this.elementIsWrapper) {
                _destroy(this.element);
                wrapper = this.element;
                this.originalElement.css({
                    position: wrapper.css("position"),
                    width: wrapper.outerWidth(),
                    height: wrapper.outerHeight(),
                    top: wrapper.css("top"),
                    left: wrapper.css("left")
                }).insertAfter(wrapper);
                wrapper.remove()
            }
            this.originalElement.css("resize",
                this.originalResizeStyle);
            _destroy(this.originalElement);
            return this
        },
        _setOption: function(key, value) {
            this._super(key, value);
            switch (key) {
                case "handles":
                    this._removeHandles();
                    this._setupHandles();
                    break;
                default:
                    break
            }
        },
        _setupHandles: function() {
            var o = this.options,
                handle, i, n, hname, axis, that = this;
            this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : {
                n: ".ui-resizable-n",
                e: ".ui-resizable-e",
                s: ".ui-resizable-s",
                w: ".ui-resizable-w",
                se: ".ui-resizable-se",
                sw: ".ui-resizable-sw",
                ne: ".ui-resizable-ne",
                nw: ".ui-resizable-nw"
            });
            this._handles = $();
            if (this.handles.constructor === String) {
                if (this.handles === "all") this.handles = "n,e,s,w,se,sw,ne,nw";
                n = this.handles.split(",");
                this.handles = {};
                for (i = 0; i < n.length; i++) {
                    handle = $.trim(n[i]);
                    hname = "ui-resizable-" + handle;
                    axis = $("<div>");
                    this._addClass(axis, "ui-resizable-handle " + hname);
                    axis.css({
                        zIndex: o.zIndex
                    });
                    this.handles[handle] = ".ui-resizable-" + handle;
                    this.element.append(axis)
                }
            }
            this._renderAxis = function(target) {
                var i, axis, padPos, padWrapper;
                target = target || this.element;
                for (i in this.handles) {
                    if (this.handles[i].constructor === String) this.handles[i] = this.element.children(this.handles[i]).first().show();
                    else if (this.handles[i].jquery || this.handles[i].nodeType) {
                        this.handles[i] = $(this.handles[i]);
                        this._on(this.handles[i], {
                            "mousedown": that._mouseDown
                        })
                    }
                    if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {
                        axis = $(this.handles[i], this.element);
                        padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
                        padPos = ["padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left"].join("");
                        target.css(padPos, padWrapper);
                        this._proportionallyResize()
                    }
                    this._handles = this._handles.add(this.handles[i])
                }
            };
            this._renderAxis(this.element);
            this._handles = this._handles.add(this.element.find(".ui-resizable-handle"));
            this._handles.disableSelection();
            this._handles.on("mouseover", function() {
                if (!that.resizing) {
                    if (this.className) axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
                    that.axis =
                        axis && axis[1] ? axis[1] : "se"
                }
            });
            if (o.autoHide) {
                this._handles.hide();
                this._addClass("ui-resizable-autohide")
            }
        },
        _removeHandles: function() {
            this._handles.remove()
        },
        _mouseCapture: function(event) {
            var i, handle, capture = false;
            for (i in this.handles) {
                handle = $(this.handles[i])[0];
                if (handle === event.target || $.contains(handle, event.target)) capture = true
            }
            return !this.options.disabled && capture
        },
        _mouseStart: function(event) {
            var curleft, curtop, cursor, o = this.options,
                el = this.element;
            this.resizing = true;
            this._renderProxy();
            curleft = this._num(this.helper.css("left"));
            curtop = this._num(this.helper.css("top"));
            if (o.containment) {
                curleft += $(o.containment).scrollLeft() || 0;
                curtop += $(o.containment).scrollTop() || 0
            }
            this.offset = this.helper.offset();
            this.position = {
                left: curleft,
                top: curtop
            };
            this.size = this._helper ? {
                width: this.helper.width(),
                height: this.helper.height()
            } : {
                width: el.width(),
                height: el.height()
            };
            this.originalSize = this._helper ? {
                width: el.outerWidth(),
                height: el.outerHeight()
            } : {
                width: el.width(),
                height: el.height()
            };
            this.sizeDiff = {
                width: el.outerWidth() - el.width(),
                height: el.outerHeight() - el.height()
            };
            this.originalPosition = {
                left: curleft,
                top: curtop
            };
            this.originalMousePosition = {
                left: event.pageX,
                top: event.pageY
            };
            this.aspectRatio = typeof o.aspectRatio === "number" ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1;
            cursor = $(".ui-resizable-" + this.axis).css("cursor");
            $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);
            this._addClass("ui-resizable-resizing");
            this._propagate("start", event);
            return true
        },
        _mouseDrag: function(event) {
            var data,
                props, smp = this.originalMousePosition,
                a = this.axis,
                dx = event.pageX - smp.left || 0,
                dy = event.pageY - smp.top || 0,
                trigger = this._change[a];
            this._updatePrevProperties();
            if (!trigger) return false;
            data = trigger.apply(this, [event, dx, dy]);
            this._updateVirtualBoundaries(event.shiftKey);
            if (this._aspectRatio || event.shiftKey) data = this._updateRatio(data, event);
            data = this._respectSize(data, event);
            this._updateCache(data);
            this._propagate("resize", event);
            props = this._applyChanges();
            if (!this._helper && this._proportionallyResizeElements.length) this._proportionallyResize();
            if (!$.isEmptyObject(props)) {
                this._updatePrevProperties();
                this._trigger("resize", event, this.ui());
                this._applyChanges()
            }
            return false
        },
        _mouseStop: function(event) {
            this.resizing = false;
            var pr, ista, soffseth, soffsetw, s, left, top, o = this.options,
                that = this;
            if (this._helper) {
                pr = this._proportionallyResizeElements;
                ista = pr.length && /textarea/i.test(pr[0].nodeName);
                soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
                soffsetw = ista ? 0 : that.sizeDiff.width;
                s = {
                    width: that.helper.width() - soffsetw,
                    height: that.helper.height() -
                        soffseth
                };
                left = parseFloat(that.element.css("left")) + (that.position.left - that.originalPosition.left) || null;
                top = parseFloat(that.element.css("top")) + (that.position.top - that.originalPosition.top) || null;
                if (!o.animate) this.element.css($.extend(s, {
                    top: top,
                    left: left
                }));
                that.helper.height(that.size.height);
                that.helper.width(that.size.width);
                if (this._helper && !o.animate) this._proportionallyResize()
            }
            $("body").css("cursor", "auto");
            this._removeClass("ui-resizable-resizing");
            this._propagate("stop", event);
            if (this._helper) this.helper.remove();
            return false
        },
        _updatePrevProperties: function() {
            this.prevPosition = {
                top: this.position.top,
                left: this.position.left
            };
            this.prevSize = {
                width: this.size.width,
                height: this.size.height
            }
        },
        _applyChanges: function() {
            var props = {};
            if (this.position.top !== this.prevPosition.top) props.top = this.position.top + "px";
            if (this.position.left !== this.prevPosition.left) props.left = this.position.left + "px";
            if (this.size.width !== this.prevSize.width) props.width = this.size.width + "px";
            if (this.size.height !== this.prevSize.height) props.height =
                this.size.height + "px";
            this.helper.css(props);
            return props
        },
        _updateVirtualBoundaries: function(forceAspectRatio) {
            var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b, o = this.options;
            b = {
                minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
                maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
                minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
                maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
            };
            if (this._aspectRatio || forceAspectRatio) {
                pMinWidth = b.minHeight * this.aspectRatio;
                pMinHeight = b.minWidth / this.aspectRatio;
                pMaxWidth = b.maxHeight * this.aspectRatio;
                pMaxHeight = b.maxWidth / this.aspectRatio;
                if (pMinWidth > b.minWidth) b.minWidth = pMinWidth;
                if (pMinHeight > b.minHeight) b.minHeight = pMinHeight;
                if (pMaxWidth < b.maxWidth) b.maxWidth = pMaxWidth;
                if (pMaxHeight < b.maxHeight) b.maxHeight = pMaxHeight
            }
            this._vBoundaries = b
        },
        _updateCache: function(data) {
            this.offset = this.helper.offset();
            if (this._isNumber(data.left)) this.position.left = data.left;
            if (this._isNumber(data.top)) this.position.top = data.top;
            if (this._isNumber(data.height)) this.size.height =
                data.height;
            if (this._isNumber(data.width)) this.size.width = data.width
        },
        _updateRatio: function(data) {
            var cpos = this.position,
                csize = this.size,
                a = this.axis;
            if (this._isNumber(data.height)) data.width = data.height * this.aspectRatio;
            else if (this._isNumber(data.width)) data.height = data.width / this.aspectRatio;
            if (a === "sw") {
                data.left = cpos.left + (csize.width - data.width);
                data.top = null
            }
            if (a === "nw") {
                data.top = cpos.top + (csize.height - data.height);
                data.left = cpos.left + (csize.width - data.width)
            }
            return data
        },
        _respectSize: function(data) {
            var o =
                this._vBoundaries,
                a = this.axis,
                ismaxw = this._isNumber(data.width) && o.maxWidth && o.maxWidth < data.width,
                ismaxh = this._isNumber(data.height) && o.maxHeight && o.maxHeight < data.height,
                isminw = this._isNumber(data.width) && o.minWidth && o.minWidth > data.width,
                isminh = this._isNumber(data.height) && o.minHeight && o.minHeight > data.height,
                dw = this.originalPosition.left + this.originalSize.width,
                dh = this.originalPosition.top + this.originalSize.height,
                cw = /sw|nw|w/.test(a),
                ch = /nw|ne|n/.test(a);
            if (isminw) data.width = o.minWidth;
            if (isminh) data.height =
                o.minHeight;
            if (ismaxw) data.width = o.maxWidth;
            if (ismaxh) data.height = o.maxHeight;
            if (isminw && cw) data.left = dw - o.minWidth;
            if (ismaxw && cw) data.left = dw - o.maxWidth;
            if (isminh && ch) data.top = dh - o.minHeight;
            if (ismaxh && ch) data.top = dh - o.maxHeight;
            if (!data.width && !data.height && !data.left && data.top) data.top = null;
            else if (!data.width && !data.height && !data.top && data.left) data.left = null;
            return data
        },
        _getPaddingPlusBorderDimensions: function(element) {
            var i = 0,
                widths = [],
                borders = [element.css("borderTopWidth"), element.css("borderRightWidth"),
                    element.css("borderBottomWidth"), element.css("borderLeftWidth")
                ],
                paddings = [element.css("paddingTop"), element.css("paddingRight"), element.css("paddingBottom"), element.css("paddingLeft")];
            for (; i < 4; i++) {
                widths[i] = parseFloat(borders[i]) || 0;
                widths[i] += parseFloat(paddings[i]) || 0
            }
            return {
                height: widths[0] + widths[2],
                width: widths[1] + widths[3]
            }
        },
        _proportionallyResize: function() {
            if (!this._proportionallyResizeElements.length) return;
            var prel, i = 0,
                element = this.helper || this.element;
            for (; i < this._proportionallyResizeElements.length; i++) {
                prel =
                    this._proportionallyResizeElements[i];
                if (!this.outerDimensions) this.outerDimensions = this._getPaddingPlusBorderDimensions(prel);
                prel.css({
                    height: element.height() - this.outerDimensions.height || 0,
                    width: element.width() - this.outerDimensions.width || 0
                })
            }
        },
        _renderProxy: function() {
            var el = this.element,
                o = this.options;
            this.elementOffset = el.offset();
            if (this._helper) {
                this.helper = this.helper || $("<div style='overflow:hidden;'></div>");
                this._addClass(this.helper, this._helper);
                this.helper.css({
                    width: this.element.outerWidth(),
                    height: this.element.outerHeight(),
                    position: "absolute",
                    left: this.elementOffset.left + "px",
                    top: this.elementOffset.top + "px",
                    zIndex: ++o.zIndex
                });
                this.helper.appendTo("body").disableSelection()
            } else this.helper = this.element
        },
        _change: {
            e: function(event, dx) {
                return {
                    width: this.originalSize.width + dx
                }
            },
            w: function(event, dx) {
                var cs = this.originalSize,
                    sp = this.originalPosition;
                return {
                    left: sp.left + dx,
                    width: cs.width - dx
                }
            },
            n: function(event, dx, dy) {
                var cs = this.originalSize,
                    sp = this.originalPosition;
                return {
                    top: sp.top + dy,
                    height: cs.height -
                        dy
                }
            },
            s: function(event, dx, dy) {
                return {
                    height: this.originalSize.height + dy
                }
            },
            se: function(event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]))
            },
            sw: function(event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]))
            },
            ne: function(event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]))
            },
            nw: function(event, dx, dy) {
                return $.extend(this._change.n.apply(this,
                    arguments), this._change.w.apply(this, [event, dx, dy]))
            }
        },
        _propagate: function(n, event) {
            $.ui.plugin.call(this, n, [event, this.ui()]);
            n !== "resize" && this._trigger(n, event, this.ui())
        },
        plugins: {},
        ui: function() {
            return {
                originalElement: this.originalElement,
                element: this.element,
                helper: this.helper,
                position: this.position,
                size: this.size,
                originalSize: this.originalSize,
                originalPosition: this.originalPosition
            }
        }
    });
    $.ui.plugin.add("resizable", "animate", {
        stop: function(event) {
            var that = $(this).resizable("instance"),
                o = that.options,
                pr = that._proportionallyResizeElements,
                ista = pr.length && /textarea/i.test(pr[0].nodeName),
                soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height,
                soffsetw = ista ? 0 : that.sizeDiff.width,
                style = {
                    width: that.size.width - soffsetw,
                    height: that.size.height - soffseth
                },
                left = parseFloat(that.element.css("left")) + (that.position.left - that.originalPosition.left) || null,
                top = parseFloat(that.element.css("top")) + (that.position.top - that.originalPosition.top) || null;
            that.element.animate($.extend(style, top && left ? {
                top: top,
                left: left
            } : {}), {
                duration: o.animateDuration,
                easing: o.animateEasing,
                step: function() {
                    var data = {
                        width: parseFloat(that.element.css("width")),
                        height: parseFloat(that.element.css("height")),
                        top: parseFloat(that.element.css("top")),
                        left: parseFloat(that.element.css("left"))
                    };
                    if (pr && pr.length) $(pr[0]).css({
                        width: data.width,
                        height: data.height
                    });
                    that._updateCache(data);
                    that._propagate("resize", event)
                }
            })
        }
    });
    $.ui.plugin.add("resizable", "containment", {
        start: function() {
            var element, p, co, ch, cw, width, height, that = $(this).resizable("instance"),
                o = that.options,
                el = that.element,
                oc = o.containment,
                ce = oc instanceof $ ? oc.get(0) : /parent/.test(oc) ? el.parent().get(0) : oc;
            if (!ce) return;
            that.containerElement = $(ce);
            if (/document/.test(oc) || oc === document) {
                that.containerOffset = {
                    left: 0,
                    top: 0
                };
                that.containerPosition = {
                    left: 0,
                    top: 0
                };
                that.parentData = {
                    element: $(document),
                    left: 0,
                    top: 0,
                    width: $(document).width(),
                    height: $(document).height() || document.body.parentNode.scrollHeight
                }
            } else {
                element = $(ce);
                p = [];
                $(["Top", "Right", "Left", "Bottom"]).each(function(i, name) {
                    p[i] =
                        that._num(element.css("padding" + name))
                });
                that.containerOffset = element.offset();
                that.containerPosition = element.position();
                that.containerSize = {
                    height: element.innerHeight() - p[3],
                    width: element.innerWidth() - p[1]
                };
                co = that.containerOffset;
                ch = that.containerSize.height;
                cw = that.containerSize.width;
                width = that._hasScroll(ce, "left") ? ce.scrollWidth : cw;
                height = that._hasScroll(ce) ? ce.scrollHeight : ch;
                that.parentData = {
                    element: ce,
                    left: co.left,
                    top: co.top,
                    width: width,
                    height: height
                }
            }
        },
        resize: function(event) {
            var woset, hoset,
                isParent, isOffsetRelative, that = $(this).resizable("instance"),
                o = that.options,
                co = that.containerOffset,
                cp = that.position,
                pRatio = that._aspectRatio || event.shiftKey,
                cop = {
                    top: 0,
                    left: 0
                },
                ce = that.containerElement,
                continueResize = true;
            if (ce[0] !== document && /static/.test(ce.css("position"))) cop = co;
            if (cp.left < (that._helper ? co.left : 0)) {
                that.size.width = that.size.width + (that._helper ? that.position.left - co.left : that.position.left - cop.left);
                if (pRatio) {
                    that.size.height = that.size.width / that.aspectRatio;
                    continueResize = false
                }
                that.position.left =
                    o.helper ? co.left : 0
            }
            if (cp.top < (that._helper ? co.top : 0)) {
                that.size.height = that.size.height + (that._helper ? that.position.top - co.top : that.position.top);
                if (pRatio) {
                    that.size.width = that.size.height * that.aspectRatio;
                    continueResize = false
                }
                that.position.top = that._helper ? co.top : 0
            }
            isParent = that.containerElement.get(0) === that.element.parent().get(0);
            isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));
            if (isParent && isOffsetRelative) {
                that.offset.left = that.parentData.left + that.position.left;
                that.offset.top = that.parentData.top + that.position.top
            } else {
                that.offset.left = that.element.offset().left;
                that.offset.top = that.element.offset().top
            }
            woset = Math.abs(that.sizeDiff.width + (that._helper ? that.offset.left - cop.left : that.offset.left - co.left));
            hoset = Math.abs(that.sizeDiff.height + (that._helper ? that.offset.top - cop.top : that.offset.top - co.top));
            if (woset + that.size.width >= that.parentData.width) {
                that.size.width = that.parentData.width - woset;
                if (pRatio) {
                    that.size.height = that.size.width / that.aspectRatio;
                    continueResize =
                        false
                }
            }
            if (hoset + that.size.height >= that.parentData.height) {
                that.size.height = that.parentData.height - hoset;
                if (pRatio) {
                    that.size.width = that.size.height * that.aspectRatio;
                    continueResize = false
                }
            }
            if (!continueResize) {
                that.position.left = that.prevPosition.left;
                that.position.top = that.prevPosition.top;
                that.size.width = that.prevSize.width;
                that.size.height = that.prevSize.height
            }
        },
        stop: function() {
            var that = $(this).resizable("instance"),
                o = that.options,
                co = that.containerOffset,
                cop = that.containerPosition,
                ce = that.containerElement,
                helper = $(that.helper),
                ho = helper.offset(),
                w = helper.outerWidth() - that.sizeDiff.width,
                h = helper.outerHeight() - that.sizeDiff.height;
            if (that._helper && !o.animate && /relative/.test(ce.css("position"))) $(this).css({
                left: ho.left - cop.left - co.left,
                width: w,
                height: h
            });
            if (that._helper && !o.animate && /static/.test(ce.css("position"))) $(this).css({
                left: ho.left - cop.left - co.left,
                width: w,
                height: h
            })
        }
    });
    $.ui.plugin.add("resizable", "alsoResize", {
        start: function() {
            var that = $(this).resizable("instance"),
                o = that.options;
            $(o.alsoResize).each(function() {
                var el =
                    $(this);
                el.data("ui-resizable-alsoresize", {
                    width: parseFloat(el.width()),
                    height: parseFloat(el.height()),
                    left: parseFloat(el.css("left")),
                    top: parseFloat(el.css("top"))
                })
            })
        },
        resize: function(event, ui) {
            var that = $(this).resizable("instance"),
                o = that.options,
                os = that.originalSize,
                op = that.originalPosition,
                delta = {
                    height: that.size.height - os.height || 0,
                    width: that.size.width - os.width || 0,
                    top: that.position.top - op.top || 0,
                    left: that.position.left - op.left || 0
                };
            $(o.alsoResize).each(function() {
                var el = $(this),
                    start = $(this).data("ui-resizable-alsoresize"),
                    style = {},
                    css = el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];
                $.each(css, function(i, prop) {
                    var sum = (start[prop] || 0) + (delta[prop] || 0);
                    if (sum && sum >= 0) style[prop] = sum || null
                });
                el.css(style)
            })
        },
        stop: function() {
            $(this).removeData("ui-resizable-alsoresize")
        }
    });
    $.ui.plugin.add("resizable", "ghost", {
        start: function() {
            var that = $(this).resizable("instance"),
                cs = that.size;
            that.ghost = that.originalElement.clone();
            that.ghost.css({
                opacity: .25,
                display: "block",
                position: "relative",
                height: cs.height,
                width: cs.width,
                margin: 0,
                left: 0,
                top: 0
            });
            that._addClass(that.ghost, "ui-resizable-ghost");
            if ($.uiBackCompat !== false && typeof that.options.ghost === "string") that.ghost.addClass(this.options.ghost);
            that.ghost.appendTo(that.helper)
        },
        resize: function() {
            var that = $(this).resizable("instance");
            if (that.ghost) that.ghost.css({
                position: "relative",
                height: that.size.height,
                width: that.size.width
            })
        },
        stop: function() {
            var that = $(this).resizable("instance");
            if (that.ghost && that.helper) that.helper.get(0).removeChild(that.ghost.get(0))
        }
    });
    $.ui.plugin.add("resizable", "grid", {
        resize: function() {
            var outerDimensions, that = $(this).resizable("instance"),
                o = that.options,
                cs = that.size,
                os = that.originalSize,
                op = that.originalPosition,
                a = that.axis,
                grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
                gridX = grid[0] || 1,
                gridY = grid[1] || 1,
                ox = Math.round((cs.width - os.width) / gridX) * gridX,
                oy = Math.round((cs.height - os.height) / gridY) * gridY,
                newWidth = os.width + ox,
                newHeight = os.height + oy,
                isMaxWidth = o.maxWidth && o.maxWidth < newWidth,
                isMaxHeight = o.maxHeight && o.maxHeight <
                newHeight,
                isMinWidth = o.minWidth && o.minWidth > newWidth,
                isMinHeight = o.minHeight && o.minHeight > newHeight;
            o.grid = grid;
            if (isMinWidth) newWidth += gridX;
            if (isMinHeight) newHeight += gridY;
            if (isMaxWidth) newWidth -= gridX;
            if (isMaxHeight) newHeight -= gridY;
            if (/^(se|s|e)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight
            } else if (/^(ne)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.top = op.top - oy
            } else if (/^(sw)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.left =
                    op.left - ox
            } else {
                if (newHeight - gridY <= 0 || newWidth - gridX <= 0) outerDimensions = that._getPaddingPlusBorderDimensions(this);
                if (newHeight - gridY > 0) {
                    that.size.height = newHeight;
                    that.position.top = op.top - oy
                } else {
                    newHeight = gridY - outerDimensions.height;
                    that.size.height = newHeight;
                    that.position.top = op.top + os.height - newHeight
                }
                if (newWidth - gridX > 0) {
                    that.size.width = newWidth;
                    that.position.left = op.left - ox
                } else {
                    newWidth = gridX - outerDimensions.width;
                    that.size.width = newWidth;
                    that.position.left = op.left + os.width - newWidth
                }
            }
        }
    });
    var widgetsResizable = $.ui.resizable;
    var widgetsSelectable = $.widget("ui.selectable", $.ui.mouse, {
        version: "1.12.1",
        options: {
            appendTo: "body",
            autoRefresh: true,
            distance: 0,
            filter: "*",
            tolerance: "touch",
            selected: null,
            selecting: null,
            start: null,
            stop: null,
            unselected: null,
            unselecting: null
        },
        _create: function() {
            var that = this;
            this._addClass("ui-selectable");
            this.dragged = false;
            this.refresh = function() {
                that.elementPos = $(that.element[0]).offset();
                that.selectees = $(that.options.filter, that.element[0]);
                that._addClass(that.selectees,
                    "ui-selectee");
                that.selectees.each(function() {
                    var $this = $(this),
                        selecteeOffset = $this.offset(),
                        pos = {
                            left: selecteeOffset.left - that.elementPos.left,
                            top: selecteeOffset.top - that.elementPos.top
                        };
                    $.data(this, "selectable-item", {
                        element: this,
                        $element: $this,
                        left: pos.left,
                        top: pos.top,
                        right: pos.left + $this.outerWidth(),
                        bottom: pos.top + $this.outerHeight(),
                        startselected: false,
                        selected: $this.hasClass("ui-selected"),
                        selecting: $this.hasClass("ui-selecting"),
                        unselecting: $this.hasClass("ui-unselecting")
                    })
                })
            };
            this.refresh();
            this._mouseInit();
            this.helper = $("<div>");
            this._addClass(this.helper, "ui-selectable-helper")
        },
        _destroy: function() {
            this.selectees.removeData("selectable-item");
            this._mouseDestroy()
        },
        _mouseStart: function(event) {
            var that = this,
                options = this.options;
            this.opos = [event.pageX, event.pageY];
            this.elementPos = $(this.element[0]).offset();
            if (this.options.disabled) return;
            this.selectees = $(options.filter, this.element[0]);
            this._trigger("start", event);
            $(options.appendTo).append(this.helper);
            this.helper.css({
                "left": event.pageX,
                "top": event.pageY,
                "width": 0,
                "height": 0
            });
            if (options.autoRefresh) this.refresh();
            this.selectees.filter(".ui-selected").each(function() {
                var selectee = $.data(this, "selectable-item");
                selectee.startselected = true;
                if (!event.metaKey && !event.ctrlKey) {
                    that._removeClass(selectee.$element, "ui-selected");
                    selectee.selected = false;
                    that._addClass(selectee.$element, "ui-unselecting");
                    selectee.unselecting = true;
                    that._trigger("unselecting", event, {
                        unselecting: selectee.element
                    })
                }
            });
            $(event.target).parents().addBack().each(function() {
                var doSelect,
                    selectee = $.data(this, "selectable-item");
                if (selectee) {
                    doSelect = !event.metaKey && !event.ctrlKey || !selectee.$element.hasClass("ui-selected");
                    that._removeClass(selectee.$element, doSelect ? "ui-unselecting" : "ui-selected")._addClass(selectee.$element, doSelect ? "ui-selecting" : "ui-unselecting");
                    selectee.unselecting = !doSelect;
                    selectee.selecting = doSelect;
                    selectee.selected = doSelect;
                    if (doSelect) that._trigger("selecting", event, {
                        selecting: selectee.element
                    });
                    else that._trigger("unselecting", event, {
                        unselecting: selectee.element
                    });
                    return false
                }
            })
        },
        _mouseDrag: function(event) {
            this.dragged = true;
            if (this.options.disabled) return;
            var tmp, that = this,
                options = this.options,
                x1 = this.opos[0],
                y1 = this.opos[1],
                x2 = event.pageX,
                y2 = event.pageY;
            if (x1 > x2) {
                tmp = x2;
                x2 = x1;
                x1 = tmp
            }
            if (y1 > y2) {
                tmp = y2;
                y2 = y1;
                y1 = tmp
            }
            this.helper.css({
                left: x1,
                top: y1,
                width: x2 - x1,
                height: y2 - y1
            });
            this.selectees.each(function() {
                var selectee = $.data(this, "selectable-item"),
                    hit = false,
                    offset = {};
                if (!selectee || selectee.element === that.element[0]) return;
                offset.left = selectee.left + that.elementPos.left;
                offset.right = selectee.right + that.elementPos.left;
                offset.top = selectee.top + that.elementPos.top;
                offset.bottom = selectee.bottom + that.elementPos.top;
                if (options.tolerance === "touch") hit = !(offset.left > x2 || offset.right < x1 || offset.top > y2 || offset.bottom < y1);
                else if (options.tolerance === "fit") hit = offset.left > x1 && offset.right < x2 && offset.top > y1 && offset.bottom < y2;
                if (hit) {
                    if (selectee.selected) {
                        that._removeClass(selectee.$element, "ui-selected");
                        selectee.selected = false
                    }
                    if (selectee.unselecting) {
                        that._removeClass(selectee.$element,
                            "ui-unselecting");
                        selectee.unselecting = false
                    }
                    if (!selectee.selecting) {
                        that._addClass(selectee.$element, "ui-selecting");
                        selectee.selecting = true;
                        that._trigger("selecting", event, {
                            selecting: selectee.element
                        })
                    }
                } else {
                    if (selectee.selecting)
                        if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
                            that._removeClass(selectee.$element, "ui-selecting");
                            selectee.selecting = false;
                            that._addClass(selectee.$element, "ui-selected");
                            selectee.selected = true
                        } else {
                            that._removeClass(selectee.$element, "ui-selecting");
                            selectee.selecting =
                                false;
                            if (selectee.startselected) {
                                that._addClass(selectee.$element, "ui-unselecting");
                                selectee.unselecting = true
                            }
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            })
                        }
                    if (selectee.selected)
                        if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
                            that._removeClass(selectee.$element, "ui-selected");
                            selectee.selected = false;
                            that._addClass(selectee.$element, "ui-unselecting");
                            selectee.unselecting = true;
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            })
                        }
                }
            });
            return false
        },
        _mouseStop: function(event) {
            var that =
                this;
            this.dragged = false;
            $(".ui-unselecting", this.element[0]).each(function() {
                var selectee = $.data(this, "selectable-item");
                that._removeClass(selectee.$element, "ui-unselecting");
                selectee.unselecting = false;
                selectee.startselected = false;
                that._trigger("unselected", event, {
                    unselected: selectee.element
                })
            });
            $(".ui-selecting", this.element[0]).each(function() {
                var selectee = $.data(this, "selectable-item");
                that._removeClass(selectee.$element, "ui-selecting")._addClass(selectee.$element, "ui-selected");
                selectee.selecting =
                    false;
                selectee.selected = true;
                selectee.startselected = true;
                that._trigger("selected", event, {
                    selected: selectee.element
                })
            });
            this._trigger("stop", event);
            this.helper.remove();
            return false
        }
    });
    var widgetsSortable = $.widget("ui.sortable", $.ui.mouse, {
        version: "1.12.1",
        widgetEventPrefix: "sort",
        ready: false,
        options: {
            appendTo: "parent",
            axis: false,
            connectWith: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            dropOnEmpty: true,
            forcePlaceholderSize: false,
            forceHelperSize: false,
            grid: false,
            handle: false,
            helper: "original",
            items: "> *",
            opacity: false,
            placeholder: false,
            revert: false,
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            scope: "default",
            tolerance: "intersect",
            zIndex: 1E3,
            activate: null,
            beforeStop: null,
            change: null,
            deactivate: null,
            out: null,
            over: null,
            receive: null,
            remove: null,
            sort: null,
            start: null,
            stop: null,
            update: null
        },
        _isOverAxis: function(x, reference, size) {
            return x >= reference && x < reference + size
        },
        _isFloating: function(item) {
            return /left|right/.test(item.css("float")) || /inline|table-cell/.test(item.css("display"))
        },
        _create: function() {
            this.containerCache = {};
            this._addClass("ui-sortable");
            this.refresh();
            this.offset = this.element.offset();
            this._mouseInit();
            this._setHandleClassName();
            this.ready = true
        },
        _setOption: function(key, value) {
            this._super(key, value);
            if (key === "handle") this._setHandleClassName()
        },
        _setHandleClassName: function() {
            var that = this;
            this._removeClass(this.element.find(".ui-sortable-handle"), "ui-sortable-handle");
            $.each(this.items, function() {
                that._addClass(this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item, "ui-sortable-handle")
            })
        },
        _destroy: function() {
            this._mouseDestroy();
            for (var i = this.items.length - 1; i >= 0; i--) this.items[i].item.removeData(this.widgetName + "-item");
            return this
        },
        _mouseCapture: function(event, overrideHandle) {
            var currentItem = null,
                validHandle = false,
                that = this;
            if (this.reverting) return false;
            if (this.options.disabled || this.options.type === "static") return false;
            this._refreshItems(event);
            $(event.target).parents().each(function() {
                if ($.data(this, that.widgetName + "-item") === that) {
                    currentItem = $(this);
                    return false
                }
            });
            if ($.data(event.target,
                    that.widgetName + "-item") === that) currentItem = $(event.target);
            if (!currentItem) return false;
            if (this.options.handle && !overrideHandle) {
                $(this.options.handle, currentItem).find("*").addBack().each(function() {
                    if (this === event.target) validHandle = true
                });
                if (!validHandle) return false
            }
            this.currentItem = currentItem;
            this._removeCurrentsFromItems();
            return true
        },
        _mouseStart: function(event, overrideHandle, noActivation) {
            var i, body, o = this.options;
            this.currentContainer = this;
            this.refreshPositions();
            this.helper = this._createHelper(event);
            this._cacheHelperProportions();
            this._cacheMargins();
            this.scrollParent = this.helper.scrollParent();
            this.offset = this.currentItem.offset();
            this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            };
            $.extend(this.offset, {
                click: {
                    left: event.pageX - this.offset.left,
                    top: event.pageY - this.offset.top
                },
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            });
            this.helper.css("position", "absolute");
            this.cssPosition = this.helper.css("position");
            this.originalPosition = this._generatePosition(event);
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;
            o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
            this.domPosition = {
                prev: this.currentItem.prev()[0],
                parent: this.currentItem.parent()[0]
            };
            if (this.helper[0] !== this.currentItem[0]) this.currentItem.hide();
            this._createPlaceholder();
            if (o.containment) this._setContainment();
            if (o.cursor && o.cursor !== "auto") {
                body = this.document.find("body");
                this.storedCursor = body.css("cursor");
                body.css("cursor", o.cursor);
                this.storedStylesheet = $("<style>*{ cursor: " +
                    o.cursor + " !important; }</style>").appendTo(body)
            }
            if (o.opacity) {
                if (this.helper.css("opacity")) this._storedOpacity = this.helper.css("opacity");
                this.helper.css("opacity", o.opacity)
            }
            if (o.zIndex) {
                if (this.helper.css("zIndex")) this._storedZIndex = this.helper.css("zIndex");
                this.helper.css("zIndex", o.zIndex)
            }
            if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") this.overflowOffset = this.scrollParent.offset();
            this._trigger("start", event, this._uiHash());
            if (!this._preserveHelperProportions) this._cacheHelperProportions();
            if (!noActivation)
                for (i = this.containers.length - 1; i >= 0; i--) this.containers[i]._trigger("activate", event, this._uiHash(this));
            if ($.ui.ddmanager) $.ui.ddmanager.current = this;
            if ($.ui.ddmanager && !o.dropBehaviour) $.ui.ddmanager.prepareOffsets(this, event);
            this.dragging = true;
            this._addClass(this.helper, "ui-sortable-helper");
            this._mouseDrag(event);
            return true
        },
        _mouseDrag: function(event) {
            var i, item, itemElement, intersection, o = this.options,
                scrolled = false;
            this.position = this._generatePosition(event);
            this.positionAbs =
                this._convertPositionTo("absolute");
            if (!this.lastPositionAbs) this.lastPositionAbs = this.positionAbs;
            if (this.options.scroll) {
                if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
                    if (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
                    else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop -
                        o.scrollSpeed;
                    if (this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
                    else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed
                } else {
                    if (event.pageY - this.document.scrollTop() < o.scrollSensitivity) scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);
                    else if (this.window.height() -
                        (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);
                    if (event.pageX - this.document.scrollLeft() < o.scrollSensitivity) scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);
                    else if (this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed)
                }
                if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) $.ui.ddmanager.prepareOffsets(this,
                    event)
            }
            this.positionAbs = this._convertPositionTo("absolute");
            if (!this.options.axis || this.options.axis !== "y") this.helper[0].style.left = this.position.left + "px";
            if (!this.options.axis || this.options.axis !== "x") this.helper[0].style.top = this.position.top + "px";
            for (i = this.items.length - 1; i >= 0; i--) {
                item = this.items[i];
                itemElement = item.item[0];
                intersection = this._intersectsWithPointer(item);
                if (!intersection) continue;
                if (item.instance !== this.currentContainer) continue;
                if (itemElement !== this.currentItem[0] && this.placeholder[intersection ===
                        1 ? "next" : "prev"]()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)) {
                    this.direction = intersection === 1 ? "down" : "up";
                    if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) this._rearrange(event, item);
                    else break;
                    this._trigger("change", event, this._uiHash());
                    break
                }
            }
            this._contactContainers(event);
            if ($.ui.ddmanager) $.ui.ddmanager.drag(this, event);
            this._trigger("sort", event, this._uiHash());
            this.lastPositionAbs =
                this.positionAbs;
            return false
        },
        _mouseStop: function(event, noPropagation) {
            if (!event) return;
            if ($.ui.ddmanager && !this.options.dropBehaviour) $.ui.ddmanager.drop(this, event);
            if (this.options.revert) {
                var that = this,
                    cur = this.placeholder.offset(),
                    axis = this.options.axis,
                    animation = {};
                if (!axis || axis === "x") animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);
                if (!axis || axis === "y") animation.top = cur.top - this.offset.parent.top -
                    this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);
                this.reverting = true;
                $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function() {
                    that._clear(event)
                })
            } else this._clear(event, noPropagation);
            return false
        },
        cancel: function() {
            if (this.dragging) {
                this._mouseUp(new $.Event("mouseup", {
                    target: null
                }));
                if (this.options.helper === "original") {
                    this.currentItem.css(this._storedCSS);
                    this._removeClass(this.currentItem, "ui-sortable-helper")
                } else this.currentItem.show();
                for (var i = this.containers.length - 1; i >= 0; i--) {
                    this.containers[i]._trigger("deactivate", null, this._uiHash(this));
                    if (this.containers[i].containerCache.over) {
                        this.containers[i]._trigger("out", null, this._uiHash(this));
                        this.containers[i].containerCache.over = 0
                    }
                }
            }
            if (this.placeholder) {
                if (this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
                if (this.options.helper !== "original" && this.helper && this.helper[0].parentNode) this.helper.remove();
                $.extend(this, {
                    helper: null,
                    dragging: false,
                    reverting: false,
                    _noFinalSort: null
                });
                if (this.domPosition.prev) $(this.domPosition.prev).after(this.currentItem);
                else $(this.domPosition.parent).prepend(this.currentItem)
            }
            return this
        },
        serialize: function(o) {
            var items = this._getItemsAsjQuery(o && o.connected),
                str = [];
            o = o || {};
            $(items).each(function() {
                var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || /(.+)[\-=_](.+)/);
                if (res) str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]))
            });
            if (!str.length && o.key) str.push(o.key +
                "=");
            return str.join("&")
        },
        toArray: function(o) {
            var items = this._getItemsAsjQuery(o && o.connected),
                ret = [];
            o = o || {};
            items.each(function() {
                ret.push($(o.item || this).attr(o.attribute || "id") || "")
            });
            return ret
        },
        _intersectsWith: function(item) {
            var x1 = this.positionAbs.left,
                x2 = x1 + this.helperProportions.width,
                y1 = this.positionAbs.top,
                y2 = y1 + this.helperProportions.height,
                l = item.left,
                r = l + item.width,
                t = item.top,
                b = t + item.height,
                dyClick = this.offset.click.top,
                dxClick = this.offset.click.left,
                isOverElementHeight = this.options.axis ===
                "x" || y1 + dyClick > t && y1 + dyClick < b,
                isOverElementWidth = this.options.axis === "y" || x1 + dxClick > l && x1 + dxClick < r,
                isOverElement = isOverElementHeight && isOverElementWidth;
            if (this.options.tolerance === "pointer" || this.options.forcePointerForContainers || this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"]) return isOverElement;
            else return l < x1 + this.helperProportions.width / 2 && x2 - this.helperProportions.width / 2 < r && t < y1 + this.helperProportions.height /
                2 && y2 - this.helperProportions.height / 2 < b
        },
        _intersectsWithPointer: function(item) {
            var verticalDirection, horizontalDirection, isOverElementHeight = this.options.axis === "x" || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
                isOverElementWidth = this.options.axis === "y" || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
                isOverElement = isOverElementHeight && isOverElementWidth;
            if (!isOverElement) return false;
            verticalDirection = this._getDragVerticalDirection();
            horizontalDirection = this._getDragHorizontalDirection();
            return this.floating ? horizontalDirection === "right" || verticalDirection === "down" ? 2 : 1 : verticalDirection && (verticalDirection === "down" ? 2 : 1)
        },
        _intersectsWithSides: function(item) {
            var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height),
                isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width),
                verticalDirection = this._getDragVerticalDirection(),
                horizontalDirection = this._getDragHorizontalDirection();
            if (this.floating && horizontalDirection) return horizontalDirection === "right" && isOverRightHalf || horizontalDirection === "left" && !isOverRightHalf;
            else return verticalDirection && (verticalDirection === "down" && isOverBottomHalf || verticalDirection === "up" && !isOverBottomHalf)
        },
        _getDragVerticalDirection: function() {
            var delta = this.positionAbs.top - this.lastPositionAbs.top;
            return delta !== 0 && (delta > 0 ? "down" : "up")
        },
        _getDragHorizontalDirection: function() {
            var delta =
                this.positionAbs.left - this.lastPositionAbs.left;
            return delta !== 0 && (delta > 0 ? "right" : "left")
        },
        refresh: function(event) {
            this._refreshItems(event);
            this._setHandleClassName();
            this.refreshPositions();
            return this
        },
        _connectWith: function() {
            var options = this.options;
            return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith
        },
        _getItemsAsjQuery: function(connected) {
            var i, j, cur, inst, items = [],
                queries = [],
                connectWith = this._connectWith();
            if (connectWith && connected)
                for (i = connectWith.length -
                    1; i >= 0; i--) {
                    cur = $(connectWith[i], this.document[0]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst])
                    }
                }
            queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
                options: this.options,
                item: this.currentItem
            }) : $(this.options.items,
                this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);

            function addItems() {
                items.push(this)
            }
            for (i = queries.length - 1; i >= 0; i--) queries[i][0].each(addItems);
            return $(items)
        },
        _removeCurrentsFromItems: function() {
            var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
            this.items = $.grep(this.items, function(item) {
                for (var j = 0; j < list.length; j++)
                    if (list[j] === item.item[0]) return false;
                return true
            })
        },
        _refreshItems: function(event) {
            this.items = [];
            this.containers = [this];
            var i, j, cur,
                inst, targetData, _queries, item, queriesLength, items = this.items,
                queries = [
                    [$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, {
                        item: this.currentItem
                    }) : $(this.options.items, this.element), this]
                ],
                connectWith = this._connectWith();
            if (connectWith && this.ready)
                for (i = connectWith.length - 1; i >= 0; i--) {
                    cur = $(connectWith[i], this.document[0]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) {
                            queries.push([$.isFunction(inst.options.items) ?
                                inst.options.items.call(inst.element[0], event, {
                                    item: this.currentItem
                                }) : $(inst.options.items, inst.element), inst
                            ]);
                            this.containers.push(inst)
                        }
                    }
                }
            for (i = queries.length - 1; i >= 0; i--) {
                targetData = queries[i][1];
                _queries = queries[i][0];
                for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
                    item = $(_queries[j]);
                    item.data(this.widgetName + "-item", targetData);
                    items.push({
                        item: item,
                        instance: targetData,
                        width: 0,
                        height: 0,
                        left: 0,
                        top: 0
                    })
                }
            }
        },
        refreshPositions: function(fast) {
            this.floating = this.items.length ? this.options.axis ===
                "x" || this._isFloating(this.items[0].item) : false;
            if (this.offsetParent && this.helper) this.offset.parent = this._getParentOffset();
            var i, item, t, p;
            for (i = this.items.length - 1; i >= 0; i--) {
                item = this.items[i];
                if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) continue;
                t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
                if (!fast) {
                    item.width = t.outerWidth();
                    item.height = t.outerHeight()
                }
                p = t.offset();
                item.left = p.left;
                item.top = p.top
            }
            if (this.options.custom &&
                this.options.custom.refreshContainers) this.options.custom.refreshContainers.call(this);
            else
                for (i = this.containers.length - 1; i >= 0; i--) {
                    p = this.containers[i].element.offset();
                    this.containers[i].containerCache.left = p.left;
                    this.containers[i].containerCache.top = p.top;
                    this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
                    this.containers[i].containerCache.height = this.containers[i].element.outerHeight()
                }
            return this
        },
        _createPlaceholder: function(that) {
            that = that || this;
            var className, o =
                that.options;
            if (!o.placeholder || o.placeholder.constructor === String) {
                className = o.placeholder;
                o.placeholder = {
                    element: function() {
                        var nodeName = that.currentItem[0].nodeName.toLowerCase(),
                            element = $("<" + nodeName + ">", that.document[0]);
                        that._addClass(element, "ui-sortable-placeholder", className || that.currentItem[0].className)._removeClass(element, "ui-sortable-helper");
                        if (nodeName === "tbody") that._createTrPlaceholder(that.currentItem.find("tr").eq(0), $("<tr>", that.document[0]).appendTo(element));
                        else if (nodeName ===
                            "tr") that._createTrPlaceholder(that.currentItem, element);
                        else if (nodeName === "img") element.attr("src", that.currentItem.attr("src"));
                        if (!className) element.css("visibility", "hidden");
                        return element
                    },
                    update: function(container, p) {
                        if (className && !o.forcePlaceholderSize) return;
                        if (!p.height()) p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10));
                        if (!p.width()) p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") ||
                            0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10))
                    }
                }
            }
            that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
            that.currentItem.after(that.placeholder);
            o.placeholder.update(that, that.placeholder)
        },
        _createTrPlaceholder: function(sourceTr, targetTr) {
            var that = this;
            sourceTr.children().each(function() {
                $("<td>&#160;</td>", that.document[0]).attr("colspan", $(this).attr("colspan") || 1).appendTo(targetTr)
            })
        },
        _contactContainers: function(event) {
            var i, j, dist, itemWithLeastDistance, posProperty,
                sizeProperty, cur, nearBottom, floating, axis, innermostContainer = null,
                innermostIndex = null;
            for (i = this.containers.length - 1; i >= 0; i--) {
                if ($.contains(this.currentItem[0], this.containers[i].element[0])) continue;
                if (this._intersectsWith(this.containers[i].containerCache)) {
                    if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) continue;
                    innermostContainer = this.containers[i];
                    innermostIndex = i
                } else if (this.containers[i].containerCache.over) {
                    this.containers[i]._trigger("out",
                        event, this._uiHash(this));
                    this.containers[i].containerCache.over = 0
                }
            }
            if (!innermostContainer) return;
            if (this.containers.length === 1) {
                if (!this.containers[innermostIndex].containerCache.over) {
                    this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                    this.containers[innermostIndex].containerCache.over = 1
                }
            } else {
                dist = 1E4;
                itemWithLeastDistance = null;
                floating = innermostContainer.floating || this._isFloating(this.currentItem);
                posProperty = floating ? "left" : "top";
                sizeProperty = floating ? "width" : "height";
                axis = floating ? "pageX" : "pageY";
                for (j = this.items.length - 1; j >= 0; j--) {
                    if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue;
                    if (this.items[j].item[0] === this.currentItem[0]) continue;
                    cur = this.items[j].item.offset()[posProperty];
                    nearBottom = false;
                    if (event[axis] - cur > this.items[j][sizeProperty] / 2) nearBottom = true;
                    if (Math.abs(event[axis] - cur) < dist) {
                        dist = Math.abs(event[axis] - cur);
                        itemWithLeastDistance = this.items[j];
                        this.direction = nearBottom ? "up" : "down"
                    }
                }
                if (!itemWithLeastDistance &&
                    !this.options.dropOnEmpty) return;
                if (this.currentContainer === this.containers[innermostIndex]) {
                    if (!this.currentContainer.containerCache.over) {
                        this.containers[innermostIndex]._trigger("over", event, this._uiHash());
                        this.currentContainer.containerCache.over = 1
                    }
                    return
                }
                itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
                this._trigger("change", event, this._uiHash());
                this.containers[innermostIndex]._trigger("change",
                    event, this._uiHash(this));
                this.currentContainer = this.containers[innermostIndex];
                this.options.placeholder.update(this.currentContainer, this.placeholder);
                this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                this.containers[innermostIndex].containerCache.over = 1
            }
        },
        _createHelper: function(event) {
            var o = this.options,
                helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : o.helper === "clone" ? this.currentItem.clone() : this.currentItem;
            if (!helper.parents("body").length) $(o.appendTo !==
                "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
            if (helper[0] === this.currentItem[0]) this._storedCSS = {
                width: this.currentItem[0].style.width,
                height: this.currentItem[0].style.height,
                position: this.currentItem.css("position"),
                top: this.currentItem.css("top"),
                left: this.currentItem.css("left")
            };
            if (!helper[0].style.width || o.forceHelperSize) helper.width(this.currentItem.width());
            if (!helper[0].style.height || o.forceHelperSize) helper.height(this.currentItem.height());
            return helper
        },
        _adjustOffsetFromHelper: function(obj) {
            if (typeof obj === "string") obj = obj.split(" ");
            if ($.isArray(obj)) obj = {
                left: +obj[0],
                top: +obj[1] || 0
            };
            if ("left" in obj) this.offset.click.left = obj.left + this.margins.left;
            if ("right" in obj) this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            if ("top" in obj) this.offset.click.top = obj.top + this.margins.top;
            if ("bottom" in obj) this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top
        },
        _getParentOffset: function() {
            this.offsetParent =
                this.helper.offsetParent();
            var po = this.offsetParent.offset();
            if (this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop()
            }
            if (this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie) po = {
                top: 0,
                left: 0
            };
            return {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            }
        },
        _getRelativeOffset: function() {
            if (this.cssPosition === "relative") {
                var p = this.currentItem.position();
                return {
                    top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                    left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                }
            } else return {
                top: 0,
                left: 0
            }
        },
        _cacheMargins: function() {
            this.margins = {
                left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
                top: parseInt(this.currentItem.css("marginTop"),
                    10) || 0
            }
        },
        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            }
        },
        _setContainment: function() {
            var ce, co, over, o = this.options;
            if (o.containment === "parent") o.containment = this.helper[0].parentNode;
            if (o.containment === "document" || o.containment === "window") this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, o.containment === "document" ? this.document.width() : this.window.width() -
                this.helperProportions.width - this.margins.left, (o.containment === "document" ? this.document.height() || document.body.parentNode.scrollHeight : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
            ];
            if (!/^(document|window|parent)$/.test(o.containment)) {
                ce = $(o.containment)[0];
                co = $(o.containment).offset();
                over = $(ce).css("overflow") !== "hidden";
                this.containment = [co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"),
                    10) || 0) - this.margins.left, co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"),
                    10) || 0) - this.helperProportions.height - this.margins.top]
            }
        },
        _convertPositionTo: function(d, pos) {
            if (!pos) pos = this.position;
            var mod = d === "absolute" ? 1 : -1,
                scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
                scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
            return {
                top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() :
                    scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,
                left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod
            }
        },
        _generatePosition: function(event) {
            var top, left, o = this.options,
                pageX = event.pageX,
                pageY = event.pageY,
                scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
                scrollIsRootNode =
                /(html|body)/i.test(scroll[0].tagName);
            if (this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) this.offset.relative = this._getRelativeOffset();
            if (this.originalPosition) {
                if (this.containment) {
                    if (event.pageX - this.offset.click.left < this.containment[0]) pageX = this.containment[0] + this.offset.click.left;
                    if (event.pageY - this.offset.click.top < this.containment[1]) pageY = this.containment[1] + this.offset.click.top;
                    if (event.pageX - this.offset.click.left >
                        this.containment[2]) pageX = this.containment[2] + this.offset.click.left;
                    if (event.pageY - this.offset.click.top > this.containment[3]) pageY = this.containment[3] + this.offset.click.top
                }
                if (o.grid) {
                    top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
                    pageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
                    left = this.originalPageX + Math.round((pageX -
                        this.originalPageX) / o.grid[0]) * o.grid[0];
                    pageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left
                }
            }
            return {
                top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),
                left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left +
                    (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())
            }
        },
        _rearrange: function(event, i, a, hardRefresh) {
            a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], this.direction === "down" ? i.item[0] : i.item[0].nextSibling);
            this.counter = this.counter ? ++this.counter : 1;
            var counter = this.counter;
            this._delay(function() {
                if (counter === this.counter) this.refreshPositions(!hardRefresh)
            })
        },
        _clear: function(event, noPropagation) {
            this.reverting =
                false;
            var i, delayedTriggers = [];
            if (!this._noFinalSort && this.currentItem.parent().length) this.placeholder.before(this.currentItem);
            this._noFinalSort = null;
            if (this.helper[0] === this.currentItem[0]) {
                for (i in this._storedCSS)
                    if (this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") this._storedCSS[i] = "";
                this.currentItem.css(this._storedCSS);
                this._removeClass(this.currentItem, "ui-sortable-helper")
            } else this.currentItem.show();
            if (this.fromOutside && !noPropagation) delayedTriggers.push(function(event) {
                this._trigger("receive",
                    event, this._uiHash(this.fromOutside))
            });
            if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) delayedTriggers.push(function(event) {
                this._trigger("update", event, this._uiHash())
            });
            if (this !== this.currentContainer)
                if (!noPropagation) {
                    delayedTriggers.push(function(event) {
                        this._trigger("remove", event, this._uiHash())
                    });
                    delayedTriggers.push(function(c) {
                        return function(event) {
                            c._trigger("receive",
                                event, this._uiHash(this))
                        }
                    }.call(this, this.currentContainer));
                    delayedTriggers.push(function(c) {
                        return function(event) {
                            c._trigger("update", event, this._uiHash(this))
                        }
                    }.call(this, this.currentContainer))
                }
            function delayEvent(type, instance, container) {
                return function(event) {
                    container._trigger(type, event, instance._uiHash(instance))
                }
            }
            for (i = this.containers.length - 1; i >= 0; i--) {
                if (!noPropagation) delayedTriggers.push(delayEvent("deactivate", this, this.containers[i]));
                if (this.containers[i].containerCache.over) {
                    delayedTriggers.push(delayEvent("out",
                        this, this.containers[i]));
                    this.containers[i].containerCache.over = 0
                }
            }
            if (this.storedCursor) {
                this.document.find("body").css("cursor", this.storedCursor);
                this.storedStylesheet.remove()
            }
            if (this._storedOpacity) this.helper.css("opacity", this._storedOpacity);
            if (this._storedZIndex) this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
            this.dragging = false;
            if (!noPropagation) this._trigger("beforeStop", event, this._uiHash());
            this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
            if (!this.cancelHelperRemoval) {
                if (this.helper[0] !==
                    this.currentItem[0]) this.helper.remove();
                this.helper = null
            }
            if (!noPropagation) {
                for (i = 0; i < delayedTriggers.length; i++) delayedTriggers[i].call(this, event);
                this._trigger("stop", event, this._uiHash())
            }
            this.fromOutside = false;
            return !this.cancelHelperRemoval
        },
        _trigger: function() {
            if ($.Widget.prototype._trigger.apply(this, arguments) === false) this.cancel()
        },
        _uiHash: function(_inst) {
            var inst = _inst || this;
            return {
                helper: inst.helper,
                placeholder: inst.placeholder || $([]),
                position: inst.position,
                originalPosition: inst.originalPosition,
                offset: inst.positionAbs,
                item: inst.currentItem,
                sender: _inst ? _inst.element : null
            }
        }
    });
    var controlgroupCornerRegex = /ui-corner-([a-z]){2,6}/g;
    var widgetsControlgroup = $.widget("ui.controlgroup", {
        version: "1.12.1",
        defaultElement: "<div>",
        options: {
            direction: "horizontal",
            disabled: null,
            onlyVisible: true,
            items: {
                "button": "input[type=button], input[type=submit], input[type=reset], button, a",
                "controlgroupLabel": ".ui-controlgroup-label",
                "checkboxradio": "input[type='checkbox'], input[type='radio']",
                "selectmenu": "select",
                "spinner": ".ui-spinner-input"
            }
        },
        _create: function() {
            this._enhance()
        },
        _enhance: function() {
            this.element.attr("role", "toolbar");
            this.refresh()
        },
        _destroy: function() {
            this._callChildMethod("destroy");
            this.childWidgets.removeData("ui-controlgroup-data");
            this.element.removeAttr("role");
            if (this.options.items.controlgroupLabel) this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap()
        },
        _initWidgets: function() {
            var that = this,
                childWidgets = [];
            $.each(this.options.items,
                function(widget, selector) {
                    var labels;
                    var options = {};
                    if (!selector) return;
                    if (widget === "controlgroupLabel") {
                        labels = that.element.find(selector);
                        labels.each(function() {
                            var element = $(this);
                            if (element.children(".ui-controlgroup-label-contents").length) return;
                            element.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>")
                        });
                        that._addClass(labels, null, "ui-widget ui-widget-content ui-state-default");
                        childWidgets = childWidgets.concat(labels.get());
                        return
                    }
                    if (!$.fn[widget]) return;
                    if (that["_" +
                            widget + "Options"]) options = that["_" + widget + "Options"]("middle");
                    else options = {
                        classes: {}
                    };
                    that.element.find(selector).each(function() {
                        var element = $(this);
                        var instance = element[widget]("instance");
                        var instanceOptions = $.widget.extend({}, options);
                        if (widget === "button" && element.parent(".ui-spinner").length) return;
                        if (!instance) instance = element[widget]()[widget]("instance");
                        if (instance) instanceOptions.classes = that._resolveClassesValues(instanceOptions.classes, instance);
                        element[widget](instanceOptions);
                        var widgetElement =
                            element[widget]("widget");
                        $.data(widgetElement[0], "ui-controlgroup-data", instance ? instance : element[widget]("instance"));
                        childWidgets.push(widgetElement[0])
                    })
                });
            this.childWidgets = $($.unique(childWidgets));
            this._addClass(this.childWidgets, "ui-controlgroup-item")
        },
        _callChildMethod: function(method) {
            this.childWidgets.each(function() {
                var element = $(this),
                    data = element.data("ui-controlgroup-data");
                if (data && data[method]) data[method]()
            })
        },
        _updateCornerClass: function(element, position) {
            var remove = "ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all";
            var add = this._buildSimpleOptions(position, "label").classes.label;
            this._removeClass(element, null, remove);
            this._addClass(element, null, add)
        },
        _buildSimpleOptions: function(position, key) {
            var direction = this.options.direction === "vertical";
            var result = {
                classes: {}
            };
            result.classes[key] = {
                "middle": "",
                "first": "ui-corner-" + (direction ? "top" : "left"),
                "last": "ui-corner-" + (direction ? "bottom" : "right"),
                "only": "ui-corner-all"
            }[position];
            return result
        },
        _spinnerOptions: function(position) {
            var options = this._buildSimpleOptions(position,
                "ui-spinner");
            options.classes["ui-spinner-up"] = "";
            options.classes["ui-spinner-down"] = "";
            return options
        },
        _buttonOptions: function(position) {
            return this._buildSimpleOptions(position, "ui-button")
        },
        _checkboxradioOptions: function(position) {
            return this._buildSimpleOptions(position, "ui-checkboxradio-label")
        },
        _selectmenuOptions: function(position) {
            var direction = this.options.direction === "vertical";
            return {
                width: direction ? "auto" : false,
                classes: {
                    middle: {
                        "ui-selectmenu-button-open": "",
                        "ui-selectmenu-button-closed": ""
                    },
                    first: {
                        "ui-selectmenu-button-open": "ui-corner-" + (direction ? "top" : "tl"),
                        "ui-selectmenu-button-closed": "ui-corner-" + (direction ? "top" : "left")
                    },
                    last: {
                        "ui-selectmenu-button-open": direction ? "" : "ui-corner-tr",
                        "ui-selectmenu-button-closed": "ui-corner-" + (direction ? "bottom" : "right")
                    },
                    only: {
                        "ui-selectmenu-button-open": "ui-corner-top",
                        "ui-selectmenu-button-closed": "ui-corner-all"
                    }
                }[position]
            }
        },
        _resolveClassesValues: function(classes, instance) {
            var result = {};
            $.each(classes, function(key) {
                var current = instance.options.classes[key] ||
                    "";
                current = $.trim(current.replace(controlgroupCornerRegex, ""));
                result[key] = (current + " " + classes[key]).replace(/\s+/g, " ")
            });
            return result
        },
        _setOption: function(key, value) {
            if (key === "direction") this._removeClass("ui-controlgroup-" + this.options.direction);
            this._super(key, value);
            if (key === "disabled") {
                this._callChildMethod(value ? "disable" : "enable");
                return
            }
            this.refresh()
        },
        refresh: function() {
            var children, that = this;
            this._addClass("ui-controlgroup ui-controlgroup-" + this.options.direction);
            if (this.options.direction ===
                "horizontal") this._addClass(null, "ui-helper-clearfix");
            this._initWidgets();
            children = this.childWidgets;
            if (this.options.onlyVisible) children = children.filter(":visible");
            if (children.length) {
                $.each(["first", "last"], function(index, value) {
                    var instance = children[value]().data("ui-controlgroup-data");
                    if (instance && that["_" + instance.widgetName + "Options"]) {
                        var options = that["_" + instance.widgetName + "Options"](children.length === 1 ? "only" : value);
                        options.classes = that._resolveClassesValues(options.classes, instance);
                        instance.element[instance.widgetName](options)
                    } else that._updateCornerClass(children[value](), value)
                });
                this._callChildMethod("refresh")
            }
        }
    });
    $.widget("ui.checkboxradio", [$.ui.formResetMixin, {
        version: "1.12.1",
        options: {
            disabled: null,
            label: null,
            icon: true,
            classes: {
                "ui-checkboxradio-label": "ui-corner-all",
                "ui-checkboxradio-icon": "ui-corner-all"
            }
        },
        _getCreateOptions: function() {
            var disabled, labels;
            var that = this;
            var options = this._super() || {};
            this._readType();
            labels = this.element.labels();
            this.label = $(labels[labels.length -
                1]);
            if (!this.label.length) $.error("No label found for checkboxradio widget");
            this.originalLabel = "";
            this.label.contents().not(this.element[0]).each(function() {
                that.originalLabel += this.nodeType === 3 ? $(this).text() : this.outerHTML
            });
            if (this.originalLabel) options.label = this.originalLabel;
            disabled = this.element[0].disabled;
            if (disabled != null) options.disabled = disabled;
            return options
        },
        _create: function() {
            var checked = this.element[0].checked;
            this._bindFormResetHandler();
            if (this.options.disabled == null) this.options.disabled =
                this.element[0].disabled;
            this._setOption("disabled", this.options.disabled);
            this._addClass("ui-checkboxradio", "ui-helper-hidden-accessible");
            this._addClass(this.label, "ui-checkboxradio-label", "ui-button ui-widget");
            if (this.type === "radio") this._addClass(this.label, "ui-checkboxradio-radio-label");
            if (this.options.label && this.options.label !== this.originalLabel) this._updateLabel();
            else if (this.originalLabel) this.options.label = this.originalLabel;
            this._enhance();
            if (checked) {
                this._addClass(this.label, "ui-checkboxradio-checked",
                    "ui-state-active");
                if (this.icon) this._addClass(this.icon, null, "ui-state-hover")
            }
            this._on({
                change: "_toggleClasses",
                focus: function() {
                    this._addClass(this.label, null, "ui-state-focus ui-visual-focus")
                },
                blur: function() {
                    this._removeClass(this.label, null, "ui-state-focus ui-visual-focus")
                }
            })
        },
        _readType: function() {
            var nodeName = this.element[0].nodeName.toLowerCase();
            this.type = this.element[0].type;
            if (nodeName !== "input" || !/radio|checkbox/.test(this.type)) $.error("Can't create checkboxradio on element.nodeName=" +
                nodeName + " and element.type=" + this.type)
        },
        _enhance: function() {
            this._updateIcon(this.element[0].checked)
        },
        widget: function() {
            return this.label
        },
        _getRadioGroup: function() {
            var group;
            var name = this.element[0].name;
            var nameSelector = "input[name='" + $.ui.escapeSelector(name) + "']";
            if (!name) return $([]);
            if (this.form.length) group = $(this.form[0].elements).filter(nameSelector);
            else group = $(nameSelector).filter(function() {
                return $(this).form().length === 0
            });
            return group.not(this.element)
        },
        _toggleClasses: function() {
            var checked =
                this.element[0].checked;
            this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", checked);
            if (this.options.icon && this.type === "checkbox") this._toggleClass(this.icon, null, "ui-icon-check ui-state-checked", checked)._toggleClass(this.icon, null, "ui-icon-blank", !checked);
            if (this.type === "radio") this._getRadioGroup().each(function() {
                var instance = $(this).checkboxradio("instance");
                if (instance) instance._removeClass(instance.label, "ui-checkboxradio-checked", "ui-state-active")
            })
        },
        _destroy: function() {
            this._unbindFormResetHandler();
            if (this.icon) {
                this.icon.remove();
                this.iconSpace.remove()
            }
        },
        _setOption: function(key, value) {
            if (key === "label" && !value) return;
            this._super(key, value);
            if (key === "disabled") {
                this._toggleClass(this.label, null, "ui-state-disabled", value);
                this.element[0].disabled = value;
                return
            }
            this.refresh()
        },
        _updateIcon: function(checked) {
            var toAdd = "ui-icon ui-icon-background ";
            if (this.options.icon) {
                if (!this.icon) {
                    this.icon = $("<span>");
                    this.iconSpace = $("<span> </span>");
                    this._addClass(this.iconSpace, "ui-checkboxradio-icon-space")
                }
                if (this.type ===
                    "checkbox") {
                    toAdd += checked ? "ui-icon-check ui-state-checked" : "ui-icon-blank";
                    this._removeClass(this.icon, null, checked ? "ui-icon-blank" : "ui-icon-check")
                } else toAdd += "ui-icon-blank";
                this._addClass(this.icon, "ui-checkboxradio-icon", toAdd);
                if (!checked) this._removeClass(this.icon, null, "ui-icon-check ui-state-checked");
                this.icon.prependTo(this.label).after(this.iconSpace)
            } else if (this.icon !== undefined) {
                this.icon.remove();
                this.iconSpace.remove();
                delete this.icon
            }
        },
        _updateLabel: function() {
            var contents = this.label.contents().not(this.element[0]);
            if (this.icon) contents = contents.not(this.icon[0]);
            if (this.iconSpace) contents = contents.not(this.iconSpace[0]);
            contents.remove();
            this.label.append(this.options.label)
        },
        refresh: function() {
            var checked = this.element[0].checked,
                isDisabled = this.element[0].disabled;
            this._updateIcon(checked);
            this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", checked);
            if (this.options.label !== null) this._updateLabel();
            if (isDisabled !== this.options.disabled) this._setOptions({
                "disabled": isDisabled
            })
        }
    }]);
    var widgetsCheckboxradio =
        $.ui.checkboxradio;
    $.widget("ui.button", {
        version: "1.12.1",
        defaultElement: "<button>",
        options: {
            classes: {
                "ui-button": "ui-corner-all"
            },
            disabled: null,
            icon: null,
            iconPosition: "beginning",
            label: null,
            showLabel: true
        },
        _getCreateOptions: function() {
            var disabled, options = this._super() || {};
            this.isInput = this.element.is("input");
            disabled = this.element[0].disabled;
            if (disabled != null) options.disabled = disabled;
            this.originalLabel = this.isInput ? this.element.val() : this.element.html();
            if (this.originalLabel) options.label = this.originalLabel;
            return options
        },
        _create: function() {
            if (!this.option.showLabel & !this.options.icon) this.options.showLabel = true;
            if (this.options.disabled == null) this.options.disabled = this.element[0].disabled || false;
            this.hasTitle = !!this.element.attr("title");
            if (this.options.label && this.options.label !== this.originalLabel)
                if (this.isInput) this.element.val(this.options.label);
                else this.element.html(this.options.label);
            this._addClass("ui-button", "ui-widget");
            this._setOption("disabled", this.options.disabled);
            this._enhance();
            if (this.element.is("a")) this._on({
                "keyup": function(event) {
                    if (event.keyCode === $.ui.keyCode.SPACE) {
                        event.preventDefault();
                        if (this.element[0].click) this.element[0].click();
                        else this.element.trigger("click")
                    }
                }
            })
        },
        _enhance: function() {
            if (!this.element.is("button")) this.element.attr("role", "button");
            if (this.options.icon) {
                this._updateIcon("icon", this.options.icon);
                this._updateTooltip()
            }
        },
        _updateTooltip: function() {
            this.title = this.element.attr("title");
            if (!this.options.showLabel && !this.title) this.element.attr("title",
                this.options.label)
        },
        _updateIcon: function(option, value) {
            var icon = option !== "iconPosition",
                position = icon ? this.options.iconPosition : value,
                displayBlock = position === "top" || position === "bottom";
            if (!this.icon) {
                this.icon = $("<span>");
                this._addClass(this.icon, "ui-button-icon", "ui-icon");
                if (!this.options.showLabel) this._addClass("ui-button-icon-only")
            } else if (icon) this._removeClass(this.icon, null, this.options.icon);
            if (icon) this._addClass(this.icon, null, value);
            this._attachIcon(position);
            if (displayBlock) {
                this._addClass(this.icon,
                    null, "ui-widget-icon-block");
                if (this.iconSpace) this.iconSpace.remove()
            } else {
                if (!this.iconSpace) {
                    this.iconSpace = $("<span> </span>");
                    this._addClass(this.iconSpace, "ui-button-icon-space")
                }
                this._removeClass(this.icon, null, "ui-wiget-icon-block");
                this._attachIconSpace(position)
            }
        },
        _destroy: function() {
            this.element.removeAttr("role");
            if (this.icon) this.icon.remove();
            if (this.iconSpace) this.iconSpace.remove();
            if (!this.hasTitle) this.element.removeAttr("title")
        },
        _attachIconSpace: function(iconPosition) {
            this.icon[/^(?:end|bottom)/.test(iconPosition) ?
                "before" : "after"](this.iconSpace)
        },
        _attachIcon: function(iconPosition) {
            this.element[/^(?:end|bottom)/.test(iconPosition) ? "append" : "prepend"](this.icon)
        },
        _setOptions: function(options) {
            var newShowLabel = options.showLabel === undefined ? this.options.showLabel : options.showLabel,
                newIcon = options.icon === undefined ? this.options.icon : options.icon;
            if (!newShowLabel && !newIcon) options.showLabel = true;
            this._super(options)
        },
        _setOption: function(key, value) {
            if (key === "icon")
                if (value) this._updateIcon(key, value);
                else if (this.icon) {
                this.icon.remove();
                if (this.iconSpace) this.iconSpace.remove()
            }
            if (key === "iconPosition") this._updateIcon(key, value);
            if (key === "showLabel") {
                this._toggleClass("ui-button-icon-only", null, !value);
                this._updateTooltip()
            }
            if (key === "label")
                if (this.isInput) this.element.val(value);
                else {
                    this.element.html(value);
                    if (this.icon) {
                        this._attachIcon(this.options.iconPosition);
                        this._attachIconSpace(this.options.iconPosition)
                    }
                }
            this._super(key, value);
            if (key === "disabled") {
                this._toggleClass(null, "ui-state-disabled", value);
                this.element[0].disabled =
                    value;
                if (value) this.element.blur()
            }
        },
        refresh: function() {
            var isDisabled = this.element.is("input, button") ? this.element[0].disabled : this.element.hasClass("ui-button-disabled");
            if (isDisabled !== this.options.disabled) this._setOptions({
                disabled: isDisabled
            });
            this._updateTooltip()
        }
    });
    if ($.uiBackCompat !== false) {
        $.widget("ui.button", $.ui.button, {
            options: {
                text: true,
                icons: {
                    primary: null,
                    secondary: null
                }
            },
            _create: function() {
                if (this.options.showLabel && !this.options.text) this.options.showLabel = this.options.text;
                if (!this.options.showLabel &&
                    this.options.text) this.options.text = this.options.showLabel;
                if (!this.options.icon && (this.options.icons.primary || this.options.icons.secondary))
                    if (this.options.icons.primary) this.options.icon = this.options.icons.primary;
                    else {
                        this.options.icon = this.options.icons.secondary;
                        this.options.iconPosition = "end"
                    } else if (this.options.icon) this.options.icons.primary = this.options.icon;
                this._super()
            },
            _setOption: function(key, value) {
                if (key === "text") {
                    this._super("showLabel", value);
                    return
                }
                if (key === "showLabel") this.options.text =
                    value;
                if (key === "icon") this.options.icons.primary = value;
                if (key === "icons")
                    if (value.primary) {
                        this._super("icon", value.primary);
                        this._super("iconPosition", "beginning")
                    } else if (value.secondary) {
                    this._super("icon", value.secondary);
                    this._super("iconPosition", "end")
                }
                this._superApply(arguments)
            }
        });
        $.fn.button = function(orig) {
            return function() {
                if (!this.length || this.length && this[0].tagName !== "INPUT" || this.length && this[0].tagName === "INPUT" && (this.attr("type") !== "checkbox" && this.attr("type") !== "radio")) return orig.apply(this,
                    arguments);
                if (!$.ui.checkboxradio) $.error("Checkboxradio widget missing");
                if (arguments.length === 0) return this.checkboxradio({
                    "icon": false
                });
                return this.checkboxradio.apply(this, arguments)
            }
        }($.fn.button);
        $.fn.buttonset = function() {
            if (!$.ui.controlgroup) $.error("Controlgroup widget missing");
            if (arguments[0] === "option" && arguments[1] === "items" && arguments[2]) return this.controlgroup.apply(this, [arguments[0], "items.button", arguments[2]]);
            if (arguments[0] === "option" && arguments[1] === "items") return this.controlgroup.apply(this, [arguments[0], "items.button"]);
            if (typeof arguments[0] === "object" && arguments[0].items) arguments[0].items = {
                button: arguments[0].items
            };
            return this.controlgroup.apply(this, arguments)
        }
    }
    var widgetsButton = $.ui.button;

    function spinnerModifer(fn) {
        return function() {
            var previous = this.element.val();
            fn.apply(this, arguments);
            this._refresh();
            if (previous !== this.element.val()) this._trigger("change")
        }
    }
    $.widget("ui.spinner", {
        version: "1.12.1",
        defaultElement: "<input>",
        widgetEventPrefix: "spin",
        options: {
            classes: {
                "ui-spinner": "ui-corner-all",
                "ui-spinner-down": "ui-corner-br",
                "ui-spinner-up": "ui-corner-tr"
            },
            culture: null,
            icons: {
                down: "ui-icon-triangle-1-s",
                up: "ui-icon-triangle-1-n"
            },
            incremental: true,
            max: null,
            min: null,
            numberFormat: null,
            page: 10,
            step: 1,
            change: null,
            spin: null,
            start: null,
            stop: null
        },
        _create: function() {
            this._setOption("max", this.options.max);
            this._setOption("min", this.options.min);
            this._setOption("step", this.options.step);
            if (this.value() !== "") this._value(this.element.val(), true);
            this._draw();
            this._on(this._events);
            this._refresh();
            this._on(this.window, {
                beforeunload: function() {
                    this.element.removeAttr("autocomplete")
                }
            })
        },
        _getCreateOptions: function() {
            var options = this._super();
            var element = this.element;
            $.each(["min", "max", "step"], function(i, option) {
                var value = element.attr(option);
                if (value != null && value.length) options[option] = value
            });
            return options
        },
        _events: {
            keydown: function(event) {
                if (this._start(event) && this._keydown(event)) event.preventDefault()
            },
            keyup: "_stop",
            focus: function() {
                this.previous = this.element.val()
            },
            blur: function(event) {
                if (this.cancelBlur) {
                    delete this.cancelBlur;
                    return
                }
                this._stop();
                this._refresh();
                if (this.previous !== this.element.val()) this._trigger("change", event)
            },
            mousewheel: function(event, delta) {
                if (!delta) return;
                if (!this.spinning && !this._start(event)) return false;
                this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
                clearTimeout(this.mousewheelTimer);
                this.mousewheelTimer = this._delay(function() {
                    if (this.spinning) this._stop(event)
                }, 100);
                event.preventDefault()
            },
            "mousedown .ui-spinner-button": function(event) {
                var previous;
                previous = this.element[0] === $.ui.safeActiveElement(this.document[0]) ?
                    this.previous : this.element.val();

                function checkFocus() {
                    var isActive = this.element[0] === $.ui.safeActiveElement(this.document[0]);
                    if (!isActive) {
                        this.element.trigger("focus");
                        this.previous = previous;
                        this._delay(function() {
                            this.previous = previous
                        })
                    }
                }
                event.preventDefault();
                checkFocus.call(this);
                this.cancelBlur = true;
                this._delay(function() {
                    delete this.cancelBlur;
                    checkFocus.call(this)
                });
                if (this._start(event) === false) return;
                this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event)
            },
            "mouseup .ui-spinner-button": "_stop",
            "mouseenter .ui-spinner-button": function(event) {
                if (!$(event.currentTarget).hasClass("ui-state-active")) return;
                if (this._start(event) === false) return false;
                this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event)
            },
            "mouseleave .ui-spinner-button": "_stop"
        },
        _enhance: function() {
            this.uiSpinner = this.element.attr("autocomplete", "off").wrap("<span>").parent().append("<a></a><a></a>")
        },
        _draw: function() {
            this._enhance();
            this._addClass(this.uiSpinner, "ui-spinner", "ui-widget ui-widget-content");
            this._addClass("ui-spinner-input");
            this.element.attr("role", "spinbutton");
            this.buttons = this.uiSpinner.children("a").attr("tabIndex", -1).attr("aria-hidden", true).button({
                classes: {
                    "ui-button": ""
                }
            });
            this._removeClass(this.buttons, "ui-corner-all");
            this._addClass(this.buttons.first(), "ui-spinner-button ui-spinner-up");
            this._addClass(this.buttons.last(), "ui-spinner-button ui-spinner-down");
            this.buttons.first().button({
                "icon": this.options.icons.up,
                "showLabel": false
            });
            this.buttons.last().button({
                "icon": this.options.icons.down,
                "showLabel": false
            });
            if (this.buttons.height() > Math.ceil(this.uiSpinner.height() * .5) && this.uiSpinner.height() > 0) this.uiSpinner.height(this.uiSpinner.height())
        },
        _keydown: function(event) {
            var options = this.options,
                keyCode = $.ui.keyCode;
            switch (event.keyCode) {
                case keyCode.UP:
                    this._repeat(null, 1, event);
                    return true;
                case keyCode.DOWN:
                    this._repeat(null, -1, event);
                    return true;
                case keyCode.PAGE_UP:
                    this._repeat(null, options.page, event);
                    return true;
                case keyCode.PAGE_DOWN:
                    this._repeat(null, -options.page, event);
                    return true
            }
            return false
        },
        _start: function(event) {
            if (!this.spinning && this._trigger("start", event) === false) return false;
            if (!this.counter) this.counter = 1;
            this.spinning = true;
            return true
        },
        _repeat: function(i, steps, event) {
            i = i || 500;
            clearTimeout(this.timer);
            this.timer = this._delay(function() {
                this._repeat(40, steps, event)
            }, i);
            this._spin(steps * this.options.step, event)
        },
        _spin: function(step, event) {
            var value = this.value() || 0;
            if (!this.counter) this.counter = 1;
            value = this._adjustValue(value + step * this._increment(this.counter));
            if (!this.spinning ||
                this._trigger("spin", event, {
                    value: value
                }) !== false) {
                this._value(value);
                this.counter++
            }
        },
        _increment: function(i) {
            var incremental = this.options.incremental;
            if (incremental) return $.isFunction(incremental) ? incremental(i) : Math.floor(i * i * i / 5E4 - i * i / 500 + 17 * i / 200 + 1);
            return 1
        },
        _precision: function() {
            var precision = this._precisionOf(this.options.step);
            if (this.options.min !== null) precision = Math.max(precision, this._precisionOf(this.options.min));
            return precision
        },
        _precisionOf: function(num) {
            var str = num.toString(),
                decimal =
                str.indexOf(".");
            return decimal === -1 ? 0 : str.length - decimal - 1
        },
        _adjustValue: function(value) {
            var base, aboveMin, options = this.options;
            base = options.min !== null ? options.min : 0;
            aboveMin = value - base;
            aboveMin = Math.round(aboveMin / options.step) * options.step;
            value = base + aboveMin;
            value = parseFloat(value.toFixed(this._precision()));
            if (options.max !== null && value > options.max) return options.max;
            if (options.min !== null && value < options.min) return options.min;
            return value
        },
        _stop: function(event) {
            if (!this.spinning) return;
            clearTimeout(this.timer);
            clearTimeout(this.mousewheelTimer);
            this.counter = 0;
            this.spinning = false;
            this._trigger("stop", event)
        },
        _setOption: function(key, value) {
            var prevValue, first, last;
            if (key === "culture" || key === "numberFormat") {
                prevValue = this._parse(this.element.val());
                this.options[key] = value;
                this.element.val(this._format(prevValue));
                return
            }
            if (key === "max" || key === "min" || key === "step")
                if (typeof value === "string") value = this._parse(value);
            if (key === "icons") {
                first = this.buttons.first().find(".ui-icon");
                this._removeClass(first, null, this.options.icons.up);
                this._addClass(first, null, value.up);
                last = this.buttons.last().find(".ui-icon");
                this._removeClass(last, null, this.options.icons.down);
                this._addClass(last, null, value.down)
            }
            this._super(key, value)
        },
        _setOptionDisabled: function(value) {
            this._super(value);
            this._toggleClass(this.uiSpinner, null, "ui-state-disabled", !!value);
            this.element.prop("disabled", !!value);
            this.buttons.button(value ? "disable" : "enable")
        },
        _setOptions: spinnerModifer(function(options) {
            this._super(options)
        }),
        _parse: function(val) {
            if (typeof val ===
                "string" && val !== "") val = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(val, 10, this.options.culture) : +val;
            return val === "" || isNaN(val) ? null : val
        },
        _format: function(value) {
            if (value === "") return "";
            return window.Globalize && this.options.numberFormat ? Globalize.format(value, this.options.numberFormat, this.options.culture) : value
        },
        _refresh: function() {
            this.element.attr({
                "aria-valuemin": this.options.min,
                "aria-valuemax": this.options.max,
                "aria-valuenow": this._parse(this.element.val())
            })
        },
        isValid: function() {
            var value =
                this.value();
            if (value === null) return false;
            return value === this._adjustValue(value)
        },
        _value: function(value, allowAny) {
            var parsed;
            if (value !== "") {
                parsed = this._parse(value);
                if (parsed !== null) {
                    if (!allowAny) parsed = this._adjustValue(parsed);
                    value = this._format(parsed)
                }
            }
            this.element.val(value);
            this._refresh()
        },
        _destroy: function() {
            this.element.prop("disabled", false).removeAttr("autocomplete role aria-valuemin aria-valuemax aria-valuenow");
            this.uiSpinner.replaceWith(this.element)
        },
        stepUp: spinnerModifer(function(steps) {
            this._stepUp(steps)
        }),
        _stepUp: function(steps) {
            if (this._start()) {
                this._spin((steps || 1) * this.options.step);
                this._stop()
            }
        },
        stepDown: spinnerModifer(function(steps) {
            this._stepDown(steps)
        }),
        _stepDown: function(steps) {
            if (this._start()) {
                this._spin((steps || 1) * -this.options.step);
                this._stop()
            }
        },
        pageUp: spinnerModifer(function(pages) {
            this._stepUp((pages || 1) * this.options.page)
        }),
        pageDown: spinnerModifer(function(pages) {
            this._stepDown((pages || 1) * this.options.page)
        }),
        value: function(newVal) {
            if (!arguments.length) return this._parse(this.element.val());
            spinnerModifer(this._value).call(this, newVal)
        },
        widget: function() {
            return this.uiSpinner
        }
    });
    if ($.uiBackCompat !== false) $.widget("ui.spinner", $.ui.spinner, {
        _enhance: function() {
            this.uiSpinner = this.element.attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml())
        },
        _uiSpinnerHtml: function() {
            return "<span>"
        },
        _buttonHtml: function() {
            return "<a></a><a></a>"
        }
    });
    var widgetsSpinner = $.ui.spinner;
    $.widget("ui.tooltip", {
        version: "1.12.1",
        options: {
            classes: {
                "ui-tooltip": "ui-corner-all ui-widget-shadow"
            },
            content: function() {
                var title = $(this).attr("title") || "";
                return $("<a>").text(title).html()
            },
            hide: true,
            items: "[title]:not([disabled])",
            position: {
                my: "left top+15",
                at: "left bottom",
                collision: "flipfit flip"
            },
            show: true,
            track: false,
            close: null,
            open: null
        },
        _addDescribedBy: function(elem, id) {
            var describedby = (elem.attr("aria-describedby") || "").split(/\s+/);
            describedby.push(id);
            elem.data("ui-tooltip-id", id).attr("aria-describedby", $.trim(describedby.join(" ")))
        },
        _removeDescribedBy: function(elem) {
            var id = elem.data("ui-tooltip-id"),
                describedby = (elem.attr("aria-describedby") || "").split(/\s+/),
                index = $.inArray(id, describedby);
            if (index !== -1) describedby.splice(index, 1);
            elem.removeData("ui-tooltip-id");
            describedby = $.trim(describedby.join(" "));
            if (describedby) elem.attr("aria-describedby", describedby);
            else elem.removeAttr("aria-describedby")
        },
        _create: function() {
            this._on({
                mouseover: "open",
                focusin: "open"
            });
            this.tooltips = {};
            this.parents = {};
            this.liveRegion = $("<div>").attr({
                role: "log",
                "aria-live": "assertive",
                "aria-relevant": "additions"
            }).appendTo(this.document[0].body);
            this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible");
            this.disabledTitles = $([])
        },
        _setOption: function(key, value) {
            var that = this;
            this._super(key, value);
            if (key === "content") $.each(this.tooltips, function(id, tooltipData) {
                that._updateContent(tooltipData.element)
            })
        },
        _setOptionDisabled: function(value) {
            this[value ? "_disable" : "_enable"]()
        },
        _disable: function() {
            var that = this;
            $.each(this.tooltips, function(id, tooltipData) {
                var event = $.Event("blur");
                event.target = event.currentTarget = tooltipData.element[0];
                that.close(event, true)
            });
            this.disabledTitles = this.disabledTitles.add(this.element.find(this.options.items).addBack().filter(function() {
                var element = $(this);
                if (element.is("[title]")) return element.data("ui-tooltip-title", element.attr("title")).removeAttr("title")
            }))
        },
        _enable: function() {
            this.disabledTitles.each(function() {
                var element = $(this);
                if (element.data("ui-tooltip-title")) element.attr("title", element.data("ui-tooltip-title"))
            });
            this.disabledTitles = $([])
        },
        open: function(event) {
            var that = this,
                target =
                $(event ? event.target : this.element).closest(this.options.items);
            if (!target.length || target.data("ui-tooltip-id")) return;
            if (target.attr("title")) target.data("ui-tooltip-title", target.attr("title"));
            target.data("ui-tooltip-open", true);
            if (event && event.type === "mouseover") target.parents().each(function() {
                var parent = $(this),
                    blurEvent;
                if (parent.data("ui-tooltip-open")) {
                    blurEvent = $.Event("blur");
                    blurEvent.target = blurEvent.currentTarget = this;
                    that.close(blurEvent, true)
                }
                if (parent.attr("title")) {
                    parent.uniqueId();
                    that.parents[this.id] = {
                        element: this,
                        title: parent.attr("title")
                    };
                    parent.attr("title", "")
                }
            });
            this._registerCloseHandlers(event, target);
            this._updateContent(target, event)
        },
        _updateContent: function(target, event) {
            var content, contentOption = this.options.content,
                that = this,
                eventType = event ? event.type : null;
            if (typeof contentOption === "string" || contentOption.nodeType || contentOption.jquery) return this._open(event, target, contentOption);
            content = contentOption.call(target[0], function(response) {
                that._delay(function() {
                    if (!target.data("ui-tooltip-open")) return;
                    if (event) event.type = eventType;
                    this._open(event, target, response)
                })
            });
            if (content) this._open(event, target, content)
        },
        _open: function(event, target, content) {
            var tooltipData, tooltip, delayedShow, a11yContent, positionOption = $.extend({}, this.options.position);
            if (!content) return;
            tooltipData = this._find(target);
            if (tooltipData) {
                tooltipData.tooltip.find(".ui-tooltip-content").html(content);
                return
            }
            if (target.is("[title]"))
                if (event && event.type === "mouseover") target.attr("title", "");
                else target.removeAttr("title");
            tooltipData =
                this._tooltip(target);
            tooltip = tooltipData.tooltip;
            this._addDescribedBy(target, tooltip.attr("id"));
            tooltip.find(".ui-tooltip-content").html(content);
            this.liveRegion.children().hide();
            a11yContent = $("<div>").html(tooltip.find(".ui-tooltip-content").html());
            a11yContent.removeAttr("name").find("[name]").removeAttr("name");
            a11yContent.removeAttr("id").find("[id]").removeAttr("id");
            a11yContent.appendTo(this.liveRegion);

            function position(event) {
                positionOption.of = event;
                if (tooltip.is(":hidden")) return;
                tooltip.position(positionOption)
            }
            if (this.options.track && event && /^mouse/.test(event.type)) {
                this._on(this.document, {
                    mousemove: position
                });
                position(event)
            } else tooltip.position($.extend({
                of: target
            }, this.options.position));
            tooltip.hide();
            this._show(tooltip, this.options.show);
            if (this.options.track && this.options.show && this.options.show.delay) delayedShow = this.delayedShow = setInterval(function() {
                if (tooltip.is(":visible")) {
                    position(positionOption.of);
                    clearInterval(delayedShow)
                }
            }, $.fx.interval);
            this._trigger("open", event, {
                tooltip: tooltip
            })
        },
        _registerCloseHandlers: function(event, target) {
            var events = {
                keyup: function(event) {
                    if (event.keyCode === $.ui.keyCode.ESCAPE) {
                        var fakeEvent = $.Event(event);
                        fakeEvent.currentTarget = target[0];
                        this.close(fakeEvent, true)
                    }
                }
            };
            if (target[0] !== this.element[0]) events.remove = function() {
                this._removeTooltip(this._find(target).tooltip)
            };
            if (!event || event.type === "mouseover") events.mouseleave = "close";
            if (!event || event.type === "focusin") events.focusout = "close";
            this._on(true, target, events)
        },
        close: function(event) {
            var tooltip,
                that = this,
                target = $(event ? event.currentTarget : this.element),
                tooltipData = this._find(target);
            if (!tooltipData) {
                target.removeData("ui-tooltip-open");
                return
            }
            tooltip = tooltipData.tooltip;
            if (tooltipData.closing) return;
            clearInterval(this.delayedShow);
            if (target.data("ui-tooltip-title") && !target.attr("title")) target.attr("title", target.data("ui-tooltip-title"));
            this._removeDescribedBy(target);
            tooltipData.hiding = true;
            tooltip.stop(true);
            this._hide(tooltip, this.options.hide, function() {
                that._removeTooltip($(this))
            });
            target.removeData("ui-tooltip-open");
            this._off(target, "mouseleave focusout keyup");
            if (target[0] !== this.element[0]) this._off(target, "remove");
            this._off(this.document, "mousemove");
            if (event && event.type === "mouseleave") $.each(this.parents, function(id, parent) {
                $(parent.element).attr("title", parent.title);
                delete that.parents[id]
            });
            tooltipData.closing = true;
            this._trigger("close", event, {
                tooltip: tooltip
            });
            if (!tooltipData.hiding) tooltipData.closing = false
        },
        _tooltip: function(element) {
            var tooltip = $("<div>").attr("role",
                    "tooltip"),
                content = $("<div>").appendTo(tooltip),
                id = tooltip.uniqueId().attr("id");
            this._addClass(content, "ui-tooltip-content");
            this._addClass(tooltip, "ui-tooltip", "ui-widget ui-widget-content");
            tooltip.appendTo(this._appendTo(element));
            return this.tooltips[id] = {
                element: element,
                tooltip: tooltip
            }
        },
        _find: function(target) {
            var id = target.data("ui-tooltip-id");
            return id ? this.tooltips[id] : null
        },
        _removeTooltip: function(tooltip) {
            tooltip.remove();
            delete this.tooltips[tooltip.attr("id")]
        },
        _appendTo: function(target) {
            var element =
                target.closest(".ui-front, dialog");
            if (!element.length) element = this.document[0].body;
            return element
        },
        _destroy: function() {
            var that = this;
            $.each(this.tooltips, function(id, tooltipData) {
                var event = $.Event("blur"),
                    element = tooltipData.element;
                event.target = event.currentTarget = element[0];
                that.close(event, true);
                $("#" + id).remove();
                if (element.data("ui-tooltip-title")) {
                    if (!element.attr("title")) element.attr("title", element.data("ui-tooltip-title"));
                    element.removeData("ui-tooltip-title")
                }
            });
            this.liveRegion.remove()
        }
    });
    if ($.uiBackCompat !== false) $.widget("ui.tooltip", $.ui.tooltip, {
        options: {
            tooltipClass: null
        },
        _tooltip: function() {
            var tooltipData = this._superApply(arguments);
            if (this.options.tooltipClass) tooltipData.tooltip.addClass(this.options.tooltipClass);
            return tooltipData
        }
    });
    var widgetsTooltip = $.ui.tooltip
});
(function(factory) {
    if (typeof define === "function" && define.amd && define.amd.jQuery) define(["jquery"], factory);
    else factory(jQuery)
})(function($) {
    var VERSION = "1.6.9",
        LEFT = "left",
        RIGHT = "right",
        UP = "up",
        DOWN = "down",
        IN = "in",
        OUT = "out",
        NONE = "none",
        AUTO = "auto",
        SWIPE = "swipe",
        PINCH = "pinch",
        TAP = "tap",
        DOUBLE_TAP = "doubletap",
        LONG_TAP = "longtap",
        HOLD = "hold",
        HORIZONTAL = "horizontal",
        VERTICAL = "vertical",
        ALL_FINGERS = "all",
        DOUBLE_TAP_THRESHOLD = 10,
        PHASE_START = "start",
        PHASE_MOVE = "move",
        PHASE_END = "end",
        PHASE_CANCEL = "cancel",
        SUPPORTS_TOUCH = "ontouchstart" in window,
        SUPPORTS_POINTER_IE10 = window.navigator.msPointerEnabled && !window.navigator.pointerEnabled,
        SUPPORTS_POINTER = window.navigator.pointerEnabled || window.navigator.msPointerEnabled,
        PLUGIN_NS = "TouchSwipe";
    var defaults = {
        fingers: 1,
        threshold: 75,
        cancelThreshold: null,
        pinchThreshold: 20,
        maxTimeThreshold: null,
        fingerReleaseThreshold: 250,
        longTapThreshold: 500,
        doubleTapThreshold: 200,
        swipe: null,
        swipeLeft: null,
        swipeRight: null,
        swipeUp: null,
        swipeDown: null,
        swipeStatus: null,
        pinchIn: null,
        pinchOut: null,
        pinchStatus: null,
        click: null,
        tap: null,
        doubleTap: null,
        longTap: null,
        hold: null,
        triggerOnTouchEnd: true,
        triggerOnTouchLeave: false,
        allowPageScroll: "auto",
        fallbackToMouseEvents: true,
        excludedElements: "label, button, input, select, textarea, a, .noSwipe",
        preventDefaultEvents: true
    };
    $.fn.swipe = function(method) {
        var $this = $(this),
            plugin = $this.data(PLUGIN_NS);
        if (plugin && typeof method === "string")
            if (plugin[method]) return plugin[method].apply(this, Array.prototype.slice.call(arguments, 1));
            else $.error("Method " +
                method + " does not exist on jQuery.swipe");
        else if (!plugin && (typeof method === "object" || !method)) return init.apply(this, arguments);
        return $this
    };
    $.fn.swipe.version = VERSION;
    $.fn.swipe.defaults = defaults;
    $.fn.swipe.phases = {
        PHASE_START: PHASE_START,
        PHASE_MOVE: PHASE_MOVE,
        PHASE_END: PHASE_END,
        PHASE_CANCEL: PHASE_CANCEL
    };
    $.fn.swipe.directions = {
        LEFT: LEFT,
        RIGHT: RIGHT,
        UP: UP,
        DOWN: DOWN,
        IN: IN,
        OUT: OUT
    };
    $.fn.swipe.pageScroll = {
        NONE: NONE,
        HORIZONTAL: HORIZONTAL,
        VERTICAL: VERTICAL,
        AUTO: AUTO
    };
    $.fn.swipe.fingers = {
        ONE: 1,
        TWO: 2,
        THREE: 3,
        ALL: ALL_FINGERS
    };

    function init(options) {
        if (options && (options.allowPageScroll === undefined && (options.swipe !== undefined || options.swipeStatus !== undefined))) options.allowPageScroll = NONE;
        if (options.click !== undefined && options.tap === undefined) options.tap = options.click;
        if (!options) options = {};
        options = $.extend({}, $.fn.swipe.defaults, options);
        return this.each(function() {
            var $this = $(this);
            var plugin = $this.data(PLUGIN_NS);
            if (!plugin) {
                plugin = new TouchSwipe(this, options);
                $this.data(PLUGIN_NS, plugin)
            }
        })
    }

    function TouchSwipe(element,
        options) {
        var useTouchEvents = SUPPORTS_TOUCH || SUPPORTS_POINTER || !options.fallbackToMouseEvents,
            START_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerDown" : "pointerdown" : "touchstart" : "mousedown",
            MOVE_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerMove" : "pointermove" : "touchmove" : "mousemove",
            END_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerUp" : "pointerup" : "touchend" : "mouseup",
            LEAVE_EV = useTouchEvents ? null : "mouseleave",
            CANCEL_EV = SUPPORTS_POINTER ?
            SUPPORTS_POINTER_IE10 ? "MSPointerCancel" : "pointercancel" : "touchcancel";
        var distance = 0,
            direction = null,
            duration = 0,
            startTouchesDistance = 0,
            endTouchesDistance = 0,
            pinchZoom = 1,
            pinchDistance = 0,
            pinchDirection = 0,
            maximumsMap = null;
        var $element = $(element);
        var phase = "start";
        var fingerCount = 0;
        var fingerData = null;
        var startTime = 0,
            endTime = 0,
            previousTouchEndTime = 0,
            previousTouchFingerCount = 0,
            doubleTapStartTime = 0;
        var singleTapTimeout = null,
            holdTimeout = null;
        try {
            $element.bind(START_EV, touchStart);
            $element.bind(CANCEL_EV, touchCancel)
        } catch (e) {
            $.error("events not supported " +
                START_EV + "," + CANCEL_EV + " on jQuery.swipe")
        }
        this.enable = function() {
            $element.bind(START_EV, touchStart);
            $element.bind(CANCEL_EV, touchCancel);
            return $element
        };
        this.disable = function() {
            removeListeners();
            return $element
        };
        this.destroy = function() {
            removeListeners();
            $element.data(PLUGIN_NS, null);
            $element = null
        };
        this.option = function(property, value) {
            if (options[property] !== undefined)
                if (value === undefined) return options[property];
                else options[property] = value;
            else $.error("Option " + property + " does not exist on jQuery.swipe.options");
            return null
        };

        function touchStart(jqEvent) {
            if (getTouchInProgress()) return;
            if ($(jqEvent.target).closest(options.excludedElements, $element).length > 0) return;
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
            var ret, touches = event.touches,
                evt = touches ? touches[0] : event;
            phase = PHASE_START;
            if (touches) fingerCount = touches.length;
            else jqEvent.preventDefault();
            distance = 0;
            direction = null;
            pinchDirection = null;
            duration = 0;
            startTouchesDistance = 0;
            endTouchesDistance = 0;
            pinchZoom = 1;
            pinchDistance = 0;
            fingerData = createAllFingerData();
            maximumsMap = createMaximumsData();
            cancelMultiFingerRelease();
            if (!touches || (fingerCount === options.fingers || options.fingers === ALL_FINGERS) || hasPinches()) {
                createFingerData(0, evt);
                startTime = getTimeStamp();
                if (fingerCount == 2) {
                    createFingerData(1, touches[1]);
                    startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)
                }
                if (options.swipeStatus || options.pinchStatus) ret = triggerHandler(event, phase)
            } else ret = false;
            if (ret === false) {
                phase = PHASE_CANCEL;
                triggerHandler(event,
                    phase);
                return ret
            } else {
                if (options.hold) holdTimeout = setTimeout($.proxy(function() {
                    $element.trigger("hold", [event.target]);
                    if (options.hold) ret = options.hold.call($element, event, event.target)
                }, this), options.longTapThreshold);
                setTouchInProgress(true)
            }
            return null
        }

        function touchMove(jqEvent) {
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
            if (phase === PHASE_END || phase === PHASE_CANCEL || inMultiFingerRelease()) return;
            var ret, touches = event.touches,
                evt = touches ? touches[0] : event;
            var currentFinger = updateFingerData(evt);
            endTime = getTimeStamp();
            if (touches) fingerCount = touches.length;
            if (options.hold) clearTimeout(holdTimeout);
            phase = PHASE_MOVE;
            if (fingerCount == 2) {
                if (startTouchesDistance == 0) {
                    createFingerData(1, touches[1]);
                    startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)
                } else {
                    updateFingerData(touches[1]);
                    endTouchesDistance = calculateTouchesDistance(fingerData[0].end, fingerData[1].end);
                    pinchDirection = calculatePinchDirection(fingerData[0].end, fingerData[1].end)
                }
                pinchZoom =
                    calculatePinchZoom(startTouchesDistance, endTouchesDistance);
                pinchDistance = Math.abs(startTouchesDistance - endTouchesDistance)
            }
            if (fingerCount === options.fingers || options.fingers === ALL_FINGERS || !touches || hasPinches()) {
                direction = calculateDirection(currentFinger.start, currentFinger.end);
                validateDefaultEvent(jqEvent, direction);
                distance = calculateDistance(currentFinger.start, currentFinger.end);
                duration = calculateDuration();
                setMaxDistance(direction, distance);
                if (options.swipeStatus || options.pinchStatus) ret = triggerHandler(event,
                    phase);
                if (!options.triggerOnTouchEnd || options.triggerOnTouchLeave) {
                    var inBounds = true;
                    if (options.triggerOnTouchLeave) {
                        var bounds = getbounds(this);
                        inBounds = isInBounds(currentFinger.end, bounds)
                    }
                    if (!options.triggerOnTouchEnd && inBounds) phase = getNextPhase(PHASE_MOVE);
                    else if (options.triggerOnTouchLeave && !inBounds) phase = getNextPhase(PHASE_END);
                    if (phase == PHASE_CANCEL || phase == PHASE_END) triggerHandler(event, phase)
                }
            } else {
                phase = PHASE_CANCEL;
                triggerHandler(event, phase)
            }
            if (ret === false) {
                phase = PHASE_CANCEL;
                triggerHandler(event,
                    phase)
            }
        }

        function touchEnd(jqEvent) {
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent,
                touches = event.touches;
            if (touches)
                if (touches.length) {
                    startMultiFingerRelease();
                    return true
                }
            if (inMultiFingerRelease()) fingerCount = previousTouchFingerCount;
            endTime = getTimeStamp();
            duration = calculateDuration();
            if (didSwipeBackToCancel() || !validateSwipeDistance()) {
                phase = PHASE_CANCEL;
                triggerHandler(event, phase)
            } else if (options.triggerOnTouchEnd || options.triggerOnTouchEnd == false && phase === PHASE_MOVE) {
                jqEvent.preventDefault();
                phase = PHASE_END;
                triggerHandler(event, phase)
            } else if (!options.triggerOnTouchEnd && hasTap()) {
                phase = PHASE_END;
                triggerHandlerForGesture(event, phase, TAP)
            } else if (phase === PHASE_MOVE) {
                phase = PHASE_CANCEL;
                triggerHandler(event, phase)
            }
            setTouchInProgress(false);
            return null
        }

        function touchCancel() {
            fingerCount = 0;
            endTime = 0;
            startTime = 0;
            startTouchesDistance = 0;
            endTouchesDistance = 0;
            pinchZoom = 1;
            cancelMultiFingerRelease();
            setTouchInProgress(false)
        }

        function touchLeave(jqEvent) {
            var event = jqEvent.originalEvent ? jqEvent.originalEvent :
                jqEvent;
            if (options.triggerOnTouchLeave) {
                phase = getNextPhase(PHASE_END);
                triggerHandler(event, phase)
            }
        }

        function removeListeners() {
            $element.unbind(START_EV, touchStart);
            $element.unbind(CANCEL_EV, touchCancel);
            $element.unbind(MOVE_EV, touchMove);
            $element.unbind(END_EV, touchEnd);
            if (LEAVE_EV) $element.unbind(LEAVE_EV, touchLeave);
            setTouchInProgress(false)
        }

        function getNextPhase(currentPhase) {
            var nextPhase = currentPhase;
            var validTime = validateSwipeTime();
            var validDistance = validateSwipeDistance();
            var didCancel = didSwipeBackToCancel();
            if (!validTime || didCancel) nextPhase = PHASE_CANCEL;
            else if (validDistance && currentPhase == PHASE_MOVE && (!options.triggerOnTouchEnd || options.triggerOnTouchLeave)) nextPhase = PHASE_END;
            else if (!validDistance && currentPhase == PHASE_END && options.triggerOnTouchLeave) nextPhase = PHASE_CANCEL;
            return nextPhase
        }

        function triggerHandler(event, phase) {
            var ret, touches = event.touches;
            if (didSwipe() && hasSwipes() || didPinch() && hasPinches()) {
                if (didSwipe() && hasSwipes()) ret = triggerHandlerForGesture(event, phase, SWIPE);
                if (didPinch() &&
                    hasPinches() && ret !== false) ret = triggerHandlerForGesture(event, phase, PINCH)
            } else if (didDoubleTap() && ret !== false) ret = triggerHandlerForGesture(event, phase, DOUBLE_TAP);
            else if (didLongTap() && ret !== false) ret = triggerHandlerForGesture(event, phase, LONG_TAP);
            else if (didTap() && ret !== false) ret = triggerHandlerForGesture(event, phase, TAP);
            if (phase === PHASE_CANCEL) touchCancel(event);
            if (phase === PHASE_END)
                if (touches) {
                    if (!touches.length) touchCancel(event)
                } else touchCancel(event);
            return ret
        }

        function triggerHandlerForGesture(event,
            phase, gesture) {
            var ret;
            if (gesture == SWIPE) {
                $element.trigger("swipeStatus", [phase, direction || null, distance || 0, duration || 0, fingerCount, fingerData]);
                if (options.swipeStatus) {
                    ret = options.swipeStatus.call($element, event, phase, direction || null, distance || 0, duration || 0, fingerCount, fingerData);
                    if (ret === false) return false
                }
                if (phase == PHASE_END && validateSwipe()) {
                    $element.trigger("swipe", [direction, distance, duration, fingerCount, fingerData]);
                    if (options.swipe) {
                        ret = options.swipe.call($element, event, direction, distance,
                            duration, fingerCount, fingerData);
                        if (ret === false) return false
                    }
                    switch (direction) {
                        case LEFT:
                            $element.trigger("swipeLeft", [direction, distance, duration, fingerCount, fingerData]);
                            if (options.swipeLeft) ret = options.swipeLeft.call($element, event, direction, distance, duration, fingerCount, fingerData);
                            break;
                        case RIGHT:
                            $element.trigger("swipeRight", [direction, distance, duration, fingerCount, fingerData]);
                            if (options.swipeRight) ret = options.swipeRight.call($element, event, direction, distance, duration, fingerCount, fingerData);
                            break;
                        case UP:
                            $element.trigger("swipeUp", [direction, distance, duration, fingerCount, fingerData]);
                            if (options.swipeUp) ret = options.swipeUp.call($element, event, direction, distance, duration, fingerCount, fingerData);
                            break;
                        case DOWN:
                            $element.trigger("swipeDown", [direction, distance, duration, fingerCount, fingerData]);
                            if (options.swipeDown) ret = options.swipeDown.call($element, event, direction, distance, duration, fingerCount, fingerData);
                            break
                    }
                }
            }
            if (gesture == PINCH) {
                $element.trigger("pinchStatus", [phase, pinchDirection ||
                    null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData
                ]);
                if (options.pinchStatus) {
                    ret = options.pinchStatus.call($element, event, phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData);
                    if (ret === false) return false
                }
                if (phase == PHASE_END && validatePinch()) switch (pinchDirection) {
                    case IN:
                        $element.trigger("pinchIn", [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]);
                        if (options.pinchIn) ret = options.pinchIn.call($element, event, pinchDirection ||
                            null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData);
                        break;
                    case OUT:
                        $element.trigger("pinchOut", [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]);
                        if (options.pinchOut) ret = options.pinchOut.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData);
                        break
                }
            }
            if (gesture == TAP) {
                if (phase === PHASE_CANCEL || phase === PHASE_END) {
                    clearTimeout(singleTapTimeout);
                    clearTimeout(holdTimeout);
                    if (hasDoubleTap() && !inDoubleTap()) {
                        doubleTapStartTime =
                            getTimeStamp();
                        singleTapTimeout = setTimeout($.proxy(function() {
                            doubleTapStartTime = null;
                            $element.trigger("tap", [event.target]);
                            if (options.tap) ret = options.tap.call($element, event, event.target)
                        }, this), options.doubleTapThreshold)
                    } else {
                        doubleTapStartTime = null;
                        $element.trigger("tap", [event.target]);
                        if (options.tap) ret = options.tap.call($element, event, event.target)
                    }
                }
            } else if (gesture == DOUBLE_TAP) {
                if (phase === PHASE_CANCEL || phase === PHASE_END) {
                    clearTimeout(singleTapTimeout);
                    doubleTapStartTime = null;
                    $element.trigger("doubletap", [event.target]);
                    if (options.doubleTap) ret = options.doubleTap.call($element, event, event.target)
                }
            } else if (gesture == LONG_TAP)
                if (phase === PHASE_CANCEL || phase === PHASE_END) {
                    clearTimeout(singleTapTimeout);
                    doubleTapStartTime = null;
                    $element.trigger("longtap", [event.target]);
                    if (options.longTap) ret = options.longTap.call($element, event, event.target)
                }
            return ret
        }

        function validateSwipeDistance() {
            var valid = true;
            if (options.threshold !== null) valid = distance >= options.threshold;
            return valid
        }

        function didSwipeBackToCancel() {
            var cancelled =
                false;
            if (options.cancelThreshold !== null && direction !== null) cancelled = getMaxDistance(direction) - distance >= options.cancelThreshold;
            return cancelled
        }

        function validatePinchDistance() {
            if (options.pinchThreshold !== null) return pinchDistance >= options.pinchThreshold;
            return true
        }

        function validateSwipeTime() {
            var result;
            if (options.maxTimeThreshold)
                if (duration >= options.maxTimeThreshold) result = false;
                else result = true;
            else result = true;
            return result
        }

        function validateDefaultEvent(jqEvent, direction) {
            if (options.preventDefaultEvents ===
                false) return;
            if (options.allowPageScroll === NONE) jqEvent.preventDefault();
            else {
                var auto = options.allowPageScroll === AUTO;
                switch (direction) {
                    case LEFT:
                        if (options.swipeLeft && auto || !auto && options.allowPageScroll != HORIZONTAL) jqEvent.preventDefault();
                        break;
                    case RIGHT:
                        if (options.swipeRight && auto || !auto && options.allowPageScroll != HORIZONTAL) jqEvent.preventDefault();
                        break;
                    case UP:
                        if (options.swipeUp && auto || !auto && options.allowPageScroll != VERTICAL) jqEvent.preventDefault();
                        break;
                    case DOWN:
                        if (options.swipeDown && auto ||
                            !auto && options.allowPageScroll != VERTICAL) jqEvent.preventDefault();
                        break
                }
            }
        }

        function validatePinch() {
            var hasCorrectFingerCount = validateFingers();
            var hasEndPoint = validateEndPoint();
            var hasCorrectDistance = validatePinchDistance();
            return hasCorrectFingerCount && hasEndPoint && hasCorrectDistance
        }

        function hasPinches() {
            return !!(options.pinchStatus || options.pinchIn || options.pinchOut)
        }

        function didPinch() {
            return !!(validatePinch() && hasPinches())
        }

        function validateSwipe() {
            var hasValidTime = validateSwipeTime();
            var hasValidDistance =
                validateSwipeDistance();
            var hasCorrectFingerCount = validateFingers();
            var hasEndPoint = validateEndPoint();
            var didCancel = didSwipeBackToCancel();
            var valid = !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime;
            return valid
        }

        function hasSwipes() {
            return !!(options.swipe || options.swipeStatus || options.swipeLeft || options.swipeRight || options.swipeUp || options.swipeDown)
        }

        function didSwipe() {
            return !!(validateSwipe() && hasSwipes())
        }

        function validateFingers() {
            return fingerCount === options.fingers ||
                options.fingers === ALL_FINGERS || !SUPPORTS_TOUCH
        }

        function validateEndPoint() {
            return fingerData[0].end.x !== 0
        }

        function hasTap() {
            return !!options.tap
        }

        function hasDoubleTap() {
            return !!options.doubleTap
        }

        function hasLongTap() {
            return !!options.longTap
        }

        function validateDoubleTap() {
            if (doubleTapStartTime == null) return false;
            var now = getTimeStamp();
            return hasDoubleTap() && now - doubleTapStartTime <= options.doubleTapThreshold
        }

        function inDoubleTap() {
            return validateDoubleTap()
        }

        function validateTap() {
            return (fingerCount ===
                1 || !SUPPORTS_TOUCH) && (isNaN(distance) || distance < options.threshold)
        }

        function validateLongTap() {
            return duration > options.longTapThreshold && distance < DOUBLE_TAP_THRESHOLD
        }

        function didTap() {
            return !!(validateTap() && hasTap())
        }

        function didDoubleTap() {
            return !!(validateDoubleTap() && hasDoubleTap())
        }

        function didLongTap() {
            return !!(validateLongTap() && hasLongTap())
        }

        function startMultiFingerRelease() {
            previousTouchEndTime = getTimeStamp();
            previousTouchFingerCount = event.touches.length + 1
        }

        function cancelMultiFingerRelease() {
            previousTouchEndTime =
                0;
            previousTouchFingerCount = 0
        }

        function inMultiFingerRelease() {
            var withinThreshold = false;
            if (previousTouchEndTime) {
                var diff = getTimeStamp() - previousTouchEndTime;
                if (diff <= options.fingerReleaseThreshold) withinThreshold = true
            }
            return withinThreshold
        }

        function getTouchInProgress() {
            return !!($element.data(PLUGIN_NS + "_intouch") === true)
        }

        function setTouchInProgress(val) {
            if (val === true) {
                $element.bind(MOVE_EV, touchMove);
                $element.bind(END_EV, touchEnd);
                if (LEAVE_EV) $element.bind(LEAVE_EV, touchLeave)
            } else {
                $element.unbind(MOVE_EV,
                    touchMove, false);
                $element.unbind(END_EV, touchEnd, false);
                if (LEAVE_EV) $element.unbind(LEAVE_EV, touchLeave, false)
            }
            $element.data(PLUGIN_NS + "_intouch", val === true)
        }

        function createFingerData(index, evt) {
            var id = evt.identifier !== undefined ? evt.identifier : 0;
            fingerData[index].identifier = id;
            fingerData[index].start.x = fingerData[index].end.x = evt.pageX || evt.clientX;
            fingerData[index].start.y = fingerData[index].end.y = evt.pageY || evt.clientY;
            return fingerData[index]
        }

        function updateFingerData(evt) {
            var id = evt.identifier !==
                undefined ? evt.identifier : 0;
            var f = getFingerData(id);
            f.end.x = evt.pageX || evt.clientX;
            f.end.y = evt.pageY || evt.clientY;
            return f
        }

        function getFingerData(id) {
            for (var i = 0; i < fingerData.length; i++)
                if (fingerData[i].identifier == id) return fingerData[i]
        }

        function createAllFingerData() {
            var fingerData = [];
            for (var i = 0; i <= 5; i++) fingerData.push({
                start: {
                    x: 0,
                    y: 0
                },
                end: {
                    x: 0,
                    y: 0
                },
                identifier: 0
            });
            return fingerData
        }

        function setMaxDistance(direction, distance) {
            distance = Math.max(distance, getMaxDistance(direction));
            maximumsMap[direction].distance =
                distance
        }

        function getMaxDistance(direction) {
            if (maximumsMap[direction]) return maximumsMap[direction].distance;
            return undefined
        }

        function createMaximumsData() {
            var maxData = {};
            maxData[LEFT] = createMaximumVO(LEFT);
            maxData[RIGHT] = createMaximumVO(RIGHT);
            maxData[UP] = createMaximumVO(UP);
            maxData[DOWN] = createMaximumVO(DOWN);
            return maxData
        }

        function createMaximumVO(dir) {
            return {
                direction: dir,
                distance: 0
            }
        }

        function calculateDuration() {
            return endTime - startTime
        }

        function calculateTouchesDistance(startPoint, endPoint) {
            var diffX =
                Math.abs(startPoint.x - endPoint.x);
            var diffY = Math.abs(startPoint.y - endPoint.y);
            return Math.round(Math.sqrt(diffX * diffX + diffY * diffY))
        }

        function calculatePinchZoom(startDistance, endDistance) {
            var percent = endDistance / startDistance * 1;
            return percent.toFixed(2)
        }

        function calculatePinchDirection() {
            if (pinchZoom < 1) return OUT;
            else return IN
        }

        function calculateDistance(startPoint, endPoint) {
            return Math.round(Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)))
        }

        function calculateAngle(startPoint,
            endPoint) {
            var x = startPoint.x - endPoint.x;
            var y = endPoint.y - startPoint.y;
            var r = Math.atan2(y, x);
            var angle = Math.round(r * 180 / Math.PI);
            if (angle < 0) angle = 360 - Math.abs(angle);
            return angle
        }

        function calculateDirection(startPoint, endPoint) {
            var angle = calculateAngle(startPoint, endPoint);
            if (angle <= 45 && angle >= 0) return LEFT;
            else if (angle <= 360 && angle >= 315) return LEFT;
            else if (angle >= 135 && angle <= 225) return RIGHT;
            else if (angle > 45 && angle < 135) return DOWN;
            else return UP
        }

        function getTimeStamp() {
            var now = new Date;
            return now.getTime()
        }

        function getbounds(el) {
            el = $(el);
            var offset = el.offset();
            var bounds = {
                left: offset.left,
                right: offset.left + el.outerWidth(),
                top: offset.top,
                bottom: offset.top + el.outerHeight()
            };
            return bounds
        }

        function isInBounds(point, bounds) {
            return point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom
        }
    }
});
SVG.easing = {
    quadIn: function(pos) {
        return Math.pow(pos, 2)
    },
    quadOut: function(pos) {
        return -(Math.pow(pos - 1, 2) - 1)
    },
    quadInOut: function(pos) {
        if ((pos /= .5) < 1) return .5 * Math.pow(pos, 2);
        return -.5 * ((pos -= 2) * pos - 2)
    },
    cubicIn: function(pos) {
        return Math.pow(pos, 3)
    },
    cubicOut: function(pos) {
        return Math.pow(pos - 1, 3) + 1
    },
    cubicInOut: function(pos) {
        if ((pos /= .5) < 1) return .5 * Math.pow(pos, 3);
        return .5 * (Math.pow(pos - 2, 3) + 2)
    },
    quartIn: function(pos) {
        return Math.pow(pos, 4)
    },
    quartOut: function(pos) {
        return -(Math.pow(pos - 1, 4) - 1)
    },
    quartInOut: function(pos) {
        if ((pos /=
                .5) < 1) return .5 * Math.pow(pos, 4);
        return -.5 * ((pos -= 2) * Math.pow(pos, 3) - 2)
    },
    quintIn: function(pos) {
        return Math.pow(pos, 5)
    },
    quintOut: function(pos) {
        return Math.pow(pos - 1, 5) + 1
    },
    quintInOut: function(pos) {
        if ((pos /= .5) < 1) return .5 * Math.pow(pos, 5);
        return .5 * (Math.pow(pos - 2, 5) + 2)
    },
    sineIn: function(pos) {
        return -Math.cos(pos * (Math.PI / 2)) + 1
    },
    sineOut: function(pos) {
        return Math.sin(pos * (Math.PI / 2))
    },
    sineInOut: function(pos) {
        return -.5 * (Math.cos(Math.PI * pos) - 1)
    },
    expoIn: function(pos) {
        return pos == 0 ? 0 : Math.pow(2, 10 * (pos - 1))
    },
    expoOut: function(pos) {
        return pos ==
            1 ? 1 : -Math.pow(2, -10 * pos) + 1
    },
    expoInOut: function(pos) {
        if (pos == 0) return 0;
        if (pos == 1) return 1;
        if ((pos /= .5) < 1) return .5 * Math.pow(2, 10 * (pos - 1));
        return .5 * (-Math.pow(2, -10 * --pos) + 2)
    },
    circIn: function(pos) {
        return -(Math.sqrt(1 - pos * pos) - 1)
    },
    circOut: function(pos) {
        return Math.sqrt(1 - Math.pow(pos - 1, 2))
    },
    circInOut: function(pos) {
        if ((pos /= .5) < 1) return -.5 * (Math.sqrt(1 - pos * pos) - 1);
        return .5 * (Math.sqrt(1 - (pos -= 2) * pos) + 1)
    },
    backIn: function(pos) {
        var s = 1.70158;
        return pos * pos * ((s + 1) * pos - s)
    },
    backOut: function(pos) {
        pos = pos - 1;
        var s =
            1.70158;
        return pos * pos * ((s + 1) * pos + s) + 1
    },
    backInOut: function(pos) {
        var s = 1.70158;
        if ((pos /= .5) < 1) return .5 * (pos * pos * (((s *= 1.525) + 1) * pos - s));
        return .5 * ((pos -= 2) * pos * (((s *= 1.525) + 1) * pos + s) + 2)
    },
    swingFromTo: function(pos) {
        var s = 1.70158;
        return (pos /= .5) < 1 ? .5 * (pos * pos * (((s *= 1.525) + 1) * pos - s)) : .5 * ((pos -= 2) * pos * (((s *= 1.525) + 1) * pos + s) + 2)
    },
    swingFrom: function(pos) {
        var s = 1.70158;
        return pos * pos * ((s + 1) * pos - s)
    },
    swingTo: function(pos) {
        var s = 1.70158;
        return (pos -= 1) * pos * ((s + 1) * pos + s) + 1
    },
    bounce: function(pos) {
        var s = 7.5625,
            p = 2.75,
            l;
        if (pos < 1 / p) l = s * pos * pos;
        else if (pos < 2 / p) {
            pos -= 1.5 / p;
            l = s * pos * pos + .75
        } else if (pos < 2.5 / p) {
            pos -= 2.25 / p;
            l = s * pos * pos + .9375
        } else {
            pos -= 2.625 / p;
            l = s * pos * pos + .984375
        }
        return l
    },
    bounceOut: function(pos) {
        if (pos < 1 / 2.75) return 7.5625 * pos * pos;
        else if (pos < 2 / 2.75) return 7.5625 * (pos -= 1.5 / 2.75) * pos + .75;
        else if (pos < 2.5 / 2.75) return 7.5625 * (pos -= 2.25 / 2.75) * pos + .9375;
        else return 7.5625 * (pos -= 2.625 / 2.75) * pos + .984375
    },
    elastic: function(pos) {
        if (pos == !!pos) return pos;
        return Math.pow(2, -10 * pos) * Math.sin((pos - .075) * (2 * Math.PI) /
            .3) + 1
    }
};
clazz.construct.extend("simpl4.util.Base64", {
    _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    encode: function(input) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;
        input = simpl4.util.Base64._utf8_encode(input);
        while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = (chr1 & 3) << 4 | chr2 >> 4;
            enc3 = (chr2 & 15) << 2 | chr3 >> 6;
            enc4 = chr3 & 63;
            if (isNaN(chr2)) enc3 = enc4 = 64;
            else if (isNaN(chr3)) enc4 = 64;
            var keyStr = simpl4.util.Base64._keyStr;
            output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4)
        }
        return output
    },
    decode: function(input) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while (i < input.length) {
            var keyStr = simpl4.util.Base64._keyStr;
            enc1 = keyStr.indexOf(input.charAt(i++));
            enc2 = keyStr.indexOf(input.charAt(i++));
            enc3 = keyStr.indexOf(input.charAt(i++));
            enc4 = keyStr.indexOf(input.charAt(i++));
            chr1 = enc1 << 2 | enc2 >> 4;
            chr2 = (enc2 & 15) << 4 | enc3 >>
                2;
            chr3 = (enc3 & 3) << 6 | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 != 64) output = output + String.fromCharCode(chr2);
            if (enc4 != 64) output = output + String.fromCharCode(chr3)
        }
        output = simpl4.util.Base64._utf8_decode(output);
        return output
    },
    _utf8_encode: function(string) {
        string = string.replace(/\r\n/g, "\n");
        var utftext = "";
        for (var n = 0; n < string.length; n++) {
            var c = string.charCodeAt(n);
            if (c < 128) utftext += String.fromCharCode(c);
            else if (c > 127 && c < 2048) {
                utftext += String.fromCharCode(c >> 6 | 192);
                utftext += String.fromCharCode(c &
                    63 | 128)
            } else {
                utftext += String.fromCharCode(c >> 12 | 224);
                utftext += String.fromCharCode(c >> 6 & 63 | 128);
                utftext += String.fromCharCode(c & 63 | 128)
            }
        }
        return utftext
    },
    _utf8_decode: function(utftext) {
        var string = "";
        var i = 0;
        var c = 0;
        var c1 = 0;
        var c2 = 0;
        var c3 = 0;
        while (i < utftext.length) {
            c = utftext.charCodeAt(i);
            if (c < 128) {
                string += String.fromCharCode(c);
                i++
            } else if (c > 191 && c < 224) {
                c2 = utftext.charCodeAt(i + 1);
                string += String.fromCharCode((c & 31) << 6 | c2 & 63);
                i += 2
            } else {
                c2 = utftext.charCodeAt(i + 1);
                c3 = utftext.charCodeAt(i + 2);
                string += String.fromCharCode((c &
                    15) << 12 | (c2 & 63) << 6 | c3 & 63);
                i += 3
            }
        }
        return string
    }
}, {});
clazz.construct.extend("simpl4.util.BaseManager", {
    namespace: null,
    language: null,
    user: null,
    password: null,
    baseurl: "",
    setBaseUrl: function(baseUrl) {
        simpl4.util.BaseManager.baseurl = baseUrl
    },
    getBaseUrl: function() {
        return simpl4.util.BaseManager.baseurl
    },
    setNamespace: function(namespace) {
        simpl4.util.BaseManager.namespace = namespace
    },
    getNamespace: function() {
        return simpl4.util.BaseManager.namespace
    },
    getStoreId: function() {
        return simpl4.util.BaseManager.namespace + "_data"
    },
    setLanguage: function(language) {
        simpl4.util.BaseManager.language =
            language
    },
    getLanguage: function(language) {
        return simpl4.util.BaseManager.language
    },
    setUser: function(user) {
        simpl4.util.BaseManager.user = user
    },
    getUser: function(user) {
        return simpl4.util.BaseManager.user
    },
    setPassword: function(password) {
        simpl4.util.BaseManager.password = password
    },
    getPassword: function(password) {
        return simpl4.util.BaseManager.password
    },
    getCredentials: function() {
        return simpl4.util.Base64.encode(simpl4.util.BaseManager.getUser() + ":" + simpl4.util.BaseManager.getPassword())
    },
    getDateFormat: function() {
        return simpl4.util.BaseManager.getLanguage() ===
            "de" ? "DD.MM.YYYY" : "MM/DD/YYYY"
    }
}, {});
clazz = {};
clazz.define = function(moduleName, deps, callback) {
    var module;
    var args = [];
    args.push(deps);
    var result = callback ? callback.apply(null, args) : undefined
};
clazz.simpleExtend = function(d, s) {
    for (var prop in s) d[prop] = s[prop];
    return d
};
clazz.makeArray = function(arr) {
    var ret = [];
    var keys = Object.keys(arr);
    for (i = 0, len = keys.length; i < len; i++) {
        var key = keys[i];
        ret[i] = arr[key]
    }
    return ret
};
clazz.underscore = function(s) {
    var strColons = /\=\=/;
    var strWords = /([A-Z]+)([A-Z][a-z])/g;
    strLowUp = /([a-z\d])([A-Z])/g;
    strDash = /([a-z\d])([A-Z])/g;
    strQuote = /"/g;
    strSingleQuote = /'/g;
    return s.replace(strColons, "/").replace(strWords, "$1_$2").replace(strLowUp, "$1_$2").replace(strDash, "_").toLowerCase()
};
clazz.getNext = function(obj, prop, add) {
    var result = obj[prop];
    if (result === undefined && add === true) result = obj[prop] = {};
    return result
};
clazz.isContainer = function(current) {
    return /^f|^o/.test(typeof current)
};
clazz.getGlobal = function() {
    try {
        global = window
    } catch (e) {}
    return global
};
clazz.getObject = function(name, roots, add) {
    var parts = name ? name.split(".") : [],
        length = parts.length,
        current, r = 0,
        i, container, rootsLength;
    roots = [roots || clazz.getGlobal()];
    rootsLength = roots.length;
    if (!length) return roots[0];
    for (r; r < rootsLength; r++) {
        current = roots[r];
        container = undefined;
        for (i = 0; i < length && clazz.isContainer(current); i++) {
            container = current;
            current = clazz.getNext(container, parts[i])
        }
        if (container !== undefined && current !== undefined) break
    }
    if (add === false && current !== undefined) delete container[parts[i -
        1]];
    if (add === true && current === undefined) {
        current = roots[0];
        for (i = 0; i < length && clazz.isContainer(current); i++) current = clazz.getNext(current, parts[i], true)
    }
    return current
};
clazz.define("clazz/construct/construct", clazz, function(clazz) {
    var initializing = 0;
    var canGetDescriptor;
    try {
        Object.getOwnPropertyDescriptor({});
        canGetDescriptor = true
    } catch (e) {
        canGetDescriptor = false
    }
    var getDescriptor = function(newProps, name) {
        var descriptor = Object.getOwnPropertyDescriptor(newProps, name);
        if (descriptor && (descriptor.get || descriptor.set)) return descriptor;
        return null
    };
    var inheritGetterSetter = function(newProps, oldProps, addTo) {
        addTo = addTo || newProps;
        var descriptor;
        for (var name in newProps)
            if (descriptor =
                getDescriptor(newProps, name)) this._defineProperty(addTo, oldProps, name, descriptor);
            else clazz.construct._overwrite(addTo, oldProps, name, newProps[name])
    };
    var simpleInherit = function(newProps, oldProps, addTo) {
        addTo = addTo || newProps;
        for (var name in newProps) clazz.construct._overwrite(addTo, oldProps, name, newProps[name])
    };
    clazz.construct = function() {
        if (arguments.length) return clazz.construct.extend.apply(clazz.construct, arguments)
    };
    clazz.simpleExtend(clazz.construct, {
        constructorExtends: true,
        newInstance: function() {
            var inst =
                this.instance(),
                args;
            if (inst.setup) args = inst.setup.apply(inst, arguments);
            if (inst.init) inst.init.apply(inst, args || arguments);
            return inst
        },
        _inherit: canGetDescriptor ? inheritGetterSetter : simpleInherit,
        _defineProperty: function(what, oldProps, propName, descriptor) {
            Object.defineProperty(what, propName, descriptor)
        },
        _overwrite: function(what, oldProps, propName, val) {
            what[propName] = val
        },
        setup: function(base, fullName) {
            this.defaults = clazz.simpleExtend(true, {}, base.defaults, this.defaults)
        },
        instance: function() {
            initializing =
                1;
            var inst = new this;
            initializing = 0;
            return inst
        },
        extend: function(name, staticProperties, instanceProperties) {
            clazz.extend = this;
            var fullName = name,
                klass = staticProperties,
                proto = instanceProperties;
            if (typeof fullName !== "string") {
                proto = klass;
                klass = fullName;
                fullName = null
            }
            if (!proto) {
                proto = klass;
                klass = null
            }
            proto = proto || {};
            var _super_class = this,
                _super = this.prototype,
                Constructor, parts, current, _fullName, _shortName, propName, shortName, namespace, prototype;
            prototype = this.instance();
            clazz.construct._inherit(proto, _super,
                prototype);
            if (fullName) {
                parts = fullName.split(".");
                shortName = parts.pop()
            }
            if (typeof constructorName === "undefined") Constructor = function() {
                return init.apply(this, arguments)
            };

            function init() {
                if (!initializing) return this.constructor !== Constructor && arguments.length && Constructor.constructorExtends ? Constructor.extend.apply(Constructor, arguments) : Constructor.newInstance.apply(Constructor, arguments)
            }
            for (propName in _super_class)
                if (_super_class.hasOwnProperty(propName)) Constructor[propName] = _super_class[propName];
            clazz.construct._inherit(klass, _super_class, Constructor);
            if (fullName) {
                current = clazz.getObject(parts.join("."), clazz.getGlobal(), true);
                namespace = current;
                _fullName = clazz.underscore(fullName.replace(/\./g, "_"));
                _shortName = clazz.underscore(shortName);
                current[shortName] = Constructor
            }
            clazz.simpleExtend(Constructor, {
                constructor: Constructor,
                prototype: prototype,
                namespace: namespace,
                _shortName: _shortName,
                fullName: fullName,
                _fullName: _fullName
            });
            if (shortName !== undefined) Constructor.shortName = shortName;
            Constructor.prototype.constructor =
                Constructor;
            var t = [_super_class].concat(clazz.makeArray(arguments)),
                args = Constructor.setup.apply(Constructor, t);
            if (Constructor.init) Constructor.init.apply(Constructor, args || t);
            return Constructor
        }
    });
    clazz.construct.prototype.setup = function() {};
    clazz.construct.prototype.init = function() {};
    return clazz.construct
});
clazz.construct.extend("simpl4.util.CrudForm", {}, {
    init: function(namespace, entityname, fields, props) {
        this.entityname = entityname;
        this.namespace = namespace;
        var tabView = this.getTabview(props.formlayout, entityname);
        this._fields = fields;
        this._form = {};
        var tabLists = this.getTabLists(this._fields);
        var tabKeys = Object.keys(tabLists);
        tabKeys.forEach(function(tabKey) {
            var tabviewPage = this.getTabViewPage(tabView, tabKey);
            tabviewPage.childShapes = [];
            var layout = tabviewPage.layout || "single";
            var row = null;
            var prevF = null;
            tabLists[tabKey].forEach(function(f,
                i) {
                if (layout == "full" || layout == "single") {
                    row = {
                        id: "Row",
                        childShapes: []
                    };
                    tabviewPage.childShapes.push(row)
                }
                var isBreak = f.edittype == "textarea" || prevF && prevF.edittype == "textarea";
                if ((layout == "double" || layout == "double.mobile") && (isBreak || (i == 0 || i % 2 == 0))) {
                    row = {
                        id: "Row",
                        childShapes: []
                    };
                    tabviewPage.childShapes.push(row)
                }
                row.childShapes.push(this.getFieldShape(f));
                prevF = f
            }, this)
        }, this);
        var p = "data";
        var e = entityname;
        if (entityname.indexOf(":") >= 0) {
            p = entityname.split(":")[0];
            e = entityname.split(":")[1]
        }
        var h1 =
            p + "." + e + "." + tabView.childShapes[0].xf_id;
        if (tabView.childShapes.length == 1 && h1 == tr(h1)) {
            this._form = tabView.childShapes[0];
            this._form.id = "Form"
        } else this._form = tabView
    },
    getFieldShape: function(f) {
        var shape = {};
        if (!isNaN(f.datatype)) {
            shape.id = this.convertOrientId(f.datatype);
            shape.xf_id = f.name;
            shape.xf_type = this.convertOrientType(f.datatype);
            shape.xf_default = f.default_value !== "" ? f.default_value : null;
            var p = "odata";
            var e = this.entityname;
            if (this.entityname.indexOf(":") >= 0) {
                p = this.entityname.split(":")[0];
                e = this.entityname.split(":")[1]
            }
            shape.label = tr(p + "." + e + "." + f.name);
            shape.xf_namespace = this.namespace;
            console.log("OrientDB:", shape);
            return shape
        }
        shape.id = "Input";
        if (f.edittype == "select") {
            shape.id = "Enumselect";
            shape.items = f.selectable_items.getItems()
        }
        if (f.edittype == "textarea") {
            shape.id = "Textarea";
            shape.xf_rows = f.editoptions_rows
        }
        if (f.datatype == "binary") shape.id = "Upload";
        shape.xf_id = f.name;
        shape.xf_type = this.convertFieldType(f);
        var p = "data";
        var e = this.entityname;
        if (this.entityname.indexOf(":") >= 0) {
            p =
                this.entityname.split(":")[0];
            e = this.entityname.split(":")[1]
        }
        shape.label = tr(p + "." + e + "." + f.name);
        if (f.constraints) {
            var c = JSON.parse(f.constraints);
            shape.regulaConstraints = simpl4.util.FormManager.constructRegulaConstraints(c)
        }
        if (f.datatype && f.datatype.match(/^relatedto/)) {
            var s = f.datatype.split("/");
            shape.id = "RelatedTo";
            shape.xf_type = s[2];
            shape.xf_namespace = this.namespace
        }
        if (f.form_enabled_expr != null) shape.xf_enabled = f.form_enabled_expr + "";
        shape.xf_default = f.default_value !== "" ? f.default_value : null;
        return shape
    },
    convertFieldType: function(f) {
        var retType = null;
        if (f.datatype && f.datatype == "date") retType = f.edittype == "text" ? "date" : f.edittype;
        else if (f.datatype && (f.datatype == "decimal" || f.datatype == "double")) retType = "double";
        else if (f.datatype && (f.datatype == "number" || f.datatype == "integer" || f.datatype == "long")) retType = "integer";
        if (retType === "boolean") retType = "integer";
        return retType
    },
    getTabViewPage: function(tabView, tabKey) {
        var childShapes = tabView.childShapes;
        var ret = null;
        childShapes.forEach(function(c) {
            if (c.xf_id ==
                tabKey) {
                ret = c;
                return
            }
        }, this);
        return ret
    },
    getTabLists: function(fields) {
        var ret = {};
        fields.forEach(function(f) {
            if (f.id == "id") return;
            var tab = "tab1";
            if (f.formoptions && f.formoptions.tab) tab = f.formoptions.tab;
            var list = ret[tab];
            if (list === undefined) {
                list = [];
                ret[tab] = list
            }
            list.push(f)
        }, this);
        return ret
    },
    getTabview: function(formLayout, entityname) {
        var defLayout = {
            "id": "Tabview",
            "childShapes": [{
                "xf_id": "tab1",
                "id": "Page",
                "childShapes": []
            }]
        };
        if (formLayout == null) return defLayout;
        else {
            try {
                var lays = formLayout.split(";");
                var formLayout = {
                    id: "Tabview",
                    childShapes: []
                };
                var childShapes = formLayout.childShapes;
                for (var i = 0; i < lays.length; i++) {
                    var t = lays[i].split(":");
                    var page = {};
                    if (t.length == 2) {
                        page.xf_id = t[0];
                        page.layout = t[1]
                    }
                    if (t.length == 1) {
                        page.xf_id = t[0];
                        page.layout = "single"
                    }
                    page.id = "Page";
                    var p = "data";
                    var e = entityname;
                    if (entityname.indexOf(":") >= 0) {
                        p = entityname.split(":")[0];
                        e = entityname.split(":")[1]
                    }
                    page.title = tr(p + "." + e + "." + page.xf_id);
                    childShapes.push(page)
                }
            } catch (e) {
                console.log("catch:" + e);
                return defLayout
            }
            return formLayout
        }
    },
    convertOrientId: function(type) {
        if (type == "17") type = "Input";
        if (type == "5") type = "Input";
        if (type == "1") type = "Input";
        if (type == "3") type = "Input";
        if (type == "7") type = "Input";
        if (type == "0") type = "Input";
        if (type == "21") type = "Input";
        if (type == "19") type = "Input";
        if (type == "6") type = "Input";
        if (type == "9") type = "Form";
        if (type == "10") type = "Crud";
        if (type == "11") type = "Crud";
        if (type == "12") type = "Crud";
        if (type == "13") type = "Form";
        if (type == "14") type = "Crud";
        if (type == "15") type = "Crud";
        if (type == "16") type = "Crud";
        return type
    },
    convertOrientType: function(type) {
        if (type ==
            "17") type = "integer";
        if (type == "5") type = "double";
        if (type == "1") type = "integer";
        if (type == "3") type = "integer";
        if (type == "7") type = "string";
        if (type == "0") type = "boolean";
        if (type == "21") type = "double";
        if (type == "19") type = "date";
        if (type == "6") type = "datetime";
        if (type == "9") type = "Form";
        if (type == "10") type = "Crud";
        if (type == "11") type = "Crud";
        if (type == "12") type = "Crud";
        if (type == "13") type = "Form";
        if (type == "14") type = "Crud";
        if (type == "15") type = "Crud";
        if (type == "16") type = "Crud";
        return type
    },
    getSpec: function() {
        return this._form
    },
    toString: function() {
        return "CrudForm:" +
            this._fields
    }
});
simpl4.util.BaseManager.extend("simpl4.util.EntityManager", {
    entityCache: {},
    fieldCache: {},
    clearCache: function() {
        simpl4.util.EntityManager.fieldCache = {};
        simpl4.util.EntityManager.entityCache = {}
    },
    getFields: function(entity, withAutoGen, withRelations, filter, mapping) {
        var args = Args([{
                entity: Args.STRING | Args.Required
            }, {
                withAutoGen: Args.BOOLEAN | Args.Optional
            }, {
                withRelations: Args.BOOLEAN | Args.Optional
            }, {
                filter: Args.STRING | Args.Optional
            }, {
                mapping: Args.STRING | Args.Optional
            }, {
                namespace: Args.STRING | Args.Optional
            }],
            arguments);
        var pack = "data";
        var entityName = args.entity;
        if (args.entity.indexOf(":") > 0) {
            pack = args.entity.split(":")[0];
            entityName = args.entity.split(":")[1]
        }
        var namespace = args.namespace || simpl4.util.BaseManager.getNamespace();
        var withAutoGen = args.withAutoGen === true;
        var withRelations = args.withRelations === true;
        var fields = simpl4.util.EntityManager.fieldCache["fields-" + namespace + "-" + args.entity + "-" + withAutoGen + "-" + withRelations + "-" + args.filter + "-" + args.mapping];
        if (!fields) try {
            fields = simpl4.util.Rpc.rpcSync("entity:getFields", {
                storeId: namespace + "_" + pack,
                withAutoGen: withAutoGen,
                withRelations: withRelations,
                filter: args.filter,
                mapping: args.mapping,
                entity: entityName
            });
            simpl4.util.EntityManager.fieldCache["fields-" + namespace + "-" + args.entity + "-" + withAutoGen + "-" + withRelations + "-" + args.filter + "-" + args.mapping] = fields
        } catch (e) {
            this._error("EntityManager.getFields", e);
            return []
        }
        return fields
    },
    getUser: function() {
        var user = simpl4.util.EntityManager.entityCache["user"];
        if (!user) {
            user = simpl4.util.Rpc.rpcSync("auth:getUserProperties");
            simpl4.util.EntityManager.entityCache["user"] = user
        } else;
        return user
    },
    getEntityAccess: function(entity) {
        var args = Args([{
            antity: Args.STRING | Args.Required
        }, {
            namespace: Args.STRING | Args.Optional
        }], arguments);
        var namespace = args.namespace || this.getNamespace();
        var user = this.getUser();
        var entityDesc = this.getEntity(entity, {
            namespace: namespace
        });
        var access = {
            "update": "all",
            "import": "all",
            "delete": "all"
        };
        if (entityDesc && entityDesc.write === false) {
            access["update"] = "no";
            access["import"] = "no";
            access["delete"] = "no"
        }
        return access
    },
    hasEntityUpdatePermission: function(entity, namespace) {
        var access = this.getEntityAccess(entity, namespace);
        console.log("access:", access);
        var user = this.getUser();
        console.log("user:", user);
        if (user.admin) return true;
        if (access["update"] === undefined || access["update"] == "all" || access["update"] == "owner") return true;
        return false
    },
    getEntities: function() {
        var args = Args([{
            namespace: Args.STRING | Args.Optional
        }, {
            pack: Args.STRING | Args.Optional
        }], arguments);
        var namespace = args.namespace || simpl4.util.BaseManager.getNamespace();
        var entities = simpl4.util.EntityManager.entityCache["entities-" + namespace];
        if (!entities) try {
            entities = simpl4.util.Rpc.rpcSync("entity:getEntities", {
                storeId: namespace + "_" + args.pack
            });
            simpl4.util.EntityManager.entityCache["entities-" + namespace] = entities
        } catch (e) {
            this._error("EntityManager.getEntities", e);
            return []
        }
        return entities
    },
    getEntity: function(name) {
        var args = Args([{
            name: Args.STRING | Args.Required
        }, {
            namespace: Args.STRING | Args.Optional
        }], arguments);
        var pack = "data";
        var entityName = args.name;
        if (args.name.indexOf(":") >
            0) {
            pack = args.name.split(":")[0];
            entityName = args.name.split(":")[1]
        }
        var namespace = args.namespace || this.getNamespace();
        var entities = simpl4.util.EntityManager.entityCache["entities-" + namespace];
        if (!entities) entities = this.getEntities({
            namespace: namespace,
            pack: pack
        });
        if (!entities) {
            this._error("EntityManager.getEntity:" + args.name + "(" + namespace + ") not found");
            return null
        }
        for (var i = 0; i < entities.length; i++) {
            var entity = entities[i];
            if (entity.name == entityName) return entity
        }
        for (var i = 0; i < entities.length; i++) {
            var entity =
                entities[i];
            for (var j = 0; entity.childs && j < entity.childs.length; j++) {
                var child = entity.childs[j];
                if (child.modulename == entityName) return child
            }
        }
        return null
    },
    getEntityViewProperties: function(entity, view) {
        var args = Args([{
            entity: Args.STRING | Args.Required
        }, {
            view: Args.STRING | Args.Required
        }, {
            namespace: Args.STRING | Args.Optional
        }], arguments);
        var namespace = args.namespace || simpl4.util.BaseManager.getNamespace();
        var props = simpl4.util.EntityManager.fieldCache["mvcf-" + args.entity + "-" + namespace + "-" + args.view];
        if (!props) try {
            props =
                this.__getEntityViewProperties(namespace, args.entity, args.view);
            if (!props) props = simpl4.util.Rpc.rpcSync("setting:getPropertiesForEntityView", {
                settingsid: "global",
                namespace: namespace,
                entity: args.entity,
                view: args.view
            });
            if (props == null) props = {};
            simpl4.util.EntityManager.fieldCache["mvcf-" + args.entity + "-" + namespace + "-" + args.view] = props
        } catch (e) {
            this._error("EntityManager.getEntityViewProperties", e)
        }
        return props
    },
    getFieldsetsForEntity: function(entity) {
        var args = Args([{
            entity: Args.STRING | Args.Required
        }, {
            namespace: Args.STRING | Args.Optional
        }], arguments);
        var namespace = args.namespace || simpl4.util.BaseManager.getNamespace();
        var fieldsets = simpl4.util.EntityManager.fieldCache["fsetf-" + namespace + "-" + args.entity];
        if (fieldsets === undefined) {
            fieldsets = this.__getFieldsetsForEntity(namespace, args.entity);
            if (!fieldsets) fieldsets = simpl4.util.Rpc.rpcSync("setting:getFieldsetsForEntity", {
                namespace: namespace,
                settingsid: "global",
                entity: args.entity
            });
            simpl4.util.EntityManager.fieldCache["fsetf-" + namespace + "-" + args.entity] =
                fieldsets
        }
        return fieldsets
    },
    getPropertiesForEntity: function(entity) {
        var args = Args([{
            entity: Args.STRING | Args.Required
        }, {
            namespace: Args.STRING | Args.Optional
        }], arguments);
        var namespace = args.namespace || simpl4.util.BaseManager.getNamespace();
        var properties = simpl4.util.EntityManager.fieldCache["eprops-" + namespace + "-" + args.entity];
        if (properties === undefined) {
            properties = this.__getPropertiesForEntity(namespace, args.entity);
            if (!properties) properties = simpl4.util.Rpc.rpcSync("setting:getPropertiesForEntityView", {
                namespace: namespace,
                settingsid: "global",
                view: null,
                entity: args.entity
            });
            simpl4.util.EntityManager.fieldCache["eprops-" + namespace + "-" + args.entity] = properties
        }
        return properties
    },
    getEntityViewFields: function(entity, view, build) {
        var args = Args([{
            entity: Args.STRING | Args.Required
        }, {
            namespace: Args.STRING | Args.Optional
        }, {
            view: Args.STRING | Args.Required
        }, {
            build: Args.BOOLEAN | Args.Optional
        }], arguments);
        var buildstr = build !== false ? "true" : "no";
        var namespace = args.namespace || this.getNamespace();
        var fields = simpl4.util.EntityManager.fieldCache["vf-" +
            args.entity + "-" + namespace + "-" + args.view + "-" + buildstr];
        if (fields === undefined) {
            try {
                fields = this.__getEntityViewFields(namespace, args.entity, args.view);
                if (!fields) fields = simpl4.util.Rpc.rpcSync("setting:getFieldsForEntityView", {
                    settingsid: "global",
                    namespace: namespace,
                    entity: args.entity,
                    view: args.view
                })
            } catch (e) {
                this._error("EntityManager.getEntityViewFields", e)
            }
            if (build !== false) fields = this.buildColModel(fields, namespace, args.entity, args.view);
            simpl4.util.EntityManager.fieldCache["vf-" + args.entity + "-" +
                namespace + "-" + args.view + "-" + buildstr] = fields
        }
        return fields
    },
    __getEntityViewFields: function(namespace, entity, view) {
        view = view || "all";
        var settings = this.getAllSettingsForEntityList(namespace, entity);
        return settings.viewFields[view]
    },
    __getEntityViewProperties: function(namespace, entity, view) {
        view = view || "all";
        var settings = this.getAllSettingsForEntityList(namespace, entity);
        return settings.viewProps[view]
    },
    __getFieldsetsForEntity: function(namespace, entity) {
        var settings = this.getAllSettingsForEntityList(namespace,
            entity);
        return settings.fieldSets
    },
    __getPropertiesForEntity: function(namespace, entity) {
        var settings = this.getAllSettingsForEntityList(namespace, entity);
        return settings.properties
    },
    getAllSettingsForEntityList: function(namespace, entityList) {
        if (!Array.isArray(entityList)) entityList = [entityList];
        var ok = true;
        for (var i = 0; i < entityList.length; i++) {
            var e = entityList[i];
            if (!simpl4.util.EntityManager.fieldCache["as-" + namespace + "-" + e]) {
                ok = false;
                break
            }
        }
        if (!ok) {
            var settingList = simpl4.util.Rpc.rpcSync("setting:getAllSettingsForEntityList", {
                namespace: namespace || this.getNamespace(),
                settingsid: "global",
                entities: entityList
            });
            for (var i = 0; i < entityList.length; i++) {
                var entity = entityList[i];
                var setting = settingList[i];
                simpl4.util.EntityManager.fieldCache["as-" + namespace + "-" + entity] = setting
            }
        }
        return simpl4.util.EntityManager.fieldCache["as-" + namespace + "-" + entityList[0]]
    },
    getEntityPermittedFields: function(entity) {
        var args = Args([{
            entity: Args.STRING | Args.Required
        }, {
            namespace: Args.STRING | Args.Optional
        }], arguments);
        var pack = "data";
        var entityName = args.entity;
        if (args.entity.indexOf(":") > 0) {
            pack = args.entity.split(":")[0];
            entityName = args.entity.split(":")[1]
        }
        var namespace = args.namespace || simpl4.util.BaseManager.getNamespace();
        var fields = simpl4.util.EntityManager.fieldCache["af-" + args.entity];
        if (fields === undefined) {
            fields = simpl4.util.Rpc.rpcSync("entity:getPermittedFields", {
                storeId: namespace + "_" + pack,
                entity: entityName
            });
            simpl4.util.EntityManager.fieldCache["af-" + args.entity] = fields
        }
        return fields
    },
    _hasSelectableItems: function(si) {
        if (si == undefined || si == null) return false;
        if (typeof si == "string" && si == "") return false;
        if (typeof si == "string" && si.match(/^{/)) si = JSON.parse(si);
        if (si.totalCount != null && si.totalCount == 0) return false;
        return true
    },
    _error: function(msg, e) {
        if (e) {
            console.error(msg + ":" + (e.message || e));
            alert(msg + ":" + (e.message || e))
        } else {
            console.error(msg);
            alert(msg)
        }
    },
    createSelectableItems: function(url, varMap, namespace, entity, name, view) {
        return new simpl4.util.SelectableItems({
            url: url,
            namespace: namespace,
            varMap: varMap
        })
    },
    buildColModel: function(gridfields, namespace,
        entity, view) {
        var category = "data";
        if (gridfields == null) return;
        var primKey = null;
        var hasIdField = false;
        jQuery.each(gridfields, function(k, v) {
            if (v["primary_key"]) primKey = v["name"];
            if (v["id"] == "id") hasIdField = true
        });
        var colModel = [];
        if (!(view && view.match(/duplicate/)))
            if (!hasIdField && primKey == null) {
                var col = {};
                col.name = "id";
                col.id = "id";
                col.hidden = true;
                col.search_options = ["bw", "cn", "eq"];
                colModel.push(col)
            }
        for (var ci = 0; ci < gridfields.length; ci++) {
            var col = {};
            var gridfield = gridfields[ci];
            col.name = col.id = gridfield.name;
            col.editable = true;
            col.edittype = gridfield.edittype;
            col.readonly = gridfield.readonly;
            col.datatype = gridfield.datatype || "string";
            if (col.datatype.match("^related")) col.edittype = "relatedto";
            if (col.edittype == null || col.edittype == "")
                if (col.datatype == "boolean") col.edittype = "checkbox";
                else if (col.datatype == "binary") col.edittype = "upload";
            else if (col.datatype == "string" && col.selectable_items) col.edittype = "select";
            else col.edittype = "text";
            if (gridfield.name.match(/^_/)) col.label = gridfield.label || tr(category + "." + gridfield.name);
            else col.label = gridfield.label || tr(category + "." + entity + "." + gridfield.name);
            for (var prop in gridfield) {
                var val = gridfield[prop];
                if (prop != "name" && prop != "formula_in" && prop != "formula_out" && prop != "datatype" && prop != "id" && !prop.match("^jcr:") && prop != "edittype" && prop != "tab")
                    if (val != null) col[prop] = val
            }
            if (view && (view.match(/form/) || view.match(/search/) || view.match(/grid/))) {
                if (gridfield["tab"] == null) gridfield["tab"] = "tab1";
                col.formoptions = {
                    tab: gridfield["tab"]
                };
                var varMap = {};
                if (this._hasSelectableItems(col.selectable_items)) col.selectable_items =
                    this.createSelectableItems(col.selectable_items, varMap, namespace, entity, col.name, view);
                else col.selectable_items = null;
                if (this._hasSelectableItems(col.searchable_items)) col.searchable_items = this.createSelectableItems(col.searchable_items, varMap, namespace, entity, col.name, view);
                else col.searchable_items = null
            }
            if (primKey && primKey == col.name) col.key = true;
            colModel.push(col)
        }
        return colModel
    }
}, {});
simpl4.util.BaseManager.extend("simpl4.util.FormManager", {
    selectableItemsCache: {},
    crudFormCache: {},
    getForm: function(name, namespace) {
        var failed = function(details) {
            alert("GetForm failed" + ":" + details.message)
        };
        try {
            var ns = namespace || simpl4.util.BaseManager.getNamespace();
            simpl4.util.MessageManager.installMessages(ns);
            var ret = simpl4.util.Rpc.rpcSync("git:searchContent", {
                reponame: ns,
                name: name,
                type: "sw.form"
            });
            return ret
        } catch (e) {
            failed(e);
            return []
        }
    },
    getCrudForm: function(entityname, namespace) {
        var cf = this.crudFormCache[namespace +
            "/" + entityname];
        if (cf == null) {
            var props = simpl4.util.EntityManager.getEntityViewProperties(entityname, "main-form", {
                namespace: namespace
            });
            console.log("props:", props);
            if (this.isEmpty(props.customForm)) {
                var fields = simpl4.util.EntityManager.getEntityViewFields(entityname, "main-form", true, {
                    namespace: namespace
                });
                var _cf = new simpl4.util.CrudForm(namespace, entityname, fields, props);
                cf = _cf.getSpec()
            } else cf = props.customForm;
            this.crudFormCache[namespace + "/" + entityname] = cf
        }
        return cf
    },
    createSelectableItems: function(namespace,
        formName, fieldName, url) {
        namespace = namespace || simpl4.util.BaseManager.getNamespace();
        var si = new simpl4.util.SelectableItems({
            namespace: namespace,
            url: url
        });
        this.selectableItemsCache[namespace + "/" + formName + "/" + fieldName + "/" + url] = si;
        return si
    },
    getSelectableItems: function(namespace, formName, fieldName, url) {
        var si = this.selectableItemsCache[namespace + "/" + formName + "/" + fieldName + "/" + url];
        if (si == null && url != null) si = this.createSelectableItems(namespace, formName, fieldName, url);
        return si
    },
    handleQueryBuilderSearchInput: function(rule,
        filter) {
        var regulaConstraints = null;
        if (filter.constraints) {
            var c = JSON.parse(filter.constraints);
            regulaConstraints = "data-constraints='" + this.constructRegulaConstraints(c) + "'"
        }
        var attributes = this.constructAttributes(filter.type, filter.label, c, filter.dataValues != null);
        if (filter.dataValues) rule.find(".rule-value-container").append("<select-field " + attributes + " name='" + rule.selector.substring(1) + "_value_0' json-items='" + JSON.stringify(filter.dataValues) + "'></select-field>");
        else if (filter.datatype == "boolean") rule.find(".rule-value-container").append("<checkbox-field " +
            attributes + " " + regulaConstraints + ' name="' + rule.selector.substring(1) + '_value_0" ></checkbox-field>');
        else rule.find(".rule-value-container").append("<input-field " + attributes + " " + regulaConstraints + ' name="' + rule.selector.substring(1) + '_value_0" ></input-field>')
    },
    getSelectables: function(selectables) {
        var elements = "";
        for (var i = 0; i < selectables.length; i++) {
            var sel = selectables[i];
            elements += '<paper-item name="' + sel.value + '">' + sel.label + "</paper-item>"
        }
        return elements
    },
    constructRegulaConstraints: function(c) {
        var ret =
            "";
        var b = "";
        c.forEach(function(x) {
            var params = this._constraintParams[x.annotation];
            ret += b + "@" + x.annotation;
            ret += '(message="' + this.getMessage(x) + '"';
            if (params) {
                if (params.length > 0) {
                    var key = params[0];
                    var val = key == "format" ? '"YMD"' : x.parameter1;
                    if (key == "regex") val = "/" + val + "/";
                    ret += "," + key + "=" + val
                }
                if (params.length > 1) {
                    var key = params[1];
                    var val = x.parameter2;
                    ret += "," + key + "=" + val
                }
            }
            ret += ")";
            b = " "
        }, this);
        return ret
    },
    getMessage: function(x) {
        if (x.message && x.message.length > 0)
            if (x.message.match(/^[%@]/)) return tr(x.message.substring(1));
            else return x.message;
        return tr("validation." + x.annotation)
    },
    constructAttributes: function(xtype, label, c, dropdown) {
        var map = {};
        if (c == null) c = [];
        map.type = "text";
        if (xtype === "date") map.type = "date";
        if (xtype === "integer") map.type = "number";
        if (xtype === "double") map.type = "number";
        map.style = "min-width:60px;";
        if (dropdown) map.style += "display:inline-block;";
        map.label = label;
        map.floatingLabel = false;
        map.compact = true;
        if (map.type == "number") {
            map.step = "1";
            map.preventInvalidInput = true
        }
        if (map.type == "double") {
            map.preventInvalidInput =
                true;
            map.step = "any"
        }
        c.forEach(function(x) {
            var a = x.annotation;
            if (a == "Min" || a == "Max" || a == "Pattern") map[a] = x.parameter1;
            if (a == "Digits") {
                var f = parseInt(x.parameter2);
                map.step = Math.pow(10, -f) + ""
            }
            if (a == "Email") map.type = "email";
            if (a == "Url") map.type = "url"
        });
        var b = "";
        var ret = "";
        Object.keys(map).forEach(function(key) {
            if (map[key] === true) ret += b + this.toDash(key);
            else ret += b + this.toDash(key) + "=" + map[key];
            b = " "
        }.bind(this));
        return ret
    },
    isEmpty: function(str) {
        return !str || !str.length
    },
    toDash: function(camel) {
        if (Polymer.whenReady) return camel;
        var dash = camel.replace(/([a-z][A-Z])/g, function(g) {
            return g[0] + "-" + g[1].toLowerCase()
        });
        return dash
    },
    _constraintParams: {
        Max: ["value"],
        Min: ["value"],
        Range: ["min", "max"],
        Pattern: ["regex"],
        Length: ["min", "max"],
        Digits: ["integer", "fraction"],
        Past: ["format"],
        Future: ["format"],
        Step: ["min", "max", "value"]
    }
}, {});
clazz.construct.extend("simpl4.util.Globals", {
    globalsCache: {},
    clearCache: function() {
        simpl4.util.Globals.globalsCache = {}
    },
    getAll: function() {
        return simpl4.util.Globals.globalsCache
    },
    set: function(key, value) {
        simpl4.util.Globals.globalsCache[key] = value
    },
    get: function(key) {
        return simpl4.util.Globals.globalsCache[key]
    }
}, {});
clazz.construct.extend("simpl4.util.Inflector", {
    getEntityName: function(name) {
        return this.singularize(name).toLowerCase()
    },
    pluralize: function(word) {
        console.log("pluralize:" + word);
        if (word && !word.match(/_list$/)) return word + "_list";
        return word
    },
    singularize: function(word) {
        console.log("singularize:" + word);
        if (word && word.match(/_list$/)) return word.substring(0, word.length - 5);
        return word
    }
}, {});
require("./Construct");
clazz.construct.extend("simpl4.util.Map", {}, {
    init: function(iterable) {
        this.store = {};
        if (iterable) iterable.forEach(function(i) {
            this.set(i[0], i[1])
        })
    },
    get: function(key) {
        return this.store[key]
    },
    put: function(key, val) {
        return this.set(key, val)
    },
    set: function(key, val) {
        this.store[key] = val;
        return this
    },
    "delete": function(key, val) {
        if (!this.has(key)) return false;
        delete this.store[key];
        return true
    },
    clear: function() {
        this.store = {}
    },
    has: function(key, val) {
        var hasKey = this.store[key];
        return hasKey ? true : false
    },
    size: function() {
        return this.keys().length
    },
    keys: function() {
        return Object.keys(this.store)
    },
    keys: function() {
        return Object.keys(this.store)
    },
    values: function() {
        var vals = [];
        this.forEachEntry(function(entry) {
            vals.push(entry)
        });
        return vals
    },
    forEachEntry: function(iter) {
        var keys = this.makeIterator(this.keys());
        var next;
        while (!(next = keys.next()).done) iter(this.get(next.value), next.value, this)
    },
    forEach: function(iter) {
        this.forEachEntry(function(entry, key) {
            iter(entry, key, this)
        })
    },
    makeIterator: function(array) {
        var nextIndex = 0;
        return {
            next: function() {
                return nextIndex <
                    array.length ? {
                        value: array[nextIndex++],
                        done: false
                    } : {
                        done: true
                    }
            }
        }
    },
    toJS: function() {
        return this.store
    }
});
require("./Construct");
clazz.construct.extend("simpl4.util.Merge", {
    deepmerge: function(target, src) {
        var array = Array.isArray(src);
        var dst = array && [] || {};
        if (array) {
            target = target || [];
            dst = dst.concat(target);
            src.forEach(function(e, i) {
                if (typeof dst[i] === "undefined") dst[i] = e;
                else if (typeof e === "object") dst[i] = simpl4.util.Merge.deepmerge(target[i], e);
                else if (target.indexOf(e) === -1) dst.push(e)
            })
        } else {
            if (target && typeof target === "object") Object.keys(target).forEach(function(key) {
                dst[key] = target[key]
            });
            Object.keys(src).forEach(function(key) {
                if (typeof src[key] !==
                    "object" || !src[key]) dst[key] = src[key];
                else if (!target[key]) dst[key] = src[key];
                else dst[key] = simpl4.util.Merge.deepmerge(target[key], src[key])
            })
        }
        return dst
    },
    clonemerge: function(argv) {
        [].splice.call(arguments, 0, 0, true);
        return simpl4.util.Merge.merge.apply(null, arguments)
    },
    merge: function(clone, argv) {
        var firstarg = 1;
        var result = arguments[firstarg];
        var size = arguments.length - firstarg;
        if (clone || simpl4.util.Merge._typeof(result) !== "object") result = {};
        for (var index = 0; index < size; ++index) {
            var item = arguments[index +
                    firstarg],
                type = simpl4.util.Merge._typeof(item);
            if (type !== "object") continue;
            for (var key in item) {
                var sitem = clone ? simpl4.util.Merge.clone(item[key]) : item[key];
                result[key] = simpl4.util.Merge._mergeRecursive(result[key], sitem)
            }
        }
        return result
    },
    clone: function(input) {
        var output = input,
            type = simpl4.util.Merge._typeof(input),
            index, size;
        if (type === "array") {
            output = [];
            size = input.length;
            for (index = 0; index < size; ++index) output[index] = simpl4.util.Merge.clone(input[index])
        } else if (type === "object") {
            output = {};
            for (index in input) output[index] =
                simpl4.util.Merge.clone(input[index])
        }
        return output
    },
    _mergeRecursive: function(base, extend) {
        if (simpl4.util.Merge._typeof(base) !== "object") return extend;
        for (var key in extend)
            if (simpl4.util.Merge._typeof(base[key]) === "object" && simpl4.util.Merge._typeof(extend[key]) === "object") base[key] = simpl4.util.Merge._mergeRecursive(base[key], extend[key]);
            else base[key] = extend[key];
        return base
    },
    _typeof: function(input) {
        return {}.toString.call(input).slice(8, -1).toLowerCase()
    }
}, {});
simpl4.util.BaseManager.extend("simpl4.util.MessageManager", {
    namespaceMap: null,
    transMap: null,
    getMessages: function(namespace) {
        var failed = function(details) {
            console.error("GetMessages(" + namespace + ") failed" + ":" + details.message)
        };
        try {
            var ret = simpl4.util.Rpc.rpcSync("message:getMessages", {
                namespace: namespace,
                lang: simpl4.util.BaseManager.getLanguage()
            });
            return ret
        } catch (e) {
            failed(e);
            return []
        }
    },
    toMap: function(rows) {
        var transMap = simpl4.util.MessageManager.transMap;
        var count = rows.length;
        for (var i = 0; i < count; i++) {
            var row =
                rows[i];
            transMap[row.msgid] = row.msgstr
        }
    },
    addAliases: function(map) {
        Object.keys(map).forEach(function(key) {
            var val = map[key];
            var t = simpl4.util.MessageManager.transMap[val];
            simpl4.util.MessageManager.transMap[key] = t
        })
    },
    installMessages: function(namespace) {
        if (this.namespaceMap[namespace] == null) {
            var rows = this.getMessages(namespace);
            this.toMap(rows);
            this.namespaceMap[namespace] = true
        }
    },
    installBaseMessages: function() {
        this.namespaceMap = {};
        this.transMap = {};
        this.installMessages("global");
        this.installMessages(simpl4.util.BaseManager.getNamespace())
    },
    tr: function(id) {
        var t = simpl4.util.MessageManager.transMap[id];
        return t == null ? id : t
    }
}, {});
require("./Construct");
require("./Map");
simpl4.util.Map.extend("simpl4.util.MultiMap", {}, {
    init: function(iterable) {
        simpl4.util.Map.prototype.init.call(this, iterable)
    },
    set: function(key, val) {
        var args = Array.prototype.slice.call(arguments);
        key = args.shift();
        var entry = this.get(key);
        if (!entry) {
            entry = [];
            this.store[key] = entry
        }
        Array.prototype.push.apply(entry, args);
        return this
    },
    "delete": function(key, val) {
        if (!this.has(key)) return false;
        if (arguments.length == 1) {
            delete this.store[key];
            return true
        } else {
            var entry = this.get(key);
            var idx = entry.indexOf(val);
            if (idx != -1) {
                entry.splice(idx, 1);
                return true
            }
        }
        return false
    },
    has: function(key, val) {
        var hasKey = this.store.hasOwnProperty(key);
        if (arguments.length == 1 || !hasKey) return hasKey;
        var entry = this.get(key) || [];
        return entry.indexOf(val) != -1
    },
    size: function() {
        var keys = this.makeIterator(this.keys());
        var next, total = 0;
        while (!(next = keys.next()).done) total += this.get(next.value).length;
        return total
    },
    values: function() {
        var vals = [];
        this.forEachEntry(function(entry) {
            Array.prototype.push.apply(vals, entry)
        });
        return vals
    },
    forEach: function(iter) {
        this.forEachEntry(function(entry,
            key) {
            entry.forEach(function(item) {
                iter(item, key, this)
            })
        })
    }
});
clazz.construct.extend("simpl4.util.PageRegistry", {
    pageCache: {},
    observable: null,
    activePage: null,
    clearCache: function() {
        simpl4.util.PageRegistry.pageCache = {}
    },
    addPage: function(hash, page) {
        simpl4.util.PageRegistry.pageCache[hash] = page
    },
    getPage: function(hash) {
        return simpl4.util.PageRegistry.pageCache[hash]
    },
    addPages: function(pages) {
        for (var i = 0; i < pages.length; i++) simpl4.util.PageRegistry.pageCache[pages[i].hash] = pages[i]
    },
    getPages: function() {
        var keys = Object.keys(simpl4.util.PageRegistry.pageCache);
        var ret = [];
        for (var i = 0; i < keys.length; i++) ret.push(simpl4.util.PageRegistry.pageCache[keys[i]]);
        return ret
    },
    getPageByHash: function(hash) {
        var pages = simpl4.util.PageRegistry.getPages();
        for (var i = 0; i < pages.length; i++)
            if (pages[i].hash == hash) return pages[i];
        return null
    },
    setActivePage: function(ap) {
        this.activePage = ap
    },
    getActivePage: function() {
        return this.activePage
    },
    registerListener: function() {
        var aList = document.querySelectorAll("html /deep/ a");
        var source = Rx.DOM.fromEvent(aList, "tap", function(e) {
            return e
        });
        return source
    },
    subscribe: function(cb) {
        if (this.observable == null) this.observable = this.registerListener();
        this.observable.subscribe(cb)
    }
}, {});
regula.custom({
    name: "AssertTrue",
    defaultMessage: "The answer must be equal to 42",
    validator: function() {
        return this.value === true
    }
});
regula.custom({
    name: "AssertFalse",
    defaultMessage: "The answer must be equal to 42",
    validator: function() {
        return this.value !== true
    }
});
regula.custom({
    name: "NotNull",
    defaultMessage: "",
    validator: function() {
        return this.getValue() !== null
    }
});
clazz.construct.extend("simpl4.util.Rpc", {
    _getPassword: function() {
        return simpl4.util.BaseManager.getPassword()
    },
    _getUserName: function() {
        return simpl4.util.BaseManager.getUser()
    },
    rpcSync: function(dummy, parameter) {
        if (arguments.length < 1) throw "RpcSync not enough args";
        var s = arguments[0].split(":");
        if (s.length != 2) throw "RpcSync wrong arg(service:method)";
        parameter = parameter || {};
        var service = s[0];
        var method = s[1];
        var newArgs = [];
        newArgs.push(method);
        for (var i = 1; i < arguments.length; i++) newArgs.push(arguments[i]);
        var namespace = "xyz";
        if (parameter && parameter.namespace) namespace = parameter.namespace;
        var url = simpl4.util.BaseManager.getBaseUrl() + "/rpc/" + namespace + "/" + service;
        var requestObject = {
            "service": service,
            "method": method,
            "params": parameter
        };
        var config = {
            completed: parameter.completed,
            failed: parameter.failed,
            context: parameter.context,
            msg: parameter.msg
        };
        var result = simpl4.util.Rpc._send(url, false, config, requestObject);
        if (!result) throw "Networkerror:result is null";
        if (result.error) {
            console.log("Rpc.error:", result);
            throw result.error;
        }
        if (typeof result.result == "string") try {
            return JSON.parse(result.result)
        } catch (e) {
            return result.result
        }
        return result.result
    },
    rpcAsync: function(params) {
        if (params.async != null && params.async == false) try {
            var result = simpl4.util.Rpc.rpcSync(params.service + ":" + params.method, params.parameter);
            if (params.completed) params.completed.call(params.context, result);
            return result
        } catch (ex) {
            if (params.failed) {
                params.failed.call(params.context, ex);
                return
            } else throw ex;
        } else {
            var namespace = "xyz";
            if (params.parameter &&
                params.parameter.namespace) namespace = params.parameter.namespace
        }
        var url = simpl4.util.BaseManager.getBaseUrl() + "/rpc/" + namespace + "/" + params.service;
        var requestObject = {
            "service": params.service,
            "method": params.method,
            "params": params.parameter
        };
        var config = {
            completed: params.completed,
            failed: params.failed,
            context: params.context,
            msg: params.msg
        };
        simpl4.util.Rpc._send(url, true, config, requestObject)
    },
    _send: function(url, async, config, requestObject) {
        var ret = null;
        var req = {};
        req.data = JSON.stringify(requestObject);
        req.timeout = 5E7;
        req.contentType = "application/json; charset=utf-8";
        req.dataType = "json";
        req.async = async;
        req.url = url;
        req.type = "POST";
        if (config.completed == null) {
            req.success = function(data, status) {
                ret = data;
                if (config.msg != null) console.error(config.msg)
            };
            req.context = this
        } else req.success = function(data, status) {
            if (data.result || data.error == null) {
                var result = data.result;
                if (typeof result == "string" && result != "" && result != "void") result = JSON.parse(result);
                config.completed.call(config.context, result)
            } else if (config.failed) config.failed.call(config.context,
                data.error);
            else console.error(data.error)
        };
        if (config.failed != null) {
            req.error = config.failed;
            req.context = config.context
        } else {
            req.context = config.context;
            req.error = function(data, status) {
                ret = {};
                ret.error = {};
                ret.error.message = data.statusText + "(" + data.status + ")"
            }
        }
        var username = simpl4.util.Rpc._getUserName();
        var password = simpl4.util.Rpc._getPassword();
        req.headers = {
            "Authorization": "Basic " + simpl4.util.Base64.encode(username + ":" + password)
        };
        $.ajax(req);
        return ret
    }
}, {});
clazz.construct.extend("simpl4.util.Rx", {
    observableFromWebSocket: function(url, options, openObserver, closingObserver) {
        if (!WebSocket) throw new TypeError("WebSocket not implemented in your runtime.");
        var socket;
        var socketClose = function(code, reason) {
            console.log("socketClose:" + code + "/" + reason + "/" + socket + "/" + closingObserver);
            if (socket) {
                if (closingObserver) {
                    closingObserver.onNext();
                    closingObserver.onCompleted()
                }
                if (code == -1) return;
                if (!code) socket.close();
                else socket.close(code, reason)
            }
        };
        var observable = new Rx.AnonymousObservable(function(obs) {
            socket =
                new ReconnectingWebSocket(url, null, options);
            var openHandler = function(e) {
                openObserver.onNext(e);
                openObserver.onCompleted();
                socket.removeEventListener("open", openHandler, false)
            };
            var messageHandler = function(e) {
                obs.onNext(e)
            };
            var errHandler = function(e) {
                obs.onError(e)
            };
            var closeHandler = function(e) {
                console.log("closeHandler.code", e.code);
                if (e.code == null) return;
                if (e.code !== 1E3 || !e.wasClean) return obs.onError(e);
                else obs.onCompleted()
            };
            openObserver && socket.addEventListener("open", openHandler, false);
            socket.addEventListener("message",
                messageHandler, false);
            socket.addEventListener("error", errHandler, false);
            socket.addEventListener("close", closeHandler, false);
            return function() {
                socketClose(-1);
                socket.removeEventListener("message", messageHandler, false);
                socket.removeEventListener("error", errHandler, false);
                socket.removeEventListener("close", closeHandler, false)
            }
        });
        var observer = Rx.Observer.create(function(data) {
            socket.readyState === WebSocket.OPEN && socket.send(data)
        }, function(e) {
            if (!e.code) throw new Error('no code specified. be sure to pass { code: ###, reason: "" } to onError()');
            socketClose(e.code, e.reason || "")
        }, function() {
            socketClose(1E3, "")
        });
        return Rx.Subject.create(observer, observable)
    }
}, {});
clazz.construct.extend("simpl4.util.SearchFilter", {
    createSearchFilter: function(entityname) {
        var args = Args([{
            entityname: Args.STRING | Args.Required
        }, {
            namespace: Args.STRING | Args.Optional
        }], arguments);
        var f1 = this._getSearchFilterFieldSets(args.namespace, args.entityname);
        var f2 = this._getSearchFilterFields(args.namespace, args.entityname);
        var fields = f1.concat(f2);
        var ret = [];
        for (var i = 0; i < fields.length; i++) {
            var f = fields[i];
            var node = {};
            node.id = f.itemval;
            node.label = f.text;
            node.type = f.type;
            node.datatype = f.datatype;
            node.edittype = f.edittype;
            node.constraints = f.constraints;
            node.dataValues = f.dataValues;
            node.input = f.input;
            node.operators = this._adaptOps(f.ops);
            ret.push(node)
        }
        return ret
    },
    createSearchFilterWithChilds: function(entityname) {
        var args = Args([{
            entityname: Args.STRING | Args.Required
        }, {
            namespace: Args.STRING | Args.Optional
        }], arguments);
        var f1 = this._getSearchFilterFieldSets(args.namespace, args.entityname);
        var fsids = [];
        jQuery.each(f1, function(e) {
            fsids.push(e.itemval)
        });
        var f2 = this._getSearchFilterFields(args.namespace,
            args.entityname);
        var fields = f1.concat(f2);
        var moduleList = simpl4.util.EntityManager.getEntity(args.entityname, {
            namespace: args.namespace
        });
        if (moduleList && moduleList.childs != null)
            for (var j = 0; j < moduleList.childs.length; j++) {
                var child = moduleList.childs[j];
                child.label = tr("data." + moduleList.name + "." + child.name);
                var fs = this._getSearchFilterFieldSets(args.namespace, child.modulename);
                var ff = this._getSearchFilterFields(args.namespace, child.modulename);
                child.fields = fs.concat(ff)
            }
        var root = {};
        root.id = "root";
        root.label =
            "root";
        root.children = [];
        for (var i = 0; i < fields.length; i++) {
            var f = fields[i];
            f.module = "";
            var node = {};
            if (fsids.indexOf(f.itemval) == -1) {
                node.id = args.entityname + "." + f.itemval;
                f.itemval = node.id
            } else node.id = f.itemval;
            node.label = f.text;
            node.module = "";
            node.moduleTitle = "";
            node.children = [];
            root.children.push(node)
        }
        for (var i = 0; moduleList && moduleList.childs != null && i < moduleList.childs.length; i++) {
            var child = moduleList.childs[i];
            if (child.name == args.entityname) continue;
            var node = {};
            node.id = child.name;
            node.label = child.title;
            node.children = [];
            node.selectable = false;
            root.children.push(node);
            var fchildren = node.children;
            for (var j = 0; j < child.fields.length; j++) {
                var field = child.fields[j];
                field.module = child.name;
                fields.push(field);
                var fnode = {};
                fnode.id = args.entityname + "$" + child.name + "." + field.itemval;
                field.itemval = fnode.id;
                fnode.label = field.text;
                fnode.module = child.name;
                fnode.moduleTitle = child.title;
                fnode.children = [];
                fchildren.push(fnode)
            }
        }
        return {
            filter: root,
            fields: fields
        }
    },
    _getSearchFilterFieldSets: function(namespace, entityname) {
        var allops = ["eq", "ne", "lt", "le", "gt", "ge", "bw", "bn", "in", "inn", "ew", "en", "cn", "nc"];
        var odata = tr("meta.lists.odata");
        odata = odata.replace(/'/g, '"');
        try {
            odata = JSON.parse(odata)
        } catch (e) {}
        try {
            var list = simpl4.util.EntityManager.getFieldsetsForEntity(entityname, {
                namespace: namespace
            });
            var fields = [];
            for (var i = 0; i < list.length; i++) {
                var o = list[i];
                var field = {};
                if (!o.fields || o.fields.length == 0) continue;
                field.text = tr(o.fsname);
                field.itemval = o.fsname;
                field.type = "string";
                fields.push(field);
                field.input = simpl4.util.FormManager.handleQueryBuilderSearchInput.bind(simpl4.util.FormManager);
                var sopt = o.search_options;
                if (!sopt || sopt.length == 0) sopt = ["cn", "bw", "eq", "ne"];
                var ops = [];
                jQuery.each(sopt, function(index, so) {
                    var pos = -1;
                    if ((pos = jQuery.inArray(so, allops)) != -1) ops.push({
                        op: so,
                        text: odata[pos]
                    })
                });
                field.ops = ops
            }
            return fields
        } catch (e) {
            return []
        }
    },
    _getSearchFilterFields: function(namespace, entityname) {
        var allops = ["eq", "ne", "lt", "le", "gt", "ge", "bw", "bn", "in", "inn", "ew", "en", "cn", "nc"];
        var odata = tr("meta.lists.odata");
        odata = odata.replace(/'/g, '"');
        try {
            odata = JSON.parse(odata)
        } catch (e) {}
        var model =
            simpl4.util.EntityManager.getEntityViewFields(entityname, "search", {
                namespace: namespace
            });
        if (model == undefined) return [];
        var category = "data";
        var cols = model;
        var pack = "data";
        var entity = entityname;
        if (entityname.indexOf(":") >= 0) {
            pack = entityname.split(":")[0];
            entity = entityname.split(":")[1]
        }
        var fields = [];
        for (var i = 0; i < cols.length; i++) {
            var col = cols[i];
            if (col.hidden !== true && col.edittype != "relatedto") {
                var field = {};
                field.text = tr(pack + "." + entity + "." + col.name);
                field.itemval = col.name;
                var sopt = this._setDefaultSearchOptions(col);
                sopt = eval(this._checkvalue(sopt));
                var ops = [];
                jQuery.each(sopt, function(index, so) {
                    var pos = -1;
                    if ((pos = jQuery.inArray(so, allops)) != -1) ops.push({
                        op: so,
                        text: odata[pos]
                    })
                });
                var hasSearchables = false;
                if (col.searchable_items) {
                    field.dataValues = col.searchable_items.getItems();
                    hasSearchables = true
                }
                if (!field.dataValues)
                    if (col.selectable_items) field.dataValues = col.selectable_items.getItems();
                field.ops = ops;
                field.edittype = col.edittype;
                field.datatype = col.datatype;
                field.constraints = col.constraints;
                field.type = "string";
                if (col.datatype && col.datatype == "date") field.type = col.edittype == "text" ? "date" : col.edittype;
                else if (col.datatype && (col.datatype == "decimal" || col.datatype == "double")) field.type = "double";
                else if (col.datatype && (col.datatype == "number" || col.datatype == "integer" || col.datatype == "long")) field.type = "integer";
                if (field.type === "text") field.type = "string";
                if (field.type === "boolean") field.type = "integer";
                field.input = simpl4.util.FormManager.handleQueryBuilderSearchInput.bind(simpl4.util.FormManager);
                fields.push(field)
            }
        }
        return fields
    },
    _adaptOps: function(list) {
        var ret = [];
        var self = this;
        list.forEach(function(e) {
            ret.push(self.mapOpFromSimpl4(e.op))
        });
        return ret
    },
    mapOpFromSimpl4: function(op_in) {
        var map = {
            "eq": "equal",
            "ne": "not_equal",
            "in": "in",
            "inn": "not_in",
            "lt": "less",
            "le": "less_or_equal",
            "gt": "greater",
            "ge": "greater_or_equal",
            "bw": "begins_with",
            "bn": "not_begins_with",
            "cn": "contains",
            "ew": "ends_with",
            "en": "not_ends_with",
            "empty": "is_empty",
            "not_empty": "is_not_empty"
        };
        if (map[op_in] === undefined) console.error("SearchFilter.mapOpFromSimpl4 not found:" +
            op_in);
        return map[op_in]
    },
    mapOpToSimpl4: function(op_in) {
        var map = {
            "equal": "eq",
            "not_equal": "ne",
            "in": "in ",
            "not_in": "inn",
            "less": "lt",
            "less_or_equal": "le",
            "greater": "gt",
            "greater_or_equal": "ge",
            "begins_with": "bw",
            "not_begins_with": "bn",
            "contains": "cn",
            "ends_with": "ew",
            "not_ends_with": "en",
            "is_empty": "empty",
            "is_not_empty": "not_empty"
        };
        if (map[op_in] === undefined) console.error("SearchFilter.mapOpToSimpl4 not found:" + op_in);
        return map[op_in]
    },
    _setDefaultSearchOptions: function(col) {
        if (col.search_options) return col.search_options;
        var search_options;
        if (col.datatype == "date" || col.datatype == "integer" || col.datatype == "long" || col.id == "id" || col.datatype == "number" || col.datatype == "decimal" || col.datatype == "double") search_options = ["gt", "lt", "eq"];
        else if (col.selectable_items || col.edittype == "select" || col.edittype == "checkbox" || col.datatype == "boolean") search_options = ["eq", "ne"];
        else search_options = ["cn", "bw", "eq", "ne"];
        return search_options
    },
    _checkvalue: function(val) {
        if (typeof val == "string" && !val.match("^\\[")) {
            var values = val.split(",");
            var ret = [];
            for (var i = 0; i < values.length; i++) ret.push(values[i]);
            return ret
        }
        return val
    }
}, {});
clazz.construct.extend("simpl4.util.SelectableItems", {}, {
    init: function(context) {
        this._url = context.url;
        this._varMap = context.varMap || {};
        this._items = null;
        this.namespace = context.namespace || simpl4.util.BaseManager.getNamespace()
    },
    setVarMap: function(varMap) {
        this._varMap = simpl4.util.Merge.deepmerge(this._varMap, varMap);
        this._items = null
    },
    setVariable: function(name, value) {
        this._varMap[name] = value
    },
    getItems: function() {
        if (this._items == null) this._evalUrl();
        return this._convert(this._items)
    },
    getItemsAsMap: function() {
        return this._list2map(this.getItems())
    },
    getMissingParamList: function() {
        return this._missingParamList
    },
    _evalUrl: function() {
        if (this._url instanceof Array) {
            this._items = this._url;
            this._items = this._translate(this._items);
            return
        }
        if (this._url && this._url.items instanceof Array) {
            this._items = this._url.items;
            this._items = this._translate(this._items);
            return
        }
        if (this._url == null) {
            this._items = [];
            return
        }
        this._setDefaultVars();
        if (this._url.match("^delayed")) {
            this._items = this._url;
            return
        } else if (this._url.match("^rpc:")) try {
            var url = this._url.substring(4);
            url = this._supplant(url, this._varMap);
            var comma = url.indexOf(",");
            if (comma != -1) {
                var sm = url.substring(0, comma);
                sm = sm.replace(".", ":");
                var params = url.substring(comma + 1);
                if (!params.match("^{")) params = "{" + params + "}";
                console.log("params:" + params);
                params = this._evalJson(params);
                this._items = simpl4.util.Rpc.rpcSync(sm, params)
            } else this._items = simpl4.util.Rpc.rpcSync(url)
        } catch (e) {
            console.error("SelectableItems._getItems:" + url + "/" + e);
            console.error(e.stack);
            this._items = [];
            return
        } else if (this._url.match("^enumeration:")) try {
                var comma =
                    this._url.indexOf(",");
                var mapping = null;
                var enumname = null;
                if (comma == -1) enumname = this._url.substring("enumeration".length + 1);
                else {
                    enumname = this._url.substring("enumeration".length + 1, comma);
                    var mappingstr = this._url.substring(comma + 1);
                    mapping = this._evalJson(mappingstr)
                }
                this._items = simpl4.util.Rpc.rpcSync("enumeration:get", {
                    name: enumname,
                    namespace: this._varMap.namespace,
                    mapping: mapping
                })
            } catch (e) {
                console.error("SelectableItems._getItems:" + url + "/" + e);
                console.error(e.stack);
                this._items = [];
                return
            } else if (this._url.match("^{") ||
                this._url.match("^\\[")) try {
                var url = JSON.parse(this._url);
                if (url.enumDescription || url.enumDescription) {
                    if (url.totalCount != null && url.totalCount == 0) {
                        this._items = [];
                        return
                    }
                    this._items = this._handleEnumDescricption(url);
                    if (this._items == null) {
                        this._items = [];
                        return
                    }
                } else this._items = url
            } catch (e) {
                console.error("SelectableItems.Could not parse:" + this._url + ":" + e);
                console.error(e.stack)
            } else {
                var values = this._url.split(";");
                if (values.length < 2) values = this._url.split(",");
                this._items = [];
                for (var j = 0; j < values.length; j++) {
                    var value =
                        values[j];
                    var v = value.split(":");
                    var o = {};
                    if (v.length < 2) {
                        o.label = v[0];
                        o.value = v[0]
                    } else {
                        o.label = v[1];
                        o.value = v[0]
                    }
                    this._items.push(o)
                }
            }
            this._items = this._translate(this._items)
    },
    _convert: function() {
        if (this._items == null) return [];
        if (this._items.length !== undefined) return this._items;
        else if (this._items.value == "root") return this._items;
        else {
            var newList = [];
            for (var key in this._items) {
                var val = this._items[key];
                if (typeof val === "string") {
                    if (val.match(/^[@%]/)) val = tr(val.substring(1));
                    var o = {};
                    o.label = val;
                    o.tooltip =
                        val;
                    o.value = key;
                    val = o
                }
                newList.push(val)
            }
            return newList
        }
    },
    _translate: function(o) {
        if (typeof o == "string") {
            if (o.match(/^[@%]/)) {
                var t = tr(o.substring(1));
                if (t) o = t
            }
            return o.toString()
        }
        for (var i in o) {
            if (typeof o[i] == "function") continue;
            o[i] = this._translate(o[i])
        }
        return o
    },
    _setDefaultVars: function() {
        if (!this._varMap.NAMESPACE) this.setVariable("NAMESPACE", this.namespace);
        if (!this._varMap.namespace) this._varMap.namespace = this._varMap.NAMESPACE
    },
    _handleEnumDescricption: function(url) {
        var itemsRet = null;
        try {
            var x =
                url.enumDescription.split(":");
            var type = x[0];
            var name = x[1];
            var ms = "";
            var items = url.items;
            var params = url.params;
            var mapping = {};
            for (var i = 0; i < items.length; i++)
                if (items[i].mapping) mapping[items[i].mapping] = items[i].colname;
                else mapping[items[i].colname] = items[i].colname;
            if (Object.keys(mapping).length == 0) mapping = null;
            if (type == "sw.enum") itemsRet = simpl4.util.Rpc.rpcSync("enumeration:get", {
                name: name,
                namespace: this._varMap.namespace,
                mapping: mapping
            });
            if (type == "camelparam_route" || type == "sw.service") {
                var ns =
                    this._varMap.namespace;
                var defParams = {
                    lang: simpl4.util.BaseManager.getLanguage(),
                    uuid: window.uuid
                };
                var p = params ? params : defParams;
                itemsRet = simpl4.util.Rpc.rpcSync("camelRoute:" + ns + "." + name, p);
                if (itemsRet.length == null) {
                    var l = [];
                    l.push(itemsRet);
                    itemsRet = l
                }
            }
            if (type == "sw.filter") {
                console.log("varMap:", this._varMap);
                var storeId = this._varMap.STORE_ID || this.getStoreId();
                var p = params ? params : this._varMap;
                var ret = simpl4.util.Rpc.rpcSync("data:executeFilterByName", {
                    name: name,
                    params: p,
                    checkParams: url.checkParams ===
                        true ? true : false,
                    storeId: storeId,
                    mapping: mapping
                });
                this._missingParamList = null;
                if (ret.missingParamList) {
                    this._missingParamList = ret.missingParamList;
                    return this._url
                }
                itemsRet = ret.rows
            }
        } catch (e) {
            console.error("SelectableItems._handleEnumDescricption:" + url + "/" + e);
            console.error(e.stack);
            return null
        }
        return itemsRet
    },
    _supplant: function(s, o) {
        if (!o) return s;
        return s.replace(/[\\$@]{([^{}]*)}/g, function(a, b) {
            var r = o[b];
            return typeof r === "string" || typeof r === "number" ? r : a
        })
    },
    _list2map: function(list) {
        var ret = {};
        if (list.length === undefined) return ret;
        for (var i = 0; i < list.length; i++) {
            var o = list[i];
            ret[o["value"]] = o
        }
        return ret
    },
    _getFilterParams: function(filter, paramList) {
        var label = filter["label"];
        if (filter["connector"] == null && label != null) {
            label = label.toLowerCase();
            if (label.match(/^[a-z].*/)) paramList.push(label)
        }
        var children = filter["children"];
        for (var i = 0; i < children.length; i++) {
            var c = children[i];
            this._getFilterParams(c, paramList)
        }
    },
    _evalJson: function(text) {
        var trim = /^(\s|\u00A0)+|(\s|\u00A0)+$/g;
        text = text.replace(trim,
            "");
        if (/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/['"][^"\\\n\r]*['"]|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ":").replace(/\w*\s*\:/g, ":"))) return (new Function("return " + text))();
        else throw "SelectableItems.invalid JSON: " + text;
    },
    getStoreId: function() {
        return this.namespace + "_data"
    },
    toString: function() {
        return "SelectableItems:" + this._url
    }
});
clazz.construct.extend("simpl4.util.Text", {
    explode: function(text, max) {
        text = text.replace(/  +/g, " ").replace(/^ /, "").replace(/ $/, "");
        if (typeof text === "undefined") return "";
        if (typeof max === "undefined") max = 50;
        if (text.length <= max) return text;
        var exploded = text.substring(0, max);
        text = text.substring(max);
        if (text.charAt(0) !== " ") {
            while (exploded.charAt(exploded.length - 1) !== " " && exploded.length > 0) {
                text = exploded.charAt(exploded.length - 1) + text;
                exploded = exploded.substring(0, exploded.length - 1)
            }
            if (exploded.length ==
                0) {
                exploded = text.substring(0, max);
                text = text.substring(max)
            } else exploded = exploded.substring(0, exploded.length - 1)
        } else text = text.substring(1);
        return exploded + "<br/>" + simpl4.util.Text.explode(text, max)
    }
}, {});
"use strict";

function waitForElement(selector, timeout) {
    var _resolve, _reject;
    var promise = new Promise(function(resolve, reject) {
        _resolve = resolve;
        _reject = reject
    });
    var observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            for (var i = 0; i < mutation.addedNodes.length; i++) {
                var addedNode = mutation.addedNodes[i];
                if (typeof addedNode.matches === "function" && addedNode.matches(selector)) {
                    _resolve(addedNode);
                    observer.disconnect();
                    clearTimeout(timerId)
                }
            }
        })
    });
    var element = document.querySelector(selector);
    if (element != null) {
        _resolve(element);
        return promise
    }
    var timeoutOption = timeout || 2E3;
    observer.observe(document.body, {
        childList: true,
        subtree: true
    });
    var timerId = setTimeout(function() {
        _reject(new Error("Not found element match the selector:" + selector));
        observer.disconnect()
    }, timeoutOption);
    return promise
}
clazz.construct.extend("simpl4.util.Xml2Json", {
    NODE_TYPES: {
        Element: 1,
        Attribute: 2,
        Text: 3,
        CDATA: 4,
        Root: 9,
        Fragment: 11
    },
    parseXMLString: function(strXML) {
        var xmlDoc = null,
            out = null,
            isParsed = true;
        try {
            xmlDoc = "DOMParser" in window ? new DOMParser : new ActiveXObject("MSXML2.DOMDocument");
            xmlDoc.async = false
        } catch (e) {
            throw new Error("XML Parser could not be instantiated");
        }
        if ("parseFromString" in xmlDoc) {
            out = xmlDoc.parseFromString(strXML, "text/xml");
            isParsed = out.documentElement.tagName !== "parsererror"
        } else {
            isParsed =
                xmlDoc.loadXML(strXML);
            out = isParsed ? xmlDoc : false
        }
        if (!isParsed) throw new Error("Error parsing XML string");
        return out
    }
}, {
    prefixAttr: false,
    toLower: true,
    withText: false,
    withRoot: false,
    isXML: function(o) {
        return typeof o === "object" && o.nodeType !== undefined
    },
    getRoot: function(doc) {
        return doc.nodeType === this.constructor.NODE_TYPES.Root ? doc.documentElement : doc.nodeType === this.constructor.NODE_TYPES.Fragment ? doc.firstChild : doc
    },
    convert: function(xml) {
        var out = {},
            xdoc = typeof xml === "string" ? simpl4.util.Xml2Json.parseXMLString(xml) :
            this.isXML(xml) ? xml : undefined,
            root;
        if (!xdoc) throw new Error("Unable to parse XML");
        if (xdoc.nodeType === this.constructor.NODE_TYPES.Text || xdoc.nodeType === this.constructor.NODE_TYPES.CDATA) return xdoc.nodeValue;
        root = this.getRoot(xdoc);
        var rootName = this.toLower ? root.nodeName.toLowerCase() : root.nodeName;
        out[rootName] = {};
        this.process(root, out[rootName]);
        return this.withRoot ? out : out[rootName]
    },
    process: function(node, buff) {
        var child, attr, name, att_name, value, i, j, tmp, iMax, jMax;
        if (node.hasChildNodes()) {
            iMax =
                node.childNodes.length;
            for (i = 0; i < iMax; i++) {
                child = node.childNodes[i];
                switch (child.nodeType) {
                    case this.constructor.NODE_TYPES.Text:
                        if (this.withText) buff.Text = buff.Text ? buff.Text + child.nodeValue.trim() : child.nodeValue.trim();
                        break;
                    case this.constructor.NODE_TYPES.CDATA:
                        if (this.withText) {
                            value = child[child.text ? "text" : "nodeValue"];
                            buff.Text = buff.Text ? buff.Text + value : value
                        }
                        break;
                    case this.constructor.NODE_TYPES.Element:
                        name = child.nodeName;
                        if (this.toLower) name = name.toLowerCase();
                        tmp = {};
                        if (name in buff)
                            if (buff[name].length) {
                                this.process(child,
                                    tmp);
                                buff[name].push(tmp)
                            } else {
                                this.process(child, tmp);
                                buff[name] = [buff[name], tmp]
                            } else {
                            this.process(child, tmp);
                            buff[name] = tmp
                        }
                        break
                }
            }
        }
        if (node.attributes.length)
            for (j = node.attributes.length - 1; j >= 0; j--) {
                attr = node.attributes[j];
                att_name = attr.name.trim();
                if (this.toLower) att_name = att_name.toLowerCase();
                value = attr.value;
                buff[(this.prefixAttr ? "@" : "") + att_name] = value
            }
    }
});