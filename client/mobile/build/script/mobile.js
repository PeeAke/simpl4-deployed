(function(){

if (!window.qx) window.qx = {};

qx.$$start = new Date();

if (!qx.$$environment) qx.$$environment = {};
var envinfo = {"qx.application":"mobile.Application","qx.debug":false,"qx.debug.databinding":false,"qx.debug.dispose":false,"qx.debug.io":false,"qx.debug.ui.queue":false,"qx.optimization.comments":true,"qx.revision":"","qx.theme":"custom","qx.version":"4.0.1"};
for (var k in envinfo) qx.$$environment[k] = envinfo[k];

if (!qx.$$libraries) qx.$$libraries = {};
var libinfo = {"__out__":{"sourceUri":"script"},"mobile":{"resourceUri":"resource","sourceUri":"script"},"ms123":{"resourceUri":"resource","sourceUri":"script"},"qx":{"resourceUri":"resource","sourceUri":"script","sourceViewUri":"https://github.com/qooxdoo/qooxdoo/blob/%{qxGitBranch}/framework/source/class/%{classFilePath}#L%{lineNumber}"}};
for (var k in libinfo) qx.$$libraries[k] = libinfo[k];

qx.$$resources = {};
qx.$$translations = {"C":null,"en":null};
qx.$$locales = {"C":null,"en":null};
qx.$$packageData = {};
qx.$$g = {}

qx.$$loader = {
  parts : {"boot":[0]},
  packages : {"0":{"uris":["__out__:mobile.967e730e2f3f.js"]}},
  urisBefore : [],
  cssBefore : ["./resource/mobile/css/custom.css"],
  boot : "boot",
  closureParts : {},
  bootIsInline : true,
  addNoCacheParam : false,

  decodeUris : function(compressedUris)
  {
    var libs = qx.$$libraries;
    var uris = [];
    for (var i=0; i<compressedUris.length; i++)
    {
      var uri = compressedUris[i].split(":");
      var euri;
      if (uri.length==2 && uri[0] in libs) {
        var prefix = libs[uri[0]].sourceUri;
        euri = prefix + "/" + uri[1];
      } else {
        euri = compressedUris[i];
      }
      if (qx.$$loader.addNoCacheParam) {
        euri += "?nocache=" + Math.random();
      }
      
      uris.push(euri);
    }
    return uris;
  }
};

var readyStateValue = {"complete" : true};
if (document.documentMode && document.documentMode < 10 ||
    (typeof window.ActiveXObject !== "undefined" && !document.documentMode)) {
  readyStateValue["loaded"] = true;
}

function loadScript(uri, callback) {
  var elem = document.createElement("script");
  elem.charset = "utf-8";
  elem.src = uri;
  elem.onreadystatechange = elem.onload = function() {
    if (!this.readyState || readyStateValue[this.readyState]) {
      elem.onreadystatechange = elem.onload = null;
      if (typeof callback === "function") {
        callback();
      }
    }
  };

  if (isLoadParallel) {
    elem.async = null;
  }

  var head = document.getElementsByTagName("head")[0];
  head.appendChild(elem);
}

function loadCss(uri) {
  var elem = document.createElement("link");
  elem.rel = "stylesheet";
  elem.type = "text/css";
  elem.href = uri;
  elem.onload = onLoadCss();
  var head = document.getElementsByTagName("head")[0];
  head.appendChild(elem);
}

function onLoadCss() {
  cssFilesToLoad = cssFilesToLoad - 1;
  if(cssFilesToLoad == 0) {
    setTimeout(initScripts,0);
  }
}

var isWebkit = /AppleWebKit\/([^ ]+)/.test(navigator.userAgent);
var isLoadParallel = 'async' in document.createElement('script');

function loadScriptList(list, callback) {
  if (list.length == 0) {
    callback();
    return;
  }

  var item;

  if (isLoadParallel) {
    while (list.length) {
      item = list.shift();
      if (list.length) {
        loadScript(item);
      } else {
        loadScript(item, callback);
      }
    }
  } else {
    item = list.shift();
    loadScript(item,  function() {
      if (isWebkit) {
        // force async, else Safari fails with a "maximum recursion depth exceeded"
        window.setTimeout(function() {
          loadScriptList(list, callback);
        }, 0);
      } else {
        loadScriptList(list, callback);
      }
    });
  }
}

var fireContentLoadedEvent = function() {
  qx.$$domReady = true;
  document.removeEventListener('DOMContentLoaded', fireContentLoadedEvent, false);
};
if (document.addEventListener) {
  document.addEventListener('DOMContentLoaded', fireContentLoadedEvent, false);
}

qx.$$loader.importPackageData = function (dataMap, callback) {
  if (dataMap["resources"]){
    var resMap = dataMap["resources"];
    for (var k in resMap) qx.$$resources[k] = resMap[k];
  }
  if (dataMap["locales"]){
    var locMap = dataMap["locales"];
    var qxlocs = qx.$$locales;
    for (var lang in locMap){
      if (!qxlocs[lang]) qxlocs[lang] = locMap[lang];
      else
        for (var k in locMap[lang]) qxlocs[lang][k] = locMap[lang][k];
    }
  }
  if (dataMap["translations"]){
    var trMap   = dataMap["translations"];
    var qxtrans = qx.$$translations;
    for (var lang in trMap){
      if (!qxtrans[lang]) qxtrans[lang] = trMap[lang];
      else
        for (var k in trMap[lang]) qxtrans[lang][k] = trMap[lang][k];
    }
  }
  if (callback){
    callback(dataMap);
  }
}

qx.$$loader.signalStartup = function ()
{
  qx.$$loader.scriptLoaded = true;
  if (window.qx && qx.event && qx.event.handler && qx.event.handler.Application) {
    qx.event.handler.Application.onScriptLoaded();
    qx.$$loader.applicationHandlerReady = true;
  } else {
    qx.$$loader.applicationHandlerReady = false;
  }
}


// Load all stuff

var cssFilesToLoad = 0;

qx.$$loader.init = function() {
  var l=qx.$$loader;
  if (l.cssBefore.length>0) {

    cssFilesToLoad = l.cssBefore.length;

    for (var i=0, m=l.cssBefore.length; i<m; i++) {
      loadCss(l.cssBefore[i]);
    }
  } else {
    initScripts();
  }
}

// Init scripts...
function initScripts() {
  var l=qx.$$loader;
  if (l.urisBefore.length>0){
    loadScriptList(l.urisBefore, function(){
      l.initUris();
    });
  } else {
    l.initUris();
  }
}

// Load qooxdoo boot stuff
qx.$$loader.initUris = function(){
  var l=qx.$$loader;
  var bootPackageHash=l.parts[l.boot][0];
  if (l.bootIsInline){
    l.importPackageData(qx.$$packageData[bootPackageHash]);
    l.signalStartup();
  } else {
    loadScriptList(l.decodeUris(l.packages[l.parts[l.boot][0]].uris), function(){
      // Opera needs this extra time to parse the scripts
      window.setTimeout(function(){
        l.importPackageData(qx.$$packageData[bootPackageHash] || {});
        l.signalStartup();
      }, 0);
    });
  }
}
})();

qx.$$packageData['0']={"locales":{"C":{"alternateQuotationEnd":"’","alternateQuotationStart":"‘","cldr_am":"AM","cldr_date_format_full":"EEEE, MMMM d, y","cldr_date_format_long":"MMMM d, y","cldr_date_format_medium":"MMM d, y","cldr_date_format_short":"M/d/yy","cldr_date_time_format_EHm":"E HH:mm","cldr_date_time_format_EHms":"E HH:mm:ss","cldr_date_time_format_Ed":"d E","cldr_date_time_format_Ehm":"E h:mm a","cldr_date_time_format_Ehms":"E h:mm:ss a","cldr_date_time_format_Gy":"y G","cldr_date_time_format_GyMMM":"MMM y G","cldr_date_time_format_GyMMMEd":"E, MMM d, y G","cldr_date_time_format_GyMMMd":"MMM d, y G","cldr_date_time_format_H":"HH","cldr_date_time_format_Hm":"HH:mm","cldr_date_time_format_Hms":"HH:mm:ss","cldr_date_time_format_M":"L","cldr_date_time_format_MEd":"E, M/d","cldr_date_time_format_MMM":"LLL","cldr_date_time_format_MMMEd":"E, MMM d","cldr_date_time_format_MMMd":"MMM d","cldr_date_time_format_Md":"M/d","cldr_date_time_format_d":"d","cldr_date_time_format_h":"h a","cldr_date_time_format_hm":"h:mm a","cldr_date_time_format_hms":"h:mm:ss a","cldr_date_time_format_ms":"mm:ss","cldr_date_time_format_y":"y","cldr_date_time_format_yM":"M/y","cldr_date_time_format_yMEd":"E, M/d/y","cldr_date_time_format_yMMM":"MMM y","cldr_date_time_format_yMMMEd":"E, MMM d, y","cldr_date_time_format_yMMMd":"MMM d, y","cldr_date_time_format_yMd":"M/d/y","cldr_date_time_format_yQQQ":"QQQ y","cldr_date_time_format_yQQQQ":"QQQQ y","cldr_day_format_abbreviated_fri":"Fri","cldr_day_format_abbreviated_mon":"Mon","cldr_day_format_abbreviated_sat":"Sat","cldr_day_format_abbreviated_sun":"Sun","cldr_day_format_abbreviated_thu":"Thu","cldr_day_format_abbreviated_tue":"Tue","cldr_day_format_abbreviated_wed":"Wed","cldr_day_format_short_fri":"Fr","cldr_day_format_short_mon":"Mo","cldr_day_format_short_sat":"Sa","cldr_day_format_short_sun":"Su","cldr_day_format_short_thu":"Th","cldr_day_format_short_tue":"Tu","cldr_day_format_short_wed":"We","cldr_day_format_wide_fri":"Friday","cldr_day_format_wide_mon":"Monday","cldr_day_format_wide_sat":"Saturday","cldr_day_format_wide_sun":"Sunday","cldr_day_format_wide_thu":"Thursday","cldr_day_format_wide_tue":"Tuesday","cldr_day_format_wide_wed":"Wednesday","cldr_day_stand-alone_narrow_fri":"F","cldr_day_stand-alone_narrow_mon":"M","cldr_day_stand-alone_narrow_sat":"S","cldr_day_stand-alone_narrow_sun":"S","cldr_day_stand-alone_narrow_thu":"T","cldr_day_stand-alone_narrow_tue":"T","cldr_day_stand-alone_narrow_wed":"W","cldr_month_format_abbreviated_1":"Jan","cldr_month_format_abbreviated_10":"Oct","cldr_month_format_abbreviated_11":"Nov","cldr_month_format_abbreviated_12":"Dec","cldr_month_format_abbreviated_2":"Feb","cldr_month_format_abbreviated_3":"Mar","cldr_month_format_abbreviated_4":"Apr","cldr_month_format_abbreviated_5":"May","cldr_month_format_abbreviated_6":"Jun","cldr_month_format_abbreviated_7":"Jul","cldr_month_format_abbreviated_8":"Aug","cldr_month_format_abbreviated_9":"Sep","cldr_month_format_wide_1":"January","cldr_month_format_wide_10":"October","cldr_month_format_wide_11":"November","cldr_month_format_wide_12":"December","cldr_month_format_wide_2":"February","cldr_month_format_wide_3":"March","cldr_month_format_wide_4":"April","cldr_month_format_wide_5":"May","cldr_month_format_wide_6":"June","cldr_month_format_wide_7":"July","cldr_month_format_wide_8":"August","cldr_month_format_wide_9":"September","cldr_month_stand-alone_narrow_1":"J","cldr_month_stand-alone_narrow_10":"O","cldr_month_stand-alone_narrow_11":"N","cldr_month_stand-alone_narrow_12":"D","cldr_month_stand-alone_narrow_2":"F","cldr_month_stand-alone_narrow_3":"M","cldr_month_stand-alone_narrow_4":"A","cldr_month_stand-alone_narrow_5":"M","cldr_month_stand-alone_narrow_6":"J","cldr_month_stand-alone_narrow_7":"J","cldr_month_stand-alone_narrow_8":"A","cldr_month_stand-alone_narrow_9":"S","cldr_number_decimal_separator":".","cldr_number_group_separator":",","cldr_number_percent_format":"#,##0%","cldr_pm":"PM","cldr_time_format_full":"h:mm:ss a zzzz","cldr_time_format_long":"h:mm:ss a z","cldr_time_format_medium":"h:mm:ss a","cldr_time_format_short":"h:mm a","quotationEnd":"”","quotationStart":"“"},"en":{"alternateQuotationEnd":"’","alternateQuotationStart":"‘","cldr_am":"AM","cldr_date_format_full":"EEEE, MMMM d, y","cldr_date_format_long":"MMMM d, y","cldr_date_format_medium":"MMM d, y","cldr_date_format_short":"M/d/yy","cldr_date_time_format_EHm":"E HH:mm","cldr_date_time_format_EHms":"E HH:mm:ss","cldr_date_time_format_Ed":"d E","cldr_date_time_format_Ehm":"E h:mm a","cldr_date_time_format_Ehms":"E h:mm:ss a","cldr_date_time_format_Gy":"y G","cldr_date_time_format_GyMMM":"MMM y G","cldr_date_time_format_GyMMMEd":"E, MMM d, y G","cldr_date_time_format_GyMMMd":"MMM d, y G","cldr_date_time_format_H":"HH","cldr_date_time_format_Hm":"HH:mm","cldr_date_time_format_Hms":"HH:mm:ss","cldr_date_time_format_M":"L","cldr_date_time_format_MEd":"E, M/d","cldr_date_time_format_MMM":"LLL","cldr_date_time_format_MMMEd":"E, MMM d","cldr_date_time_format_MMMd":"MMM d","cldr_date_time_format_Md":"M/d","cldr_date_time_format_d":"d","cldr_date_time_format_h":"h a","cldr_date_time_format_hm":"h:mm a","cldr_date_time_format_hms":"h:mm:ss a","cldr_date_time_format_ms":"mm:ss","cldr_date_time_format_y":"y","cldr_date_time_format_yM":"M/y","cldr_date_time_format_yMEd":"E, M/d/y","cldr_date_time_format_yMMM":"MMM y","cldr_date_time_format_yMMMEd":"E, MMM d, y","cldr_date_time_format_yMMMd":"MMM d, y","cldr_date_time_format_yMd":"M/d/y","cldr_date_time_format_yQQQ":"QQQ y","cldr_date_time_format_yQQQQ":"QQQQ y","cldr_day_format_abbreviated_fri":"Fri","cldr_day_format_abbreviated_mon":"Mon","cldr_day_format_abbreviated_sat":"Sat","cldr_day_format_abbreviated_sun":"Sun","cldr_day_format_abbreviated_thu":"Thu","cldr_day_format_abbreviated_tue":"Tue","cldr_day_format_abbreviated_wed":"Wed","cldr_day_format_short_fri":"Fr","cldr_day_format_short_mon":"Mo","cldr_day_format_short_sat":"Sa","cldr_day_format_short_sun":"Su","cldr_day_format_short_thu":"Th","cldr_day_format_short_tue":"Tu","cldr_day_format_short_wed":"We","cldr_day_format_wide_fri":"Friday","cldr_day_format_wide_mon":"Monday","cldr_day_format_wide_sat":"Saturday","cldr_day_format_wide_sun":"Sunday","cldr_day_format_wide_thu":"Thursday","cldr_day_format_wide_tue":"Tuesday","cldr_day_format_wide_wed":"Wednesday","cldr_day_stand-alone_narrow_fri":"F","cldr_day_stand-alone_narrow_mon":"M","cldr_day_stand-alone_narrow_sat":"S","cldr_day_stand-alone_narrow_sun":"S","cldr_day_stand-alone_narrow_thu":"T","cldr_day_stand-alone_narrow_tue":"T","cldr_day_stand-alone_narrow_wed":"W","cldr_month_format_abbreviated_1":"Jan","cldr_month_format_abbreviated_10":"Oct","cldr_month_format_abbreviated_11":"Nov","cldr_month_format_abbreviated_12":"Dec","cldr_month_format_abbreviated_2":"Feb","cldr_month_format_abbreviated_3":"Mar","cldr_month_format_abbreviated_4":"Apr","cldr_month_format_abbreviated_5":"May","cldr_month_format_abbreviated_6":"Jun","cldr_month_format_abbreviated_7":"Jul","cldr_month_format_abbreviated_8":"Aug","cldr_month_format_abbreviated_9":"Sep","cldr_month_format_wide_1":"January","cldr_month_format_wide_10":"October","cldr_month_format_wide_11":"November","cldr_month_format_wide_12":"December","cldr_month_format_wide_2":"February","cldr_month_format_wide_3":"March","cldr_month_format_wide_4":"April","cldr_month_format_wide_5":"May","cldr_month_format_wide_6":"June","cldr_month_format_wide_7":"July","cldr_month_format_wide_8":"August","cldr_month_format_wide_9":"September","cldr_month_stand-alone_narrow_1":"J","cldr_month_stand-alone_narrow_10":"O","cldr_month_stand-alone_narrow_11":"N","cldr_month_stand-alone_narrow_12":"D","cldr_month_stand-alone_narrow_2":"F","cldr_month_stand-alone_narrow_3":"M","cldr_month_stand-alone_narrow_4":"A","cldr_month_stand-alone_narrow_5":"M","cldr_month_stand-alone_narrow_6":"J","cldr_month_stand-alone_narrow_7":"J","cldr_month_stand-alone_narrow_8":"A","cldr_month_stand-alone_narrow_9":"S","cldr_number_decimal_separator":".","cldr_number_group_separator":",","cldr_number_percent_format":"#,##0%","cldr_pm":"PM","cldr_time_format_full":"h:mm:ss a zzzz","cldr_time_format_long":"h:mm:ss a z","cldr_time_format_medium":"h:mm:ss a","cldr_time_format_short":"h:mm a","quotationEnd":"”","quotationStart":"“"}},"resources":{"mobile/css/custom.css":"mobile","mobile/css/custom.css.map":"mobile","mobile/mobile.png":[45,33,"png","mobile"],"mobile/scss/_styles.scss":"mobile","mobile/scss/custom.scss":"mobile","qx/icon/Tango/22/actions/dialog-cancel.png":[22,22,"png","qx"],"qx/icon/Tango/22/actions/dialog-ok.png":[22,22,"png","qx"],"qx/icon/Tango/22/actions/document-save.png":[22,22,"png","qx"],"qx/icon/Tango/48/status/dialog-information.png":[48,48,"png","qx"],"qx/icon/Tango/48/status/dialog-warning.png":[48,48,"png","qx"],"qx/mobile/css/LICENSE":"qx","qx/mobile/css/custom.css":"qx","qx/mobile/js/iscroll.js":"qx","qx/mobile/js/iscroll.min.js":"qx","qx/static/blank.gif":[1,1,"gif","qx"],"qx/static/blank.html":"qx"},"translations":{"C":{},"en":{}}};

if(!window.qx){

  window.qx = {
  };
};
qx.Bootstrap = {
  genericToString : function(){

    return "[Class " + this.classname + "]";
  },
  createNamespace : function(name, object){

    var splits = name.split(".");
    var part = splits[0];
    var parent = qx.$$namespaceRoot && qx.$$namespaceRoot[part] ? qx.$$namespaceRoot : window;
    for(var i = 0,len = splits.length - 1;i < len;i++,part = splits[i]){

      if(!parent[part]){

        parent = parent[part] = {
        };
      } else {

        parent = parent[part];
      };
    };
    parent[part] = object;
    return part;
  },
  setDisplayName : function(fcn, classname, name){

    fcn.displayName = classname + "." + name + "()";
  },
  setDisplayNames : function(functionMap, classname){

    for(var name in functionMap){

      var value = functionMap[name];
      if(value instanceof Function){

        value.displayName = classname + "." + name + "()";
      };
    };
  },
  base : function(args, varargs){

    if(qx.Bootstrap.DEBUG){

      if(!qx.Bootstrap.isFunction(args.callee.base)){

        throw new Error("Cannot call super class. Method is not derived: " + args.callee.displayName);
      };
    };
    if(arguments.length === 1){

      return args.callee.base.call(this);
    } else {

      return args.callee.base.apply(this, Array.prototype.slice.call(arguments, 1));
    };
  },
  define : function(name, config){

    if(!config){

      config = {
        statics : {
        }
      };
    };
    var clazz;
    var proto = null;
    qx.Bootstrap.setDisplayNames(config.statics, name);
    if(config.members || config.extend){

      qx.Bootstrap.setDisplayNames(config.members, name + ".prototype");
      clazz = config.construct || new Function;
      if(config.extend){

        this.extendClass(clazz, clazz, config.extend, name, basename);
      };
      var statics = config.statics || {
      };
      for(var i = 0,keys = qx.Bootstrap.keys(statics),l = keys.length;i < l;i++){

        var key = keys[i];
        clazz[key] = statics[key];
      };
      proto = clazz.prototype;
      proto.base = qx.Bootstrap.base;
      proto.name = proto.classname = name;
      var members = config.members || {
      };
      var key,member;
      for(var i = 0,keys = qx.Bootstrap.keys(members),l = keys.length;i < l;i++){

        key = keys[i];
        member = members[key];
        if(member instanceof Function && proto[key]){

          member.base = proto[key];
        };
        proto[key] = member;
      };
    } else {

      clazz = config.statics || {
      };
      if(qx.Bootstrap.$$registry && qx.Bootstrap.$$registry[name]){

        var formerClass = qx.Bootstrap.$$registry[name];
        if(this.keys(clazz).length !== 0){

          if(config.defer){

            config.defer(clazz, proto);
          };
          for(var curProp in clazz){

            formerClass[curProp] = clazz[curProp];
          };
          return formerClass;
        };
      };
    };
    clazz.$$type = "Class";
    if(!clazz.hasOwnProperty("toString")){

      clazz.toString = this.genericToString;
    };
    var basename = name ? this.createNamespace(name, clazz) : "";
    clazz.name = clazz.classname = name;
    clazz.basename = basename;
    clazz.$$events = config.events;
    if(config.defer){

      config.defer(clazz, proto);
    };
    if(name != null){

      qx.Bootstrap.$$registry[name] = clazz;
    };
    return clazz;
  }
};
qx.Bootstrap.define("qx.Bootstrap", {
  statics : {
    LOADSTART : qx.$$start || new Date(),
    DEBUG : (function(){

      var debug = true;
      if(qx.$$environment && qx.$$environment["qx.debug"] === false){

        debug = false;
      };
      return debug;
    })(),
    getEnvironmentSetting : function(key){

      if(qx.$$environment){

        return qx.$$environment[key];
      };
    },
    setEnvironmentSetting : function(key, value){

      if(!qx.$$environment){

        qx.$$environment = {
        };
      };
      if(qx.$$environment[key] === undefined){

        qx.$$environment[key] = value;
      };
    },
    createNamespace : qx.Bootstrap.createNamespace,
    setRoot : function(root){

      qx.$$namespaceRoot = root;
    },
    base : qx.Bootstrap.base,
    define : qx.Bootstrap.define,
    setDisplayName : qx.Bootstrap.setDisplayName,
    setDisplayNames : qx.Bootstrap.setDisplayNames,
    genericToString : qx.Bootstrap.genericToString,
    extendClass : function(clazz, construct, superClass, name, basename){

      var superproto = superClass.prototype;
      var helper = new Function();
      helper.prototype = superproto;
      var proto = new helper();
      clazz.prototype = proto;
      proto.name = proto.classname = name;
      proto.basename = basename;
      construct.base = superClass;
      clazz.superclass = superClass;
      construct.self = clazz.constructor = proto.constructor = clazz;
    },
    getByName : function(name){

      return qx.Bootstrap.$$registry[name];
    },
    $$registry : {
    },
    objectGetLength : function(map){

      return qx.Bootstrap.keys(map).length;
    },
    objectMergeWith : function(target, source, overwrite){

      if(overwrite === undefined){

        overwrite = true;
      };
      for(var key in source){

        if(overwrite || target[key] === undefined){

          target[key] = source[key];
        };
      };
      return target;
    },
    __shadowedKeys : ["isPrototypeOf", "hasOwnProperty", "toLocaleString", "toString", "valueOf", "propertyIsEnumerable", "constructor"],
    keys : ({
      "ES5" : Object.keys,
      "BROKEN_IE" : function(map){

        if(map === null || (typeof map != "object" && typeof map != "function")){

          throw new TypeError("Object.keys requires an object as argument.");
        };
        var arr = [];
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        for(var key in map){

          if(hasOwnProperty.call(map, key)){

            arr.push(key);
          };
        };
        var shadowedKeys = qx.Bootstrap.__shadowedKeys;
        for(var i = 0,a = shadowedKeys,l = a.length;i < l;i++){

          if(hasOwnProperty.call(map, a[i])){

            arr.push(a[i]);
          };
        };
        return arr;
      },
      "default" : function(map){

        if(map === null || (typeof map != "object" && typeof map != "function")){

          throw new TypeError("Object.keys requires an object as argument.");
        };
        var arr = [];
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        for(var key in map){

          if(hasOwnProperty.call(map, key)){

            arr.push(key);
          };
        };
        return arr;
      }
    })[typeof (Object.keys) == "function" ? "ES5" : (function(){

      for(var key in {
        toString : 1
      }){

        return key;
      };
    })() !== "toString" ? "BROKEN_IE" : "default"],
    __classToTypeMap : {
      "[object String]" : "String",
      "[object Array]" : "Array",
      "[object Object]" : "Object",
      "[object RegExp]" : "RegExp",
      "[object Number]" : "Number",
      "[object Boolean]" : "Boolean",
      "[object Date]" : "Date",
      "[object Function]" : "Function",
      "[object Error]" : "Error"
    },
    bind : function(func, self, varargs){

      var fixedArgs = Array.prototype.slice.call(arguments, 2, arguments.length);
      return function(){

        var args = Array.prototype.slice.call(arguments, 0, arguments.length);
        return func.apply(self, fixedArgs.concat(args));
      };
    },
    firstUp : function(str){

      return str.charAt(0).toUpperCase() + str.substr(1);
    },
    firstLow : function(str){

      return str.charAt(0).toLowerCase() + str.substr(1);
    },
    getClass : function(value){

      var classString = Object.prototype.toString.call(value);
      return (qx.Bootstrap.__classToTypeMap[classString] || classString.slice(8, -1));
    },
    isString : function(value){

      return (value !== null && (typeof value === "string" || qx.Bootstrap.getClass(value) == "String" || value instanceof String || (!!value && !!value.$$isString)));
    },
    isArray : function(value){

      return (value !== null && (value instanceof Array || (value && qx.data && qx.data.IListData && qx.util.OOUtil.hasInterface(value.constructor, qx.data.IListData)) || qx.Bootstrap.getClass(value) == "Array" || (!!value && !!value.$$isArray)));
    },
    isObject : function(value){

      return (value !== undefined && value !== null && qx.Bootstrap.getClass(value) == "Object");
    },
    isFunction : function(value){

      return qx.Bootstrap.getClass(value) == "Function";
    },
    $$logs : [],
    debug : function(object, message){

      qx.Bootstrap.$$logs.push(["debug", arguments]);
    },
    info : function(object, message){

      qx.Bootstrap.$$logs.push(["info", arguments]);
    },
    warn : function(object, message){

      qx.Bootstrap.$$logs.push(["warn", arguments]);
    },
    error : function(object, message){

      qx.Bootstrap.$$logs.push(["error", arguments]);
    },
    trace : function(object){
    }
  }
});

qx.Bootstrap.define("qx.util.OOUtil", {
  statics : {
    classIsDefined : function(name){

      return qx.Bootstrap.getByName(name) !== undefined;
    },
    getPropertyDefinition : function(clazz, name){

      while(clazz){

        if(clazz.$$properties && clazz.$$properties[name]){

          return clazz.$$properties[name];
        };
        clazz = clazz.superclass;
      };
      return null;
    },
    hasProperty : function(clazz, name){

      return !!qx.util.OOUtil.getPropertyDefinition(clazz, name);
    },
    getEventType : function(clazz, name){

      var clazz = clazz.constructor;
      while(clazz.superclass){

        if(clazz.$$events && clazz.$$events[name] !== undefined){

          return clazz.$$events[name];
        };
        clazz = clazz.superclass;
      };
      return null;
    },
    supportsEvent : function(clazz, name){

      return !!qx.util.OOUtil.getEventType(clazz, name);
    },
    getByInterface : function(clazz, iface){

      var list,i,l;
      while(clazz){

        if(clazz.$$implements){

          list = clazz.$$flatImplements;
          for(i = 0,l = list.length;i < l;i++){

            if(list[i] === iface){

              return clazz;
            };
          };
        };
        clazz = clazz.superclass;
      };
      return null;
    },
    hasInterface : function(clazz, iface){

      return !!qx.util.OOUtil.getByInterface(clazz, iface);
    },
    getMixins : function(clazz){

      var list = [];
      while(clazz){

        if(clazz.$$includes){

          list.push.apply(list, clazz.$$flatIncludes);
        };
        clazz = clazz.superclass;
      };
      return list;
    }
  }
});

qx.Bootstrap.define("qx.core.Environment", {
  statics : {
    _checks : {
    },
    _asyncChecks : {
    },
    __cache : {
    },
    _checksMap : {
      "engine.version" : "qx.bom.client.Engine.getVersion",
      "engine.name" : "qx.bom.client.Engine.getName",
      "browser.name" : "qx.bom.client.Browser.getName",
      "browser.version" : "qx.bom.client.Browser.getVersion",
      "browser.documentmode" : "qx.bom.client.Browser.getDocumentMode",
      "browser.quirksmode" : "qx.bom.client.Browser.getQuirksMode",
      "runtime.name" : "qx.bom.client.Runtime.getName",
      "device.name" : "qx.bom.client.Device.getName",
      "device.type" : "qx.bom.client.Device.getType",
      "device.pixelRatio" : "qx.bom.client.Device.getPixelRatio",
      "device.touch" : "qx.bom.client.Device.getTouch",
      "locale" : "qx.bom.client.Locale.getLocale",
      "locale.variant" : "qx.bom.client.Locale.getVariant",
      "os.name" : "qx.bom.client.OperatingSystem.getName",
      "os.version" : "qx.bom.client.OperatingSystem.getVersion",
      "os.scrollBarOverlayed" : "qx.bom.client.Scroll.scrollBarOverlayed",
      "plugin.gears" : "qx.bom.client.Plugin.getGears",
      "plugin.activex" : "qx.bom.client.Plugin.getActiveX",
      "plugin.skype" : "qx.bom.client.Plugin.getSkype",
      "plugin.quicktime" : "qx.bom.client.Plugin.getQuicktime",
      "plugin.quicktime.version" : "qx.bom.client.Plugin.getQuicktimeVersion",
      "plugin.windowsmedia" : "qx.bom.client.Plugin.getWindowsMedia",
      "plugin.windowsmedia.version" : "qx.bom.client.Plugin.getWindowsMediaVersion",
      "plugin.divx" : "qx.bom.client.Plugin.getDivX",
      "plugin.divx.version" : "qx.bom.client.Plugin.getDivXVersion",
      "plugin.silverlight" : "qx.bom.client.Plugin.getSilverlight",
      "plugin.silverlight.version" : "qx.bom.client.Plugin.getSilverlightVersion",
      "plugin.flash" : "qx.bom.client.Flash.isAvailable",
      "plugin.flash.version" : "qx.bom.client.Flash.getVersion",
      "plugin.flash.express" : "qx.bom.client.Flash.getExpressInstall",
      "plugin.flash.strictsecurity" : "qx.bom.client.Flash.getStrictSecurityModel",
      "plugin.pdf" : "qx.bom.client.Plugin.getPdf",
      "plugin.pdf.version" : "qx.bom.client.Plugin.getPdfVersion",
      "plugin.pdfjs" : "qx.bom.client.Pdfjs.getPdfjs",
      "io.maxrequests" : "qx.bom.client.Transport.getMaxConcurrentRequestCount",
      "io.ssl" : "qx.bom.client.Transport.getSsl",
      "io.xhr" : "qx.bom.client.Transport.getXmlHttpRequest",
      "event.touch" : "qx.bom.client.Event.getTouch",
      "event.mspointer" : "qx.bom.client.Event.getMsPointer",
      "event.help" : "qx.bom.client.Event.getHelp",
      "event.hashchange" : "qx.bom.client.Event.getHashChange",
      "event.dispatchevent" : "qx.bom.client.Event.getDispatchEvent",
      "event.customevent" : "qx.bom.client.Event.getCustomEvent",
      "event.mouseevent" : "qx.bom.client.Event.getMouseEvent",
      "event.mousewheel" : "qx.bom.client.Event.getMouseWheel",
      "ecmascript.error.stacktrace" : "qx.bom.client.EcmaScript.getStackTrace",
      "ecmascript.array.indexof" : "qx.bom.client.EcmaScript.getArrayIndexOf",
      "ecmascript.array.lastindexof" : "qx.bom.client.EcmaScript.getArrayLastIndexOf",
      "ecmascript.array.foreach" : "qx.bom.client.EcmaScript.getArrayForEach",
      "ecmascript.array.filter" : "qx.bom.client.EcmaScript.getArrayFilter",
      "ecmascript.array.map" : "qx.bom.client.EcmaScript.getArrayMap",
      "ecmascript.array.some" : "qx.bom.client.EcmaScript.getArraySome",
      "ecmascript.array.every" : "qx.bom.client.EcmaScript.getArrayEvery",
      "ecmascript.array.reduce" : "qx.bom.client.EcmaScript.getArrayReduce",
      "ecmascript.array.reduceright" : "qx.bom.client.EcmaScript.getArrayReduceRight",
      "ecmascript.function.bind" : "qx.bom.client.EcmaScript.getFunctionBind",
      "ecmascript.object.keys" : "qx.bom.client.EcmaScript.getObjectKeys",
      "ecmascript.date.now" : "qx.bom.client.EcmaScript.getDateNow",
      "ecmascript.error.toString" : "qx.bom.client.EcmaScript.getErrorToString",
      "ecmascript.string.trim" : "qx.bom.client.EcmaScript.getStringTrim",
      "html.webworker" : "qx.bom.client.Html.getWebWorker",
      "html.filereader" : "qx.bom.client.Html.getFileReader",
      "html.geolocation" : "qx.bom.client.Html.getGeoLocation",
      "html.audio" : "qx.bom.client.Html.getAudio",
      "html.audio.ogg" : "qx.bom.client.Html.getAudioOgg",
      "html.audio.mp3" : "qx.bom.client.Html.getAudioMp3",
      "html.audio.wav" : "qx.bom.client.Html.getAudioWav",
      "html.audio.au" : "qx.bom.client.Html.getAudioAu",
      "html.audio.aif" : "qx.bom.client.Html.getAudioAif",
      "html.video" : "qx.bom.client.Html.getVideo",
      "html.video.ogg" : "qx.bom.client.Html.getVideoOgg",
      "html.video.h264" : "qx.bom.client.Html.getVideoH264",
      "html.video.webm" : "qx.bom.client.Html.getVideoWebm",
      "html.storage.local" : "qx.bom.client.Html.getLocalStorage",
      "html.storage.session" : "qx.bom.client.Html.getSessionStorage",
      "html.storage.userdata" : "qx.bom.client.Html.getUserDataStorage",
      "html.classlist" : "qx.bom.client.Html.getClassList",
      "html.xpath" : "qx.bom.client.Html.getXPath",
      "html.xul" : "qx.bom.client.Html.getXul",
      "html.canvas" : "qx.bom.client.Html.getCanvas",
      "html.svg" : "qx.bom.client.Html.getSvg",
      "html.vml" : "qx.bom.client.Html.getVml",
      "html.dataset" : "qx.bom.client.Html.getDataset",
      "html.dataurl" : "qx.bom.client.Html.getDataUrl",
      "html.console" : "qx.bom.client.Html.getConsole",
      "html.stylesheet.createstylesheet" : "qx.bom.client.Stylesheet.getCreateStyleSheet",
      "html.stylesheet.insertrule" : "qx.bom.client.Stylesheet.getInsertRule",
      "html.stylesheet.deleterule" : "qx.bom.client.Stylesheet.getDeleteRule",
      "html.stylesheet.addimport" : "qx.bom.client.Stylesheet.getAddImport",
      "html.stylesheet.removeimport" : "qx.bom.client.Stylesheet.getRemoveImport",
      "html.element.contains" : "qx.bom.client.Html.getContains",
      "html.element.compareDocumentPosition" : "qx.bom.client.Html.getCompareDocumentPosition",
      "html.element.textcontent" : "qx.bom.client.Html.getTextContent",
      "html.image.naturaldimensions" : "qx.bom.client.Html.getNaturalDimensions",
      "html.history.state" : "qx.bom.client.Html.getHistoryState",
      "html.selection" : "qx.bom.client.Html.getSelection",
      "html.node.isequalnode" : "qx.bom.client.Html.getIsEqualNode",
      "json" : "qx.bom.client.Json.getJson",
      "css.textoverflow" : "qx.bom.client.Css.getTextOverflow",
      "css.placeholder" : "qx.bom.client.Css.getPlaceholder",
      "css.borderradius" : "qx.bom.client.Css.getBorderRadius",
      "css.borderimage" : "qx.bom.client.Css.getBorderImage",
      "css.borderimage.standardsyntax" : "qx.bom.client.Css.getBorderImageSyntax",
      "css.boxshadow" : "qx.bom.client.Css.getBoxShadow",
      "css.gradient.linear" : "qx.bom.client.Css.getLinearGradient",
      "css.gradient.filter" : "qx.bom.client.Css.getFilterGradient",
      "css.gradient.radial" : "qx.bom.client.Css.getRadialGradient",
      "css.gradient.legacywebkit" : "qx.bom.client.Css.getLegacyWebkitGradient",
      "css.boxmodel" : "qx.bom.client.Css.getBoxModel",
      "css.rgba" : "qx.bom.client.Css.getRgba",
      "css.userselect" : "qx.bom.client.Css.getUserSelect",
      "css.userselect.none" : "qx.bom.client.Css.getUserSelectNone",
      "css.usermodify" : "qx.bom.client.Css.getUserModify",
      "css.appearance" : "qx.bom.client.Css.getAppearance",
      "css.float" : "qx.bom.client.Css.getFloat",
      "css.boxsizing" : "qx.bom.client.Css.getBoxSizing",
      "css.animation" : "qx.bom.client.CssAnimation.getSupport",
      "css.animation.requestframe" : "qx.bom.client.CssAnimation.getRequestAnimationFrame",
      "css.transform" : "qx.bom.client.CssTransform.getSupport",
      "css.transform.3d" : "qx.bom.client.CssTransform.get3D",
      "css.transition" : "qx.bom.client.CssTransition.getSupport",
      "css.inlineblock" : "qx.bom.client.Css.getInlineBlock",
      "css.opacity" : "qx.bom.client.Css.getOpacity",
      "css.textShadow" : "qx.bom.client.Css.getTextShadow",
      "css.textShadow.filter" : "qx.bom.client.Css.getFilterTextShadow",
      "css.alphaimageloaderneeded" : "qx.bom.client.Css.getAlphaImageLoaderNeeded",
      "css.pointerevents" : "qx.bom.client.Css.getPointerEvents",
      "phonegap" : "qx.bom.client.PhoneGap.getPhoneGap",
      "phonegap.notification" : "qx.bom.client.PhoneGap.getNotification",
      "xml.implementation" : "qx.bom.client.Xml.getImplementation",
      "xml.domparser" : "qx.bom.client.Xml.getDomParser",
      "xml.selectsinglenode" : "qx.bom.client.Xml.getSelectSingleNode",
      "xml.selectnodes" : "qx.bom.client.Xml.getSelectNodes",
      "xml.getelementsbytagnamens" : "qx.bom.client.Xml.getElementsByTagNameNS",
      "xml.domproperties" : "qx.bom.client.Xml.getDomProperties",
      "xml.attributens" : "qx.bom.client.Xml.getAttributeNS",
      "xml.createnode" : "qx.bom.client.Xml.getCreateNode",
      "xml.getqualifieditem" : "qx.bom.client.Xml.getQualifiedItem",
      "xml.createelementns" : "qx.bom.client.Xml.getCreateElementNS",
      "qx.mobile.nativescroll" : "qx.bom.client.Scroll.getNativeScroll"
    },
    get : function(key){

      if(qx.Bootstrap.DEBUG){

        if(key === "json"){

          qx.Bootstrap.warn("The environment key 'json' is deprecated " + "and will eventually be removed.");
        };
        if(key === "qx.emulatemouse"){

          qx.Bootstrap.warn("The environment key 'qx.emulatemouse' has been removed. " + "See the release notes for more details.");
        };
        if(key === "qx.mobile.emulatetouch"){

          qx.Bootstrap.warn("The environment key 'qx.mobile.emulatetouch' has been removed. " + "See the release notes for more details.");
        };
      };
      if(this.__cache[key] != undefined){

        return this.__cache[key];
      };
      var check = this._checks[key];
      if(check){

        var value = check();
        this.__cache[key] = value;
        return value;
      };
      var classAndMethod = this._getClassNameFromEnvKey(key);
      if(classAndMethod[0] != undefined){

        var clazz = classAndMethod[0];
        var method = classAndMethod[1];
        var value = clazz[method]();
        this.__cache[key] = value;
        return value;
      };
      if(qx.Bootstrap.DEBUG){

        qx.Bootstrap.warn(key + " is not a valid key. Please see the API-doc of " + "qx.core.Environment for a list of predefined keys.");
        qx.Bootstrap.trace(this);
      };
    },
    _getClassNameFromEnvKey : function(key){

      var envmappings = this._checksMap;
      if(envmappings[key] != undefined){

        var implementation = envmappings[key];
        var lastdot = implementation.lastIndexOf(".");
        if(lastdot > -1){

          var classname = implementation.slice(0, lastdot);
          var methodname = implementation.slice(lastdot + 1);
          var clazz = qx.Bootstrap.getByName(classname);
          if(clazz != undefined){

            return [clazz, methodname];
          };
        };
      };
      return [undefined, undefined];
    },
    getAsync : function(key, callback, self){

      var env = this;
      if(this.__cache[key] != undefined){

        window.setTimeout(function(){

          callback.call(self, env.__cache[key]);
        }, 0);
        return;
      };
      var check = this._asyncChecks[key];
      if(check){

        check(function(result){

          env.__cache[key] = result;
          callback.call(self, result);
        });
        return;
      };
      var classAndMethod = this._getClassNameFromEnvKey(key);
      if(classAndMethod[0] != undefined){

        var clazz = classAndMethod[0];
        var method = classAndMethod[1];
        clazz[method](function(result){

          env.__cache[key] = result;
          callback.call(self, result);
        });
        return;
      };
      if(qx.Bootstrap.DEBUG){

        qx.Bootstrap.warn(key + " is not a valid key. Please see the API-doc of " + "qx.core.Environment for a list of predefined keys.");
        qx.Bootstrap.trace(this);
      };
    },
    select : function(key, values){

      return this.__pickFromValues(this.get(key), values);
    },
    selectAsync : function(key, values, self){

      this.getAsync(key, function(result){

        var value = this.__pickFromValues(key, values);
        value.call(self, result);
      }, this);
    },
    __pickFromValues : function(key, values){

      var value = values[key];
      if(values.hasOwnProperty(key)){

        return value;
      };
      for(var id in values){

        if(id.indexOf("|") != -1){

          var ids = id.split("|");
          for(var i = 0;i < ids.length;i++){

            if(ids[i] == key){

              return values[id];
            };
          };
        };
      };
      if(values["default"] !== undefined){

        return values["default"];
      };
      if(qx.Bootstrap.DEBUG){

        throw new Error('No match for variant "' + key + '" (' + (typeof key) + ' type)' + ' in variants [' + qx.Bootstrap.keys(values) + '] found, and no default ("default") given');
      };
    },
    filter : function(map){

      var returnArray = [];
      for(var check in map){

        if(this.get(check)){

          returnArray.push(map[check]);
        };
      };
      return returnArray;
    },
    invalidateCacheKey : function(key){

      delete this.__cache[key];
    },
    add : function(key, check){

      if(this._checks[key] == undefined){

        if(check instanceof Function){

          this._checks[key] = check;
        } else {

          this._checks[key] = this.__createCheck(check);
        };
      };
    },
    addAsync : function(key, check){

      if(this._checks[key] == undefined){

        this._asyncChecks[key] = check;
      };
    },
    getChecks : function(){

      return this._checks;
    },
    getAsyncChecks : function(){

      return this._asyncChecks;
    },
    _initDefaultQxValues : function(){

      this.add("true", function(){

        return true;
      });
      this.add("qx.allowUrlSettings", function(){

        return false;
      });
      this.add("qx.allowUrlVariants", function(){

        return false;
      });
      this.add("qx.debug.property.level", function(){

        return 0;
      });
      this.add("qx.debug", function(){

        return true;
      });
      this.add("qx.debug.ui.queue", function(){

        return true;
      });
      this.add("qx.aspects", function(){

        return false;
      });
      this.add("qx.dynlocale", function(){

        return true;
      });
      this.add("qx.dyntheme", function(){

        return true;
      });
      this.add("qx.mobile.emulatetouch", function(){

        return false;
      });
      this.add("qx.emulatemouse", function(){

        return false;
      });
      this.add("qx.blankpage", function(){

        return "qx/static/blank.html";
      });
      this.add("qx.debug.databinding", function(){

        return false;
      });
      this.add("qx.debug.dispose", function(){

        return false;
      });
      this.add("qx.optimization.basecalls", function(){

        return false;
      });
      this.add("qx.optimization.comments", function(){

        return false;
      });
      this.add("qx.optimization.privates", function(){

        return false;
      });
      this.add("qx.optimization.strings", function(){

        return false;
      });
      this.add("qx.optimization.variables", function(){

        return false;
      });
      this.add("qx.optimization.variants", function(){

        return false;
      });
      this.add("module.databinding", function(){

        return true;
      });
      this.add("module.logger", function(){

        return true;
      });
      this.add("module.property", function(){

        return true;
      });
      this.add("module.events", function(){

        return true;
      });
      this.add("qx.nativeScrollBars", function(){

        return false;
      });
    },
    __importFromGenerator : function(){

      if(qx && qx.$$environment){

        for(var key in qx.$$environment){

          var value = qx.$$environment[key];
          this._checks[key] = this.__createCheck(value);
        };
      };
    },
    __importFromUrl : function(){

      if(window.document && window.document.location){

        var urlChecks = window.document.location.search.slice(1).split("&");
        for(var i = 0;i < urlChecks.length;i++){

          var check = urlChecks[i].split(":");
          if(check.length != 3 || check[0] != "qxenv"){

            continue;
          };
          var key = check[1];
          var value = decodeURIComponent(check[2]);
          if(value == "true"){

            value = true;
          } else if(value == "false"){

            value = false;
          } else if(/^(\d|\.)+$/.test(value)){

            value = parseFloat(value);
          };;
          this._checks[key] = this.__createCheck(value);
        };
      };
    },
    __createCheck : function(value){

      return qx.Bootstrap.bind(function(value){

        return value;
      }, null, value);
    }
  },
  defer : function(statics){

    statics._initDefaultQxValues();
    statics.__importFromGenerator();
    if(statics.get("qx.allowUrlSettings") === true){

      statics.__importFromUrl();
    };
  }
});

qx.Bootstrap.define("qx.bom.client.EcmaScript", {
  statics : {
    getStackTrace : function(){

      var propName;
      var e = new Error("e");
      propName = e.stack ? "stack" : e.stacktrace ? "stacktrace" : null;
      if(!propName){

        try{

          throw e;
        } catch(ex) {

          e = ex;
        };
      };
      return e.stacktrace ? "stacktrace" : e.stack ? "stack" : null;
    },
    getArrayIndexOf : function(){

      return !!Array.prototype.indexOf;
    },
    getArrayLastIndexOf : function(){

      return !!Array.prototype.lastIndexOf;
    },
    getArrayForEach : function(){

      return !!Array.prototype.forEach;
    },
    getArrayFilter : function(){

      return !!Array.prototype.filter;
    },
    getArrayMap : function(){

      return !!Array.prototype.map;
    },
    getArraySome : function(){

      return !!Array.prototype.some;
    },
    getArrayEvery : function(){

      return !!Array.prototype.every;
    },
    getArrayReduce : function(){

      return !!Array.prototype.reduce;
    },
    getArrayReduceRight : function(){

      return !!Array.prototype.reduceRight;
    },
    getErrorToString : function(){

      return typeof Error.prototype.toString == "function" && Error.prototype.toString() !== "[object Error]";
    },
    getFunctionBind : function(){

      return typeof Function.prototype.bind === "function";
    },
    getObjectKeys : function(){

      return !!Object.keys;
    },
    getDateNow : function(){

      return !!Date.now;
    },
    getStringTrim : function(){

      return typeof String.prototype.trim === "function";
    }
  },
  defer : function(statics){

    qx.core.Environment.add("ecmascript.array.indexof", statics.getArrayIndexOf);
    qx.core.Environment.add("ecmascript.array.lastindexof", statics.getArrayLastIndexOf);
    qx.core.Environment.add("ecmascript.array.foreach", statics.getArrayForEach);
    qx.core.Environment.add("ecmascript.array.filter", statics.getArrayFilter);
    qx.core.Environment.add("ecmascript.array.map", statics.getArrayMap);
    qx.core.Environment.add("ecmascript.array.some", statics.getArraySome);
    qx.core.Environment.add("ecmascript.array.every", statics.getArrayEvery);
    qx.core.Environment.add("ecmascript.array.reduce", statics.getArrayReduce);
    qx.core.Environment.add("ecmascript.array.reduceright", statics.getArrayReduceRight);
    qx.core.Environment.add("ecmascript.date.now", statics.getDateNow);
    qx.core.Environment.add("ecmascript.error.toString", statics.getErrorToString);
    qx.core.Environment.add("ecmascript.error.stacktrace", statics.getStackTrace);
    qx.core.Environment.add("ecmascript.function.bind", statics.getFunctionBind);
    qx.core.Environment.add("ecmascript.object.keys", statics.getObjectKeys);
    qx.core.Environment.add("ecmascript.string.trim", statics.getStringTrim);
  }
});

qx.Bootstrap.define("qx.lang.normalize.Function", {
  statics : {
    bind : function(that){

      var slice = Array.prototype.slice;
      var target = this;
      if(typeof target != "function"){

        throw new TypeError("Function.prototype.bind called on incompatible " + target);
      };
      var args = slice.call(arguments, 1);
      var bound = function(){

        if(this instanceof bound){

          var F = function(){
          };
          F.prototype = target.prototype;
          var self = new F;
          var result = target.apply(self, args.concat(slice.call(arguments)));
          if(Object(result) === result){

            return result;
          };
          return self;
        } else {

          return target.apply(that, args.concat(slice.call(arguments)));
        };
      };
      return bound;
    }
  },
  defer : function(statics){

    if(!qx.core.Environment.get("ecmascript.function.bind")){

      Function.prototype.bind = statics.bind;
    };
  }
});

qx.Bootstrap.define("qx.lang.normalize.Array", {
  statics : {
    indexOf : function(searchElement, fromIndex){

      if(fromIndex == null){

        fromIndex = 0;
      } else if(fromIndex < 0){

        fromIndex = Math.max(0, this.length + fromIndex);
      };
      for(var i = fromIndex;i < this.length;i++){

        if(this[i] === searchElement){

          return i;
        };
      };
      return -1;
    },
    lastIndexOf : function(searchElement, fromIndex){

      if(fromIndex == null){

        fromIndex = this.length - 1;
      } else if(fromIndex < 0){

        fromIndex = Math.max(0, this.length + fromIndex);
      };
      for(var i = fromIndex;i >= 0;i--){

        if(this[i] === searchElement){

          return i;
        };
      };
      return -1;
    },
    forEach : function(callback, obj){

      var l = this.length;
      for(var i = 0;i < l;i++){

        var value = this[i];
        if(value !== undefined){

          callback.call(obj || window, value, i, this);
        };
      };
    },
    filter : function(callback, obj){

      var res = [];
      var l = this.length;
      for(var i = 0;i < l;i++){

        var value = this[i];
        if(value !== undefined){

          if(callback.call(obj || window, value, i, this)){

            res.push(this[i]);
          };
        };
      };
      return res;
    },
    map : function(callback, obj){

      var res = [];
      var l = this.length;
      for(var i = 0;i < l;i++){

        var value = this[i];
        if(value !== undefined){

          res[i] = callback.call(obj || window, value, i, this);
        };
      };
      return res;
    },
    some : function(callback, obj){

      var l = this.length;
      for(var i = 0;i < l;i++){

        var value = this[i];
        if(value !== undefined){

          if(callback.call(obj || window, value, i, this)){

            return true;
          };
        };
      };
      return false;
    },
    every : function(callback, obj){

      var l = this.length;
      for(var i = 0;i < l;i++){

        var value = this[i];
        if(value !== undefined){

          if(!callback.call(obj || window, value, i, this)){

            return false;
          };
        };
      };
      return true;
    },
    reduce : function(callback, init){

      if(typeof callback !== "function"){

        throw new TypeError("First argument is not callable");
      };
      if(init === undefined && this.length === 0){

        throw new TypeError("Length is 0 and no second argument given");
      };
      var ret = init === undefined ? this[0] : init;
      for(var i = init === undefined ? 1 : 0;i < this.length;i++){

        if(i in this){

          ret = callback.call(undefined, ret, this[i], i, this);
        };
      };
      return ret;
    },
    reduceRight : function(callback, init){

      if(typeof callback !== "function"){

        throw new TypeError("First argument is not callable");
      };
      if(init === undefined && this.length === 0){

        throw new TypeError("Length is 0 and no second argument given");
      };
      var ret = init === undefined ? this[this.length - 1] : init;
      for(var i = init === undefined ? this.length - 2 : this.length - 1;i >= 0;i--){

        if(i in this){

          ret = callback.call(undefined, ret, this[i], i, this);
        };
      };
      return ret;
    }
  },
  defer : function(statics){

    if(!qx.core.Environment.get("ecmascript.array.indexof")){

      Array.prototype.indexOf = statics.indexOf;
    };
    if(!qx.core.Environment.get("ecmascript.array.lastindexof")){

      Array.prototype.lastIndexOf = statics.lastIndexOf;
    };
    if(!qx.core.Environment.get("ecmascript.array.foreach")){

      Array.prototype.forEach = statics.forEach;
    };
    if(!qx.core.Environment.get("ecmascript.array.filter")){

      Array.prototype.filter = statics.filter;
    };
    if(!qx.core.Environment.get("ecmascript.array.map")){

      Array.prototype.map = statics.map;
    };
    if(!qx.core.Environment.get("ecmascript.array.some")){

      Array.prototype.some = statics.some;
    };
    if(!qx.core.Environment.get("ecmascript.array.every")){

      Array.prototype.every = statics.every;
    };
    if(!qx.core.Environment.get("ecmascript.array.reduce")){

      Array.prototype.reduce = statics.reduce;
    };
    if(!qx.core.Environment.get("ecmascript.array.reduceright")){

      Array.prototype.reduceRight = statics.reduceRight;
    };
  }
});

qx.Bootstrap.define("qx.Mixin", {
  statics : {
    define : function(name, config){

      if(config){

        if(config.include && !(qx.Bootstrap.getClass(config.include) === "Array")){

          config.include = [config.include];
        };
        if(qx.core.Environment.get("qx.debug")){

          this.__validateConfig(name, config);
        };
        var mixin = config.statics ? config.statics : {
        };
        qx.Bootstrap.setDisplayNames(mixin, name);
        for(var key in mixin){

          if(mixin[key] instanceof Function){

            mixin[key].$$mixin = mixin;
          };
        };
        if(config.construct){

          mixin.$$constructor = config.construct;
          qx.Bootstrap.setDisplayName(config.construct, name, "constructor");
        };
        if(config.include){

          mixin.$$includes = config.include;
        };
        if(config.properties){

          mixin.$$properties = config.properties;
        };
        if(config.members){

          mixin.$$members = config.members;
          qx.Bootstrap.setDisplayNames(config.members, name + ".prototype");
        };
        for(var key in mixin.$$members){

          if(mixin.$$members[key] instanceof Function){

            mixin.$$members[key].$$mixin = mixin;
          };
        };
        if(config.events){

          mixin.$$events = config.events;
        };
        if(config.destruct){

          mixin.$$destructor = config.destruct;
          qx.Bootstrap.setDisplayName(config.destruct, name, "destruct");
        };
      } else {

        var mixin = {
        };
      };
      mixin.$$type = "Mixin";
      mixin.name = name;
      mixin.toString = this.genericToString;
      mixin.basename = qx.Bootstrap.createNamespace(name, mixin);
      this.$$registry[name] = mixin;
      return mixin;
    },
    checkCompatibility : function(mixins){

      var list = this.flatten(mixins);
      var len = list.length;
      if(len < 2){

        return true;
      };
      var properties = {
      };
      var members = {
      };
      var events = {
      };
      var mixin;
      for(var i = 0;i < len;i++){

        mixin = list[i];
        for(var key in mixin.events){

          if(events[key]){

            throw new Error('Conflict between mixin "' + mixin.name + '" and "' + events[key] + '" in member "' + key + '"!');
          };
          events[key] = mixin.name;
        };
        for(var key in mixin.properties){

          if(properties[key]){

            throw new Error('Conflict between mixin "' + mixin.name + '" and "' + properties[key] + '" in property "' + key + '"!');
          };
          properties[key] = mixin.name;
        };
        for(var key in mixin.members){

          if(members[key]){

            throw new Error('Conflict between mixin "' + mixin.name + '" and "' + members[key] + '" in member "' + key + '"!');
          };
          members[key] = mixin.name;
        };
      };
      return true;
    },
    isCompatible : function(mixin, clazz){

      var list = qx.util.OOUtil.getMixins(clazz);
      list.push(mixin);
      return qx.Mixin.checkCompatibility(list);
    },
    getByName : function(name){

      return this.$$registry[name];
    },
    isDefined : function(name){

      return this.getByName(name) !== undefined;
    },
    getTotalNumber : function(){

      return qx.Bootstrap.objectGetLength(this.$$registry);
    },
    flatten : function(mixins){

      if(!mixins){

        return [];
      };
      var list = mixins.concat();
      for(var i = 0,l = mixins.length;i < l;i++){

        if(mixins[i].$$includes){

          list.push.apply(list, this.flatten(mixins[i].$$includes));
        };
      };
      return list;
    },
    genericToString : function(){

      return "[Mixin " + this.name + "]";
    },
    $$registry : {
    },
    __allowedKeys : qx.core.Environment.select("qx.debug", {
      "true" : {
        "include" : "object",
        "statics" : "object",
        "members" : "object",
        "properties" : "object",
        "events" : "object",
        "destruct" : "function",
        "construct" : "function"
      },
      "default" : null
    }),
    __validateConfig : qx.core.Environment.select("qx.debug", {
      "true" : function(name, config){

        var allowed = this.__allowedKeys;
        for(var key in config){

          if(!allowed[key]){

            throw new Error('The configuration key "' + key + '" in mixin "' + name + '" is not allowed!');
          };
          if(config[key] == null){

            throw new Error('Invalid key "' + key + '" in mixin "' + name + '"! The value is undefined/null!');
          };
          if(allowed[key] !== null && typeof config[key] !== allowed[key]){

            throw new Error('Invalid type of key "' + key + '" in mixin "' + name + '"! The type of the key must be "' + allowed[key] + '"!');
          };
        };
        var maps = ["statics", "members", "properties", "events"];
        for(var i = 0,l = maps.length;i < l;i++){

          var key = maps[i];
          if(config[key] !== undefined && (["Array", "RegExp", "Date"].indexOf(qx.Bootstrap.getClass(config[key])) != -1 || config[key].classname !== undefined)){

            throw new Error('Invalid key "' + key + '" in mixin "' + name + '"! The value needs to be a map!');
          };
        };
        if(config.include){

          for(var i = 0,a = config.include,l = a.length;i < l;i++){

            if(a[i] == null){

              throw new Error("Includes of mixins must be mixins. The include number '" + (i + 1) + "' in mixin '" + name + "'is undefined/null!");
            };
            if(a[i].$$type !== "Mixin"){

              throw new Error("Includes of mixins must be mixins. The include number '" + (i + 1) + "' in mixin '" + name + "'is not a mixin!");
            };
          };
          this.checkCompatibility(config.include);
        };
      },
      "default" : function(name, config){
      }
    })
  }
});

qx.Bootstrap.define("qx.core.Aspect", {
  statics : {
    __registry : [],
    wrap : function(fullName, fcn, type){

      var before = [];
      var after = [];
      var reg = this.__registry;
      var entry;
      for(var i = 0;i < reg.length;i++){

        entry = reg[i];
        if((entry.type == null || type == entry.type || entry.type == "*") && (entry.name == null || fullName.match(entry.name))){

          entry.pos == -1 ? before.push(entry.fcn) : after.push(entry.fcn);
        };
      };
      if(before.length === 0 && after.length === 0){

        return fcn;
      };
      var wrapper = function(){

        for(var i = 0;i < before.length;i++){

          before[i].call(this, fullName, fcn, type, arguments);
        };
        var ret = fcn.apply(this, arguments);
        for(var i = 0;i < after.length;i++){

          after[i].call(this, fullName, fcn, type, arguments, ret);
        };
        return ret;
      };
      if(type !== "static"){

        wrapper.self = fcn.self;
        wrapper.base = fcn.base;
      };
      fcn.wrapper = wrapper;
      wrapper.original = fcn;
      return wrapper;
    },
    addAdvice : function(fcn, position, type, name){

      this.__registry.push({
        fcn : fcn,
        pos : position === "before" ? -1 : 1,
        type : type,
        name : name
      });
    }
  }
});

qx.Bootstrap.define("qx.lang.normalize.String", {
  statics : {
    trim : function(){

      return this.replace(/^\s+|\s+$/g, '');
    }
  },
  defer : function(statics){

    if(!qx.core.Environment.get("ecmascript.string.trim")){

      String.prototype.trim = statics.trim;
    };
  }
});

qx.Bootstrap.define("qx.lang.normalize.Object", {
  statics : {
    keys : qx.Bootstrap.keys
  },
  defer : function(statics){

    if(!qx.core.Environment.get("ecmascript.object.keys")){

      Object.keys = statics.keys;
    };
  }
});

qx.Bootstrap.define("qx.Interface", {
  statics : {
    define : function(name, config){

      if(config){

        if(config.extend && !(qx.Bootstrap.getClass(config.extend) === "Array")){

          config.extend = [config.extend];
        };
        if(qx.core.Environment.get("qx.debug")){

          this.__validateConfig(name, config);
        };
        var iface = config.statics ? config.statics : {
        };
        if(config.extend){

          iface.$$extends = config.extend;
        };
        if(config.properties){

          iface.$$properties = config.properties;
        };
        if(config.members){

          iface.$$members = config.members;
        };
        if(config.events){

          iface.$$events = config.events;
        };
      } else {

        var iface = {
        };
      };
      iface.$$type = "Interface";
      iface.name = name;
      iface.toString = this.genericToString;
      iface.basename = qx.Bootstrap.createNamespace(name, iface);
      qx.Interface.$$registry[name] = iface;
      return iface;
    },
    getByName : function(name){

      return this.$$registry[name];
    },
    isDefined : function(name){

      return this.getByName(name) !== undefined;
    },
    getTotalNumber : function(){

      return qx.Bootstrap.objectGetLength(this.$$registry);
    },
    flatten : function(ifaces){

      if(!ifaces){

        return [];
      };
      var list = ifaces.concat();
      for(var i = 0,l = ifaces.length;i < l;i++){

        if(ifaces[i].$$extends){

          list.push.apply(list, this.flatten(ifaces[i].$$extends));
        };
      };
      return list;
    },
    __checkMembers : function(object, clazz, iface, wrap, shouldThrow){

      var members = iface.$$members;
      if(members){

        for(var key in members){

          if(qx.Bootstrap.isFunction(members[key])){

            var isPropertyMethod = this.__isPropertyMethod(clazz, key);
            var hasMemberFunction = isPropertyMethod || qx.Bootstrap.isFunction(object[key]);
            if(!hasMemberFunction){

              if(shouldThrow){

                throw new Error('Implementation of method "' + key + '" is missing in class "' + clazz.classname + '" required by interface "' + iface.name + '"');
              } else {

                return false;
              };
            };
            var shouldWrapFunction = wrap === true && !isPropertyMethod && !qx.util.OOUtil.hasInterface(clazz, iface);
            if(shouldWrapFunction){

              object[key] = this.__wrapInterfaceMember(iface, object[key], key, members[key]);
            };
          } else {

            if(typeof object[key] === undefined){

              if(typeof object[key] !== "function"){

                if(shouldThrow){

                  throw new Error('Implementation of member "' + key + '" is missing in class "' + clazz.classname + '" required by interface "' + iface.name + '"');
                } else {

                  return false;
                };
              };
            };
          };
        };
      };
      if(!shouldThrow){

        return true;
      };
    },
    __isPropertyMethod : function(clazz, methodName){

      var match = methodName.match(/^(is|toggle|get|set|reset)(.*)$/);
      if(!match){

        return false;
      };
      var propertyName = qx.Bootstrap.firstLow(match[2]);
      var isPropertyMethod = qx.util.OOUtil.getPropertyDefinition(clazz, propertyName);
      if(!isPropertyMethod){

        return false;
      };
      var isBoolean = match[0] == "is" || match[0] == "toggle";
      if(isBoolean){

        return qx.util.OOUtil.getPropertyDefinition(clazz, propertyName).check == "Boolean";
      };
      return true;
    },
    __checkProperties : function(clazz, iface, shouldThrow){

      if(iface.$$properties){

        for(var key in iface.$$properties){

          if(!qx.util.OOUtil.getPropertyDefinition(clazz, key)){

            if(shouldThrow){

              throw new Error('The property "' + key + '" is not supported by Class "' + clazz.classname + '"!');
            } else {

              return false;
            };
          };
        };
      };
      if(!shouldThrow){

        return true;
      };
    },
    __checkEvents : function(clazz, iface, shouldThrow){

      if(iface.$$events){

        for(var key in iface.$$events){

          if(!qx.util.OOUtil.supportsEvent(clazz, key)){

            if(shouldThrow){

              throw new Error('The event "' + key + '" is not supported by Class "' + clazz.classname + '"!');
            } else {

              return false;
            };
          };
        };
      };
      if(!shouldThrow){

        return true;
      };
    },
    assertObject : function(object, iface){

      var clazz = object.constructor;
      this.__checkMembers(object, clazz, iface, false, true);
      this.__checkProperties(clazz, iface, true);
      this.__checkEvents(clazz, iface, true);
      var extend = iface.$$extends;
      if(extend){

        for(var i = 0,l = extend.length;i < l;i++){

          this.assertObject(object, extend[i]);
        };
      };
    },
    assert : function(clazz, iface, wrap){

      this.__checkMembers(clazz.prototype, clazz, iface, wrap, true);
      this.__checkProperties(clazz, iface, true);
      this.__checkEvents(clazz, iface, true);
      var extend = iface.$$extends;
      if(extend){

        for(var i = 0,l = extend.length;i < l;i++){

          this.assert(clazz, extend[i], wrap);
        };
      };
    },
    objectImplements : function(object, iface){

      var clazz = object.constructor;
      if(!this.__checkMembers(object, clazz, iface) || !this.__checkProperties(clazz, iface) || !this.__checkEvents(clazz, iface)){

        return false;
      };
      var extend = iface.$$extends;
      if(extend){

        for(var i = 0,l = extend.length;i < l;i++){

          if(!this.objectImplements(object, extend[i])){

            return false;
          };
        };
      };
      return true;
    },
    classImplements : function(clazz, iface){

      if(!this.__checkMembers(clazz.prototype, clazz, iface) || !this.__checkProperties(clazz, iface) || !this.__checkEvents(clazz, iface)){

        return false;
      };
      var extend = iface.$$extends;
      if(extend){

        for(var i = 0,l = extend.length;i < l;i++){

          if(!this.has(clazz, extend[i])){

            return false;
          };
        };
      };
      return true;
    },
    genericToString : function(){

      return "[Interface " + this.name + "]";
    },
    $$registry : {
    },
    __wrapInterfaceMember : qx.core.Environment.select("qx.debug", {
      "true" : function(iface, origFunction, functionName, preCondition){

        function wrappedFunction(){

          preCondition.apply(this, arguments);
          return origFunction.apply(this, arguments);
        };
        origFunction.wrapper = wrappedFunction;
        return wrappedFunction;
      },
      "default" : function(iface, origFunction, functionName, preCondition){
      }
    }),
    __allowedKeys : qx.core.Environment.select("qx.debug", {
      "true" : {
        "extend" : "object",
        "statics" : "object",
        "members" : "object",
        "properties" : "object",
        "events" : "object"
      },
      "default" : null
    }),
    __validateConfig : qx.core.Environment.select("qx.debug", {
      "true" : function(name, config){

        if(qx.core.Environment.get("qx.debug")){

          var allowed = this.__allowedKeys;
          for(var key in config){

            if(allowed[key] === undefined){

              throw new Error('The configuration key "' + key + '" in class "' + name + '" is not allowed!');
            };
            if(config[key] == null){

              throw new Error("Invalid key '" + key + "' in interface '" + name + "'! The value is undefined/null!");
            };
            if(allowed[key] !== null && typeof config[key] !== allowed[key]){

              throw new Error('Invalid type of key "' + key + '" in interface "' + name + '"! The type of the key must be "' + allowed[key] + '"!');
            };
          };
          var maps = ["statics", "members", "properties", "events"];
          for(var i = 0,l = maps.length;i < l;i++){

            var key = maps[i];
            if(config[key] !== undefined && (["Array", "RegExp", "Date"].indexOf(qx.Bootstrap.getClass(config[key])) != -1 || config[key].classname !== undefined)){

              throw new Error('Invalid key "' + key + '" in interface "' + name + '"! The value needs to be a map!');
            };
          };
          if(config.extend){

            for(var i = 0,a = config.extend,l = a.length;i < l;i++){

              if(a[i] == null){

                throw new Error("Extends of interfaces must be interfaces. The extend number '" + i + 1 + "' in interface '" + name + "' is undefined/null!");
              };
              if(a[i].$$type !== "Interface"){

                throw new Error("Extends of interfaces must be interfaces. The extend number '" + i + 1 + "' in interface '" + name + "' is not an interface!");
              };
            };
          };
          if(config.statics){

            for(var key in config.statics){

              if(key.toUpperCase() !== key){

                throw new Error('Invalid key "' + key + '" in interface "' + name + '"! Static constants must be all uppercase.');
              };
              switch(typeof config.statics[key]){case "boolean":case "string":case "number":
              break;default:
              throw new Error('Invalid key "' + key + '" in interface "' + name + '"! Static constants must be all of a primitive type.');};
            };
          };
        };
      },
      "default" : function(name, config){
      }
    })
  }
});

qx.Bootstrap.define("qx.lang.normalize.Error", {
  statics : {
    toString : function(){

      var name = this.name || "Error";
      var message = this.message || "";
      if(name === "" && message === ""){

        return "Error";
      };
      if(name === ""){

        return message;
      };
      if(message === ""){

        return name;
      };
      return name + ": " + message;
    }
  },
  defer : function(statics){

    if(!qx.core.Environment.get("ecmascript.error.toString")){

      Error.prototype.toString = statics.toString;
    };
  }
});

qx.Bootstrap.define("qx.lang.normalize.Date", {
  statics : {
    now : function(){

      return +new Date();
    }
  },
  defer : function(statics){

    if(!qx.core.Environment.get("ecmascript.date.now")){

      Date.now = statics.now;
    };
  }
});

qx.Bootstrap.define("qx.core.Property", {
  statics : {
    __gatherDependency : function(){

      if(qx.core.Environment.get("module.events")){

        qx.event.type.Data;
        qx.event.dispatch.Direct;
      };
    },
    __checks : {
      "Boolean" : 'qx.core.Assert.assertBoolean(value, msg) || true',
      "String" : 'qx.core.Assert.assertString(value, msg) || true',
      "Number" : 'qx.core.Assert.assertNumber(value, msg) || true',
      "Integer" : 'qx.core.Assert.assertInteger(value, msg) || true',
      "PositiveNumber" : 'qx.core.Assert.assertPositiveNumber(value, msg) || true',
      "PositiveInteger" : 'qx.core.Assert.assertPositiveInteger(value, msg) || true',
      "Error" : 'qx.core.Assert.assertInstance(value, Error, msg) || true',
      "RegExp" : 'qx.core.Assert.assertInstance(value, RegExp, msg) || true',
      "Object" : 'qx.core.Assert.assertObject(value, msg) || true',
      "Array" : 'qx.core.Assert.assertArray(value, msg) || true',
      "Map" : 'qx.core.Assert.assertMap(value, msg) || true',
      "Function" : 'qx.core.Assert.assertFunction(value, msg) || true',
      "Date" : 'qx.core.Assert.assertInstance(value, Date, msg) || true',
      "Node" : 'value !== null && value.nodeType !== undefined',
      "Element" : 'value !== null && value.nodeType === 1 && value.attributes',
      "Document" : 'value !== null && value.nodeType === 9 && value.documentElement',
      "Window" : 'value !== null && value.document',
      "Event" : 'value !== null && value.type !== undefined',
      "Class" : 'value !== null && value.$$type === "Class"',
      "Mixin" : 'value !== null && value.$$type === "Mixin"',
      "Interface" : 'value !== null && value.$$type === "Interface"',
      "Theme" : 'value !== null && value.$$type === "Theme"',
      "Color" : 'qx.lang.Type.isString(value) && qx.util.ColorUtil.isValidPropertyValue(value)',
      "Decorator" : 'value !== null && qx.theme.manager.Decoration.getInstance().isValidPropertyValue(value)',
      "Font" : 'value !== null && qx.theme.manager.Font.getInstance().isDynamic(value)'
    },
    __dereference : {
      "Node" : true,
      "Element" : true,
      "Document" : true,
      "Window" : true,
      "Event" : true
    },
    $$inherit : "inherit",
    $$store : {
      runtime : {
      },
      user : {
      },
      theme : {
      },
      inherit : {
      },
      init : {
      },
      useinit : {
      }
    },
    $$method : {
      get : {
      },
      set : {
      },
      reset : {
      },
      init : {
      },
      refresh : {
      },
      setRuntime : {
      },
      resetRuntime : {
      },
      setThemed : {
      },
      resetThemed : {
      }
    },
    $$allowedKeys : {
      name : "string",
      dereference : "boolean",
      inheritable : "boolean",
      nullable : "boolean",
      themeable : "boolean",
      refine : "boolean",
      init : null,
      apply : "string",
      event : "string",
      check : null,
      transform : "string",
      deferredInit : "boolean",
      validate : null
    },
    $$allowedGroupKeys : {
      name : "string",
      group : "object",
      mode : "string",
      themeable : "boolean"
    },
    $$inheritable : {
    },
    __executeOptimizedRefresh : function(clazz){

      var inheritables = this.__getInheritablesOfClass(clazz);
      if(!inheritables.length){

        var refresher = function(){
        };
      } else {

        refresher = this.__createRefresher(inheritables);
      };
      clazz.prototype.$$refreshInheritables = refresher;
    },
    __getInheritablesOfClass : function(clazz){

      var inheritable = [];
      while(clazz){

        var properties = clazz.$$properties;
        if(properties){

          for(var name in this.$$inheritable){

            if(properties[name] && properties[name].inheritable){

              inheritable.push(name);
            };
          };
        };
        clazz = clazz.superclass;
      };
      return inheritable;
    },
    __createRefresher : function(inheritables){

      var inherit = this.$$store.inherit;
      var init = this.$$store.init;
      var refresh = this.$$method.refresh;
      var code = ["var parent = this.getLayoutParent();", "if (!parent) return;"];
      for(var i = 0,l = inheritables.length;i < l;i++){

        var name = inheritables[i];
        code.push("var value = parent.", inherit[name], ";", "if (value===undefined) value = parent.", init[name], ";", "this.", refresh[name], "(value);");
      };
      return new Function(code.join(""));
    },
    attachRefreshInheritables : function(clazz){

      clazz.prototype.$$refreshInheritables = function(){

        qx.core.Property.__executeOptimizedRefresh(clazz);
        return this.$$refreshInheritables();
      };
    },
    attachMethods : function(clazz, name, config){

      config.group ? this.__attachGroupMethods(clazz, config, name) : this.__attachPropertyMethods(clazz, config, name);
    },
    __attachGroupMethods : function(clazz, config, name){

      var upname = qx.Bootstrap.firstUp(name);
      var members = clazz.prototype;
      var themeable = config.themeable === true;
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.property.level") > 1){

          qx.Bootstrap.debug("Generating property group: " + name);
        };
      };
      var setter = [];
      var resetter = [];
      if(themeable){

        var styler = [];
        var unstyler = [];
      };
      var argHandler = "var a=arguments[0] instanceof Array?arguments[0]:arguments;";
      setter.push(argHandler);
      if(themeable){

        styler.push(argHandler);
      };
      if(config.mode == "shorthand"){

        var shorthand = "a=qx.lang.Array.fromShortHand(qx.lang.Array.fromArguments(a));";
        setter.push(shorthand);
        if(themeable){

          styler.push(shorthand);
        };
      };
      for(var i = 0,a = config.group,l = a.length;i < l;i++){

        if(qx.core.Environment.get("qx.debug")){

          if(!this.$$method.set[a[i]] || !this.$$method.reset[a[i]]){

            throw new Error("Cannot create property group '" + name + "' including non-existing property '" + a[i] + "'!");
          };
        };
        setter.push("this.", this.$$method.set[a[i]], "(a[", i, "]);");
        resetter.push("this.", this.$$method.reset[a[i]], "();");
        if(themeable){

          if(qx.core.Environment.get("qx.debug")){

            if(!this.$$method.setThemed[a[i]]){

              throw new Error("Cannot add the non themable property '" + a[i] + "' to the themable property group '" + name + "'");
            };
          };
          styler.push("this.", this.$$method.setThemed[a[i]], "(a[", i, "]);");
          unstyler.push("this.", this.$$method.resetThemed[a[i]], "();");
        };
      };
      this.$$method.set[name] = "set" + upname;
      members[this.$$method.set[name]] = new Function(setter.join(""));
      this.$$method.reset[name] = "reset" + upname;
      members[this.$$method.reset[name]] = new Function(resetter.join(""));
      if(themeable){

        this.$$method.setThemed[name] = "setThemed" + upname;
        members[this.$$method.setThemed[name]] = new Function(styler.join(""));
        this.$$method.resetThemed[name] = "resetThemed" + upname;
        members[this.$$method.resetThemed[name]] = new Function(unstyler.join(""));
      };
    },
    __attachPropertyMethods : function(clazz, config, name){

      var upname = qx.Bootstrap.firstUp(name);
      var members = clazz.prototype;
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.property.level") > 1){

          qx.Bootstrap.debug("Generating property wrappers: " + name);
        };
      };
      if(config.dereference === undefined && typeof config.check === "string"){

        config.dereference = this.__shouldBeDereferenced(config.check);
      };
      var method = this.$$method;
      var store = this.$$store;
      store.runtime[name] = "$$runtime_" + name;
      store.user[name] = "$$user_" + name;
      store.theme[name] = "$$theme_" + name;
      store.init[name] = "$$init_" + name;
      store.inherit[name] = "$$inherit_" + name;
      store.useinit[name] = "$$useinit_" + name;
      method.get[name] = "get" + upname;
      members[method.get[name]] = function(){

        return qx.core.Property.executeOptimizedGetter(this, clazz, name, "get");
      };
      method.set[name] = "set" + upname;
      members[method.set[name]] = function(value){

        return qx.core.Property.executeOptimizedSetter(this, clazz, name, "set", arguments);
      };
      method.reset[name] = "reset" + upname;
      members[method.reset[name]] = function(){

        return qx.core.Property.executeOptimizedSetter(this, clazz, name, "reset");
      };
      if(config.inheritable || config.apply || config.event || config.deferredInit){

        method.init[name] = "init" + upname;
        members[method.init[name]] = function(value){

          return qx.core.Property.executeOptimizedSetter(this, clazz, name, "init", arguments);
        };
        if(qx.core.Environment.get("qx.debug")){

          members[method.init[name]].$$propertyMethod = true;
        };
      };
      if(config.inheritable){

        method.refresh[name] = "refresh" + upname;
        members[method.refresh[name]] = function(value){

          return qx.core.Property.executeOptimizedSetter(this, clazz, name, "refresh", arguments);
        };
        if(qx.core.Environment.get("qx.debug")){

          members[method.refresh[name]].$$propertyMethod = true;
        };
      };
      method.setRuntime[name] = "setRuntime" + upname;
      members[method.setRuntime[name]] = function(value){

        return qx.core.Property.executeOptimizedSetter(this, clazz, name, "setRuntime", arguments);
      };
      method.resetRuntime[name] = "resetRuntime" + upname;
      members[method.resetRuntime[name]] = function(){

        return qx.core.Property.executeOptimizedSetter(this, clazz, name, "resetRuntime");
      };
      if(config.themeable){

        method.setThemed[name] = "setThemed" + upname;
        members[method.setThemed[name]] = function(value){

          return qx.core.Property.executeOptimizedSetter(this, clazz, name, "setThemed", arguments);
        };
        method.resetThemed[name] = "resetThemed" + upname;
        members[method.resetThemed[name]] = function(){

          return qx.core.Property.executeOptimizedSetter(this, clazz, name, "resetThemed");
        };
        if(qx.core.Environment.get("qx.debug")){

          members[method.setThemed[name]].$$propertyMethod = true;
          members[method.resetThemed[name]].$$propertyMethod = true;
        };
      };
      if(config.check === "Boolean"){

        members["toggle" + upname] = new Function("return this." + method.set[name] + "(!this." + method.get[name] + "())");
        members["is" + upname] = new Function("return this." + method.get[name] + "()");
        if(qx.core.Environment.get("qx.debug")){

          members["toggle" + upname].$$propertyMethod = true;
          members["is" + upname].$$propertyMethod = true;
        };
      };
      if(qx.core.Environment.get("qx.debug")){

        members[method.get[name]].$$propertyMethod = true;
        members[method.set[name]].$$propertyMethod = true;
        members[method.reset[name]].$$propertyMethod = true;
        members[method.setRuntime[name]].$$propertyMethod = true;
        members[method.resetRuntime[name]].$$propertyMethod = true;
      };
    },
    __shouldBeDereferenced : function(check){

      return !!this.__dereference[check];
    },
    __errors : {
      '0' : 'Could not change or apply init value after constructing phase!',
      '1' : 'Requires exactly one argument!',
      '2' : 'Undefined value is not allowed!',
      '3' : 'Does not allow any arguments!',
      '4' : 'Null value is not allowed!',
      '5' : 'Is invalid!'
    },
    error : function(obj, id, property, variant, value){

      var classname = obj.constructor.classname;
      var msg = "Error in property " + property + " of class " + classname + " in method " + this.$$method[variant][property] + " with incoming value '" + value + "': ";
      throw new Error(msg + (this.__errors[id] || "Unknown reason: " + id));
    },
    __unwrapFunctionFromCode : function(instance, members, name, variant, code, args){

      var store = this.$$method[variant][name];
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.property.level") > 1){

          qx.Bootstrap.debug("Code[" + this.$$method[variant][name] + "]: " + code.join(""));
        };
        try{

          members[store] = new Function("value", code.join(""));
        } catch(ex) {

          throw new Error("Malformed generated code to unwrap method: " + this.$$method[variant][name] + "\n" + code.join(""));
        };
      } else {

        members[store] = new Function("value", code.join(""));
      };
      if(qx.core.Environment.get("qx.aspects")){

        members[store] = qx.core.Aspect.wrap(instance.classname + "." + store, members[store], "property");
      };
      qx.Bootstrap.setDisplayName(members[store], instance.classname + ".prototype", store);
      if(args === undefined){

        return instance[store]();
      } else if(qx.core.Environment.get("qx.debug")){

        return instance[store].apply(instance, args);
      } else {

        return instance[store](args[0]);
      };
    },
    executeOptimizedGetter : function(instance, clazz, name, variant){

      var config = clazz.$$properties[name];
      var members = clazz.prototype;
      var code = [];
      var store = this.$$store;
      code.push('if(this.', store.runtime[name], '!==undefined)');
      code.push('return this.', store.runtime[name], ';');
      if(config.inheritable){

        code.push('else if(this.', store.inherit[name], '!==undefined)');
        code.push('return this.', store.inherit[name], ';');
        code.push('else ');
      };
      code.push('if(this.', store.user[name], '!==undefined)');
      code.push('return this.', store.user[name], ';');
      if(config.themeable){

        code.push('else if(this.', store.theme[name], '!==undefined)');
        code.push('return this.', store.theme[name], ';');
      };
      if(config.deferredInit && config.init === undefined){

        code.push('else if(this.', store.init[name], '!==undefined)');
        code.push('return this.', store.init[name], ';');
      };
      code.push('else ');
      if(config.init !== undefined){

        if(config.inheritable){

          code.push('var init=this.', store.init[name], ';');
          if(config.nullable){

            code.push('if(init==qx.core.Property.$$inherit)init=null;');
          } else if(config.init !== undefined){

            code.push('return this.', store.init[name], ';');
          } else {

            code.push('if(init==qx.core.Property.$$inherit)throw new Error("Inheritable property ', name, ' of an instance of ', clazz.classname, ' is not (yet) ready!");');
          };
          code.push('return init;');
        } else {

          code.push('return this.', store.init[name], ';');
        };
      } else if(config.inheritable || config.nullable){

        code.push('return null;');
      } else {

        code.push('throw new Error("Property ', name, ' of an instance of ', clazz.classname, ' is not (yet) ready!");');
      };
      return this.__unwrapFunctionFromCode(instance, members, name, variant, code);
    },
    executeOptimizedSetter : function(instance, clazz, name, variant, args){

      var config = clazz.$$properties[name];
      var members = clazz.prototype;
      var code = [];
      var incomingValue = variant === "set" || variant === "setThemed" || variant === "setRuntime" || (variant === "init" && config.init === undefined);
      var hasCallback = config.apply || config.event || config.inheritable;
      var store = this.__getStore(variant, name);
      this.__emitSetterPreConditions(code, config, name, variant, incomingValue);
      if(incomingValue){

        this.__emitIncomingValueTransformation(code, clazz, config, name);
      };
      if(hasCallback){

        this.__emitOldNewComparison(code, incomingValue, store, variant);
      };
      if(config.inheritable){

        code.push('var inherit=prop.$$inherit;');
      };
      if(qx.core.Environment.get("qx.debug")){

        if(incomingValue){

          this.__emitIncomingValueValidation(code, config, clazz, name, variant);
        };
      };
      if(!hasCallback){

        this.__emitStoreValue(code, name, variant, incomingValue);
      } else {

        this.__emitStoreComputedAndOldValue(code, config, name, variant, incomingValue);
      };
      if(config.inheritable){

        this.__emitStoreInheritedPropertyValue(code, config, name, variant);
      } else if(hasCallback){

        this.__emitNormalizeUndefinedValues(code, config, name, variant);
      };
      if(hasCallback){

        this.__emitCallCallback(code, config, name, variant);
        if(config.inheritable && members._getChildren){

          this.__emitRefreshChildrenValue(code, name);
        };
      };
      if(incomingValue){

        code.push('return value;');
      };
      return this.__unwrapFunctionFromCode(instance, members, name, variant, code, args);
    },
    __getStore : function(variant, name){

      if(variant === "setRuntime" || variant === "resetRuntime"){

        var store = this.$$store.runtime[name];
      } else if(variant === "setThemed" || variant === "resetThemed"){

        store = this.$$store.theme[name];
      } else if(variant === "init"){

        store = this.$$store.init[name];
      } else {

        store = this.$$store.user[name];
      };;
      return store;
    },
    __emitSetterPreConditions : function(code, config, name, variant, incomingValue){

      if(qx.core.Environment.get("qx.debug")){

        code.push('var prop=qx.core.Property;');
        if(variant === "init"){

          code.push('if(this.$$initialized)prop.error(this,0,"', name, '","', variant, '",value);');
        };
        if(variant === "refresh"){
        } else if(incomingValue){

          code.push('if(arguments.length!==1)prop.error(this,1,"', name, '","', variant, '",value);');
          code.push('if(value===undefined)prop.error(this,2,"', name, '","', variant, '",value);');
        } else {

          code.push('if(arguments.length!==0)prop.error(this,3,"', name, '","', variant, '",value);');
        };
      } else {

        if(!config.nullable || config.check || config.inheritable){

          code.push('var prop=qx.core.Property;');
        };
        if(variant === "set"){

          code.push('if(value===undefined)prop.error(this,2,"', name, '","', variant, '",value);');
        };
      };
    },
    __emitIncomingValueTransformation : function(code, clazz, config, name){

      if(config.transform){

        code.push('value=this.', config.transform, '(value);');
      };
      if(config.validate){

        if(typeof config.validate === "string"){

          code.push('this.', config.validate, '(value);');
        } else if(config.validate instanceof Function){

          code.push(clazz.classname, '.$$properties.', name);
          code.push('.validate.call(this, value);');
        };
      };
    },
    __emitOldNewComparison : function(code, incomingValue, store, variant){

      var resetValue = (variant === "reset" || variant === "resetThemed" || variant === "resetRuntime");
      if(incomingValue){

        code.push('if(this.', store, '===value)return value;');
      } else if(resetValue){

        code.push('if(this.', store, '===undefined)return;');
      };
    },
    __emitIncomingValueValidation : qx.core.Environment.select("qx.debug", {
      "true" : function(code, config, clazz, name, variant){

        if(!config.nullable){

          code.push('if(value===null)prop.error(this,4,"', name, '","', variant, '",value);');
        };
        if(config.check !== undefined){

          code.push('var msg = "Invalid incoming value for property \'' + name + '\' of class \'' + clazz.classname + '\'";');
          if(config.nullable){

            code.push('if(value!==null)');
          };
          if(config.inheritable){

            code.push('if(value!==inherit)');
          };
          code.push('if(');
          if(this.__checks[config.check] !== undefined){

            code.push('!(', this.__checks[config.check], ')');
          } else if(qx.Class.isDefined(config.check)){

            code.push('qx.core.Assert.assertInstance(value, qx.Class.getByName("', config.check, '"), msg)');
          } else if(qx.Interface && qx.Interface.isDefined(config.check)){

            code.push('qx.core.Assert.assertInterface(value, qx.Interface.getByName("', config.check, '"), msg)');
          } else if(typeof config.check === "function"){

            code.push('!', clazz.classname, '.$$properties.', name);
            code.push('.check.call(this, value)');
          } else if(typeof config.check === "string"){

            code.push('!(', config.check, ')');
          } else if(config.check instanceof Array){

            code.push('qx.core.Assert.assertInArray(value, ', clazz.classname, '.$$properties.', name, '.check, msg)');
          } else {

            throw new Error("Could not add check to property " + name + " of class " + clazz.classname);
          };;;;;
          code.push(')prop.error(this,5,"', name, '","', variant, '",value);');
        };
      },
      "false" : undefined
    }),
    __emitStoreValue : function(code, name, variant, incomingValue){

      if(variant === "setRuntime"){

        code.push('this.', this.$$store.runtime[name], '=value;');
      } else if(variant === "resetRuntime"){

        code.push('if(this.', this.$$store.runtime[name], '!==undefined)');
        code.push('delete this.', this.$$store.runtime[name], ';');
      } else if(variant === "set"){

        code.push('this.', this.$$store.user[name], '=value;');
      } else if(variant === "reset"){

        code.push('if(this.', this.$$store.user[name], '!==undefined)');
        code.push('delete this.', this.$$store.user[name], ';');
      } else if(variant === "setThemed"){

        code.push('this.', this.$$store.theme[name], '=value;');
      } else if(variant === "resetThemed"){

        code.push('if(this.', this.$$store.theme[name], '!==undefined)');
        code.push('delete this.', this.$$store.theme[name], ';');
      } else if(variant === "init" && incomingValue){

        code.push('this.', this.$$store.init[name], '=value;');
      };;;;;;
    },
    __emitStoreComputedAndOldValue : function(code, config, name, variant, incomingValue){

      if(config.inheritable){

        code.push('var computed, old=this.', this.$$store.inherit[name], ';');
      } else {

        code.push('var computed, old;');
      };
      code.push('if(this.', this.$$store.runtime[name], '!==undefined){');
      if(variant === "setRuntime"){

        code.push('computed=this.', this.$$store.runtime[name], '=value;');
      } else if(variant === "resetRuntime"){

        code.push('delete this.', this.$$store.runtime[name], ';');
        code.push('if(this.', this.$$store.user[name], '!==undefined)');
        code.push('computed=this.', this.$$store.user[name], ';');
        code.push('else if(this.', this.$$store.theme[name], '!==undefined)');
        code.push('computed=this.', this.$$store.theme[name], ';');
        code.push('else if(this.', this.$$store.init[name], '!==undefined){');
        code.push('computed=this.', this.$$store.init[name], ';');
        code.push('this.', this.$$store.useinit[name], '=true;');
        code.push('}');
      } else {

        code.push('old=computed=this.', this.$$store.runtime[name], ';');
        if(variant === "set"){

          code.push('this.', this.$$store.user[name], '=value;');
        } else if(variant === "reset"){

          code.push('delete this.', this.$$store.user[name], ';');
        } else if(variant === "setThemed"){

          code.push('this.', this.$$store.theme[name], '=value;');
        } else if(variant === "resetThemed"){

          code.push('delete this.', this.$$store.theme[name], ';');
        } else if(variant === "init" && incomingValue){

          code.push('this.', this.$$store.init[name], '=value;');
        };;;;
      };
      code.push('}');
      code.push('else if(this.', this.$$store.user[name], '!==undefined){');
      if(variant === "set"){

        if(!config.inheritable){

          code.push('old=this.', this.$$store.user[name], ';');
        };
        code.push('computed=this.', this.$$store.user[name], '=value;');
      } else if(variant === "reset"){

        if(!config.inheritable){

          code.push('old=this.', this.$$store.user[name], ';');
        };
        code.push('delete this.', this.$$store.user[name], ';');
        code.push('if(this.', this.$$store.runtime[name], '!==undefined)');
        code.push('computed=this.', this.$$store.runtime[name], ';');
        code.push('if(this.', this.$$store.theme[name], '!==undefined)');
        code.push('computed=this.', this.$$store.theme[name], ';');
        code.push('else if(this.', this.$$store.init[name], '!==undefined){');
        code.push('computed=this.', this.$$store.init[name], ';');
        code.push('this.', this.$$store.useinit[name], '=true;');
        code.push('}');
      } else {

        if(variant === "setRuntime"){

          code.push('computed=this.', this.$$store.runtime[name], '=value;');
        } else if(config.inheritable){

          code.push('computed=this.', this.$$store.user[name], ';');
        } else {

          code.push('old=computed=this.', this.$$store.user[name], ';');
        };
        if(variant === "setThemed"){

          code.push('this.', this.$$store.theme[name], '=value;');
        } else if(variant === "resetThemed"){

          code.push('delete this.', this.$$store.theme[name], ';');
        } else if(variant === "init" && incomingValue){

          code.push('this.', this.$$store.init[name], '=value;');
        };;
      };
      code.push('}');
      if(config.themeable){

        code.push('else if(this.', this.$$store.theme[name], '!==undefined){');
        if(!config.inheritable){

          code.push('old=this.', this.$$store.theme[name], ';');
        };
        if(variant === "setRuntime"){

          code.push('computed=this.', this.$$store.runtime[name], '=value;');
        } else if(variant === "set"){

          code.push('computed=this.', this.$$store.user[name], '=value;');
        } else if(variant === "setThemed"){

          code.push('computed=this.', this.$$store.theme[name], '=value;');
        } else if(variant === "resetThemed"){

          code.push('delete this.', this.$$store.theme[name], ';');
          code.push('if(this.', this.$$store.init[name], '!==undefined){');
          code.push('computed=this.', this.$$store.init[name], ';');
          code.push('this.', this.$$store.useinit[name], '=true;');
          code.push('}');
        } else if(variant === "init"){

          if(incomingValue){

            code.push('this.', this.$$store.init[name], '=value;');
          };
          code.push('computed=this.', this.$$store.theme[name], ';');
        } else if(variant === "refresh"){

          code.push('computed=this.', this.$$store.theme[name], ';');
        };;;;;
        code.push('}');
      };
      code.push('else if(this.', this.$$store.useinit[name], '){');
      if(!config.inheritable){

        code.push('old=this.', this.$$store.init[name], ';');
      };
      if(variant === "init"){

        if(incomingValue){

          code.push('computed=this.', this.$$store.init[name], '=value;');
        } else {

          code.push('computed=this.', this.$$store.init[name], ';');
        };
      } else if(variant === "set" || variant === "setRuntime" || variant === "setThemed" || variant === "refresh"){

        code.push('delete this.', this.$$store.useinit[name], ';');
        if(variant === "setRuntime"){

          code.push('computed=this.', this.$$store.runtime[name], '=value;');
        } else if(variant === "set"){

          code.push('computed=this.', this.$$store.user[name], '=value;');
        } else if(variant === "setThemed"){

          code.push('computed=this.', this.$$store.theme[name], '=value;');
        } else if(variant === "refresh"){

          code.push('computed=this.', this.$$store.init[name], ';');
        };;;
      };
      code.push('}');
      if(variant === "set" || variant === "setRuntime" || variant === "setThemed" || variant === "init"){

        code.push('else{');
        if(variant === "setRuntime"){

          code.push('computed=this.', this.$$store.runtime[name], '=value;');
        } else if(variant === "set"){

          code.push('computed=this.', this.$$store.user[name], '=value;');
        } else if(variant === "setThemed"){

          code.push('computed=this.', this.$$store.theme[name], '=value;');
        } else if(variant === "init"){

          if(incomingValue){

            code.push('computed=this.', this.$$store.init[name], '=value;');
          } else {

            code.push('computed=this.', this.$$store.init[name], ';');
          };
          code.push('this.', this.$$store.useinit[name], '=true;');
        };;;
        code.push('}');
      };
    },
    __emitStoreInheritedPropertyValue : function(code, config, name, variant){

      code.push('if(computed===undefined||computed===inherit){');
      if(variant === "refresh"){

        code.push('computed=value;');
      } else {

        code.push('var pa=this.getLayoutParent();if(pa)computed=pa.', this.$$store.inherit[name], ';');
      };
      code.push('if((computed===undefined||computed===inherit)&&');
      code.push('this.', this.$$store.init[name], '!==undefined&&');
      code.push('this.', this.$$store.init[name], '!==inherit){');
      code.push('computed=this.', this.$$store.init[name], ';');
      code.push('this.', this.$$store.useinit[name], '=true;');
      code.push('}else{');
      code.push('delete this.', this.$$store.useinit[name], ';}');
      code.push('}');
      code.push('if(old===computed)return value;');
      code.push('if(computed===inherit){');
      code.push('computed=undefined;delete this.', this.$$store.inherit[name], ';');
      code.push('}');
      code.push('else if(computed===undefined)');
      code.push('delete this.', this.$$store.inherit[name], ';');
      code.push('else this.', this.$$store.inherit[name], '=computed;');
      code.push('var backup=computed;');
      if(config.init !== undefined && variant !== "init"){

        code.push('if(old===undefined)old=this.', this.$$store.init[name], ";");
      } else {

        code.push('if(old===undefined)old=null;');
      };
      code.push('if(computed===undefined||computed==inherit)computed=null;');
    },
    __emitNormalizeUndefinedValues : function(code, config, name, variant){

      if(variant !== "set" && variant !== "setRuntime" && variant !== "setThemed"){

        code.push('if(computed===undefined)computed=null;');
      };
      code.push('if(old===computed)return value;');
      if(config.init !== undefined && variant !== "init"){

        code.push('if(old===undefined)old=this.', this.$$store.init[name], ";");
      } else {

        code.push('if(old===undefined)old=null;');
      };
    },
    __emitCallCallback : function(code, config, name, variant){

      if(config.apply){

        code.push('this.', config.apply, '(computed, old, "', name, '", "', variant, '");');
      };
      if(config.event){

        code.push("var reg=qx.event.Registration;", "if(reg.hasListener(this, '", config.event, "')){", "reg.fireEvent(this, '", config.event, "', qx.event.type.Data, [computed, old]", ")}");
      };
    },
    __emitRefreshChildrenValue : function(code, name){

      code.push('var a=this._getChildren();if(a)for(var i=0,l=a.length;i<l;i++){');
      code.push('if(a[i].', this.$$method.refresh[name], ')a[i].', this.$$method.refresh[name], '(backup);');
      code.push('}');
    }
  }
});

qx.Bootstrap.define("qx.Class", {
  statics : {
    __Property : qx.core.Environment.get("module.property") ? qx.core.Property : null,
    define : function(name, config){

      if(!config){

        config = {
        };
      };
      if(config.include && !(qx.Bootstrap.getClass(config.include) === "Array")){

        config.include = [config.include];
      };
      if(config.implement && !(qx.Bootstrap.getClass(config.implement) === "Array")){

        config.implement = [config.implement];
      };
      var implicitType = false;
      if(!config.hasOwnProperty("extend") && !config.type){

        config.type = "static";
        implicitType = true;
      };
      if(qx.core.Environment.get("qx.debug")){

        try{

          this.__validateConfig(name, config);
        } catch(ex) {

          if(implicitType){

            ex.message = 'Assumed static class because no "extend" key was found. ' + ex.message;
          };
          throw ex;
        };
      };
      var clazz = this.__createClass(name, config.type, config.extend, config.statics, config.construct, config.destruct, config.include);
      if(config.extend){

        if(config.properties){

          this.__addProperties(clazz, config.properties, true);
        };
        if(config.members){

          this.__addMembers(clazz, config.members, true, true, false);
        };
        if(config.events){

          this.__addEvents(clazz, config.events, true);
        };
        if(config.include){

          for(var i = 0,l = config.include.length;i < l;i++){

            this.__addMixin(clazz, config.include[i], false);
          };
        };
      } else if(config.hasOwnProperty('extend') && qx.core.Environment.get("qx.debug")){

        throw new Error('"extend" parameter is null or undefined');
      };
      if(config.environment){

        for(var key in config.environment){

          qx.core.Environment.add(key, config.environment[key]);
        };
      };
      if(config.implement){

        for(var i = 0,l = config.implement.length;i < l;i++){

          this.__addInterface(clazz, config.implement[i]);
        };
      };
      if(qx.core.Environment.get("qx.debug")){

        this.__validateAbstractInterfaces(clazz);
      };
      if(config.defer){

        config.defer.self = clazz;
        config.defer(clazz, clazz.prototype, {
          add : function(name, config){

            var properties = {
            };
            properties[name] = config;
            qx.Class.__addProperties(clazz, properties, true);
          }
        });
      };
      return clazz;
    },
    undefine : function(name){

      delete this.$$registry[name];
      var ns = name.split(".");
      var objects = [window];
      for(var i = 0;i < ns.length;i++){

        objects.push(objects[i][ns[i]]);
      };
      for(var i = objects.length - 1;i >= 1;i--){

        var last = objects[i];
        var parent = objects[i - 1];
        if(qx.Bootstrap.isFunction(last) || qx.Bootstrap.objectGetLength(last) === 0){

          delete parent[ns[i - 1]];
        } else {

          break;
        };
      };
    },
    isDefined : qx.util.OOUtil.classIsDefined,
    getTotalNumber : function(){

      return qx.Bootstrap.objectGetLength(this.$$registry);
    },
    getByName : qx.Bootstrap.getByName,
    include : function(clazz, mixin){

      if(qx.core.Environment.get("qx.debug")){

        if(!mixin){

          throw new Error("The mixin to include into class '" + clazz.classname + "' is undefined/null!");
        };
        qx.Mixin.isCompatible(mixin, clazz);
      };
      qx.Class.__addMixin(clazz, mixin, false);
    },
    patch : function(clazz, mixin){

      if(qx.core.Environment.get("qx.debug")){

        if(!mixin){

          throw new Error("The mixin to patch class '" + clazz.classname + "' is undefined/null!");
        };
        qx.Mixin.isCompatible(mixin, clazz);
      };
      qx.Class.__addMixin(clazz, mixin, true);
    },
    isSubClassOf : function(clazz, superClass){

      if(!clazz){

        return false;
      };
      if(clazz == superClass){

        return true;
      };
      if(clazz.prototype instanceof superClass){

        return true;
      };
      return false;
    },
    getPropertyDefinition : qx.util.OOUtil.getPropertyDefinition,
    getProperties : function(clazz){

      var list = [];
      while(clazz){

        if(clazz.$$properties){

          list.push.apply(list, Object.keys(clazz.$$properties));
        };
        clazz = clazz.superclass;
      };
      return list;
    },
    getByProperty : function(clazz, name){

      while(clazz){

        if(clazz.$$properties && clazz.$$properties[name]){

          return clazz;
        };
        clazz = clazz.superclass;
      };
      return null;
    },
    hasProperty : qx.util.OOUtil.hasProperty,
    getEventType : qx.util.OOUtil.getEventType,
    supportsEvent : qx.util.OOUtil.supportsEvent,
    hasOwnMixin : function(clazz, mixin){

      return clazz.$$includes && clazz.$$includes.indexOf(mixin) !== -1;
    },
    getByMixin : function(clazz, mixin){

      var list,i,l;
      while(clazz){

        if(clazz.$$includes){

          list = clazz.$$flatIncludes;
          for(i = 0,l = list.length;i < l;i++){

            if(list[i] === mixin){

              return clazz;
            };
          };
        };
        clazz = clazz.superclass;
      };
      return null;
    },
    getMixins : qx.util.OOUtil.getMixins,
    hasMixin : function(clazz, mixin){

      return !!this.getByMixin(clazz, mixin);
    },
    hasOwnInterface : function(clazz, iface){

      return clazz.$$implements && clazz.$$implements.indexOf(iface) !== -1;
    },
    getByInterface : qx.util.OOUtil.getByInterface,
    getInterfaces : function(clazz){

      var list = [];
      while(clazz){

        if(clazz.$$implements){

          list.push.apply(list, clazz.$$flatImplements);
        };
        clazz = clazz.superclass;
      };
      return list;
    },
    hasInterface : qx.util.OOUtil.hasInterface,
    implementsInterface : function(obj, iface){

      var clazz = obj.constructor;
      if(this.hasInterface(clazz, iface)){

        return true;
      };
      if(qx.Interface.objectImplements(obj, iface)){

        return true;
      };
      if(qx.Interface.classImplements(clazz, iface)){

        return true;
      };
      return false;
    },
    getInstance : function(){

      if(!this.$$instance){

        this.$$allowconstruct = true;
        this.$$instance = new this();
        delete this.$$allowconstruct;
      };
      return this.$$instance;
    },
    genericToString : function(){

      return "[Class " + this.classname + "]";
    },
    $$registry : qx.Bootstrap.$$registry,
    __allowedKeys : qx.core.Environment.select("qx.debug", {
      "true" : {
        "type" : "string",
        "extend" : "function",
        "implement" : "object",
        "include" : "object",
        "construct" : "function",
        "statics" : "object",
        "properties" : "object",
        "members" : "object",
        "environment" : "object",
        "events" : "object",
        "defer" : "function",
        "destruct" : "function"
      },
      "default" : null
    }),
    __staticAllowedKeys : qx.core.Environment.select("qx.debug", {
      "true" : {
        "type" : "string",
        "statics" : "object",
        "environment" : "object",
        "defer" : "function"
      },
      "default" : null
    }),
    __validateConfig : qx.core.Environment.select("qx.debug", {
      "true" : function(name, config){

        if(config.type && !(config.type === "static" || config.type === "abstract" || config.type === "singleton")){

          throw new Error('Invalid type "' + config.type + '" definition for class "' + name + '"!');
        };
        if(config.type && config.type !== "static" && !config.extend){

          throw new Error('Invalid config in class "' + name + '"! Every non-static class has to extend at least the "qx.core.Object" class.');
        };
        var allowed = config.type === "static" ? this.__staticAllowedKeys : this.__allowedKeys;
        for(var key in config){

          if(!allowed[key]){

            throw new Error('The configuration key "' + key + '" in class "' + name + '" is not allowed!');
          };
          if(config[key] == null){

            throw new Error('Invalid key "' + key + '" in class "' + name + '"! The value is undefined/null!');
          };
          if(typeof config[key] !== allowed[key]){

            throw new Error('Invalid type of key "' + key + '" in class "' + name + '"! The type of the key must be "' + allowed[key] + '"!');
          };
        };
        var maps = ["statics", "properties", "members", "environment", "settings", "variants", "events"];
        for(var i = 0,l = maps.length;i < l;i++){

          var key = maps[i];
          if(config[key] !== undefined && (config[key].$$hash !== undefined || !qx.Bootstrap.isObject(config[key]))){

            throw new Error('Invalid key "' + key + '" in class "' + name + '"! The value needs to be a map!');
          };
        };
        if(config.include){

          if(qx.Bootstrap.getClass(config.include) === "Array"){

            for(var i = 0,a = config.include,l = a.length;i < l;i++){

              if(a[i] == null || a[i].$$type !== "Mixin"){

                throw new Error('The include definition in class "' + name + '" contains an invalid mixin at position ' + i + ': ' + a[i]);
              };
            };
          } else {

            throw new Error('Invalid include definition in class "' + name + '"! Only mixins and arrays of mixins are allowed!');
          };
        };
        if(config.implement){

          if(qx.Bootstrap.getClass(config.implement) === "Array"){

            for(var i = 0,a = config.implement,l = a.length;i < l;i++){

              if(a[i] == null || a[i].$$type !== "Interface"){

                throw new Error('The implement definition in class "' + name + '" contains an invalid interface at position ' + i + ': ' + a[i]);
              };
            };
          } else {

            throw new Error('Invalid implement definition in class "' + name + '"! Only interfaces and arrays of interfaces are allowed!');
          };
        };
        if(config.include){

          try{

            qx.Mixin.checkCompatibility(config.include);
          } catch(ex) {

            throw new Error('Error in include definition of class "' + name + '"! ' + ex.message);
          };
        };
        if(config.environment){

          for(var key in config.environment){

            if(key.substr(0, key.indexOf(".")) != name.substr(0, name.indexOf("."))){

              throw new Error('Forbidden environment setting "' + key + '" found in "' + name + '". It is forbidden to define a ' + 'environment setting for an external namespace!');
            };
          };
        };
        if(config.settings){

          for(var key in config.settings){

            if(key.substr(0, key.indexOf(".")) != name.substr(0, name.indexOf("."))){

              throw new Error('Forbidden setting "' + key + '" found in "' + name + '". It is forbidden to define a default setting for an external namespace!');
            };
          };
        };
        if(config.variants){

          for(var key in config.variants){

            if(key.substr(0, key.indexOf(".")) != name.substr(0, name.indexOf("."))){

              throw new Error('Forbidden variant "' + key + '" found in "' + name + '". It is forbidden to define a variant for an external namespace!');
            };
          };
        };
      },
      "default" : function(name, config){
      }
    }),
    __validateAbstractInterfaces : qx.core.Environment.select("qx.debug", {
      "true" : function(clazz){

        var superclass = clazz.superclass;
        while(superclass){

          if(superclass.$$classtype !== "abstract"){

            break;
          };
          var interfaces = superclass.$$implements;
          if(interfaces){

            for(var i = 0;i < interfaces.length;i++){

              qx.Interface.assert(clazz, interfaces[i], true);
            };
          };
          superclass = superclass.superclass;
        };
      },
      "default" : function(clazz){
      }
    }),
    __createClass : function(name, type, extend, statics, construct, destruct, mixins){

      var clazz;
      if(!extend && qx.core.Environment.get("qx.aspects") == false){

        clazz = statics || {
        };
        qx.Bootstrap.setDisplayNames(clazz, name);
      } else {

        clazz = {
        };
        if(extend){

          if(!construct){

            construct = this.__createDefaultConstructor();
          };
          if(this.__needsConstructorWrapper(extend, mixins)){

            clazz = this.__wrapConstructor(construct, name, type);
          } else {

            clazz = construct;
          };
          if(type === "singleton"){

            clazz.getInstance = this.getInstance;
          };
          qx.Bootstrap.setDisplayName(construct, name, "constructor");
        };
        if(statics){

          qx.Bootstrap.setDisplayNames(statics, name);
          var key;
          for(var i = 0,a = Object.keys(statics),l = a.length;i < l;i++){

            key = a[i];
            var staticValue = statics[key];
            if(qx.core.Environment.get("qx.aspects")){

              if(staticValue instanceof Function){

                staticValue = qx.core.Aspect.wrap(name + "." + key, staticValue, "static");
              };
              clazz[key] = staticValue;
            } else {

              clazz[key] = staticValue;
            };
          };
        };
      };
      var basename = name ? qx.Bootstrap.createNamespace(name, clazz) : "";
      clazz.name = clazz.classname = name;
      clazz.basename = basename;
      clazz.$$type = "Class";
      if(type){

        clazz.$$classtype = type;
      };
      if(!clazz.hasOwnProperty("toString")){

        clazz.toString = this.genericToString;
      };
      if(extend){

        qx.Bootstrap.extendClass(clazz, construct, extend, name, basename);
        if(destruct){

          if(qx.core.Environment.get("qx.aspects")){

            destruct = qx.core.Aspect.wrap(name, destruct, "destructor");
          };
          clazz.$$destructor = destruct;
          qx.Bootstrap.setDisplayName(destruct, name, "destruct");
        };
      };
      this.$$registry[name] = clazz;
      return clazz;
    },
    __addEvents : function(clazz, events, patch){

      if(qx.core.Environment.get("qx.debug")){

        if(typeof events !== "object" || qx.Bootstrap.getClass(events) === "Array"){

          throw new Error(clazz.classname + ": the events must be defined as map!");
        };
        for(var key in events){

          if(typeof events[key] !== "string"){

            throw new Error(clazz.classname + "/" + key + ": the event value needs to be a string with the class name of the event object which will be fired.");
          };
        };
        if(clazz.$$events && patch !== true){

          for(var key in events){

            if(clazz.$$events[key] !== undefined && clazz.$$events[key] !== events[key]){

              throw new Error(clazz.classname + "/" + key + ": the event value/type cannot be changed from " + clazz.$$events[key] + " to " + events[key]);
            };
          };
        };
      };
      if(clazz.$$events){

        for(var key in events){

          clazz.$$events[key] = events[key];
        };
      } else {

        clazz.$$events = events;
      };
    },
    __addProperties : function(clazz, properties, patch){

      if(!qx.core.Environment.get("module.property")){

        throw new Error("Property module disabled.");
      };
      var config;
      if(patch === undefined){

        patch = false;
      };
      var proto = clazz.prototype;
      for(var name in properties){

        config = properties[name];
        if(qx.core.Environment.get("qx.debug")){

          this.__validateProperty(clazz, name, config, patch);
        };
        config.name = name;
        if(!config.refine){

          if(clazz.$$properties === undefined){

            clazz.$$properties = {
            };
          };
          clazz.$$properties[name] = config;
        };
        if(config.init !== undefined){

          clazz.prototype["$$init_" + name] = config.init;
        };
        if(config.event !== undefined){

          if(!qx.core.Environment.get("module.events")){

            throw new Error("Events module not enabled.");
          };
          var event = {
          };
          event[config.event] = "qx.event.type.Data";
          this.__addEvents(clazz, event, patch);
        };
        if(config.inheritable){

          this.__Property.$$inheritable[name] = true;
          if(!proto.$$refreshInheritables){

            this.__Property.attachRefreshInheritables(clazz);
          };
        };
        if(!config.refine){

          this.__Property.attachMethods(clazz, name, config);
        };
      };
    },
    __validateProperty : qx.core.Environment.select("qx.debug", {
      "true" : function(clazz, name, config, patch){

        if(!qx.core.Environment.get("module.property")){

          throw new Error("Property module disabled.");
        };
        var has = this.hasProperty(clazz, name);
        if(has){

          var existingProperty = this.getPropertyDefinition(clazz, name);
          if(config.refine && existingProperty.init === undefined){

            throw new Error("Could not refine an init value if there was previously no init value defined. Property '" + name + "' of class '" + clazz.classname + "'.");
          };
        };
        if(!has && config.refine){

          throw new Error("Could not refine non-existent property: '" + name + "' of class: '" + clazz.classname + "'!");
        };
        if(has && !patch){

          throw new Error("Class " + clazz.classname + " already has a property: " + name + "!");
        };
        if(has && patch){

          if(!config.refine){

            throw new Error('Could not refine property "' + name + '" without a "refine" flag in the property definition! This class: ' + clazz.classname + ', original class: ' + this.getByProperty(clazz, name).classname + '.');
          };
          for(var key in config){

            if(key !== "init" && key !== "refine"){

              throw new Error("Class " + clazz.classname + " could not refine property: " + name + "! Key: " + key + " could not be refined!");
            };
          };
        };
        var allowed = config.group ? this.__Property.$$allowedGroupKeys : this.__Property.$$allowedKeys;
        for(var key in config){

          if(allowed[key] === undefined){

            throw new Error('The configuration key "' + key + '" of property "' + name + '" in class "' + clazz.classname + '" is not allowed!');
          };
          if(config[key] === undefined){

            throw new Error('Invalid key "' + key + '" of property "' + name + '" in class "' + clazz.classname + '"! The value is undefined: ' + config[key]);
          };
          if(allowed[key] !== null && typeof config[key] !== allowed[key]){

            throw new Error('Invalid type of key "' + key + '" of property "' + name + '" in class "' + clazz.classname + '"! The type of the key must be "' + allowed[key] + '"!');
          };
        };
        if(config.transform != null){

          if(!(typeof config.transform == "string")){

            throw new Error('Invalid transform definition of property "' + name + '" in class "' + clazz.classname + '"! Needs to be a String.');
          };
        };
        if(config.check != null){

          if(!qx.Bootstrap.isString(config.check) && !qx.Bootstrap.isArray(config.check) && !qx.Bootstrap.isFunction(config.check)){

            throw new Error('Invalid check definition of property "' + name + '" in class "' + clazz.classname + '"! Needs to be a String, Array or Function.');
          };
        };
      },
      "default" : null
    }),
    __addMembers : function(clazz, members, patch, base, wrap){

      var proto = clazz.prototype;
      var key,member;
      qx.Bootstrap.setDisplayNames(members, clazz.classname + ".prototype");
      for(var i = 0,a = Object.keys(members),l = a.length;i < l;i++){

        key = a[i];
        member = members[key];
        if(qx.core.Environment.get("qx.debug")){

          if(proto[key] !== undefined && key.charAt(0) == "_" && key.charAt(1) == "_"){

            throw new Error('Overwriting private member "' + key + '" of Class "' + clazz.classname + '" is not allowed!');
          };
          if(patch !== true && proto.hasOwnProperty(key)){

            throw new Error('Overwriting member "' + key + '" of Class "' + clazz.classname + '" is not allowed!');
          };
          if(proto[key] != undefined && proto[key].$$propertyMethod){

            throw new Error('Overwriting generated property method "' + key + '" of Class "' + clazz.classname + '" is not allowed!');
          };
        };
        if(base !== false && member instanceof Function && member.$$type == null){

          if(wrap == true){

            member = this.__mixinMemberWrapper(member, proto[key]);
          } else {

            if(proto[key]){

              member.base = proto[key];
            };
            member.self = clazz;
          };
          if(qx.core.Environment.get("qx.aspects")){

            member = qx.core.Aspect.wrap(clazz.classname + "." + key, member, "member");
          };
        };
        proto[key] = member;
      };
    },
    __mixinMemberWrapper : function(member, base){

      if(base){

        return function(){

          var oldBase = member.base;
          member.base = base;
          var retval = member.apply(this, arguments);
          member.base = oldBase;
          return retval;
        };
      } else {

        return member;
      };
    },
    __addInterface : function(clazz, iface){

      if(qx.core.Environment.get("qx.debug")){

        if(!clazz || !iface){

          throw new Error("Incomplete parameters!");
        };
        if(this.hasOwnInterface(clazz, iface)){

          throw new Error('Interface "' + iface.name + '" is already used by Class "' + clazz.classname + '!');
        };
        if(clazz.$$classtype !== "abstract"){

          qx.Interface.assert(clazz, iface, true);
        };
      };
      var list = qx.Interface.flatten([iface]);
      if(clazz.$$implements){

        clazz.$$implements.push(iface);
        clazz.$$flatImplements.push.apply(clazz.$$flatImplements, list);
      } else {

        clazz.$$implements = [iface];
        clazz.$$flatImplements = list;
      };
    },
    __retrospectWrapConstruct : function(clazz){

      var name = clazz.classname;
      var wrapper = this.__wrapConstructor(clazz, name, clazz.$$classtype);
      for(var i = 0,a = Object.keys(clazz),l = a.length;i < l;i++){

        key = a[i];
        wrapper[key] = clazz[key];
      };
      wrapper.prototype = clazz.prototype;
      var members = clazz.prototype;
      for(var i = 0,a = Object.keys(members),l = a.length;i < l;i++){

        key = a[i];
        var method = members[key];
        if(method && method.self == clazz){

          method.self = wrapper;
        };
      };
      for(var key in this.$$registry){

        var construct = this.$$registry[key];
        if(!construct){

          continue;
        };
        if(construct.base == clazz){

          construct.base = wrapper;
        };
        if(construct.superclass == clazz){

          construct.superclass = wrapper;
        };
        if(construct.$$original){

          if(construct.$$original.base == clazz){

            construct.$$original.base = wrapper;
          };
          if(construct.$$original.superclass == clazz){

            construct.$$original.superclass = wrapper;
          };
        };
      };
      qx.Bootstrap.createNamespace(name, wrapper);
      this.$$registry[name] = wrapper;
      return wrapper;
    },
    __addMixin : function(clazz, mixin, patch){

      if(qx.core.Environment.get("qx.debug")){

        if(!clazz || !mixin){

          throw new Error("Incomplete parameters!");
        };
      };
      if(this.hasMixin(clazz, mixin)){

        return;
      };
      var isConstructorWrapped = clazz.$$original;
      if(mixin.$$constructor && !isConstructorWrapped){

        clazz = this.__retrospectWrapConstruct(clazz);
      };
      var list = qx.Mixin.flatten([mixin]);
      var entry;
      for(var i = 0,l = list.length;i < l;i++){

        entry = list[i];
        if(entry.$$events){

          this.__addEvents(clazz, entry.$$events, patch);
        };
        if(entry.$$properties){

          this.__addProperties(clazz, entry.$$properties, patch);
        };
        if(entry.$$members){

          this.__addMembers(clazz, entry.$$members, patch, patch, patch);
        };
      };
      if(clazz.$$includes){

        clazz.$$includes.push(mixin);
        clazz.$$flatIncludes.push.apply(clazz.$$flatIncludes, list);
      } else {

        clazz.$$includes = [mixin];
        clazz.$$flatIncludes = list;
      };
    },
    __createDefaultConstructor : function(){

      function defaultConstructor(){

        defaultConstructor.base.apply(this, arguments);
      };
      return defaultConstructor;
    },
    __createEmptyFunction : function(){

      return function(){
      };
    },
    __needsConstructorWrapper : function(base, mixins){

      if(qx.core.Environment.get("qx.debug")){

        return true;
      };
      if(base && base.$$includes){

        var baseMixins = base.$$flatIncludes;
        for(var i = 0,l = baseMixins.length;i < l;i++){

          if(baseMixins[i].$$constructor){

            return true;
          };
        };
      };
      if(mixins){

        var flatMixins = qx.Mixin.flatten(mixins);
        for(var i = 0,l = flatMixins.length;i < l;i++){

          if(flatMixins[i].$$constructor){

            return true;
          };
        };
      };
      return false;
    },
    __wrapConstructor : function(construct, name, type){

      var wrapper = function(){

        var clazz = wrapper;
        if(qx.core.Environment.get("qx.debug")){

          if(!(this instanceof clazz)){

            throw new Error("Please initialize '" + name + "' objects using the new keyword!");
          };
          if(type === "abstract"){

            if(this.classname === name){

              throw new Error("The class '," + name + "' is abstract! It is not possible to instantiate it.");
            };
          } else if(type === "singleton"){

            if(!clazz.$$allowconstruct){

              throw new Error("The class '" + name + "' is a singleton! It is not possible to instantiate it directly. Use the static getInstance() method instead.");
            };
          };
        };
        var retval = clazz.$$original.apply(this, arguments);
        if(clazz.$$includes){

          var mixins = clazz.$$flatIncludes;
          for(var i = 0,l = mixins.length;i < l;i++){

            if(mixins[i].$$constructor){

              mixins[i].$$constructor.apply(this, arguments);
            };
          };
        };
        if(qx.core.Environment.get("qx.debug")){

          if(this.classname === name){

            this.$$initialized = true;
          };
        };
        return retval;
      };
      if(qx.core.Environment.get("qx.aspects")){

        var aspectWrapper = qx.core.Aspect.wrap(name, wrapper, "constructor");
        wrapper.$$original = construct;
        wrapper.constructor = aspectWrapper;
        wrapper = aspectWrapper;
      };
      wrapper.$$original = construct;
      construct.wrapper = wrapper;
      return wrapper;
    }
  },
  defer : function(){

    if(qx.core.Environment.get("qx.aspects")){

      for(var classname in qx.Bootstrap.$$registry){

        var statics = qx.Bootstrap.$$registry[classname];
        for(var key in statics){

          if(statics[key] instanceof Function){

            statics[key] = qx.core.Aspect.wrap(classname + "." + key, statics[key], "static");
          };
        };
      };
    };
  }
});

qx.Mixin.define("qx.data.MBinding", {
  members : {
    bind : function(sourcePropertyChain, targetObject, targetProperty, options){

      return qx.data.SingleValueBinding.bind(this, sourcePropertyChain, targetObject, targetProperty, options);
    },
    removeBinding : function(id){

      qx.data.SingleValueBinding.removeBindingFromObject(this, id);
    },
    removeAllBindings : function(){

      qx.data.SingleValueBinding.removeAllBindingsForObject(this);
    },
    getBindings : function(){

      return qx.data.SingleValueBinding.getAllBindingsForObject(this);
    }
  }
});

qx.Class.define("qx.data.SingleValueBinding", {
  statics : {
    __bindings : {
    },
    bind : function(sourceObject, sourcePropertyChain, targetObject, targetPropertyChain, options){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert.assertObject(sourceObject, "sourceObject");
        qx.core.Assert.assertString(sourcePropertyChain, "sourcePropertyChain");
        qx.core.Assert.assertObject(targetObject, "targetObject");
        qx.core.Assert.assertString(targetPropertyChain, "targetPropertyChain");
      };
      var targetListenerMap = this.__setUpTargetBinding(sourceObject, sourcePropertyChain, targetObject, targetPropertyChain, options);
      var propertyNames = sourcePropertyChain.split(".");
      var arrayIndexValues = this.__checkForArrayInPropertyChain(propertyNames);
      var sources = [];
      var listeners = [];
      var listenerIds = [];
      var eventNames = [];
      var source = sourceObject;
      try{

        for(var i = 0;i < propertyNames.length;i++){

          if(arrayIndexValues[i] !== ""){

            eventNames.push("change");
          } else {

            eventNames.push(this.__getEventNameForProperty(source, propertyNames[i]));
          };
          sources[i] = source;
          if(i == propertyNames.length - 1){

            if(arrayIndexValues[i] !== ""){

              var itemIndex = arrayIndexValues[i] === "last" ? source.length - 1 : arrayIndexValues[i];
              var currentValue = source.getItem(itemIndex);
              this.__setInitialValue(currentValue, targetObject, targetPropertyChain, options, sourceObject);
              listenerIds[i] = this.__bindEventToProperty(source, eventNames[i], targetObject, targetPropertyChain, options, arrayIndexValues[i]);
            } else {

              if(propertyNames[i] != null && source["get" + qx.lang.String.firstUp(propertyNames[i])] != null){

                var currentValue = source["get" + qx.lang.String.firstUp(propertyNames[i])]();
                this.__setInitialValue(currentValue, targetObject, targetPropertyChain, options, sourceObject);
              };
              listenerIds[i] = this.__bindEventToProperty(source, eventNames[i], targetObject, targetPropertyChain, options);
            };
          } else {

            var context = {
              index : i,
              propertyNames : propertyNames,
              sources : sources,
              listenerIds : listenerIds,
              arrayIndexValues : arrayIndexValues,
              targetObject : targetObject,
              targetPropertyChain : targetPropertyChain,
              options : options,
              listeners : listeners
            };
            var listener = qx.lang.Function.bind(this.__chainListener, this, context);
            listeners.push(listener);
            listenerIds[i] = source.addListener(eventNames[i], listener);
          };
          if(source["get" + qx.lang.String.firstUp(propertyNames[i])] == null){

            source = undefined;
          } else if(arrayIndexValues[i] !== ""){

            var itemIndex = arrayIndexValues[i] === "last" ? source.length - 1 : arrayIndexValues[i];
            source = source["get" + qx.lang.String.firstUp(propertyNames[i])](itemIndex);
          } else {

            source = source["get" + qx.lang.String.firstUp(propertyNames[i])]();
            if(source === null && (propertyNames.length - 1) != i){

              source = undefined;
            };
          };
          if(!source){

            this.__setInitialValue(source, targetObject, targetPropertyChain, options, sourceObject);
            break;
          };
        };
      } catch(ex) {

        for(var i = 0;i < sources.length;i++){

          if(sources[i] && listenerIds[i]){

            sources[i].removeListenerById(listenerIds[i]);
          };
        };
        var targets = targetListenerMap.targets;
        var targetIds = targetListenerMap.listenerIds;
        for(var i = 0;i < targets.length;i++){

          if(targets[i] && targetIds[i]){

            targets[i].removeListenerById(targetIds[i]);
          };
        };
        throw ex;
      };
      var id = {
        type : "deepBinding",
        listenerIds : listenerIds,
        sources : sources,
        targetListenerIds : targetListenerMap.listenerIds,
        targets : targetListenerMap.targets
      };
      this.__storeBinding(id, sourceObject, sourcePropertyChain, targetObject, targetPropertyChain);
      return id;
    },
    __chainListener : function(context){

      if(context.options && context.options.onUpdate){

        context.options.onUpdate(context.sources[context.index], context.targetObject);
      };
      for(var j = context.index + 1;j < context.propertyNames.length;j++){

        var source = context.sources[j];
        context.sources[j] = null;
        if(!source){

          continue;
        };
        source.removeListenerById(context.listenerIds[j]);
      };
      var source = context.sources[context.index];
      for(var j = context.index + 1;j < context.propertyNames.length;j++){

        if(context.arrayIndexValues[j - 1] !== ""){

          source = source["get" + qx.lang.String.firstUp(context.propertyNames[j - 1])](context.arrayIndexValues[j - 1]);
        } else {

          source = source["get" + qx.lang.String.firstUp(context.propertyNames[j - 1])]();
        };
        context.sources[j] = source;
        if(!source){

          if(context.options && context.options.converter){

            var ignoreConverter = false;
            if(context.options.ignoreConverter){

              var currentSourceChain = context.propertyNames.slice(0, j).join(".");
              var match = currentSourceChain.match(new RegExp("^" + context.options.ignoreConverter));
              ignoreConverter = match ? match.length > 0 : false;
            };
            if(!ignoreConverter){

              this.__setTargetValue(context.targetObject, context.targetPropertyChain, context.options.converter());
            } else {

              this.__resetTargetValue(context.targetObject, context.targetPropertyChain);
            };
          } else {

            this.__resetTargetValue(context.targetObject, context.targetPropertyChain);
          };
          break;
        };
        if(j == context.propertyNames.length - 1){

          if(qx.Class.implementsInterface(source, qx.data.IListData)){

            var itemIndex = context.arrayIndexValues[j] === "last" ? source.length - 1 : context.arrayIndexValues[j];
            var currentValue = source.getItem(itemIndex);
            this.__setInitialValue(currentValue, context.targetObject, context.targetPropertyChain, context.options, context.sources[context.index]);
            context.listenerIds[j] = this.__bindEventToProperty(source, "change", context.targetObject, context.targetPropertyChain, context.options, context.arrayIndexValues[j]);
          } else {

            if(context.propertyNames[j] != null && source["get" + qx.lang.String.firstUp(context.propertyNames[j])] != null){

              var currentValue = source["get" + qx.lang.String.firstUp(context.propertyNames[j])]();
              this.__setInitialValue(currentValue, context.targetObject, context.targetPropertyChain, context.options, context.sources[context.index]);
            };
            var eventName = this.__getEventNameForProperty(source, context.propertyNames[j]);
            context.listenerIds[j] = this.__bindEventToProperty(source, eventName, context.targetObject, context.targetPropertyChain, context.options);
          };
        } else {

          if(context.listeners[j] == null){

            var listener = qx.lang.Function.bind(this.__chainListener, this, context);
            context.listeners.push(listener);
          };
          if(qx.Class.implementsInterface(source, qx.data.IListData)){

            var eventName = "change";
          } else {

            var eventName = this.__getEventNameForProperty(source, context.propertyNames[j]);
          };
          context.listenerIds[j] = source.addListener(eventName, context.listeners[j]);
        };
      };
    },
    __setUpTargetBinding : function(sourceObject, sourcePropertyChain, targetObject, targetPropertyChain, options){

      var propertyNames = targetPropertyChain.split(".");
      var arrayIndexValues = this.__checkForArrayInPropertyChain(propertyNames);
      var targets = [];
      var listeners = [];
      var listenerIds = [];
      var eventNames = [];
      var target = targetObject;
      for(var i = 0;i < propertyNames.length - 1;i++){

        if(arrayIndexValues[i] !== ""){

          eventNames.push("change");
        } else {

          try{

            eventNames.push(this.__getEventNameForProperty(target, propertyNames[i]));
          } catch(e) {

            break;
          };
        };
        targets[i] = target;
        var listener = function(){

          for(var j = i + 1;j < propertyNames.length - 1;j++){

            var target = targets[j];
            targets[j] = null;
            if(!target){

              continue;
            };
            target.removeListenerById(listenerIds[j]);
          };
          var target = targets[i];
          for(var j = i + 1;j < propertyNames.length - 1;j++){

            var firstUpPropName = qx.lang.String.firstUp(propertyNames[j - 1]);
            if(arrayIndexValues[j - 1] !== ""){

              var currentIndex = arrayIndexValues[j - 1] === "last" ? target.getLength() - 1 : arrayIndexValues[j - 1];
              target = target["get" + firstUpPropName](currentIndex);
            } else {

              target = target["get" + firstUpPropName]();
            };
            targets[j] = target;
            if(listeners[j] == null){

              listeners.push(listener);
            };
            if(qx.Class.implementsInterface(target, qx.data.IListData)){

              var eventName = "change";
            } else {

              try{

                var eventName = qx.data.SingleValueBinding.__getEventNameForProperty(target, propertyNames[j]);
              } catch(e) {

                break;
              };
            };
            listenerIds[j] = target.addListener(eventName, listeners[j]);
          };
          qx.data.SingleValueBinding.updateTarget(sourceObject, sourcePropertyChain, targetObject, targetPropertyChain, options);
        };
        listeners.push(listener);
        listenerIds[i] = target.addListener(eventNames[i], listener);
        var firstUpPropName = qx.lang.String.firstUp(propertyNames[i]);
        if(target["get" + firstUpPropName] == null){

          target = null;
        } else if(arrayIndexValues[i] !== ""){

          target = target["get" + firstUpPropName](arrayIndexValues[i]);
        } else {

          target = target["get" + firstUpPropName]();
        };
        if(!target){

          break;
        };
      };
      return {
        listenerIds : listenerIds,
        targets : targets
      };
    },
    updateTarget : function(sourceObject, sourcePropertyChain, targetObject, targetPropertyChain, options){

      var value = this.resolvePropertyChain(sourceObject, sourcePropertyChain);
      value = qx.data.SingleValueBinding.__convertValue(value, targetObject, targetPropertyChain, options, sourceObject);
      this.__setTargetValue(targetObject, targetPropertyChain, value);
    },
    resolvePropertyChain : function(o, propertyChain){

      var source = this.__getTargetFromChain(o, propertyChain);
      var value;
      if(source != null){

        var lastProperty = propertyChain.substring(propertyChain.lastIndexOf(".") + 1, propertyChain.length);
        if(lastProperty.charAt(lastProperty.length - 1) == "]"){

          var index = lastProperty.substring(lastProperty.lastIndexOf("[") + 1, lastProperty.length - 1);
          var prop = lastProperty.substring(0, lastProperty.lastIndexOf("["));
          var sourceArray = source["get" + qx.lang.String.firstUp(prop)]();
          if(index == "last"){

            index = sourceArray.length - 1;
          };
          if(sourceArray != null){

            value = sourceArray.getItem(index);
          };
        } else {

          value = source["get" + qx.lang.String.firstUp(lastProperty)]();
        };
      };
      return value;
    },
    __getEventNameForProperty : function(source, propertyname){

      var eventName = this.__getEventForProperty(source, propertyname);
      if(eventName == null){

        if(qx.Class.supportsEvent(source.constructor, propertyname)){

          eventName = propertyname;
        } else if(qx.Class.supportsEvent(source.constructor, "change" + qx.lang.String.firstUp(propertyname))){

          eventName = "change" + qx.lang.String.firstUp(propertyname);
        } else {

          throw new qx.core.AssertionError("Binding property " + propertyname + " of object " + source + " not possible: No event available. ");
        };
      };
      return eventName;
    },
    __resetTargetValue : function(targetObject, targetPropertyChain){

      var target = this.__getTargetFromChain(targetObject, targetPropertyChain);
      if(target != null){

        var lastProperty = targetPropertyChain.substring(targetPropertyChain.lastIndexOf(".") + 1, targetPropertyChain.length);
        if(lastProperty.charAt(lastProperty.length - 1) == "]"){

          this.__setTargetValue(targetObject, targetPropertyChain, null);
          return;
        };
        if(target["reset" + qx.lang.String.firstUp(lastProperty)] != undefined){

          target["reset" + qx.lang.String.firstUp(lastProperty)]();
        } else {

          target["set" + qx.lang.String.firstUp(lastProperty)](null);
        };
      };
    },
    __setTargetValue : function(targetObject, targetPropertyChain, value){

      var target = this.__getTargetFromChain(targetObject, targetPropertyChain);
      if(target != null){

        var lastProperty = targetPropertyChain.substring(targetPropertyChain.lastIndexOf(".") + 1, targetPropertyChain.length);
        if(lastProperty.charAt(lastProperty.length - 1) == "]"){

          var index = lastProperty.substring(lastProperty.lastIndexOf("[") + 1, lastProperty.length - 1);
          var prop = lastProperty.substring(0, lastProperty.lastIndexOf("["));
          var targetArray = targetObject;
          if(!qx.Class.implementsInterface(targetArray, qx.data.IListData)){

            targetArray = target["get" + qx.lang.String.firstUp(prop)]();
          };
          if(index == "last"){

            index = targetArray.length - 1;
          };
          if(targetArray != null){

            targetArray.setItem(index, value);
          };
        } else {

          target["set" + qx.lang.String.firstUp(lastProperty)](value);
        };
      };
    },
    __getTargetFromChain : function(targetObject, targetPropertyChain){

      var properties = targetPropertyChain.split(".");
      var target = targetObject;
      for(var i = 0;i < properties.length - 1;i++){

        try{

          var property = properties[i];
          if(property.indexOf("]") == property.length - 1){

            var index = property.substring(property.indexOf("[") + 1, property.length - 1);
            property = property.substring(0, property.indexOf("["));
          };
          if(property != ""){

            target = target["get" + qx.lang.String.firstUp(property)]();
          };
          if(index != null){

            if(index == "last"){

              index = target.length - 1;
            };
            target = target.getItem(index);
            index = null;
          };
        } catch(ex) {

          return null;
        };
      };
      return target;
    },
    __setInitialValue : function(value, targetObject, targetPropertyChain, options, sourceObject){

      value = this.__convertValue(value, targetObject, targetPropertyChain, options, sourceObject);
      if(value === undefined){

        this.__resetTargetValue(targetObject, targetPropertyChain);
      };
      if(value !== undefined){

        try{

          this.__setTargetValue(targetObject, targetPropertyChain, value);
          if(options && options.onUpdate){

            options.onUpdate(sourceObject, targetObject, value);
          };
        } catch(e) {

          if(!(e instanceof qx.core.ValidationError)){

            throw e;
          };
          if(options && options.onSetFail){

            options.onSetFail(e);
          } else {

            qx.log.Logger.warn("Failed so set value " + value + " on " + targetObject + ". Error message: " + e);
          };
        };
      };
    },
    __checkForArrayInPropertyChain : function(propertyNames){

      var arrayIndexValues = [];
      for(var i = 0;i < propertyNames.length;i++){

        var name = propertyNames[i];
        if(qx.lang.String.endsWith(name, "]")){

          var arrayIndex = name.substring(name.indexOf("[") + 1, name.indexOf("]"));
          if(name.indexOf("]") != name.length - 1){

            throw new Error("Please use only one array at a time: " + name + " does not work.");
          };
          if(arrayIndex !== "last"){

            if(arrayIndex == "" || isNaN(parseInt(arrayIndex, 10))){

              throw new Error("No number or 'last' value hast been given" + " in an array binding: " + name + " does not work.");
            };
          };
          if(name.indexOf("[") != 0){

            propertyNames[i] = name.substring(0, name.indexOf("["));
            arrayIndexValues[i] = "";
            arrayIndexValues[i + 1] = arrayIndex;
            propertyNames.splice(i + 1, 0, "item");
            i++;
          } else {

            arrayIndexValues[i] = arrayIndex;
            propertyNames.splice(i, 1, "item");
          };
        } else {

          arrayIndexValues[i] = "";
        };
      };
      return arrayIndexValues;
    },
    __bindEventToProperty : function(sourceObject, sourceEvent, targetObject, targetProperty, options, arrayIndex){

      if(qx.core.Environment.get("qx.debug")){

        var eventType = qx.Class.getEventType(sourceObject.constructor, sourceEvent);
        qx.core.Assert.assertEquals("qx.event.type.Data", eventType, sourceEvent + " is not an data (qx.event.type.Data) event on " + sourceObject + ".");
      };
      var bindListener = function(arrayIndex, e){

        if(arrayIndex !== ""){

          if(arrayIndex === "last"){

            arrayIndex = sourceObject.length - 1;
          };
          var data = sourceObject.getItem(arrayIndex);
          if(data === undefined){

            qx.data.SingleValueBinding.__resetTargetValue(targetObject, targetProperty);
          };
          var start = e.getData().start;
          var end = e.getData().end;
          if(arrayIndex < start || arrayIndex > end){

            return;
          };
        } else {

          var data = e.getData();
        };
        if(qx.core.Environment.get("qx.debug.databinding")){

          qx.log.Logger.debug("Binding executed from " + sourceObject + " by " + sourceEvent + " to " + targetObject + " (" + targetProperty + ")");
          qx.log.Logger.debug("Data before conversion: " + data);
        };
        data = qx.data.SingleValueBinding.__convertValue(data, targetObject, targetProperty, options, sourceObject);
        if(qx.core.Environment.get("qx.debug.databinding")){

          qx.log.Logger.debug("Data after conversion: " + data);
        };
        try{

          if(data !== undefined){

            qx.data.SingleValueBinding.__setTargetValue(targetObject, targetProperty, data);
          } else {

            qx.data.SingleValueBinding.__resetTargetValue(targetObject, targetProperty);
          };
          if(options && options.onUpdate){

            options.onUpdate(sourceObject, targetObject, data);
          };
        } catch(ex) {

          if(!(ex instanceof qx.core.ValidationError)){

            throw ex;
          };
          if(options && options.onSetFail){

            options.onSetFail(ex);
          } else {

            qx.log.Logger.warn("Failed so set value " + data + " on " + targetObject + ". Error message: " + ex);
          };
        };
      };
      if(!arrayIndex){

        arrayIndex = "";
      };
      bindListener = qx.lang.Function.bind(bindListener, sourceObject, arrayIndex);
      var id = sourceObject.addListener(sourceEvent, bindListener);
      return id;
    },
    __storeBinding : function(id, sourceObject, sourceEvent, targetObject, targetProperty){

      if(this.__bindings[sourceObject.toHashCode()] === undefined){

        this.__bindings[sourceObject.toHashCode()] = [];
      };
      this.__bindings[sourceObject.toHashCode()].push([id, sourceObject, sourceEvent, targetObject, targetProperty]);
    },
    __convertValue : function(value, targetObject, targetPropertyChain, options, sourceObject){

      if(options && options.converter){

        var model;
        if(targetObject.getModel){

          model = targetObject.getModel();
        };
        return options.converter(value, model, sourceObject, targetObject);
      } else {

        var target = this.__getTargetFromChain(targetObject, targetPropertyChain);
        var lastProperty = targetPropertyChain.substring(targetPropertyChain.lastIndexOf(".") + 1, targetPropertyChain.length);
        if(target == null){

          return value;
        };
        var propertieDefinition = qx.Class.getPropertyDefinition(target.constructor, lastProperty);
        var check = propertieDefinition == null ? "" : propertieDefinition.check;
        return this.__defaultConversion(value, check);
      };
    },
    __getEventForProperty : function(sourceObject, sourceProperty){

      var propertieDefinition = qx.Class.getPropertyDefinition(sourceObject.constructor, sourceProperty);
      if(propertieDefinition == null){

        return null;
      };
      return propertieDefinition.event;
    },
    __defaultConversion : function(data, targetCheck){

      var dataType = qx.lang.Type.getClass(data);
      if((dataType == "Number" || dataType == "String") && (targetCheck == "Integer" || targetCheck == "PositiveInteger")){

        data = parseInt(data, 10);
      };
      if((dataType == "Boolean" || dataType == "Number" || dataType == "Date") && targetCheck == "String"){

        data = data + "";
      };
      if((dataType == "Number" || dataType == "String") && (targetCheck == "Number" || targetCheck == "PositiveNumber")){

        data = parseFloat(data);
      };
      return data;
    },
    removeBindingFromObject : function(sourceObject, id){

      if(id.type == "deepBinding"){

        for(var i = 0;i < id.sources.length;i++){

          if(id.sources[i]){

            id.sources[i].removeListenerById(id.listenerIds[i]);
          };
        };
        for(var i = 0;i < id.targets.length;i++){

          if(id.targets[i]){

            id.targets[i].removeListenerById(id.targetListenerIds[i]);
          };
        };
      } else {

        sourceObject.removeListenerById(id);
      };
      var bindings = this.__bindings[sourceObject.toHashCode()];
      if(bindings != undefined){

        for(var i = 0;i < bindings.length;i++){

          if(bindings[i][0] == id){

            qx.lang.Array.remove(bindings, bindings[i]);
            return;
          };
        };
      };
      throw new Error("Binding could not be found!");
    },
    removeAllBindingsForObject : function(object){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert.assertNotNull(object, "Can not remove the bindings for null object!");
      };
      var bindings = this.__bindings[object.toHashCode()];
      if(bindings != undefined){

        for(var i = bindings.length - 1;i >= 0;i--){

          this.removeBindingFromObject(object, bindings[i][0]);
        };
      };
    },
    getAllBindingsForObject : function(object){

      if(this.__bindings[object.toHashCode()] === undefined){

        this.__bindings[object.toHashCode()] = [];
      };
      return this.__bindings[object.toHashCode()];
    },
    removeAllBindings : function(){

      for(var hash in this.__bindings){

        var object = qx.core.ObjectRegistry.fromHashCode(hash);
        if(object == null){

          delete this.__bindings[hash];
          continue;
        };
        this.removeAllBindingsForObject(object);
      };
      this.__bindings = {
      };
    },
    getAllBindings : function(){

      return this.__bindings;
    },
    showBindingInLog : function(object, id){

      var binding;
      for(var i = 0;i < this.__bindings[object.toHashCode()].length;i++){

        if(this.__bindings[object.toHashCode()][i][0] == id){

          binding = this.__bindings[object.toHashCode()][i];
          break;
        };
      };
      if(binding === undefined){

        var message = "Binding does not exist!";
      } else {

        var message = "Binding from '" + binding[1] + "' (" + binding[2] + ") to the object '" + binding[3] + "' (" + binding[4] + ").";
      };
      qx.log.Logger.debug(message);
    },
    showAllBindingsInLog : function(){

      for(var hash in this.__bindings){

        var object = qx.core.ObjectRegistry.fromHashCode(hash);
        for(var i = 0;i < this.__bindings[hash].length;i++){

          this.showBindingInLog(object, this.__bindings[hash][i][0]);
        };
      };
    }
  }
});

qx.Bootstrap.define("qx.lang.Type", {
  statics : {
    getClass : qx.Bootstrap.getClass,
    isString : qx.Bootstrap.isString,
    isArray : qx.Bootstrap.isArray,
    isObject : qx.Bootstrap.isObject,
    isFunction : qx.Bootstrap.isFunction,
    isRegExp : function(value){

      return this.getClass(value) == "RegExp";
    },
    isNumber : function(value){

      return (value !== null && (this.getClass(value) == "Number" || value instanceof Number));
    },
    isBoolean : function(value){

      return (value !== null && (this.getClass(value) == "Boolean" || value instanceof Boolean));
    },
    isDate : function(value){

      return (value !== null && (this.getClass(value) == "Date" || value instanceof Date));
    },
    isError : function(value){

      return (value !== null && (this.getClass(value) == "Error" || value instanceof Error));
    }
  }
});

qx.Class.define("qx.core.Assert", {
  statics : {
    __logError : true,
    __fail : function(comment, msgvarargs){

      var msg = "";
      for(var i = 1,l = arguments.length;i < l;i++){

        msg = msg + this.__toString(arguments[i] === undefined ? "'undefined'" : arguments[i]);
      };
      var fullComment = "";
      if(msg){

        fullComment = comment + ": " + msg;
      } else {

        fullComment = comment;
      };
      var errorMsg = "Assertion error! " + fullComment;
      if(qx.Class.isDefined("qx.core.AssertionError")){

        var err = new qx.core.AssertionError(comment, msg);
        if(this.__logError){

          qx.Bootstrap.error(errorMsg + "\n Stack trace: \n" + err.getStackTrace());
        };
        throw err;
      } else {

        if(this.__logError){

          qx.Bootstrap.error(errorMsg);
        };
        throw new Error(errorMsg);
      };
    },
    __toString : function(value){

      var stringValue;
      if(value === null){

        stringValue = "null";
      } else if(qx.lang.Type.isArray(value) && value.length > 10){

        stringValue = "Array[" + value.length + "]";
      } else if((value instanceof Object) && (value.toString == null)){

        stringValue = qx.lang.Json.stringify(value, null, 2);
      } else {

        try{

          stringValue = value.toString();
        } catch(e) {

          stringValue = "";
        };
      };;
      return stringValue;
    },
    assert : function(condition, msg){

      condition == true || this.__fail(msg || "", "Called assert with 'false'");
    },
    fail : function(msg, compact){

      var msgvarargs = compact ? "" : "Called fail().";
      this.__fail(msg || "", msgvarargs);
    },
    assertTrue : function(value, msg){

      (value === true) || this.__fail(msg || "", "Called assertTrue with '", value, "'");
    },
    assertFalse : function(value, msg){

      (value === false) || this.__fail(msg || "", "Called assertFalse with '", value, "'");
    },
    assertEquals : function(expected, found, msg){

      expected == found || this.__fail(msg || "", "Expected '", expected, "' but found '", found, "'!");
    },
    assertNotEquals : function(expected, found, msg){

      expected != found || this.__fail(msg || "", "Expected '", expected, "' to be not equal with '", found, "'!");
    },
    assertIdentical : function(expected, found, msg){

      expected === found || this.__fail(msg || "", "Expected '", expected, "' (identical) but found '", found, "'!");
    },
    assertNotIdentical : function(expected, found, msg){

      expected !== found || this.__fail(msg || "", "Expected '", expected, "' to be not identical with '", found, "'!");
    },
    assertNotUndefined : function(value, msg){

      value !== undefined || this.__fail(msg || "", "Expected value not to be undefined but found undefined!");
    },
    assertUndefined : function(value, msg){

      value === undefined || this.__fail(msg || "", "Expected value to be undefined but found ", value, "!");
    },
    assertNotNull : function(value, msg){

      value !== null || this.__fail(msg || "", "Expected value not to be null but found null!");
    },
    assertNull : function(value, msg){

      value === null || this.__fail(msg || "", "Expected value to be null but found ", value, "!");
    },
    assertJsonEquals : function(expected, found, msg){

      this.assertEquals(qx.lang.Json.stringify(expected), qx.lang.Json.stringify(found), msg);
    },
    assertMatch : function(str, re, msg){

      this.assertString(str);
      this.assert(qx.lang.Type.isRegExp(re) || qx.lang.Type.isString(re), "The parameter 're' must be a string or a regular expression.");
      str.search(re) >= 0 || this.__fail(msg || "", "The String '", str, "' does not match the regular expression '", re.toString(), "'!");
    },
    assertArgumentsCount : function(args, minCount, maxCount, msg){

      var argCount = args.length;
      (argCount >= minCount && argCount <= maxCount) || this.__fail(msg || "", "Wrong number of arguments given. Expected '", minCount, "' to '", maxCount, "' arguments but found '", argCount, "' arguments.");
    },
    assertEventFired : function(obj, event, invokeFunc, listenerFunc, msg){

      var called = false;
      var listener = function(e){

        if(listenerFunc){

          listenerFunc.call(obj, e);
        };
        called = true;
      };
      var id;
      try{

        id = obj.addListener(event, listener, obj);
        invokeFunc.call(obj);
      } catch(ex) {

        throw ex;
      }finally{

        try{

          obj.removeListenerById(id);
        } catch(ex) {
        };
      };
      called === true || this.__fail(msg || "", "Event (", event, ") not fired.");
    },
    assertEventNotFired : function(obj, event, invokeFunc, msg){

      var called = false;
      var listener = function(e){

        called = true;
      };
      var id = obj.addListener(event, listener, obj);
      invokeFunc.call();
      called === false || this.__fail(msg || "", "Event (", event, ") was fired.");
      obj.removeListenerById(id);
    },
    assertException : function(callback, exception, re, msg){

      var exception = exception || Error;
      var error;
      try{

        this.__logError = false;
        callback();
      } catch(ex) {

        error = ex;
      }finally{

        this.__logError = true;
      };
      if(error == null){

        this.__fail(msg || "", "The function did not raise an exception!");
      };
      error instanceof exception || this.__fail(msg || "", "The raised exception does not have the expected type! ", exception, " != ", error);
      if(re){

        this.assertMatch(error.toString(), re, msg);
      };
    },
    assertInArray : function(value, array, msg){

      array.indexOf(value) !== -1 || this.__fail(msg || "", "The value '", value, "' must have any of the values defined in the array '", array, "'");
    },
    assertArrayEquals : function(expected, found, msg){

      this.assertArray(expected, msg);
      this.assertArray(found, msg);
      msg = msg || "Expected [" + expected.join(", ") + "], but found [" + found.join(", ") + "]";
      if(expected.length !== found.length){

        this.fail(msg, true);
      };
      for(var i = 0;i < expected.length;i++){

        if(expected[i] !== found[i]){

          this.fail(msg, true);
        };
      };
    },
    assertKeyInMap : function(value, map, msg){

      map[value] !== undefined || this.__fail(msg || "", "The value '", value, "' must must be a key of the map '", map, "'");
    },
    assertFunction : function(value, msg){

      qx.lang.Type.isFunction(value) || this.__fail(msg || "", "Expected value to be typeof function but found ", value, "!");
    },
    assertString : function(value, msg){

      qx.lang.Type.isString(value) || this.__fail(msg || "", "Expected value to be a string but found ", value, "!");
    },
    assertBoolean : function(value, msg){

      qx.lang.Type.isBoolean(value) || this.__fail(msg || "", "Expected value to be a boolean but found ", value, "!");
    },
    assertNumber : function(value, msg){

      (qx.lang.Type.isNumber(value) && isFinite(value)) || this.__fail(msg || "", "Expected value to be a number but found ", value, "!");
    },
    assertPositiveNumber : function(value, msg){

      (qx.lang.Type.isNumber(value) && isFinite(value) && value >= 0) || this.__fail(msg || "", "Expected value to be a number >= 0 but found ", value, "!");
    },
    assertInteger : function(value, msg){

      (qx.lang.Type.isNumber(value) && isFinite(value) && value % 1 === 0) || this.__fail(msg || "", "Expected value to be an integer but found ", value, "!");
    },
    assertPositiveInteger : function(value, msg){

      var condition = (qx.lang.Type.isNumber(value) && isFinite(value) && value % 1 === 0 && value >= 0);
      condition || this.__fail(msg || "", "Expected value to be an integer >= 0 but found ", value, "!");
    },
    assertInRange : function(value, min, max, msg){

      (value >= min && value <= max) || this.__fail(msg || "", qx.lang.String.format("Expected value '%1' to be in the range '%2'..'%3'!", [value, min, max]));
    },
    assertObject : function(value, msg){

      var condition = value !== null && (qx.lang.Type.isObject(value) || typeof value === "object");
      condition || this.__fail(msg || "", "Expected value to be typeof object but found ", (value), "!");
    },
    assertArray : function(value, msg){

      qx.lang.Type.isArray(value) || this.__fail(msg || "", "Expected value to be an array but found ", value, "!");
    },
    assertMap : function(value, msg){

      qx.lang.Type.isObject(value) || this.__fail(msg || "", "Expected value to be a map but found ", value, "!");
    },
    assertRegExp : function(value, msg){

      qx.lang.Type.isRegExp(value) || this.__fail(msg || "", "Expected value to be a regular expression but found ", value, "!");
    },
    assertType : function(value, type, msg){

      this.assertString(type, "Invalid argument 'type'");
      typeof (value) === type || this.__fail(msg || "", "Expected value to be typeof '", type, "' but found ", value, "!");
    },
    assertInstance : function(value, clazz, msg){

      var className = clazz.classname || clazz + "";
      value instanceof clazz || this.__fail(msg || "", "Expected value to be instanceof '", className, "' but found ", value, "!");
    },
    assertInterface : function(value, iface, msg){

      qx.Class.implementsInterface(value, iface) || this.__fail(msg || "", "Expected object '", value, "' to implement the interface '", iface, "'!");
    },
    assertCssColor : function(expected, value, msg){

      var ColorUtil = qx.Class.getByName("qx.util.ColorUtil");
      if(!ColorUtil){

        throw new Error("qx.util.ColorUtil not available! Your code must have a dependency on 'qx.util.ColorUtil'");
      };
      var expectedRgb = ColorUtil.stringToRgb(expected);
      try{

        var valueRgb = ColorUtil.stringToRgb(value);
      } catch(ex) {

        this.__fail(msg || "", "Expected value to be the CSS color '", expected, "' (rgb(", expectedRgb.join(","), ")), but found value '", value, "', which cannot be converted to a CSS color!");
      };
      var condition = expectedRgb[0] == valueRgb[0] && expectedRgb[1] == valueRgb[1] && expectedRgb[2] == valueRgb[2];
      condition || this.__fail(msg || "", "Expected value to be the CSS color '", expectedRgb, "' (rgb(", expectedRgb.join(","), ")), but found value '", value, "' (rgb(", valueRgb.join(","), "))!");
    },
    assertElement : function(value, msg){

      !!(value && value.nodeType === 1) || this.__fail(msg || "", "Expected value to be a DOM element but found  '", value, "'!");
    },
    assertQxObject : function(value, msg){

      this.__isQxInstance(value, "qx.core.Object") || this.__fail(msg || "", "Expected value to be a qooxdoo object but found ", value, "!");
    },
    assertQxWidget : function(value, msg){

      this.__isQxInstance(value, "qx.ui.core.Widget") || this.__fail(msg || "", "Expected value to be a qooxdoo widget but found ", value, "!");
    },
    __isQxInstance : function(object, classname){

      if(!object){

        return false;
      };
      var clazz = object.constructor;
      while(clazz){

        if(clazz.classname === classname){

          return true;
        };
        clazz = clazz.superclass;
      };
      return false;
    }
  }
});

qx.Class.define("qx.type.BaseError", {
  extend : Error,
  construct : function(comment, failMessage){

    var inst = Error.call(this, failMessage);
    if(inst.stack){

      this.stack = inst.stack;
    };
    if(inst.stacktrace){

      this.stacktrace = inst.stacktrace;
    };
    this.__comment = comment || "";
    this.message = failMessage || qx.type.BaseError.DEFAULTMESSAGE;
  },
  statics : {
    DEFAULTMESSAGE : "error"
  },
  members : {
    __sTrace : null,
    __comment : null,
    message : null,
    getComment : function(){

      return this.__comment;
    },
    toString : function(){

      return this.__comment + (this.message ? ": " + this.message : "");
    }
  }
});

qx.Class.define("qx.core.AssertionError", {
  extend : qx.type.BaseError,
  construct : function(comment, failMessage){

    qx.type.BaseError.call(this, comment, failMessage);
    this.__trace = qx.dev.StackTrace.getStackTrace();
  },
  members : {
    __trace : null,
    getStackTrace : function(){

      return this.__trace;
    }
  }
});

qx.Bootstrap.define("qx.dev.StackTrace", {
  statics : {
    FILENAME_TO_CLASSNAME : null,
    FORMAT_STACKTRACE : null,
    getStackTrace : function(){

      var trace = [];
      try{

        throw new Error();
      } catch(ex) {

        if(qx.dev.StackTrace.hasEnvironmentCheck && qx.core.Environment.get("ecmascript.error.stacktrace")){

          var errorTrace = qx.dev.StackTrace.getStackTraceFromError(ex);
          var callerTrace = qx.dev.StackTrace.getStackTraceFromCaller(arguments);
          qx.lang.Array.removeAt(errorTrace, 0);
          trace = callerTrace.length > errorTrace.length ? callerTrace : errorTrace;
          for(var i = 0;i < Math.min(callerTrace.length, errorTrace.length);i++){

            var callerCall = callerTrace[i];
            if(callerCall.indexOf("anonymous") >= 0){

              continue;
            };
            var methodName = null;
            var callerArr = callerCall.split(".");
            var mO = /(.*?)\(/.exec(callerArr[callerArr.length - 1]);
            if(mO && mO.length == 2){

              methodName = mO[1];
              callerArr.pop();
            };
            if(callerArr[callerArr.length - 1] == "prototype"){

              callerArr.pop();
            };
            var callerClassName = callerArr.join(".");
            var errorCall = errorTrace[i];
            var errorArr = errorCall.split(":");
            var errorClassName = errorArr[0];
            var lineNumber = errorArr[1];
            var columnNumber;
            if(errorArr[2]){

              columnNumber = errorArr[2];
            };
            var className = null;
            if(qx.Class && qx.Class.getByName(errorClassName)){

              className = errorClassName;
            } else {

              className = callerClassName;
            };
            var line = className;
            if(methodName){

              line += "." + methodName;
            };
            line += ":" + lineNumber;
            if(columnNumber){

              line += ":" + columnNumber;
            };
            trace[i] = line;
          };
        } else {

          trace = this.getStackTraceFromCaller(arguments);
        };
      };
      return trace;
    },
    getStackTraceFromCaller : function(args){

      var trace = [];
      var fcn = qx.lang.Function.getCaller(args);
      var knownFunction = {
      };
      while(fcn){

        var fcnName = qx.lang.Function.getName(fcn);
        trace.push(fcnName);
        try{

          fcn = fcn.caller;
        } catch(ex) {

          break;
        };
        if(!fcn){

          break;
        };
        var hash = qx.core.ObjectRegistry.toHashCode(fcn);
        if(knownFunction[hash]){

          trace.push("...");
          break;
        };
        knownFunction[hash] = fcn;
      };
      return trace;
    },
    getStackTraceFromError : function(error){

      var trace = [];
      var lineRe,hit,className,lineNumber,columnNumber,fileName,url;
      var traceProp = qx.dev.StackTrace.hasEnvironmentCheck ? qx.core.Environment.get("ecmascript.error.stacktrace") : null;
      if(traceProp === "stack"){

        if(!error.stack){

          return trace;
        };
        lineRe = /@(.+):(\d+)$/gm;
        while((hit = lineRe.exec(error.stack)) != null){

          url = hit[1];
          lineNumber = hit[2];
          className = this.__fileNameToClassName(url);
          trace.push(className + ":" + lineNumber);
        };
        if(trace.length > 0){

          return this.__formatStackTrace(trace);
        };
        lineRe = /at (.*)/gm;
        var fileReParens = /\((.*?)(:[^\/].*)\)/;
        var fileRe = /(.*?)(:[^\/].*)/;
        while((hit = lineRe.exec(error.stack)) != null){

          var fileMatch = fileReParens.exec(hit[1]);
          if(!fileMatch){

            fileMatch = fileRe.exec(hit[1]);
          };
          if(fileMatch){

            className = this.__fileNameToClassName(fileMatch[1]);
            trace.push(className + fileMatch[2]);
          } else {

            trace.push(hit[1]);
          };
        };
      } else if(traceProp === "stacktrace"){

        var stacktrace = error.stacktrace;
        if(!stacktrace){

          return trace;
        };
        if(stacktrace.indexOf("Error created at") >= 0){

          stacktrace = stacktrace.split("Error created at")[0];
        };
        lineRe = /line\ (\d+?),\ column\ (\d+?)\ in\ (?:.*?)\ in\ (.*?):[^\/]/gm;
        while((hit = lineRe.exec(stacktrace)) != null){

          lineNumber = hit[1];
          columnNumber = hit[2];
          url = hit[3];
          className = this.__fileNameToClassName(url);
          trace.push(className + ":" + lineNumber + ":" + columnNumber);
        };
        if(trace.length > 0){

          return this.__formatStackTrace(trace);
        };
        lineRe = /Line\ (\d+?)\ of\ linked\ script\ (.*?)$/gm;
        while((hit = lineRe.exec(stacktrace)) != null){

          lineNumber = hit[1];
          url = hit[2];
          className = this.__fileNameToClassName(url);
          trace.push(className + ":" + lineNumber);
        };
      } else if(error.message && error.message.indexOf("Backtrace:") >= 0){

        var traceString = error.message.split("Backtrace:")[1].trim();
        var lines = traceString.split("\n");
        for(var i = 0;i < lines.length;i++){

          var reResult = lines[i].match(/\s*Line ([0-9]+) of.* (\S.*)/);
          if(reResult && reResult.length >= 2){

            lineNumber = reResult[1];
            fileName = this.__fileNameToClassName(reResult[2]);
            trace.push(fileName + ":" + lineNumber);
          };
        };
      } else if(error.sourceURL && error.line){

        trace.push(this.__fileNameToClassName(error.sourceURL) + ":" + error.line);
      };;;
      return this.__formatStackTrace(trace);
    },
    __fileNameToClassName : function(fileName){

      if(typeof qx.dev.StackTrace.FILENAME_TO_CLASSNAME == "function"){

        var convertedName = qx.dev.StackTrace.FILENAME_TO_CLASSNAME(fileName);
        if(qx.core.Environment.get("qx.debug") && !qx.lang.Type.isString(convertedName)){

          throw new Error("FILENAME_TO_CLASSNAME must return a string!");
        };
        return convertedName;
      };
      return qx.dev.StackTrace.__fileNameToClassNameDefault(fileName);
    },
    __fileNameToClassNameDefault : function(fileName){

      var scriptDir = "/source/class/";
      var jsPos = fileName.indexOf(scriptDir);
      var paramPos = fileName.indexOf("?");
      if(paramPos >= 0){

        fileName = fileName.substring(0, paramPos);
      };
      var className = (jsPos == -1) ? fileName : fileName.substring(jsPos + scriptDir.length).replace(/\//g, ".").replace(/\.js$/, "");
      return className;
    },
    __formatStackTrace : function(trace){

      if(typeof qx.dev.StackTrace.FORMAT_STACKTRACE == "function"){

        trace = qx.dev.StackTrace.FORMAT_STACKTRACE(trace);
        if(qx.core.Environment.get("qx.debug") && !qx.lang.Type.isArray(trace)){

          throw new Error("FORMAT_STACKTRACE must return an array of strings!");
        };
      };
      return trace;
    }
  },
  defer : function(statics){

    statics.hasEnvironmentCheck = qx.bom.client.EcmaScript && qx.bom.client.EcmaScript.getStackTrace;
  }
});

qx.Bootstrap.define("qx.lang.Array", {
  statics : {
    cast : function(object, constructor, offset){

      if(object.constructor === constructor){

        return object;
      };
      if(qx.data && qx.data.IListData){

        if(qx.Class && qx.Class.hasInterface(object, qx.data.IListData)){

          var object = object.toArray();
        };
      };
      var ret = new constructor;
      if((qx.core.Environment.get("engine.name") == "mshtml")){

        if(object.item){

          for(var i = offset || 0,l = object.length;i < l;i++){

            ret.push(object[i]);
          };
          return ret;
        };
      };
      if(Object.prototype.toString.call(object) === "[object Array]" && offset == null){

        ret.push.apply(ret, object);
      } else {

        ret.push.apply(ret, Array.prototype.slice.call(object, offset || 0));
      };
      return ret;
    },
    fromArguments : function(args, offset){

      return Array.prototype.slice.call(args, offset || 0);
    },
    fromCollection : function(coll){

      if((qx.core.Environment.get("engine.name") == "mshtml")){

        if(coll.item){

          var arr = [];
          for(var i = 0,l = coll.length;i < l;i++){

            arr[i] = coll[i];
          };
          return arr;
        };
      };
      return Array.prototype.slice.call(coll, 0);
    },
    fromShortHand : function(input){

      var len = input.length;
      var result = qx.lang.Array.clone(input);
      switch(len){case 1:
      result[1] = result[2] = result[3] = result[0];
      break;case 2:
      result[2] = result[0];case 3:
      result[3] = result[1];};
      return result;
    },
    clone : function(arr){

      return arr.concat();
    },
    insertAt : function(arr, obj, i){

      arr.splice(i, 0, obj);
      return arr;
    },
    insertBefore : function(arr, obj, obj2){

      var i = arr.indexOf(obj2);
      if(i == -1){

        arr.push(obj);
      } else {

        arr.splice(i, 0, obj);
      };
      return arr;
    },
    insertAfter : function(arr, obj, obj2){

      var i = arr.indexOf(obj2);
      if(i == -1 || i == (arr.length - 1)){

        arr.push(obj);
      } else {

        arr.splice(i + 1, 0, obj);
      };
      return arr;
    },
    removeAt : function(arr, i){

      return arr.splice(i, 1)[0];
    },
    removeAll : function(arr){

      arr.length = 0;
      return this;
    },
    append : function(arr1, arr2){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert && qx.core.Assert.assertArray(arr1, "The first parameter must be an array.");
        qx.core.Assert && qx.core.Assert.assertArray(arr2, "The second parameter must be an array.");
      };
      Array.prototype.push.apply(arr1, arr2);
      return arr1;
    },
    exclude : function(arr1, arr2){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert && qx.core.Assert.assertArray(arr1, "The first parameter must be an array.");
        qx.core.Assert && qx.core.Assert.assertArray(arr2, "The second parameter must be an array.");
      };
      for(var i = 0,il = arr2.length,index;i < il;i++){

        index = arr1.indexOf(arr2[i]);
        if(index != -1){

          arr1.splice(index, 1);
        };
      };
      return arr1;
    },
    remove : function(arr, obj){

      var i = arr.indexOf(obj);
      if(i != -1){

        arr.splice(i, 1);
        return obj;
      };
    },
    contains : function(arr, obj){

      return arr.indexOf(obj) !== -1;
    },
    equals : function(arr1, arr2){

      var length = arr1.length;
      if(length !== arr2.length){

        return false;
      };
      for(var i = 0;i < length;i++){

        if(arr1[i] !== arr2[i]){

          return false;
        };
      };
      return true;
    },
    sum : function(arr){

      var result = 0;
      for(var i = 0,l = arr.length;i < l;i++){

        if(arr[i] != undefined){

          result += arr[i];
        };
      };
      return result;
    },
    max : function(arr){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert && qx.core.Assert.assertArray(arr, "Parameter must be an array.");
      };
      var i,len = arr.length,result = arr[0];
      for(i = 1;i < len;i++){

        if(arr[i] > result){

          result = arr[i];
        };
      };
      return result === undefined ? null : result;
    },
    min : function(arr){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert && qx.core.Assert.assertArray(arr, "Parameter must be an array.");
      };
      var i,len = arr.length,result = arr[0];
      for(i = 1;i < len;i++){

        if(arr[i] < result){

          result = arr[i];
        };
      };
      return result === undefined ? null : result;
    },
    unique : function(arr){

      var ret = [],doneStrings = {
      },doneNumbers = {
      },doneObjects = {
      };
      var value,count = 0;
      var key = "qx" + Date.now();
      var hasNull = false,hasFalse = false,hasTrue = false;
      for(var i = 0,len = arr.length;i < len;i++){

        value = arr[i];
        if(value === null){

          if(!hasNull){

            hasNull = true;
            ret.push(value);
          };
        } else if(value === undefined){
        } else if(value === false){

          if(!hasFalse){

            hasFalse = true;
            ret.push(value);
          };
        } else if(value === true){

          if(!hasTrue){

            hasTrue = true;
            ret.push(value);
          };
        } else if(typeof value === "string"){

          if(!doneStrings[value]){

            doneStrings[value] = 1;
            ret.push(value);
          };
        } else if(typeof value === "number"){

          if(!doneNumbers[value]){

            doneNumbers[value] = 1;
            ret.push(value);
          };
        } else {

          var hash = value[key];
          if(hash == null){

            hash = value[key] = count++;
          };
          if(!doneObjects[hash]){

            doneObjects[hash] = value;
            ret.push(value);
          };
        };;;;;
      };
      for(var hash in doneObjects){

        try{

          delete doneObjects[hash][key];
        } catch(ex) {

          try{

            doneObjects[hash][key] = null;
          } catch(ex1) {

            throw new Error("Cannot clean-up map entry doneObjects[" + hash + "][" + key + "]");
          };
        };
      };
      return ret;
    }
  }
});

qx.Bootstrap.define("qx.bom.client.Engine", {
  statics : {
    getVersion : function(){

      var agent = window.navigator.userAgent;
      var version = "";
      if(qx.bom.client.Engine.__isOpera()){

        if(/Opera[\s\/]([0-9]+)\.([0-9])([0-9]*)/.test(agent)){

          if(agent.indexOf("Version/") != -1){

            var match = agent.match(/Version\/(\d+)\.(\d+)/);
            version = match[1] + "." + match[2].charAt(0) + "." + match[2].substring(1, match[2].length);
          } else {

            version = RegExp.$1 + "." + RegExp.$2;
            if(RegExp.$3 != ""){

              version += "." + RegExp.$3;
            };
          };
        };
      } else if(qx.bom.client.Engine.__isWebkit()){

        if(/AppleWebKit\/([^ ]+)/.test(agent)){

          version = RegExp.$1;
          var invalidCharacter = RegExp("[^\\.0-9]").exec(version);
          if(invalidCharacter){

            version = version.slice(0, invalidCharacter.index);
          };
        };
      } else if(qx.bom.client.Engine.__isGecko() || qx.bom.client.Engine.__isMaple()){

        if(/rv\:([^\);]+)(\)|;)/.test(agent)){

          version = RegExp.$1;
        };
      } else if(qx.bom.client.Engine.__isMshtml()){

        var isTrident = /Trident\/([^\);]+)(\)|;)/.test(agent);
        if(/MSIE\s+([^\);]+)(\)|;)/.test(agent)){

          version = RegExp.$1;
          if(version < 8 && isTrident){

            if(RegExp.$1 == "4.0"){

              version = "8.0";
            } else if(RegExp.$1 == "5.0"){

              version = "9.0";
            };
          };
        } else if(isTrident){

          var match = /\brv\:(\d+?\.\d+?)\b/.exec(agent);
          if(match){

            version = match[1];
          };
        };
      } else {

        var failFunction = window.qxFail;
        if(failFunction && typeof failFunction === "function"){

          version = failFunction().FULLVERSION;
        } else {

          version = "1.9.0.0";
          qx.Bootstrap.warn("Unsupported client: " + agent + "! Assumed gecko version 1.9.0.0 (Firefox 3.0).");
        };
      };;;
      return version;
    },
    getName : function(){

      var name;
      if(qx.bom.client.Engine.__isOpera()){

        name = "opera";
      } else if(qx.bom.client.Engine.__isWebkit()){

        name = "webkit";
      } else if(qx.bom.client.Engine.__isGecko() || qx.bom.client.Engine.__isMaple()){

        name = "gecko";
      } else if(qx.bom.client.Engine.__isMshtml()){

        name = "mshtml";
      } else {

        var failFunction = window.qxFail;
        if(failFunction && typeof failFunction === "function"){

          name = failFunction().NAME;
        } else {

          name = "gecko";
          qx.Bootstrap.warn("Unsupported client: " + window.navigator.userAgent + "! Assumed gecko version 1.9.0.0 (Firefox 3.0).");
        };
      };;;
      return name;
    },
    __isOpera : function(){

      return window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
    },
    __isWebkit : function(){

      return window.navigator.userAgent.indexOf("AppleWebKit/") != -1;
    },
    __isMaple : function(){

      return window.navigator.userAgent.indexOf("Maple") != -1;
    },
    __isGecko : function(){

      return (window.controllers || window.navigator.mozApps) && window.navigator.product === "Gecko" && window.navigator.userAgent.indexOf("Maple") == -1 && window.navigator.userAgent.indexOf("Trident") == -1;
    },
    __isMshtml : function(){

      return window.navigator.cpuClass && (/MSIE\s+([^\);]+)(\)|;)/.test(window.navigator.userAgent) || /Trident\/\d+?\.\d+?/.test(window.navigator.userAgent));
    }
  },
  defer : function(statics){

    qx.core.Environment.add("engine.version", statics.getVersion);
    qx.core.Environment.add("engine.name", statics.getName);
  }
});

qx.Bootstrap.define("qx.lang.Function", {
  statics : {
    getCaller : function(args){

      return args.caller ? args.caller.callee : args.callee.caller;
    },
    getName : function(fcn){

      if(fcn.displayName){

        return fcn.displayName;
      };
      if(fcn.$$original || fcn.wrapper || fcn.classname){

        return fcn.classname + ".constructor()";
      };
      if(fcn.$$mixin){

        for(var key in fcn.$$mixin.$$members){

          if(fcn.$$mixin.$$members[key] == fcn){

            return fcn.$$mixin.name + ".prototype." + key + "()";
          };
        };
        for(var key in fcn.$$mixin){

          if(fcn.$$mixin[key] == fcn){

            return fcn.$$mixin.name + "." + key + "()";
          };
        };
      };
      if(fcn.self){

        var clazz = fcn.self.constructor;
        if(clazz){

          for(var key in clazz.prototype){

            if(clazz.prototype[key] == fcn){

              return clazz.classname + ".prototype." + key + "()";
            };
          };
          for(var key in clazz){

            if(clazz[key] == fcn){

              return clazz.classname + "." + key + "()";
            };
          };
        };
      };
      var fcnReResult = fcn.toString().match(/function\s*(\w*)\s*\(.*/);
      if(fcnReResult && fcnReResult.length >= 1 && fcnReResult[1]){

        return fcnReResult[1] + "()";
      };
      return 'anonymous()';
    },
    globalEval : function(data){

      if(window.execScript){

        return window.execScript(data);
      } else {

        return eval.call(window, data);
      };
    },
    create : function(func, options){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert && qx.core.Assert.assertFunction(func, "Invalid parameter 'func'.");
      };
      if(!options){

        return func;
      };
      if(!(options.self || options.args || options.delay != null || options.periodical != null || options.attempt)){

        return func;
      };
      return function(event){

        if(qx.core.Environment.get("qx.debug")){

          if(qx.core.Object && options.self && qx.Bootstrap.isObject(options.self) && options.self.isDisposed && qx.Bootstrap.isFunction(options.self.isDisposed)){

            qx.core.Assert && qx.core.Assert.assertFalse(options.self.isDisposed(), "Trying to call a bound function with a disposed object as context: " + options.self.toString() + " :: " + qx.lang.Function.getName(func));
          };
        };
        var args = qx.lang.Array.fromArguments(arguments);
        if(options.args){

          args = options.args.concat(args);
        };
        if(options.delay || options.periodical){

          var returns = function(){

            return func.apply(options.self || this, args);
          };
          if(qx.core.Environment.get("qx.globalErrorHandling")){

            returns = qx.event.GlobalError.observeMethod(returns);
          };
          if(options.delay){

            return window.setTimeout(returns, options.delay);
          };
          if(options.periodical){

            return window.setInterval(returns, options.periodical);
          };
        } else if(options.attempt){

          var ret = false;
          try{

            ret = func.apply(options.self || this, args);
          } catch(ex) {
          };
          return ret;
        } else {

          return func.apply(options.self || this, args);
        };
      };
    },
    bind : function(func, self, varargs){

      return this.create(func, {
        self : self,
        args : arguments.length > 2 ? qx.lang.Array.fromArguments(arguments, 2) : null
      });
    },
    curry : function(func, varargs){

      return this.create(func, {
        args : arguments.length > 1 ? qx.lang.Array.fromArguments(arguments, 1) : null
      });
    },
    listener : function(func, self, varargs){

      if(arguments.length < 3){

        return function(event){

          return func.call(self || this, event || window.event);
        };
      } else {

        var optargs = qx.lang.Array.fromArguments(arguments, 2);
        return function(event){

          var args = [event || window.event];
          args.push.apply(args, optargs);
          func.apply(self || this, args);
        };
      };
    },
    attempt : function(func, self, varargs){

      return this.create(func, {
        self : self,
        attempt : true,
        args : arguments.length > 2 ? qx.lang.Array.fromArguments(arguments, 2) : null
      })();
    },
    delay : function(func, delay, self, varargs){

      return this.create(func, {
        delay : delay,
        self : self,
        args : arguments.length > 3 ? qx.lang.Array.fromArguments(arguments, 3) : null
      })();
    },
    periodical : function(func, interval, self, varargs){

      return this.create(func, {
        periodical : interval,
        self : self,
        args : arguments.length > 3 ? qx.lang.Array.fromArguments(arguments, 3) : null
      })();
    }
  }
});

qx.Bootstrap.define("qx.event.GlobalError", {
  statics : {
    __callback : null,
    __originalOnError : null,
    __context : null,
    __isGlobaErrorHandlingEnabled : function(){

      if(qx.core && qx.core.Environment){

        return qx.core.Environment.get("qx.globalErrorHandling");
      } else {

        return !!qx.Bootstrap.getEnvironmentSetting("qx.globalErrorHandling");
      };
    },
    setErrorHandler : function(callback, context){

      this.__callback = callback || null;
      this.__context = context || window;
      if(this.__isGlobaErrorHandlingEnabled()){

        if(callback && window.onerror){

          var wrappedHandler = qx.Bootstrap.bind(this.__onErrorWindow, this);
          if(this.__originalOnError == null){

            this.__originalOnError = window.onerror;
          };
          var self = this;
          window.onerror = function(msg, uri, lineNumber){

            self.__originalOnError(msg, uri, lineNumber);
            wrappedHandler(msg, uri, lineNumber);
          };
        };
        if(callback && !window.onerror){

          window.onerror = qx.Bootstrap.bind(this.__onErrorWindow, this);
        };
        if(this.__callback == null){

          if(this.__originalOnError != null){

            window.onerror = this.__originalOnError;
            this.__originalOnError = null;
          } else {

            window.onerror = null;
          };
        };
      };
    },
    __onErrorWindow : function(msg, uri, lineNumber){

      if(this.__callback){

        this.handleError(new qx.core.WindowError(msg, uri, lineNumber));
      };
    },
    observeMethod : function(method){

      if(this.__isGlobaErrorHandlingEnabled()){

        var self = this;
        return function(){

          if(!self.__callback){

            return method.apply(this, arguments);
          };
          try{

            return method.apply(this, arguments);
          } catch(ex) {

            self.handleError(new qx.core.GlobalError(ex, arguments));
          };
        };
      } else {

        return method;
      };
    },
    handleError : function(ex){

      if(this.__callback){

        this.__callback.call(this.__context, ex);
      };
    }
  },
  defer : function(statics){

    if(qx.core && qx.core.Environment){

      qx.core.Environment.add("qx.globalErrorHandling", true);
    } else {

      qx.Bootstrap.setEnvironmentSetting("qx.globalErrorHandling", true);
    };
    statics.setErrorHandler(null, null);
  }
});

qx.Bootstrap.define("qx.core.WindowError", {
  extend : Error,
  construct : function(failMessage, uri, lineNumber){

    var inst = Error.call(this, failMessage);
    if(inst.stack){

      this.stack = inst.stack;
    };
    if(inst.stacktrace){

      this.stacktrace = inst.stacktrace;
    };
    this.__failMessage = failMessage;
    this.__uri = uri || "";
    this.__lineNumber = lineNumber === undefined ? -1 : lineNumber;
  },
  members : {
    __failMessage : null,
    __uri : null,
    __lineNumber : null,
    toString : function(){

      return this.__failMessage;
    },
    getUri : function(){

      return this.__uri;
    },
    getLineNumber : function(){

      return this.__lineNumber;
    }
  }
});

qx.Bootstrap.define("qx.core.GlobalError", {
  extend : Error,
  construct : function(exc, args){

    if(qx.Bootstrap.DEBUG){

      qx.core.Assert.assertNotUndefined(exc);
    };
    this.__failMessage = "GlobalError: " + (exc && exc.message ? exc.message : exc);
    var inst = Error.call(this, this.__failMessage);
    if(inst.stack){

      this.stack = inst.stack;
    };
    if(inst.stacktrace){

      this.stacktrace = inst.stacktrace;
    };
    this.__arguments = args;
    this.__exc = exc;
  },
  members : {
    __exc : null,
    __arguments : null,
    __failMessage : null,
    toString : function(){

      return this.__failMessage;
    },
    getArguments : function(){

      return this.__arguments;
    },
    getSourceException : function(){

      return this.__exc;
    }
  },
  destruct : function(){

    this.__exc = null;
    this.__arguments = null;
    this.__failMessage = null;
  }
});

qx.Bootstrap.define("qx.core.ObjectRegistry", {
  statics : {
    inShutDown : false,
    __registry : {
    },
    __nextHash : 0,
    __freeHashes : [],
    __postId : "",
    __stackTraces : {
    },
    register : function(obj){

      var registry = this.__registry;
      if(!registry){

        return;
      };
      var hash = obj.$$hash;
      if(hash == null){

        var cache = this.__freeHashes;
        if(cache.length > 0 && !qx.core.Environment.get("qx.debug.dispose")){

          hash = cache.pop();
        } else {

          hash = (this.__nextHash++) + this.__postId;
        };
        obj.$$hash = hash;
        if(qx.core.Environment.get("qx.debug.dispose")){

          if(qx.dev && qx.dev.Debug && qx.dev.Debug.disposeProfilingActive){

            this.__stackTraces[hash] = qx.dev.StackTrace.getStackTrace();
          };
        };
      };
      if(qx.core.Environment.get("qx.debug")){

        if(!obj.dispose){

          throw new Error("Invalid object: " + obj);
        };
      };
      registry[hash] = obj;
    },
    unregister : function(obj){

      var hash = obj.$$hash;
      if(hash == null){

        return;
      };
      var registry = this.__registry;
      if(registry && registry[hash]){

        delete registry[hash];
        this.__freeHashes.push(hash);
      };
      try{

        delete obj.$$hash;
      } catch(ex) {

        if(obj.removeAttribute){

          obj.removeAttribute("$$hash");
        };
      };
    },
    toHashCode : function(obj){

      if(qx.core.Environment.get("qx.debug")){

        if(obj == null){

          throw new Error("Invalid object: " + obj);
        };
      };
      var hash = obj.$$hash;
      if(hash != null){

        return hash;
      };
      var cache = this.__freeHashes;
      if(cache.length > 0){

        hash = cache.pop();
      } else {

        hash = (this.__nextHash++) + this.__postId;
      };
      return obj.$$hash = hash;
    },
    clearHashCode : function(obj){

      if(qx.core.Environment.get("qx.debug")){

        if(obj == null){

          throw new Error("Invalid object: " + obj);
        };
      };
      var hash = obj.$$hash;
      if(hash != null){

        this.__freeHashes.push(hash);
        try{

          delete obj.$$hash;
        } catch(ex) {

          if(obj.removeAttribute){

            obj.removeAttribute("$$hash");
          };
        };
      };
    },
    fromHashCode : function(hash){

      return this.__registry[hash] || null;
    },
    shutdown : function(){

      this.inShutDown = true;
      var registry = this.__registry;
      var hashes = [];
      for(var hash in registry){

        hashes.push(hash);
      };
      hashes.sort(function(a, b){

        return parseInt(b, 10) - parseInt(a, 10);
      });
      var obj,i = 0,l = hashes.length;
      while(true){

        try{

          for(;i < l;i++){

            hash = hashes[i];
            obj = registry[hash];
            if(obj && obj.dispose){

              obj.dispose();
            };
          };
        } catch(ex) {

          qx.Bootstrap.error(this, "Could not dispose object " + obj.toString() + ": " + ex, ex);
          if(i !== l){

            i++;
            continue;
          };
        };
        break;
      };
      qx.Bootstrap.debug(this, "Disposed " + l + " objects");
      delete this.__registry;
    },
    getRegistry : function(){

      return this.__registry;
    },
    getNextHash : function(){

      return this.__nextHash;
    },
    getPostId : function(){

      return this.__postId;
    },
    getStackTraces : function(){

      return this.__stackTraces;
    }
  },
  defer : function(statics){

    if(window && window.top){

      var frames = window.top.frames;
      for(var i = 0;i < frames.length;i++){

        if(frames[i] === window){

          statics.__postId = "-" + (i + 1);
          return;
        };
      };
    };
    statics.__postId = "-0";
  }
});

qx.Bootstrap.define("qx.lang.Json", {
  statics : {
    stringify : null,
    parse : null
  }
});
(function(){

  var JSON3;
  var exports;
  var define;
  (function(window){

    var getClass = {
    }.toString,isProperty,forEach,undef;
    var isLoader = typeof define === "function" && define.amd,JSON3 = typeof exports == "object" && exports;
    if(JSON3 || isLoader){

      if(typeof JSON == "object" && JSON){

        if(JSON3){

          JSON3.stringify = JSON.stringify;
          JSON3.parse = JSON.parse;
        } else {

          JSON3 = JSON;
        };
      } else if(isLoader){

        JSON3 = window.JSON = {
        };
      };
    } else {

      JSON3 = window.JSON || (window.JSON = {
      });
    };
    var isExtended = new Date(-3509827334573292);
    try{

      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 && isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch(exception) {
    };
    function has(name){

      if(name == "bug-string-char-index"){

        return "a"[0] != "a";
      };
      var value,serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}',isAll = name == "json";
      if(isAll || name == "json-stringify" || name == "json-parse"){

        if(name == "json-stringify" || isAll){

          var stringify = JSON3.stringify,stringifySupported = typeof stringify == "function" && isExtended;
          if(stringifySupported){

            (value = function(){

              return 1;
            }).toJSON = value;
            try{

              stringifySupported = stringify(0) === "0" && stringify(new Number()) === "0" && stringify(new String()) == '""' && stringify(getClass) === undef && stringify(undef) === undef && stringify() === undef && stringify(value) === "1" && stringify([value]) == "[1]" && stringify([undef]) == "[null]" && stringify(null) == "null" && stringify([undef, getClass, null]) == "[null,null,null]" && stringify({
                "a" : [value, true, false, null, "\x00\b\n\f\r\t"]
              }) == serialized && stringify(null, value) === "1" && stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" && stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' && stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' && stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' && stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch(exception) {

              stringifySupported = false;
            };
          };
          if(!isAll){

            return stringifySupported;
          };
        };
        if(name == "json-parse" || isAll){

          var parse = JSON3.parse;
          if(typeof parse == "function"){

            try{

              if(parse("0") === 0 && !parse(false)){

                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if(parseSupported){

                  try{

                    parseSupported = !parse('"\t"');
                  } catch(exception) {
                  };
                  if(parseSupported){

                    try{

                      parseSupported = parse("01") !== 1;
                    } catch(exception) {
                    };
                  };
                };
              };
            } catch(exception) {

              parseSupported = false;
            };
          };
          if(!isAll){

            return parseSupported;
          };
        };
        return stringifySupported && parseSupported;
      };
    };
    if(!has("json")){

      var functionClass = "[object Function]";
      var dateClass = "[object Date]";
      var numberClass = "[object Number]";
      var stringClass = "[object String]";
      var arrayClass = "[object Array]";
      var booleanClass = "[object Boolean]";
      var charIndexBuggy = has("bug-string-char-index");
      if(!isExtended){

        var floor = Math.floor;
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        var getDay = function(year, month){

          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      };
      if(!(isProperty = {
      }.hasOwnProperty)){

        isProperty = function(property){

          var members = {
          },constructor;
          if((members.__proto__ = null, members.__proto__ = {
            "toString" : 1
          }, members).toString != getClass){

            isProperty = function(property){

              var original = this.__proto__,result = property in (this.__proto__ = null, this);
              this.__proto__ = original;
              return result;
            };
          } else {

            constructor = members.constructor;
            isProperty = function(property){

              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          };
          members = null;
          return isProperty.call(this, property);
        };
      };
      var PrimitiveTypes = {
        'boolean' : 1,
        'number' : 1,
        'string' : 1,
        'undefined' : 1
      };
      var isHostType = function(object, property){

        var type = typeof object[property];
        return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
      };
      forEach = function(object, callback){

        var size = 0,Properties,members,property,forEach;
        (Properties = function(){

          this.valueOf = 0;
        }).prototype.valueOf = 0;
        members = new Properties();
        for(property in members){

          if(isProperty.call(members, property)){

            size++;
          };
        };
        Properties = members = null;
        if(!size){

          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          forEach = function(object, callback){

            var isFunction = getClass.call(object) == functionClass,property,length;
            var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;
            for(property in object){

              if(!(isFunction && property == "prototype") && hasProperty.call(object, property)){

                callback(property);
              };
            };
            for(length = members.length;property = members[--length];hasProperty.call(object, property) && callback(property));
          };
        } else if(size == 2){

          forEach = function(object, callback){

            var members = {
            },isFunction = getClass.call(object) == functionClass,property;
            for(property in object){

              if(!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)){

                callback(property);
              };
            };
          };
        } else {

          forEach = function(object, callback){

            var isFunction = getClass.call(object) == functionClass,property,isConstructor;
            for(property in object){

              if(!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")){

                callback(property);
              };
            };
            if(isConstructor || isProperty.call(object, (property = "constructor"))){

              callback(property);
            };
          };
        };
        return forEach(object, callback);
      };
      if(!has("json-stringify")){

        var Escapes = {
          '92' : "\\\\",
          '34' : '\\"',
          '8' : "\\b",
          '12' : "\\f",
          '10' : "\\n",
          '13' : "\\r",
          '9' : "\\t"
        };
        var leadingZeroes = "000000";
        var toPaddedString = function(width, value){

          return (leadingZeroes + (value || 0)).slice(-width);
        };
        var unicodePrefix = "\\u00";
        var quote = function(value){

          var result = '"',index = 0,length = value.length,isLarge = length > 10 && charIndexBuggy,symbols;
          if(isLarge){

            symbols = value.split("");
          };
          for(;index < length;index++){

            var charCode = value.charCodeAt(index);
            switch(charCode){case 8:case 9:case 10:case 12:case 13:case 34:case 92:
            result += Escapes[charCode];
            break;default:
            if(charCode < 32){

              result += unicodePrefix + toPaddedString(2, charCode.toString(16));
              break;
            };
            result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];};
          };
          return result + '"';
        };
        var serialize = function(property, object, callback, properties, whitespace, indentation, stack){

          var value = object[property],className,year,month,date,time,hours,minutes,seconds,milliseconds,results,element,index,length,prefix,hasMembers,result;
          try{

            value = object[property];
          } catch(exception) {
          };
          if(typeof value == "object" && value){

            className = getClass.call(value);
            if(className == dateClass && !isProperty.call(value, "toJSON")){

              if(value > -1 / 0 && value < 1 / 0){

                if(getDay){

                  date = floor(value / 864e5);
                  for(year = floor(date / 365.2425) + 1970 - 1;getDay(year + 1, 0) <= date;year++);
                  for(month = floor((date - getDay(year, 0)) / 30.42);getDay(year, month + 1) <= date;month++);
                  date = 1 + date - getDay(year, month);
                  time = (value % 864e5 + 864e5) % 864e5;
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {

                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                };
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) + "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) + "." + toPaddedString(3, milliseconds) + "Z";
              } else {

                value = null;
              };
            } else if(typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))){

              value = value.toJSON(property);
            };
          };
          if(callback){

            value = callback.call(object, property, value);
          };
          if(value === null){

            return "null";
          };
          className = getClass.call(value);
          if(className == booleanClass){

            return "" + value;
          } else if(className == numberClass){

            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if(className == stringClass){

            return quote("" + value);
          };;
          if(typeof value == "object"){

            for(length = stack.length;length--;){

              if(stack[length] === value){

                throw TypeError();
              };
            };
            stack.push(value);
            results = [];
            prefix = indentation;
            indentation += whitespace;
            if(className == arrayClass){

              for(index = 0,length = value.length;index < length;hasMembers || (hasMembers = true),index++){

                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              };
              result = hasMembers ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {

              forEach(properties || value, function(property){

                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if(element !== undef){

                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                };
                hasMembers || (hasMembers = true);
              });
              result = hasMembers ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            };
            stack.pop();
            return result;
          };
        };
        JSON3.stringify = function(source, filter, width){

          var whitespace,callback,properties;
          if(typeof filter == "function" || typeof filter == "object" && filter){

            if(getClass.call(filter) == functionClass){

              callback = filter;
            } else if(getClass.call(filter) == arrayClass){

              properties = {
              };
              for(var index = 0,length = filter.length,value;index < length;value = filter[index++],((getClass.call(value) == stringClass || getClass.call(value) == numberClass) && (properties[value] = 1)));
            };
          };
          if(width){

            if(getClass.call(width) == numberClass){

              if((width -= width % 1) > 0){

                for(whitespace = "",width > 10 && (width = 10);whitespace.length < width;whitespace += " ");
              };
            } else if(getClass.call(width) == stringClass){

              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            };
          };
          return serialize("", (value = {
          }, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      };
      if(!has("json-parse")){

        var fromCharCode = String.fromCharCode;
        var Unescapes = {
          '92' : "\\",
          '34' : '"',
          '47' : "/",
          '98' : "\b",
          '116' : "\t",
          '110' : "\n",
          '102' : "\f",
          '114' : "\r"
        };
        var Index,Source;
        var abort = function(){

          Index = Source = null;
          throw SyntaxError();
        };
        var lex = function(){

          var source = Source,length = source.length,value,begin,position,isSigned,charCode;
          while(Index < length){

            charCode = source.charCodeAt(Index);
            switch(charCode){case 9:case 10:case 13:case 32:
            Index++;
            break;case 123:case 125:case 91:case 93:case 58:case 44:
            value = charIndexBuggy ? source.charAt(Index) : source[Index];
            Index++;
            return value;case 34:
            for(value = "@",Index++;Index < length;){

              charCode = source.charCodeAt(Index);
              if(charCode < 32){

                abort();
              } else if(charCode == 92){

                charCode = source.charCodeAt(++Index);
                switch(charCode){case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:
                value += Unescapes[charCode];
                Index++;
                break;case 117:
                begin = ++Index;
                for(position = Index + 4;Index < position;Index++){

                  charCode = source.charCodeAt(Index);
                  if(!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)){

                    abort();
                  };
                };
                value += fromCharCode("0x" + source.slice(begin, Index));
                break;default:
                abort();};
              } else {

                if(charCode == 34){

                  break;
                };
                charCode = source.charCodeAt(Index);
                begin = Index;
                while(charCode >= 32 && charCode != 92 && charCode != 34){

                  charCode = source.charCodeAt(++Index);
                };
                value += source.slice(begin, Index);
              };
            };
            if(source.charCodeAt(Index) == 34){

              Index++;
              return value;
            };
            abort();default:
            begin = Index;
            if(charCode == 45){

              isSigned = true;
              charCode = source.charCodeAt(++Index);
            };
            if(charCode >= 48 && charCode <= 57){

              if(charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)){

                abort();
              };
              isSigned = false;
              for(;Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57);Index++);
              if(source.charCodeAt(Index) == 46){

                position = ++Index;
                for(;position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57);position++);
                if(position == Index){

                  abort();
                };
                Index = position;
              };
              charCode = source.charCodeAt(Index);
              if(charCode == 101 || charCode == 69){

                charCode = source.charCodeAt(++Index);
                if(charCode == 43 || charCode == 45){

                  Index++;
                };
                for(position = Index;position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57);position++);
                if(position == Index){

                  abort();
                };
                Index = position;
              };
              return +source.slice(begin, Index);
            };
            if(isSigned){

              abort();
            };
            if(source.slice(Index, Index + 4) == "true"){

              Index += 4;
              return true;
            } else if(source.slice(Index, Index + 5) == "false"){

              Index += 5;
              return false;
            } else if(source.slice(Index, Index + 4) == "null"){

              Index += 4;
              return null;
            };;
            abort();};
          };
          return "$";
        };
        var get = function(value){

          var results,hasMembers;
          if(value == "$"){

            abort();
          };
          if(typeof value == "string"){

            if((charIndexBuggy ? value.charAt(0) : value[0]) == "@"){

              return value.slice(1);
            };
            if(value == "["){

              results = [];
              for(;;hasMembers || (hasMembers = true)){

                value = lex();
                if(value == "]"){

                  break;
                };
                if(hasMembers){

                  if(value == ","){

                    value = lex();
                    if(value == "]"){

                      abort();
                    };
                  } else {

                    abort();
                  };
                };
                if(value == ","){

                  abort();
                };
                results.push(get(value));
              };
              return results;
            } else if(value == "{"){

              results = {
              };
              for(;;hasMembers || (hasMembers = true)){

                value = lex();
                if(value == "}"){

                  break;
                };
                if(hasMembers){

                  if(value == ","){

                    value = lex();
                    if(value == "}"){

                      abort();
                    };
                  } else {

                    abort();
                  };
                };
                if(value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":"){

                  abort();
                };
                results[value.slice(1)] = get(lex());
              };
              return results;
            };
            abort();
          };
          return value;
        };
        var update = function(source, property, callback){

          var element = walk(source, property, callback);
          if(element === undef){

            delete source[property];
          } else {

            source[property] = element;
          };
        };
        var walk = function(source, property, callback){

          var value = source[property],length;
          if(typeof value == "object" && value){

            if(getClass.call(value) == arrayClass){

              for(length = value.length;length--;){

                update(value, length, callback);
              };
            } else {

              forEach(value, function(property){

                update(value, property, callback);
              });
            };
          };
          return callback.call(source, property, value);
        };
        JSON3.parse = function(source, callback){

          var result,value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          if(lex() != "$"){

            abort();
          };
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {
          }, value[""] = result, value), "", callback) : result;
        };
      };
    };
    if(isLoader){

      define(function(){

        return JSON3;
      });
    };
  }(this));
}());
qx.lang.Json.stringify = window.JSON.stringify;
qx.lang.Json.parse = window.JSON.parse;

qx.Bootstrap.define("qx.lang.String", {
  statics : {
    __unicodeLetters : "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
    __unicodeFirstLetterInWordRegexp : null,
    __stringsMap : {
    },
    camelCase : function(str){

      var result = this.__stringsMap[str];
      if(!result){

        result = str.replace(/\-([a-z])/g, function(match, chr){

          return chr.toUpperCase();
        });
        if(str.indexOf("-") >= 0){

          this.__stringsMap[str] = result;
        };
      };
      return result;
    },
    hyphenate : function(str){

      var result = this.__stringsMap[str];
      if(!result){

        result = str.replace(/[A-Z]/g, function(match){

          return ('-' + match.charAt(0).toLowerCase());
        });
        if(str.indexOf("-") == -1){

          this.__stringsMap[str] = result;
        };
      };
      return result;
    },
    capitalize : function(str){

      if(this.__unicodeFirstLetterInWordRegexp === null){

        var unicodeEscapePrefix = '\\u';
        this.__unicodeFirstLetterInWordRegexp = new RegExp("(^|[^" + this.__unicodeLetters.replace(/[0-9A-F]{4}/g, function(match){

          return unicodeEscapePrefix + match;
        }) + "])[" + this.__unicodeLetters.replace(/[0-9A-F]{4}/g, function(match){

          return unicodeEscapePrefix + match;
        }) + "]", "g");
      };
      return str.replace(this.__unicodeFirstLetterInWordRegexp, function(match){

        return match.toUpperCase();
      });
    },
    clean : function(str){

      return str.replace(/\s+/g, ' ').trim();
    },
    trimLeft : function(str){

      return str.replace(/^\s+/, "");
    },
    trimRight : function(str){

      return str.replace(/\s+$/, "");
    },
    startsWith : function(fullstr, substr){

      return fullstr.indexOf(substr) === 0;
    },
    endsWith : function(fullstr, substr){

      return fullstr.substring(fullstr.length - substr.length, fullstr.length) === substr;
    },
    repeat : function(str, times){

      return str.length > 0 ? new Array(times + 1).join(str) : "";
    },
    pad : function(str, length, ch){

      var padLength = length - str.length;
      if(padLength > 0){

        if(typeof ch === "undefined"){

          ch = "0";
        };
        return this.repeat(ch, padLength) + str;
      } else {

        return str;
      };
    },
    firstUp : qx.Bootstrap.firstUp,
    firstLow : qx.Bootstrap.firstLow,
    contains : function(str, substring){

      return str.indexOf(substring) != -1;
    },
    format : function(pattern, args){

      var str = pattern;
      var i = args.length;
      while(i--){

        str = str.replace(new RegExp("%" + (i + 1), "g"), args[i] + "");
      };
      return str;
    },
    escapeRegexpChars : function(str){

      return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
    },
    toArray : function(str){

      return str.split(/\B|\b/g);
    },
    stripTags : function(str){

      return str.replace(/<\/?[^>]+>/gi, "");
    },
    stripScripts : function(str, exec){

      var scripts = "";
      var text = str.replace(/<script[^>]*>([\s\S]*?)<\/script>/gi, function(){

        scripts += arguments[1] + '\n';
        return "";
      });
      if(exec === true){

        qx.lang.Function.globalEval(scripts);
      };
      return text;
    },
    quote : function(str){

      return '"' + str.replace(/\\/g, "\\\\").replace(/\"/g, "\\\"") + '"';
    }
  }
});

qx.Interface.define("qx.data.IListData", {
  events : {
    "change" : "qx.event.type.Data",
    "changeLength" : "qx.event.type.Event"
  },
  members : {
    getItem : function(index){
    },
    setItem : function(index, item){
    },
    splice : function(startIndex, amount, varargs){
    },
    contains : function(item){
    },
    getLength : function(){
    },
    toArray : function(){
    }
  }
});

qx.Class.define("qx.core.ValidationError", {
  extend : qx.type.BaseError
});

qx.Bootstrap.define("qx.util.RingBuffer", {
  extend : Object,
  construct : function(maxEntries){

    this.setMaxEntries(maxEntries || 50);
  },
  members : {
    __nextIndexToStoreTo : 0,
    __entriesStored : 0,
    __isMarkActive : false,
    __entriesStoredSinceMark : 0,
    __entries : null,
    __maxEntries : null,
    setMaxEntries : function(maxEntries){

      this.__maxEntries = maxEntries;
      this.clear();
    },
    getMaxEntries : function(){

      return this.__maxEntries;
    },
    addEntry : function(entry){

      this.__entries[this.__nextIndexToStoreTo] = entry;
      this.__nextIndexToStoreTo = this.__addToIndex(this.__nextIndexToStoreTo, 1);
      var max = this.getMaxEntries();
      if(this.__entriesStored < max){

        this.__entriesStored++;
      };
      if(this.__isMarkActive && (this.__entriesStoredSinceMark < max)){

        this.__entriesStoredSinceMark++;
      };
    },
    mark : function(){

      this.__isMarkActive = true;
      this.__entriesStoredSinceMark = 0;
    },
    clearMark : function(){

      this.__isMarkActive = false;
    },
    getAllEntries : function(){

      return this.getEntries(this.getMaxEntries(), false);
    },
    getEntries : function(count, startingFromMark){

      if(count > this.__entriesStored){

        count = this.__entriesStored;
      };
      if(startingFromMark && this.__isMarkActive && (count > this.__entriesStoredSinceMark)){

        count = this.__entriesStoredSinceMark;
      };
      if(count > 0){

        var indexOfYoungestElementInHistory = this.__addToIndex(this.__nextIndexToStoreTo, -1);
        var startIndex = this.__addToIndex(indexOfYoungestElementInHistory, -count + 1);
        var result;
        if(startIndex <= indexOfYoungestElementInHistory){

          result = this.__entries.slice(startIndex, indexOfYoungestElementInHistory + 1);
        } else {

          result = this.__entries.slice(startIndex, this.__entriesStored).concat(this.__entries.slice(0, indexOfYoungestElementInHistory + 1));
        };
      } else {

        result = [];
      };
      return result;
    },
    clear : function(){

      this.__entries = new Array(this.getMaxEntries());
      this.__entriesStored = 0;
      this.__entriesStoredSinceMark = 0;
      this.__nextIndexToStoreTo = 0;
    },
    __addToIndex : function(idx, addMe){

      var max = this.getMaxEntries();
      var result = (idx + addMe) % max;
      if(result < 0){

        result += max;
      };
      return result;
    }
  }
});

qx.Bootstrap.define("qx.log.appender.RingBuffer", {
  extend : qx.util.RingBuffer,
  construct : function(maxMessages){

    this.setMaxMessages(maxMessages || 50);
  },
  members : {
    setMaxMessages : function(maxMessages){

      this.setMaxEntries(maxMessages);
    },
    getMaxMessages : function(){

      return this.getMaxEntries();
    },
    process : function(entry){

      this.addEntry(entry);
    },
    getAllLogEvents : function(){

      return this.getAllEntries();
    },
    retrieveLogEvents : function(count, startingFromMark){

      return this.getEntries(count, startingFromMark);
    },
    clearHistory : function(){

      this.clear();
    }
  }
});

qx.Bootstrap.define("qx.log.Logger", {
  statics : {
    __level : "debug",
    setLevel : function(value){

      this.__level = value;
    },
    getLevel : function(){

      return this.__level;
    },
    setTreshold : function(value){

      this.__buffer.setMaxMessages(value);
    },
    getTreshold : function(){

      return this.__buffer.getMaxMessages();
    },
    __appender : {
    },
    __id : 0,
    register : function(appender){

      if(appender.$$id){

        return;
      };
      var id = this.__id++;
      this.__appender[id] = appender;
      appender.$$id = id;
      var levels = this.__levels;
      var entries = this.__buffer.getAllLogEvents();
      for(var i = 0,l = entries.length;i < l;i++){

        if(levels[entries[i].level] >= levels[this.__level]){

          appender.process(entries[i]);
        };
      };
    },
    unregister : function(appender){

      var id = appender.$$id;
      if(id == null){

        return;
      };
      delete this.__appender[id];
      delete appender.$$id;
    },
    debug : function(object, message){

      qx.log.Logger.__log("debug", arguments);
    },
    info : function(object, message){

      qx.log.Logger.__log("info", arguments);
    },
    warn : function(object, message){

      qx.log.Logger.__log("warn", arguments);
    },
    error : function(object, message){

      qx.log.Logger.__log("error", arguments);
    },
    trace : function(object){

      var trace = qx.dev.StackTrace.getStackTrace();
      qx.log.Logger.__log("info", [(typeof object !== "undefined" ? [object].concat(trace) : trace).join("\n")]);
    },
    deprecatedMethodWarning : function(fcn, msg){

      if(qx.core.Environment.get("qx.debug")){

        var functionName = qx.lang.Function.getName(fcn);
        this.warn("The method '" + functionName + "' is deprecated: " + (msg || "Please consult the API documentation of this method for alternatives."));
        this.trace();
      };
    },
    deprecatedClassWarning : function(clazz, msg){

      if(qx.core.Environment.get("qx.debug")){

        var className = clazz.classname || "unknown";
        this.warn("The class '" + className + "' is deprecated: " + (msg || "Please consult the API documentation of this class for alternatives."));
        this.trace();
      };
    },
    deprecatedEventWarning : function(clazz, event, msg){

      if(qx.core.Environment.get("qx.debug")){

        var className = clazz.self ? clazz.self.classname : "unknown";
        this.warn("The event '" + (event || "unknown") + "' from class '" + className + "' is deprecated: " + (msg || "Please consult the API documentation of this class for alternatives."));
        this.trace();
      };
    },
    deprecatedMixinWarning : function(clazz, msg){

      if(qx.core.Environment.get("qx.debug")){

        var mixinName = clazz ? clazz.name : "unknown";
        this.warn("The mixin '" + mixinName + "' is deprecated: " + (msg || "Please consult the API documentation of this class for alternatives."));
        this.trace();
      };
    },
    deprecatedConstantWarning : function(clazz, constant, msg){

      if(qx.core.Environment.get("qx.debug")){

        if(clazz.__defineGetter__){

          var self = this;
          var constantValue = clazz[constant];
          clazz.__defineGetter__(constant, function(){

            self.warn("The constant '" + constant + "' is deprecated: " + (msg || "Please consult the API documentation for alternatives."));
            self.trace();
            return constantValue;
          });
        };
      };
    },
    deprecateMethodOverriding : function(object, baseclass, methodName, msg){

      if(qx.core.Environment.get("qx.debug")){

        var clazz = object.constructor;
        while(clazz.classname !== baseclass.classname){

          if(clazz.prototype.hasOwnProperty(methodName)){

            this.warn("The method '" + qx.lang.Function.getName(object[methodName]) + "' overrides a deprecated method: " + (msg || "Please consult the API documentation for alternatives."));
            this.trace();
            break;
          };
          clazz = clazz.superclass;
        };
      };
    },
    clear : function(){

      this.__buffer.clearHistory();
    },
    __buffer : new qx.log.appender.RingBuffer(50),
    __levels : {
      debug : 0,
      info : 1,
      warn : 2,
      error : 3
    },
    __log : function(level, args){

      var levels = this.__levels;
      if(levels[level] < levels[this.__level]){

        return;
      };
      var object = args.length < 2 ? null : args[0];
      var start = object ? 1 : 0;
      var items = [];
      for(var i = start,l = args.length;i < l;i++){

        items.push(this.__serialize(args[i], true));
      };
      var time = new Date;
      var entry = {
        time : time,
        offset : time - qx.Bootstrap.LOADSTART,
        level : level,
        items : items,
        win : window
      };
      if(object){

        if(object.$$hash !== undefined){

          entry.object = object.$$hash;
        } else if(object.$$type){

          entry.clazz = object;
        } else if(object.constructor){

          entry.clazz = object.constructor;
        };;
      };
      this.__buffer.process(entry);
      var appender = this.__appender;
      for(var id in appender){

        appender[id].process(entry);
      };
    },
    __detect : function(value){

      if(value === undefined){

        return "undefined";
      } else if(value === null){

        return "null";
      };
      if(value.$$type){

        return "class";
      };
      var type = typeof value;
      if(type === "function" || type == "string" || type === "number" || type === "boolean"){

        return type;
      } else if(type === "object"){

        if(value.nodeType){

          return "node";
        } else if(value instanceof Error || (value.name && value.message)){

          return "error";
        } else if(value.classname){

          return "instance";
        } else if(value instanceof Array){

          return "array";
        } else if(value instanceof Date){

          return "date";
        } else {

          return "map";
        };;;;
      };
      if(value.toString){

        return "stringify";
      };
      return "unknown";
    },
    __serialize : function(value, deep){

      var type = this.__detect(value);
      var text = "unknown";
      var trace = [];
      switch(type){case "null":case "undefined":
      text = type;
      break;case "string":case "number":case "boolean":case "date":
      text = value;
      break;case "node":
      if(value.nodeType === 9){

        text = "document";
      } else if(value.nodeType === 3){

        text = "text[" + value.nodeValue + "]";
      } else if(value.nodeType === 1){

        text = value.nodeName.toLowerCase();
        if(value.id){

          text += "#" + value.id;
        };
      } else {

        text = "node";
      };;
      break;case "function":
      text = qx.lang.Function.getName(value) || type;
      break;case "instance":
      text = value.basename + "[" + value.$$hash + "]";
      break;case "class":case "stringify":
      text = value.toString();
      break;case "error":
      trace = qx.dev.StackTrace.getStackTraceFromError(value);
      text = (value.basename ? value.basename + ": " : "") + value.toString();
      break;case "array":
      if(deep){

        text = [];
        for(var i = 0,l = value.length;i < l;i++){

          if(text.length > 20){

            text.push("...(+" + (l - i) + ")");
            break;
          };
          text.push(this.__serialize(value[i], false));
        };
      } else {

        text = "[...(" + value.length + ")]";
      };
      break;case "map":
      if(deep){

        var temp;
        var sorted = [];
        for(var key in value){

          sorted.push(key);
        };
        sorted.sort();
        text = [];
        for(var i = 0,l = sorted.length;i < l;i++){

          if(text.length > 20){

            text.push("...(+" + (l - i) + ")");
            break;
          };
          key = sorted[i];
          temp = this.__serialize(value[key], false);
          temp.key = key;
          text.push(temp);
        };
      } else {

        var number = 0;
        for(var key in value){

          number++;
        };
        text = "{...(" + number + ")}";
      };
      break;};
      return {
        type : type,
        text : text,
        trace : trace
      };
    }
  },
  defer : function(statics){

    var logs = qx.Bootstrap.$$logs;
    for(var i = 0;i < logs.length;i++){

      statics.__log(logs[i][0], logs[i][1]);
    };
    qx.Bootstrap.debug = statics.debug;
    qx.Bootstrap.info = statics.info;
    qx.Bootstrap.warn = statics.warn;
    qx.Bootstrap.error = statics.error;
    qx.Bootstrap.trace = statics.trace;
  }
});

qx.Mixin.define("qx.core.MLogging", {
  members : {
    __Logger : qx.log.Logger,
    debug : function(varargs){

      this.__logMessage("debug", arguments);
    },
    info : function(varargs){

      this.__logMessage("info", arguments);
    },
    warn : function(varargs){

      this.__logMessage("warn", arguments);
    },
    error : function(varargs){

      this.__logMessage("error", arguments);
    },
    trace : function(){

      this.__Logger.trace(this);
    },
    __logMessage : function(level, varargs){

      var argumentsArray = qx.lang.Array.fromArguments(varargs);
      argumentsArray.unshift(this);
      this.__Logger[level].apply(this.__Logger, argumentsArray);
    }
  }
});

qx.Bootstrap.define("qx.dom.Node", {
  statics : {
    ELEMENT : 1,
    ATTRIBUTE : 2,
    TEXT : 3,
    CDATA_SECTION : 4,
    ENTITY_REFERENCE : 5,
    ENTITY : 6,
    PROCESSING_INSTRUCTION : 7,
    COMMENT : 8,
    DOCUMENT : 9,
    DOCUMENT_TYPE : 10,
    DOCUMENT_FRAGMENT : 11,
    NOTATION : 12,
    getDocument : function(node){

      return node.nodeType === this.DOCUMENT ? node : node.ownerDocument || node.document;
    },
    getWindow : function(node){

      if(node.nodeType == null){

        return node;
      };
      if(node.nodeType !== this.DOCUMENT){

        node = node.ownerDocument;
      };
      return node.defaultView || node.parentWindow;
    },
    getDocumentElement : function(node){

      return this.getDocument(node).documentElement;
    },
    getBodyElement : function(node){

      return this.getDocument(node).body;
    },
    isNode : function(node){

      return !!(node && node.nodeType != null);
    },
    isElement : function(node){

      return !!(node && node.nodeType === this.ELEMENT);
    },
    isDocument : function(node){

      return !!(node && node.nodeType === this.DOCUMENT);
    },
    isDocumentFragment : function(node){

      return !!(node && node.nodeType === this.DOCUMENT_FRAGMENT);
    },
    isText : function(node){

      return !!(node && node.nodeType === this.TEXT);
    },
    isWindow : function(obj){

      return !!(obj && obj.history && obj.location && obj.document);
    },
    isNodeName : function(node, nodeName){

      if(!nodeName || !node || !node.nodeName){

        return false;
      };
      return nodeName.toLowerCase() == qx.dom.Node.getName(node);
    },
    getName : function(node){

      if(!node || !node.nodeName){

        return null;
      };
      return node.nodeName.toLowerCase();
    },
    getText : function(node){

      if(!node || !node.nodeType){

        return null;
      };
      switch(node.nodeType){case 1:
      var i,a = [],nodes = node.childNodes,length = nodes.length;
      for(i = 0;i < length;i++){

        a[i] = this.getText(nodes[i]);
      };
      return a.join("");case 2:case 3:case 4:
      return node.nodeValue;};
      return null;
    },
    isBlockNode : function(node){

      if(!qx.dom.Node.isElement(node)){

        return false;
      };
      node = qx.dom.Node.getName(node);
      return /^(body|form|textarea|fieldset|ul|ol|dl|dt|dd|li|div|hr|p|h[1-6]|quote|pre|table|thead|tbody|tfoot|tr|td|th|iframe|address|blockquote)$/.test(node);
    }
  }
});

qx.Bootstrap.define("qx.bom.Event", {
  statics : {
    addNativeListener : function(target, type, listener, useCapture){

      if(target.addEventListener){

        target.addEventListener(type, listener, !!useCapture);
      } else if(target.attachEvent){

        target.attachEvent("on" + type, listener);
      } else if(typeof target["on" + type] != "undefined"){

        target["on" + type] = listener;
      } else {

        if(qx.core.Environment.get("qx.debug")){

          qx.log.Logger.warn("No method available to add native listener to " + target);
        };
      };;
    },
    removeNativeListener : function(target, type, listener, useCapture){

      if(target.removeEventListener){

        target.removeEventListener(type, listener, !!useCapture);
      } else if(target.detachEvent){

        try{

          target.detachEvent("on" + type, listener);
        } catch(e) {

          if(e.number !== -2146828218){

            throw e;
          };
        };
      } else if(typeof target["on" + type] != "undefined"){

        target["on" + type] = null;
      } else {

        if(qx.core.Environment.get("qx.debug")){

          qx.log.Logger.warn("No method available to remove native listener from " + target);
        };
      };;
    },
    getTarget : function(e){

      return e.target || e.srcElement;
    },
    getRelatedTarget : function(e){

      if(e.relatedTarget !== undefined){

        if((qx.core.Environment.get("engine.name") == "gecko")){

          try{

            e.relatedTarget && e.relatedTarget.nodeType;
          } catch(ex) {

            return null;
          };
        };
        return e.relatedTarget;
      } else if(e.fromElement !== undefined && (e.type === "mouseover" || e.type === "pointerover")){

        return e.fromElement;
      } else if(e.toElement !== undefined){

        return e.toElement;
      } else {

        return null;
      };;
    },
    preventDefault : function(e){

      if(e.preventDefault){

        e.preventDefault();
      } else {

        try{

          e.keyCode = 0;
        } catch(ex) {
        };
        e.returnValue = false;
      };
    },
    stopPropagation : function(e){

      if(e.stopPropagation){

        e.stopPropagation();
      } else {

        e.cancelBubble = true;
      };
    },
    fire : function(target, type){

      if(document.createEvent){

        var evt = document.createEvent("HTMLEvents");
        evt.initEvent(type, true, true);
        return !target.dispatchEvent(evt);
      } else {

        var evt = document.createEventObject();
        return target.fireEvent("on" + type, evt);
      };
    },
    supportsEvent : function(target, type){

      if(type.toLowerCase().indexOf("transitionend") != -1 && qx.core.Environment.get("engine.name") === "mshtml" && qx.core.Environment.get("browser.documentmode") > 9){

        return true;
      };
      if(target != window && type.toLowerCase().indexOf("transitionend") != -1){

        var transitionSupport = qx.core.Environment.get("css.transition");
        return (transitionSupport && transitionSupport["end-event"] == type);
      };
      var eventName = "on" + type.toLowerCase();
      var supportsEvent = (eventName in target);
      if(!supportsEvent){

        supportsEvent = typeof target[eventName] == "function";
        if(!supportsEvent && target.setAttribute){

          target.setAttribute(eventName, "return;");
          supportsEvent = typeof target[eventName] == "function";
          target.removeAttribute(eventName);
        };
      };
      return supportsEvent;
    },
    getEventName : function(target, type){

      var pref = [""].concat(qx.bom.Style.VENDOR_PREFIXES);
      for(var i = 0,l = pref.length;i < l;i++){

        var prefix = pref[i].toLowerCase();
        if(qx.bom.Event.supportsEvent(target, prefix + type)){

          return prefix ? prefix + qx.lang.String.firstUp(type) : type;
        };
      };
      return null;
    }
  }
});

qx.Bootstrap.define("qx.bom.Style", {
  statics : {
    VENDOR_PREFIXES : ["Webkit", "Moz", "O", "ms", "Khtml"],
    __cssName : {
    },
    __supports : null,
    getPropertyName : function(propertyName){

      var style = document.documentElement.style;
      if(style[propertyName] !== undefined){

        return propertyName;
      };
      for(var i = 0,l = this.VENDOR_PREFIXES.length;i < l;i++){

        var prefixedProp = this.VENDOR_PREFIXES[i] + qx.lang.String.firstUp(propertyName);
        if(style[prefixedProp] !== undefined){

          return prefixedProp;
        };
      };
      return null;
    },
    getCssName : function(propertyName){

      var cssName = this.__cssName[propertyName];
      if(!cssName){

        cssName = propertyName.replace(/[A-Z]/g, function(match){

          return ('-' + match.charAt(0).toLowerCase());
        });
        if((/^ms/.test(cssName))){

          cssName = "-" + cssName;
        };
        this.__cssName[propertyName] = cssName;
      };
      return cssName;
    },
    getAppliedStyle : function(element, propertyName, value, prefixed){

      var cssProperty = qx.bom.Style.getCssName(propertyName);
      var win = qx.dom.Node.getWindow(element);
      var vendorPrefixes = (prefixed !== false) ? [null].concat(this.VENDOR_PREFIXES) : [null];
      for(var i = 0,l = vendorPrefixes.length;i < l;i++){

        var supported = false;
        var prefixedVal = vendorPrefixes[i] ? "-" + vendorPrefixes[i].toLowerCase() + "-" + value : value;
        if(qx.bom.Style.__supports){

          supported = qx.bom.Style.__supports.call(win, cssProperty, prefixedVal);
        } else {

          element.style.cssText += cssProperty + ":" + prefixedVal + ";";
          supported = (typeof element.style[propertyName] == "string" && element.style[propertyName] !== "");
        };
        if(supported){

          return prefixedVal;
        };
      };
      return null;
    }
  },
  defer : function(statics){

    if(window.CSS && window.CSS.supports){

      qx.bom.Style.__supports = window.CSS.supports.bind(window.CSS);
    } else if(window.supportsCSS){

      qx.bom.Style.__supports = window.supportsCSS.bind(window);
    };
  }
});

qx.Bootstrap.define("qx.bom.client.OperatingSystem", {
  statics : {
    getName : function(){

      if(!navigator){

        return "";
      };
      var input = navigator.platform || "";
      var agent = navigator.userAgent || "";
      if(input.indexOf("Windows") != -1 || input.indexOf("Win32") != -1 || input.indexOf("Win64") != -1){

        return "win";
      } else if(input.indexOf("Macintosh") != -1 || input.indexOf("MacPPC") != -1 || input.indexOf("MacIntel") != -1 || input.indexOf("Mac OS X") != -1){

        return "osx";
      } else if(agent.indexOf("RIM Tablet OS") != -1){

        return "rim_tabletos";
      } else if(agent.indexOf("webOS") != -1){

        return "webos";
      } else if(input.indexOf("iPod") != -1 || input.indexOf("iPhone") != -1 || input.indexOf("iPad") != -1){

        return "ios";
      } else if(agent.indexOf("Android") != -1){

        return "android";
      } else if(input.indexOf("Linux") != -1){

        return "linux";
      } else if(input.indexOf("X11") != -1 || input.indexOf("BSD") != -1 || input.indexOf("Darwin") != -1){

        return "unix";
      } else if(input.indexOf("SymbianOS") != -1){

        return "symbian";
      } else if(input.indexOf("BlackBerry") != -1){

        return "blackberry";
      };;;;;;;;;
      return "";
    },
    __ids : {
      "Windows NT 6.3" : "8.1",
      "Windows NT 6.2" : "8",
      "Windows NT 6.1" : "7",
      "Windows NT 6.0" : "vista",
      "Windows NT 5.2" : "2003",
      "Windows NT 5.1" : "xp",
      "Windows NT 5.0" : "2000",
      "Windows 2000" : "2000",
      "Windows NT 4.0" : "nt4",
      "Win 9x 4.90" : "me",
      "Windows CE" : "ce",
      "Windows 98" : "98",
      "Win98" : "98",
      "Windows 95" : "95",
      "Win95" : "95",
      "Mac OS X 10_9" : "10.9",
      "Mac OS X 10.9" : "10.9",
      "Mac OS X 10_8" : "10.8",
      "Mac OS X 10.8" : "10.8",
      "Mac OS X 10_7" : "10.7",
      "Mac OS X 10.7" : "10.7",
      "Mac OS X 10_6" : "10.6",
      "Mac OS X 10.6" : "10.6",
      "Mac OS X 10_5" : "10.5",
      "Mac OS X 10.5" : "10.5",
      "Mac OS X 10_4" : "10.4",
      "Mac OS X 10.4" : "10.4",
      "Mac OS X 10_3" : "10.3",
      "Mac OS X 10.3" : "10.3",
      "Mac OS X 10_2" : "10.2",
      "Mac OS X 10.2" : "10.2",
      "Mac OS X 10_1" : "10.1",
      "Mac OS X 10.1" : "10.1",
      "Mac OS X 10_0" : "10.0",
      "Mac OS X 10.0" : "10.0"
    },
    getVersion : function(){

      var version = qx.bom.client.OperatingSystem.__getVersionForDesktopOs(navigator.userAgent);
      if(version == null){

        version = qx.bom.client.OperatingSystem.__getVersionForMobileOs(navigator.userAgent);
      };
      if(version != null){

        return version;
      } else {

        return "";
      };
    },
    __getVersionForDesktopOs : function(userAgent){

      var str = [];
      for(var key in qx.bom.client.OperatingSystem.__ids){

        str.push(key);
      };
      var reg = new RegExp("(" + str.join("|").replace(/\./g, "\.") + ")", "g");
      var match = reg.exec(userAgent);
      if(match && match[1]){

        return qx.bom.client.OperatingSystem.__ids[match[1]];
      };
      return null;
    },
    __getVersionForMobileOs : function(userAgent){

      var android = userAgent.indexOf("Android") != -1;
      var iOs = userAgent.match(/(iPad|iPhone|iPod)/i) ? true : false;
      if(android){

        var androidVersionRegExp = new RegExp(/ Android (\d+(?:\.\d+)+)/i);
        var androidMatch = androidVersionRegExp.exec(userAgent);
        if(androidMatch && androidMatch[1]){

          return androidMatch[1];
        };
      } else if(iOs){

        var iOsVersionRegExp = new RegExp(/(CPU|iPhone|iPod) OS (\d+)_(\d+)(?:_(\d+))*\s+/);
        var iOsMatch = iOsVersionRegExp.exec(userAgent);
        if(iOsMatch && iOsMatch[2] && iOsMatch[3]){

          if(iOsMatch[4]){

            return iOsMatch[2] + "." + iOsMatch[3] + "." + iOsMatch[4];
          } else {

            return iOsMatch[2] + "." + iOsMatch[3];
          };
        };
      };
      return null;
    }
  },
  defer : function(statics){

    qx.core.Environment.add("os.name", statics.getName);
    qx.core.Environment.add("os.version", statics.getVersion);
  }
});

qx.Bootstrap.define("qx.bom.client.Browser", {
  statics : {
    getName : function(){

      var agent = navigator.userAgent;
      var reg = new RegExp("(" + qx.bom.client.Browser.__agents + ")(/|)?([0-9]+\.[0-9])?");
      var match = agent.match(reg);
      if(!match){

        return "";
      };
      var name = match[1].toLowerCase();
      var engine = qx.bom.client.Engine.getName();
      if(engine === "webkit"){

        if(name === "android"){

          name = "mobile chrome";
        } else if(agent.indexOf("Mobile Safari") !== -1 || agent.indexOf("Mobile/") !== -1){

          name = "mobile safari";
        } else if(agent.indexOf(" OPR/") != -1){

          name = "opera";
        };;
      } else if(engine === "mshtml"){

        if(name === "msie" || name === "trident"){

          name = "ie";
          if(qx.bom.client.OperatingSystem.getVersion() === "ce"){

            name = "iemobile";
          };
          var reg = new RegExp("IEMobile");
          if(agent.match(reg)){

            name = "iemobile";
          };
        };
      } else if(engine === "opera"){

        if(name === "opera mobi"){

          name = "operamobile";
        } else if(name === "opera mini"){

          name = "operamini";
        };
      } else if(engine === "gecko"){

        if(agent.indexOf("Maple") !== -1){

          name = "maple";
        };
      };;;
      return name;
    },
    getVersion : function(){

      var agent = navigator.userAgent;
      var reg = new RegExp("(" + qx.bom.client.Browser.__agents + ")(/| )([0-9]+\.[0-9])");
      var match = agent.match(reg);
      if(!match){

        return "";
      };
      var name = match[1].toLowerCase();
      var version = match[3];
      if(agent.match(/Version(\/| )([0-9]+\.[0-9])/)){

        version = RegExp.$2;
      };
      if(qx.bom.client.Engine.getName() == "mshtml"){

        version = qx.bom.client.Engine.getVersion();
        if(name === "msie" && qx.bom.client.OperatingSystem.getVersion() == "ce"){

          version = "5.0";
        };
      };
      if(qx.bom.client.Browser.getName() == "maple"){

        reg = new RegExp("(Maple )([0-9]+\.[0-9]+\.[0-9]*)");
        match = agent.match(reg);
        if(!match){

          return "";
        };
        version = match[2];
      };
      if(qx.bom.client.Engine.getName() == "webkit" || qx.bom.client.Browser.getName() == "opera"){

        if(agent.match(/OPR(\/| )([0-9]+\.[0-9])/)){

          version = RegExp.$2;
        };
      };
      return version;
    },
    getDocumentMode : function(){

      if(document.documentMode){

        return document.documentMode;
      };
      return 0;
    },
    getQuirksMode : function(){

      if(qx.bom.client.Engine.getName() == "mshtml" && parseFloat(qx.bom.client.Engine.getVersion()) >= 8){

        return qx.bom.client.Engine.DOCUMENT_MODE === 5;
      } else {

        return document.compatMode !== "CSS1Compat";
      };
    },
    __agents : {
      "webkit" : "AdobeAIR|Titanium|Fluid|Chrome|Android|Epiphany|Konqueror|iCab|iPad|iPhone|OmniWeb|Maxthon|Pre|PhantomJS|Mobile Safari|Safari",
      "gecko" : "prism|Fennec|Camino|Kmeleon|Galeon|Netscape|SeaMonkey|Namoroka|Firefox",
      "mshtml" : "IEMobile|Maxthon|MSIE|Trident",
      "opera" : "Opera Mini|Opera Mobi|Opera"
    }[qx.bom.client.Engine.getName()]
  },
  defer : function(statics){

    qx.core.Environment.add("browser.name", statics.getName);
    qx.core.Environment.add("browser.version", statics.getVersion);
    qx.core.Environment.add("browser.documentmode", statics.getDocumentMode);
    qx.core.Environment.add("browser.quirksmode", statics.getQuirksMode);
  }
});

qx.Bootstrap.define("qx.bom.client.CssTransition", {
  statics : {
    getTransitionName : function(){

      return qx.bom.Style.getPropertyName("transition");
    },
    getSupport : function(){

      var name = qx.bom.client.CssTransition.getTransitionName();
      if(!name){

        return null;
      };
      var eventName = qx.bom.Event.getEventName(window, "transitionEnd");
      eventName = eventName == "transitionEnd" ? eventName.toLowerCase() : eventName;
      if(!eventName){

        eventName = name + (name.indexOf("Trans") > 0 ? "E" : "e") + "nd";
      };
      return {
        name : name,
        "end-event" : eventName
      };
    }
  },
  defer : function(statics){

    qx.core.Environment.add("css.transition", statics.getSupport);
  }
});

qx.Class.define("qx.event.Manager", {
  extend : Object,
  construct : function(win, registration){

    this.__window = win;
    this.__windowId = qx.core.ObjectRegistry.toHashCode(win);
    this.__registration = registration;
    if(win.qx !== qx){

      var self = this;
      qx.bom.Event.addNativeListener(win, "unload", qx.event.GlobalError.observeMethod(function(){

        qx.bom.Event.removeNativeListener(win, "unload", arguments.callee);
        self.dispose();
      }));
    };
    this.__listeners = {
    };
    this.__handlers = {
    };
    this.__dispatchers = {
    };
    this.__handlerCache = {
    };
  },
  statics : {
    __lastUnique : 0,
    getNextUniqueId : function(){

      return (this.__lastUnique++) + "";
    }
  },
  members : {
    __registration : null,
    __listeners : null,
    __dispatchers : null,
    __disposeWrapper : null,
    __handlers : null,
    __handlerCache : null,
    __window : null,
    __windowId : null,
    getWindow : function(){

      return this.__window;
    },
    getWindowId : function(){

      return this.__windowId;
    },
    getHandler : function(clazz){

      var handler = this.__handlers[clazz.classname];
      if(handler){

        return handler;
      };
      return this.__handlers[clazz.classname] = new clazz(this);
    },
    getDispatcher : function(clazz){

      var dispatcher = this.__dispatchers[clazz.classname];
      if(dispatcher){

        return dispatcher;
      };
      return this.__dispatchers[clazz.classname] = new clazz(this, this.__registration);
    },
    getListeners : function(target, type, capture){

      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
      var targetMap = this.__listeners[targetKey];
      if(!targetMap){

        return null;
      };
      var entryKey = type + (capture ? "|capture" : "|bubble");
      var entryList = targetMap[entryKey];
      return entryList ? entryList.concat() : null;
    },
    getAllListeners : function(){

      return this.__listeners;
    },
    serializeListeners : function(target){

      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
      var targetMap = this.__listeners[targetKey];
      var result = [];
      if(targetMap){

        var indexOf,type,capture,entryList,entry;
        for(var entryKey in targetMap){

          indexOf = entryKey.indexOf("|");
          type = entryKey.substring(0, indexOf);
          capture = entryKey.charAt(indexOf + 1) == "c";
          entryList = targetMap[entryKey];
          for(var i = 0,l = entryList.length;i < l;i++){

            entry = entryList[i];
            result.push({
              self : entry.context,
              handler : entry.handler,
              type : type,
              capture : capture
            });
          };
        };
      };
      return result;
    },
    toggleAttachedEvents : function(target, enable){

      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
      var targetMap = this.__listeners[targetKey];
      if(targetMap){

        var indexOf,type,capture,entryList;
        for(var entryKey in targetMap){

          indexOf = entryKey.indexOf("|");
          type = entryKey.substring(0, indexOf);
          capture = entryKey.charCodeAt(indexOf + 1) === 99;
          entryList = targetMap[entryKey];
          if(enable){

            this.__registerAtHandler(target, type, capture);
          } else {

            this.__unregisterAtHandler(target, type, capture);
          };
        };
      };
    },
    hasListener : function(target, type, capture){

      if(qx.core.Environment.get("qx.debug")){

        if(target == null){

          qx.log.Logger.trace(this);
          throw new Error("Invalid object: " + target);
        };
      };
      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
      var targetMap = this.__listeners[targetKey];
      if(!targetMap){

        return false;
      };
      var entryKey = type + (capture ? "|capture" : "|bubble");
      var entryList = targetMap[entryKey];
      return !!(entryList && entryList.length > 0);
    },
    importListeners : function(target, list){

      if(qx.core.Environment.get("qx.debug")){

        if(target == null){

          qx.log.Logger.trace(this);
          throw new Error("Invalid object: " + target);
        };
      };
      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
      var targetMap = this.__listeners[targetKey] = {
      };
      var clazz = qx.event.Manager;
      for(var listKey in list){

        var item = list[listKey];
        var entryKey = item.type + (item.capture ? "|capture" : "|bubble");
        var entryList = targetMap[entryKey];
        if(!entryList){

          entryList = targetMap[entryKey] = [];
          this.__registerAtHandler(target, item.type, item.capture);
        };
        entryList.push({
          handler : item.listener,
          context : item.self,
          unique : item.unique || (clazz.__lastUnique++) + ""
        });
      };
    },
    addListener : function(target, type, listener, self, capture){

      if(qx.core.Environment.get("qx.debug")){

        var msg = "Failed to add event listener for type '" + type + "'" + " to the target '" + target.classname + "': ";
        qx.core.Assert.assertObject(target, msg + "Invalid Target.");
        qx.core.Assert.assertString(type, msg + "Invalid event type.");
        qx.core.Assert.assertFunction(listener, msg + "Invalid callback function");
        if(capture !== undefined){

          qx.core.Assert.assertBoolean(capture, "Invalid capture flag.");
        };
      };
      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
      var targetMap = this.__listeners[targetKey];
      if(!targetMap){

        targetMap = this.__listeners[targetKey] = {
        };
      };
      var entryKey = type + (capture ? "|capture" : "|bubble");
      var entryList = targetMap[entryKey];
      if(!entryList){

        entryList = targetMap[entryKey] = [];
      };
      if(entryList.length === 0){

        this.__registerAtHandler(target, type, capture);
      };
      var unique = (qx.event.Manager.__lastUnique++) + "";
      var entry = {
        handler : listener,
        context : self,
        unique : unique
      };
      entryList.push(entry);
      return entryKey + "|" + unique;
    },
    findHandler : function(target, type){

      var isDomNode = false,isWindow = false,isObject = false,isDocument = false;
      var key;
      if(target.nodeType === 1){

        isDomNode = true;
        key = "DOM_" + target.tagName.toLowerCase() + "_" + type;
      } else if(target.nodeType === 9){

        isDocument = true;
        key = "DOCUMENT_" + type;
      } else if(target == this.__window){

        isWindow = true;
        key = "WIN_" + type;
      } else if(target.classname){

        isObject = true;
        key = "QX_" + target.classname + "_" + type;
      } else {

        key = "UNKNOWN_" + target + "_" + type;
      };;;
      var cache = this.__handlerCache;
      if(cache[key]){

        return cache[key];
      };
      var classes = this.__registration.getHandlers();
      var IEventHandler = qx.event.IEventHandler;
      var clazz,instance,supportedTypes,targetCheck;
      for(var i = 0,l = classes.length;i < l;i++){

        clazz = classes[i];
        supportedTypes = clazz.SUPPORTED_TYPES;
        if(supportedTypes && !supportedTypes[type]){

          continue;
        };
        targetCheck = clazz.TARGET_CHECK;
        if(targetCheck){

          var found = false;
          if(isDomNode && ((targetCheck & IEventHandler.TARGET_DOMNODE) != 0)){

            found = true;
          } else if(isWindow && ((targetCheck & IEventHandler.TARGET_WINDOW) != 0)){

            found = true;
          } else if(isObject && ((targetCheck & IEventHandler.TARGET_OBJECT) != 0)){

            found = true;
          } else if(isDocument && ((targetCheck & IEventHandler.TARGET_DOCUMENT) != 0)){

            found = true;
          };;;
          if(!found){

            continue;
          };
        };
        instance = this.getHandler(classes[i]);
        if(clazz.IGNORE_CAN_HANDLE || instance.canHandleEvent(target, type)){

          cache[key] = instance;
          return instance;
        };
      };
      return null;
    },
    __registerAtHandler : function(target, type, capture){

      var handler = this.findHandler(target, type);
      if(handler){

        handler.registerEvent(target, type, capture);
        return;
      };
      if(qx.core.Environment.get("qx.debug")){

        qx.log.Logger.warn(this, "There is no event handler for the event '" + type + "' on target '" + target + "'!");
      };
    },
    removeListener : function(target, type, listener, self, capture){

      if(qx.core.Environment.get("qx.debug")){

        var msg = "Failed to remove event listener for type '" + type + "'" + " from the target '" + target.classname + "': ";
        qx.core.Assert.assertObject(target, msg + "Invalid Target.");
        qx.core.Assert.assertString(type, msg + "Invalid event type.");
        qx.core.Assert.assertFunction(listener, msg + "Invalid callback function");
        if(self !== undefined){

          qx.core.Assert.assertObject(self, "Invalid context for callback.");
        };
        if(capture !== undefined){

          qx.core.Assert.assertBoolean(capture, "Invalid capture flag.");
        };
      };
      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
      var targetMap = this.__listeners[targetKey];
      if(!targetMap){

        return false;
      };
      var entryKey = type + (capture ? "|capture" : "|bubble");
      var entryList = targetMap[entryKey];
      if(!entryList){

        return false;
      };
      var entry;
      for(var i = 0,l = entryList.length;i < l;i++){

        entry = entryList[i];
        if(entry.handler === listener && entry.context === self){

          qx.lang.Array.removeAt(entryList, i);
          if(entryList.length == 0){

            this.__unregisterAtHandler(target, type, capture);
          };
          return true;
        };
      };
      return false;
    },
    removeListenerById : function(target, id){

      if(qx.core.Environment.get("qx.debug")){

        var msg = "Failed to remove event listener for id '" + id + "'" + " from the target '" + target.classname + "': ";
        qx.core.Assert.assertObject(target, msg + "Invalid Target.");
        qx.core.Assert.assertString(id, msg + "Invalid id type.");
      };
      var split = id.split("|");
      var type = split[0];
      var capture = split[1].charCodeAt(0) == 99;
      var unique = split[2];
      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
      var targetMap = this.__listeners[targetKey];
      if(!targetMap){

        return false;
      };
      var entryKey = type + (capture ? "|capture" : "|bubble");
      var entryList = targetMap[entryKey];
      if(!entryList){

        return false;
      };
      var entry;
      for(var i = 0,l = entryList.length;i < l;i++){

        entry = entryList[i];
        if(entry.unique === unique){

          qx.lang.Array.removeAt(entryList, i);
          if(entryList.length == 0){

            this.__unregisterAtHandler(target, type, capture);
          };
          return true;
        };
      };
      return false;
    },
    removeAllListeners : function(target){

      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
      var targetMap = this.__listeners[targetKey];
      if(!targetMap){

        return false;
      };
      var split,type,capture;
      for(var entryKey in targetMap){

        if(targetMap[entryKey].length > 0){

          split = entryKey.split("|");
          type = split[0];
          capture = split[1] === "capture";
          this.__unregisterAtHandler(target, type, capture);
        };
      };
      delete this.__listeners[targetKey];
      return true;
    },
    deleteAllListeners : function(targetKey){

      delete this.__listeners[targetKey];
    },
    __unregisterAtHandler : function(target, type, capture){

      var handler = this.findHandler(target, type);
      if(handler){

        handler.unregisterEvent(target, type, capture);
        return;
      };
      if(qx.core.Environment.get("qx.debug")){

        qx.log.Logger.warn(this, "There is no event handler for the event '" + type + "' on target '" + target + "'!");
      };
    },
    dispatchEvent : function(target, event){

      if(qx.core.Environment.get("qx.debug")){

        var msg = "Could not dispatch event '" + event + "' on target '" + target.classname + "': ";
        qx.core.Assert.assertNotUndefined(target, msg + "Invalid event target.");
        qx.core.Assert.assertNotNull(target, msg + "Invalid event target.");
        qx.core.Assert.assertInstance(event, qx.event.type.Event, msg + "Invalid event object.");
      };
      var type = event.getType();
      if(!event.getBubbles() && !this.hasListener(target, type)){

        qx.event.Pool.getInstance().poolObject(event);
        return true;
      };
      if(!event.getTarget()){

        event.setTarget(target);
      };
      var classes = this.__registration.getDispatchers();
      var instance;
      var dispatched = false;
      for(var i = 0,l = classes.length;i < l;i++){

        instance = this.getDispatcher(classes[i]);
        if(instance.canDispatchEvent(target, event, type)){

          instance.dispatchEvent(target, event, type);
          dispatched = true;
          break;
        };
      };
      if(!dispatched){

        if(qx.core.Environment.get("qx.debug")){

          qx.log.Logger.error(this, "No dispatcher can handle event of type " + type + " on " + target);
        };
        return true;
      };
      var preventDefault = event.getDefaultPrevented();
      qx.event.Pool.getInstance().poolObject(event);
      return !preventDefault;
    },
    dispose : function(){

      this.__registration.removeManager(this);
      qx.util.DisposeUtil.disposeMap(this, "__handlers");
      qx.util.DisposeUtil.disposeMap(this, "__dispatchers");
      this.__listeners = this.__window = this.__disposeWrapper = null;
      this.__registration = this.__handlerCache = null;
    }
  }
});

qx.Interface.define("qx.event.IEventHandler", {
  statics : {
    TARGET_DOMNODE : 1,
    TARGET_WINDOW : 2,
    TARGET_OBJECT : 4,
    TARGET_DOCUMENT : 8
  },
  members : {
    canHandleEvent : function(target, type){
    },
    registerEvent : function(target, type, capture){
    },
    unregisterEvent : function(target, type, capture){
    }
  }
});

qx.Class.define("qx.event.Registration", {
  statics : {
    __managers : {
    },
    getManager : function(target){

      if(target == null){

        if(qx.core.Environment.get("qx.debug")){

          qx.log.Logger.error("qx.event.Registration.getManager(null) was called!");
          qx.log.Logger.trace(this);
        };
        target = window;
      } else if(target.nodeType){

        target = qx.dom.Node.getWindow(target);
      } else if(!qx.dom.Node.isWindow(target)){

        target = window;
      };;
      var hash = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
      var manager = this.__managers[hash];
      if(!manager){

        manager = new qx.event.Manager(target, this);
        this.__managers[hash] = manager;
      };
      return manager;
    },
    removeManager : function(mgr){

      var id = mgr.getWindowId();
      delete this.__managers[id];
    },
    addListener : function(target, type, listener, self, capture){

      return this.getManager(target).addListener(target, type, listener, self, capture);
    },
    removeListener : function(target, type, listener, self, capture){

      return this.getManager(target).removeListener(target, type, listener, self, capture);
    },
    removeListenerById : function(target, id){

      return this.getManager(target).removeListenerById(target, id);
    },
    removeAllListeners : function(target){

      return this.getManager(target).removeAllListeners(target);
    },
    deleteAllListeners : function(target){

      var targetKey = target.$$hash;
      if(targetKey){

        this.getManager(target).deleteAllListeners(targetKey);
      };
    },
    hasListener : function(target, type, capture){

      return this.getManager(target).hasListener(target, type, capture);
    },
    serializeListeners : function(target){

      return this.getManager(target).serializeListeners(target);
    },
    createEvent : function(type, clazz, args){

      if(qx.core.Environment.get("qx.debug")){

        if(arguments.length > 1 && clazz === undefined){

          throw new Error("Create event of type " + type + " with undefined class. Please use null to explicit fallback to default event type!");
        };
      };
      if(clazz == null){

        clazz = qx.event.type.Event;
      };
      var obj = qx.event.Pool.getInstance().getObject(clazz);
      args ? obj.init.apply(obj, args) : obj.init();
      if(type){

        obj.setType(type);
      };
      return obj;
    },
    dispatchEvent : function(target, event){

      return this.getManager(target).dispatchEvent(target, event);
    },
    fireEvent : function(target, type, clazz, args){

      if(qx.core.Environment.get("qx.debug")){

        if(arguments.length > 2 && clazz === undefined && args !== undefined){

          throw new Error("Create event of type " + type + " with undefined class. Please use null to explicit fallback to default event type!");
        };
        var msg = "Could not fire event '" + type + "' on target '" + (target ? target.classname : "undefined") + "': ";
        qx.core.Assert.assertNotUndefined(target, msg + "Invalid event target.");
        qx.core.Assert.assertNotNull(target, msg + "Invalid event target.");
      };
      var evt = this.createEvent(type, clazz || null, args);
      return this.getManager(target).dispatchEvent(target, evt);
    },
    fireNonBubblingEvent : function(target, type, clazz, args){

      if(qx.core.Environment.get("qx.debug")){

        if(arguments.length > 2 && clazz === undefined && args !== undefined){

          throw new Error("Create event of type " + type + " with undefined class. Please use null to explicit fallback to default event type!");
        };
      };
      var mgr = this.getManager(target);
      if(!mgr.hasListener(target, type, false)){

        return true;
      };
      var evt = this.createEvent(type, clazz || null, args);
      return mgr.dispatchEvent(target, evt);
    },
    PRIORITY_FIRST : -32000,
    PRIORITY_NORMAL : 0,
    PRIORITY_LAST : 32000,
    __handlers : [],
    addHandler : function(handler){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert.assertInterface(handler, qx.event.IEventHandler, "Invalid event handler.");
      };
      this.__handlers.push(handler);
      this.__handlers.sort(function(a, b){

        return a.PRIORITY - b.PRIORITY;
      });
    },
    getHandlers : function(){

      return this.__handlers;
    },
    __dispatchers : [],
    addDispatcher : function(dispatcher, priority){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert.assertInterface(dispatcher, qx.event.IEventDispatcher, "Invalid event dispatcher!");
      };
      this.__dispatchers.push(dispatcher);
      this.__dispatchers.sort(function(a, b){

        return a.PRIORITY - b.PRIORITY;
      });
    },
    getDispatchers : function(){

      return this.__dispatchers;
    }
  }
});

qx.Mixin.define("qx.core.MEvent", {
  members : {
    __Registration : qx.event.Registration,
    addListener : function(type, listener, self, capture){

      if(!this.$$disposed){

        return this.__Registration.addListener(this, type, listener, self, capture);
      };
      return null;
    },
    addListenerOnce : function(type, listener, self, capture){

      var callback = function(e){

        this.removeListener(type, listener, this, capture);
        listener.call(self || this, e);
      };
      if(!listener.$$wrapped_callback){

        listener.$$wrapped_callback = {
        };
      };
      listener.$$wrapped_callback[type + this.$$hash] = callback;
      return this.addListener(type, callback, this, capture);
    },
    removeListener : function(type, listener, self, capture){

      if(!this.$$disposed){

        if(listener.$$wrapped_callback && listener.$$wrapped_callback[type + this.$$hash]){

          var callback = listener.$$wrapped_callback[type + this.$$hash];
          delete listener.$$wrapped_callback[type + this.$$hash];
          listener = callback;
        };
        return this.__Registration.removeListener(this, type, listener, self, capture);
      };
      return false;
    },
    removeListenerById : function(id){

      if(!this.$$disposed){

        return this.__Registration.removeListenerById(this, id);
      };
      return false;
    },
    hasListener : function(type, capture){

      return this.__Registration.hasListener(this, type, capture);
    },
    dispatchEvent : function(evt){

      if(!this.$$disposed){

        return this.__Registration.dispatchEvent(this, evt);
      };
      return true;
    },
    fireEvent : function(type, clazz, args){

      if(!this.$$disposed){

        return this.__Registration.fireEvent(this, type, clazz, args);
      };
      return true;
    },
    fireNonBubblingEvent : function(type, clazz, args){

      if(!this.$$disposed){

        return this.__Registration.fireNonBubblingEvent(this, type, clazz, args);
      };
      return true;
    },
    fireDataEvent : function(type, data, oldData, cancelable){

      if(!this.$$disposed){

        if(oldData === undefined){

          oldData = null;
        };
        return this.__Registration.fireNonBubblingEvent(this, type, qx.event.type.Data, [data, oldData, !!cancelable]);
      };
      return true;
    }
  }
});

qx.Mixin.define("qx.core.MProperty", {
  members : {
    set : function(data, value){

      var setter = qx.core.Property.$$method.set;
      if(qx.Bootstrap.isString(data)){

        if(!this[setter[data]]){

          if(this["set" + qx.Bootstrap.firstUp(data)] != undefined){

            this["set" + qx.Bootstrap.firstUp(data)](value);
            return this;
          };
          throw new Error("No such property: " + data);
        };
        return this[setter[data]](value);
      } else {

        for(var prop in data){

          if(!this[setter[prop]]){

            if(this["set" + qx.Bootstrap.firstUp(prop)] != undefined){

              this["set" + qx.Bootstrap.firstUp(prop)](data[prop]);
              continue;
            };
            throw new Error("No such property: " + prop);
          };
          this[setter[prop]](data[prop]);
        };
        return this;
      };
    },
    get : function(prop){

      var getter = qx.core.Property.$$method.get;
      if(!this[getter[prop]]){

        if(this["get" + qx.Bootstrap.firstUp(prop)] != undefined){

          return this["get" + qx.Bootstrap.firstUp(prop)]();
        };
        throw new Error("No such property: " + prop);
      };
      return this[getter[prop]]();
    },
    reset : function(prop){

      var resetter = qx.core.Property.$$method.reset;
      if(!this[resetter[prop]]){

        if(this["reset" + qx.Bootstrap.firstUp(prop)] != undefined){

          this["reset" + qx.Bootstrap.firstUp(prop)]();
          return;
        };
        throw new Error("No such property: " + prop);
      };
      this[resetter[prop]]();
    }
  }
});

qx.Mixin.define("qx.core.MAssert", {
  members : {
    assert : function(condition, msg){

      qx.core.Assert.assert(condition, msg);
    },
    fail : function(msg, compact){

      qx.core.Assert.fail(msg, compact);
    },
    assertTrue : function(value, msg){

      qx.core.Assert.assertTrue(value, msg);
    },
    assertFalse : function(value, msg){

      qx.core.Assert.assertFalse(value, msg);
    },
    assertEquals : function(expected, found, msg){

      qx.core.Assert.assertEquals(expected, found, msg);
    },
    assertNotEquals : function(expected, found, msg){

      qx.core.Assert.assertNotEquals(expected, found, msg);
    },
    assertIdentical : function(expected, found, msg){

      qx.core.Assert.assertIdentical(expected, found, msg);
    },
    assertNotIdentical : function(expected, found, msg){

      qx.core.Assert.assertNotIdentical(expected, found, msg);
    },
    assertNotUndefined : function(value, msg){

      qx.core.Assert.assertNotUndefined(value, msg);
    },
    assertUndefined : function(value, msg){

      qx.core.Assert.assertUndefined(value, msg);
    },
    assertNotNull : function(value, msg){

      qx.core.Assert.assertNotNull(value, msg);
    },
    assertNull : function(value, msg){

      qx.core.Assert.assertNull(value, msg);
    },
    assertJsonEquals : function(expected, found, msg){

      qx.core.Assert.assertJsonEquals(expected, found, msg);
    },
    assertMatch : function(str, re, msg){

      qx.core.Assert.assertMatch(str, re, msg);
    },
    assertArgumentsCount : function(args, minCount, maxCount, msg){

      qx.core.Assert.assertArgumentsCount(args, minCount, maxCount, msg);
    },
    assertEventFired : function(obj, event, invokeFunc, listener, msg){

      qx.core.Assert.assertEventFired(obj, event, invokeFunc, listener, msg);
    },
    assertEventNotFired : function(obj, event, invokeFunc, msg){

      qx.core.Assert.assertEventNotFired(obj, event, invokeFunc, msg);
    },
    assertException : function(callback, exception, re, msg){

      qx.core.Assert.assertException(callback, exception, re, msg);
    },
    assertInArray : function(value, array, msg){

      qx.core.Assert.assertInArray(value, array, msg);
    },
    assertArrayEquals : function(expected, found, msg){

      qx.core.Assert.assertArrayEquals(expected, found, msg);
    },
    assertKeyInMap : function(value, map, msg){

      qx.core.Assert.assertKeyInMap(value, map, msg);
    },
    assertFunction : function(value, msg){

      qx.core.Assert.assertFunction(value, msg);
    },
    assertString : function(value, msg){

      qx.core.Assert.assertString(value, msg);
    },
    assertBoolean : function(value, msg){

      qx.core.Assert.assertBoolean(value, msg);
    },
    assertNumber : function(value, msg){

      qx.core.Assert.assertNumber(value, msg);
    },
    assertPositiveNumber : function(value, msg){

      qx.core.Assert.assertPositiveNumber(value, msg);
    },
    assertInteger : function(value, msg){

      qx.core.Assert.assertInteger(value, msg);
    },
    assertPositiveInteger : function(value, msg){

      qx.core.Assert.assertPositiveInteger(value, msg);
    },
    assertInRange : function(value, min, max, msg){

      qx.core.Assert.assertInRange(value, min, max, msg);
    },
    assertObject : function(value, msg){

      qx.core.Assert.assertObject(value, msg);
    },
    assertArray : function(value, msg){

      qx.core.Assert.assertArray(value, msg);
    },
    assertMap : function(value, msg){

      qx.core.Assert.assertMap(value, msg);
    },
    assertRegExp : function(value, msg){

      qx.core.Assert.assertRegExp(value, msg);
    },
    assertType : function(value, type, msg){

      qx.core.Assert.assertType(value, type, msg);
    },
    assertInstance : function(value, clazz, msg){

      qx.core.Assert.assertInstance(value, clazz, msg);
    },
    assertInterface : function(value, iface, msg){

      qx.core.Assert.assertInterface(value, iface, msg);
    },
    assertCssColor : function(expected, value, msg){

      qx.core.Assert.assertCssColor(expected, value, msg);
    },
    assertElement : function(value, msg){

      qx.core.Assert.assertElement(value, msg);
    },
    assertQxObject : function(value, msg){

      qx.core.Assert.assertQxObject(value, msg);
    },
    assertQxWidget : function(value, msg){

      qx.core.Assert.assertQxWidget(value, msg);
    }
  }
});

qx.Class.define("qx.core.Object", {
  extend : Object,
  include : qx.core.Environment.filter({
    "module.databinding" : qx.data.MBinding,
    "module.logger" : qx.core.MLogging,
    "module.events" : qx.core.MEvent,
    "module.property" : qx.core.MProperty,
    "qx.debug" : qx.core.MAssert
  }),
  construct : function(){

    qx.core.ObjectRegistry.register(this);
  },
  statics : {
    $$type : "Object"
  },
  members : {
    __Property : qx.core.Environment.get("module.property") ? qx.core.Property : null,
    toHashCode : function(){

      return this.$$hash;
    },
    toString : function(){

      return this.classname + "[" + this.$$hash + "]";
    },
    base : function(args, varargs){

      if(qx.core.Environment.get("qx.debug")){

        if(!qx.Bootstrap.isFunction(args.callee.base)){

          throw new Error("Cannot call super class. Method is not derived: " + args.callee.displayName);
        };
      };
      if(arguments.length === 1){

        return args.callee.base.call(this);
      } else {

        return args.callee.base.apply(this, Array.prototype.slice.call(arguments, 1));
      };
    },
    self : function(args){

      return args.callee.self;
    },
    clone : function(){

      if(!qx.core.Environment.get("module.property")){

        throw new Error("Cloning only possible with properties.");
      };
      var clazz = this.constructor;
      var clone = new clazz;
      var props = qx.Class.getProperties(clazz);
      var user = this.__Property.$$store.user;
      var setter = this.__Property.$$method.set;
      var name;
      for(var i = 0,l = props.length;i < l;i++){

        name = props[i];
        if(this.hasOwnProperty(user[name])){

          clone[setter[name]](this[user[name]]);
        };
      };
      return clone;
    },
    __userData : null,
    setUserData : function(key, value){

      if(!this.__userData){

        this.__userData = {
        };
      };
      this.__userData[key] = value;
    },
    getUserData : function(key){

      if(!this.__userData){

        return null;
      };
      var data = this.__userData[key];
      return data === undefined ? null : data;
    },
    isDisposed : function(){

      return this.$$disposed || false;
    },
    dispose : function(){

      if(this.$$disposed){

        return;
      };
      this.$$disposed = true;
      this.$$instance = null;
      this.$$allowconstruct = null;
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.dispose.level") > 2){

          qx.Bootstrap.debug(this, "Disposing " + this.classname + "[" + this.toHashCode() + "]");
        };
      };
      var clazz = this.constructor;
      var mixins;
      while(clazz.superclass){

        if(clazz.$$destructor){

          clazz.$$destructor.call(this);
        };
        if(clazz.$$includes){

          mixins = clazz.$$flatIncludes;
          for(var i = 0,l = mixins.length;i < l;i++){

            if(mixins[i].$$destructor){

              mixins[i].$$destructor.call(this);
            };
          };
        };
        clazz = clazz.superclass;
      };
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.dispose.level") > 0){

          var key,value;
          for(key in this){

            value = this[key];
            if(value !== null && typeof value === "object" && !(qx.Bootstrap.isString(value))){

              if(this.constructor.prototype[key] != null){

                continue;
              };
              if(qx.core.Environment.get("qx.debug.dispose.level") > 1){

                qx.Bootstrap.warn(this, "Missing destruct definition for '" + key + "' in " + this.classname + "[" + this.toHashCode() + "]: " + value);
                delete this[key];
              };
            };
          };
        };
      };
    },
    _disposeObjects : function(varargs){

      qx.util.DisposeUtil.disposeObjects(this, arguments);
    },
    _disposeSingletonObjects : function(varargs){

      qx.util.DisposeUtil.disposeObjects(this, arguments, true);
    },
    _disposeArray : function(field){

      qx.util.DisposeUtil.disposeArray(this, field);
    },
    _disposeMap : function(field){

      qx.util.DisposeUtil.disposeMap(this, field);
    }
  },
  environment : {
    "qx.debug.dispose.level" : 0
  },
  destruct : function(){

    if(qx.core.Environment.get("module.events")){

      if(!qx.core.ObjectRegistry.inShutDown){

        qx.event.Registration.removeAllListeners(this);
      } else {

        qx.event.Registration.deleteAllListeners(this);
      };
    };
    qx.core.ObjectRegistry.unregister(this);
    this.__userData = null;
    if(qx.core.Environment.get("module.property")){

      var clazz = this.constructor;
      var properties;
      var store = this.__Property.$$store;
      var storeUser = store.user;
      var storeTheme = store.theme;
      var storeInherit = store.inherit;
      var storeUseinit = store.useinit;
      var storeInit = store.init;
      while(clazz){

        properties = clazz.$$properties;
        if(properties){

          for(var name in properties){

            if(properties[name].dereference){

              this[storeUser[name]] = this[storeTheme[name]] = this[storeInherit[name]] = this[storeUseinit[name]] = this[storeInit[name]] = undefined;
            };
          };
        };
        clazz = clazz.superclass;
      };
    };
  }
});

qx.Class.define("qx.util.DisposeUtil", {
  statics : {
    disposeObjects : function(obj, arr, disposeSingletons){

      var name;
      for(var i = 0,l = arr.length;i < l;i++){

        name = arr[i];
        if(obj[name] == null || !obj.hasOwnProperty(name)){

          continue;
        };
        if(!qx.core.ObjectRegistry.inShutDown){

          if(obj[name].dispose){

            if(!disposeSingletons && obj[name].constructor.$$instance){

              throw new Error("The object stored in key " + name + " is a singleton! Please use disposeSingleton instead.");
            } else {

              obj[name].dispose();
            };
          } else {

            throw new Error("Has no disposable object under key: " + name + "!");
          };
        };
        obj[name] = null;
      };
    },
    disposeArray : function(obj, field){

      var data = obj[field];
      if(!data){

        return;
      };
      if(qx.core.ObjectRegistry.inShutDown){

        obj[field] = null;
        return;
      };
      try{

        var entry;
        for(var i = data.length - 1;i >= 0;i--){

          entry = data[i];
          if(entry){

            entry.dispose();
          };
        };
      } catch(ex) {

        throw new Error("The array field: " + field + " of object: " + obj + " has non disposable entries: " + ex);
      };
      data.length = 0;
      obj[field] = null;
    },
    disposeMap : function(obj, field){

      var data = obj[field];
      if(!data){

        return;
      };
      if(qx.core.ObjectRegistry.inShutDown){

        obj[field] = null;
        return;
      };
      try{

        var entry;
        for(var key in data){

          entry = data[key];
          if(data.hasOwnProperty(key) && entry){

            entry.dispose();
          };
        };
      } catch(ex) {

        throw new Error("The map field: " + field + " of object: " + obj + " has non disposable entries: " + ex);
      };
      obj[field] = null;
    },
    disposeTriggeredBy : function(disposeMe, trigger){

      var triggerDispose = trigger.dispose;
      trigger.dispose = function(){

        triggerDispose.call(trigger);
        disposeMe.dispose();
      };
    },
    destroyContainer : function(container){

      if(qx.core.Environment.get("qx.debug")){

        if(qx.ui.mobile && container instanceof qx.ui.mobile.core.Widget){

          qx.core.Assert.assertTrue(this.__isChildrenContainer(container), "Container must be an instance of qx.ui.mobile.container.Composite.");
        } else {

          qx.core.Assert.assertQxWidget(container, "First argument must be a container widget!");
          qx.core.Assert.assertTrue(this.__isChildrenContainer(container), "Container must be an instance of qx.ui.container.Composite or " + "qx.ui.container.Scroll or qx.ui.container.Resizer or " + "qx.ui.container.SlideBar or qx.ui.container.Stack!");
        };
      };
      var arr = [];
      this._collectContainerChildren(container, arr);
      var len = arr.length;
      for(var i = len - 1;i >= 0;i--){

        arr[i].destroy();
      };
      container.destroy();
    },
    _collectContainerChildren : function(container, arr){

      var children = container.getChildren();
      for(var i = 0;i < children.length;i++){

        var item = children[i];
        arr.push(item);
        if(this.__isChildrenContainer(item)){

          this._collectContainerChildren(item, arr);
        };
      };
    },
    __isChildrenContainer : function(obj){

      var classes = [];
      if(qx.ui.mobile && obj instanceof qx.ui.mobile.core.Widget){

        classes = [qx.ui.mobile.container.Composite];
      } else {

        classes = [qx.ui.container.Composite, qx.ui.container.Scroll, qx.ui.container.SlideBar, qx.ui.container.Stack];
      };
      for(var i = 0,l = classes.length;i < l;i++){

        if(typeof classes[i] !== "undefined" && qx.Class.isSubClassOf(obj.constructor, classes[i])){

          return true;
        };
      };
      return false;
    }
  }
});

qx.Class.define("qx.event.handler.Object", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_LAST,
    SUPPORTED_TYPES : null,
    TARGET_CHECK : qx.event.IEventHandler.TARGET_OBJECT,
    IGNORE_CAN_HANDLE : false
  },
  members : {
    canHandleEvent : function(target, type){

      return qx.Class.supportsEvent(target.constructor, type);
    },
    registerEvent : function(target, type, capture){
    },
    unregisterEvent : function(target, type, capture){
    }
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
  }
});

qx.Interface.define("qx.event.IEventDispatcher", {
  members : {
    canDispatchEvent : function(target, event, type){

      this.assertInstance(event, qx.event.type.Event);
      this.assertString(type);
    },
    dispatchEvent : function(target, event, type){

      this.assertInstance(event, qx.event.type.Event);
      this.assertString(type);
    }
  }
});

qx.Class.define("qx.event.type.Event", {
  extend : qx.core.Object,
  statics : {
    CAPTURING_PHASE : 1,
    AT_TARGET : 2,
    BUBBLING_PHASE : 3
  },
  members : {
    init : function(canBubble, cancelable){

      if(qx.core.Environment.get("qx.debug")){

        if(canBubble !== undefined){

          qx.core.Assert.assertBoolean(canBubble, "Invalid argument value 'canBubble'.");
        };
        if(cancelable !== undefined){

          qx.core.Assert.assertBoolean(cancelable, "Invalid argument value 'cancelable'.");
        };
      };
      this._type = null;
      this._target = null;
      this._currentTarget = null;
      this._relatedTarget = null;
      this._originalTarget = null;
      this._stopPropagation = false;
      this._preventDefault = false;
      this._bubbles = !!canBubble;
      this._cancelable = !!cancelable;
      this._timeStamp = (new Date()).getTime();
      this._eventPhase = null;
      return this;
    },
    clone : function(embryo){

      if(embryo){

        var clone = embryo;
      } else {

        var clone = qx.event.Pool.getInstance().getObject(this.constructor);
      };
      clone._type = this._type;
      clone._target = this._target;
      clone._currentTarget = this._currentTarget;
      clone._relatedTarget = this._relatedTarget;
      clone._originalTarget = this._originalTarget;
      clone._stopPropagation = this._stopPropagation;
      clone._bubbles = this._bubbles;
      clone._preventDefault = this._preventDefault;
      clone._cancelable = this._cancelable;
      return clone;
    },
    stop : function(){

      if(this._bubbles){

        this.stopPropagation();
      };
      if(this._cancelable){

        this.preventDefault();
      };
    },
    stopPropagation : function(){

      if(qx.core.Environment.get("qx.debug")){

        this.assertTrue(this._bubbles, "Cannot stop propagation on a non bubbling event: " + this.getType());
      };
      this._stopPropagation = true;
    },
    getPropagationStopped : function(){

      return !!this._stopPropagation;
    },
    preventDefault : function(){

      if(qx.core.Environment.get("qx.debug")){

        this.assertTrue(this._cancelable, "Cannot prevent default action on a non cancelable event: " + this.getType());
      };
      this._preventDefault = true;
    },
    getDefaultPrevented : function(){

      return !!this._preventDefault;
    },
    getType : function(){

      return this._type;
    },
    setType : function(type){

      this._type = type;
    },
    getEventPhase : function(){

      return this._eventPhase;
    },
    setEventPhase : function(eventPhase){

      this._eventPhase = eventPhase;
    },
    getTimeStamp : function(){

      return this._timeStamp;
    },
    getTarget : function(){

      return this._target;
    },
    setTarget : function(target){

      this._target = target;
    },
    getCurrentTarget : function(){

      return this._currentTarget || this._target;
    },
    setCurrentTarget : function(currentTarget){

      this._currentTarget = currentTarget;
    },
    getRelatedTarget : function(){

      return this._relatedTarget;
    },
    setRelatedTarget : function(relatedTarget){

      this._relatedTarget = relatedTarget;
    },
    getOriginalTarget : function(){

      return this._originalTarget;
    },
    setOriginalTarget : function(originalTarget){

      this._originalTarget = originalTarget;
    },
    getBubbles : function(){

      return this._bubbles;
    },
    setBubbles : function(bubbles){

      this._bubbles = bubbles;
    },
    isCancelable : function(){

      return this._cancelable;
    },
    setCancelable : function(cancelable){

      this._cancelable = cancelable;
    }
  },
  destruct : function(){

    this._target = this._currentTarget = this._relatedTarget = this._originalTarget = null;
  }
});

qx.Class.define("qx.util.ObjectPool", {
  extend : qx.core.Object,
  construct : function(size){

    this.base(arguments);
    this.__pool = {
    };
    if(size != null){

      this.setSize(size);
    };
  },
  properties : {
    size : {
      check : "Integer",
      init : Infinity
    }
  },
  members : {
    __pool : null,
    getObject : function(clazz){

      if(this.$$disposed){

        return new clazz;
      };
      if(!clazz){

        throw new Error("Class needs to be defined!");
      };
      var obj = null;
      var pool = this.__pool[clazz.classname];
      if(pool){

        obj = pool.pop();
      };
      if(obj){

        obj.$$pooled = false;
      } else {

        obj = new clazz;
      };
      return obj;
    },
    poolObject : function(obj){

      if(!this.__pool){

        return;
      };
      var classname = obj.classname;
      var pool = this.__pool[classname];
      if(obj.$$pooled){

        throw new Error("Object is already pooled: " + obj);
      };
      if(!pool){

        this.__pool[classname] = pool = [];
      };
      if(pool.length > this.getSize()){

        if(obj.destroy){

          obj.destroy();
        } else {

          obj.dispose();
        };
        return;
      };
      obj.$$pooled = true;
      pool.push(obj);
    }
  },
  destruct : function(){

    var pool = this.__pool;
    var classname,list,i,l;
    for(classname in pool){

      list = pool[classname];
      for(i = 0,l = list.length;i < l;i++){

        list[i].dispose();
      };
    };
    delete this.__pool;
  }
});

qx.Class.define("qx.event.Pool", {
  extend : qx.util.ObjectPool,
  type : "singleton",
  construct : function(){

    this.base(arguments, 30);
  }
});

qx.Class.define("qx.event.dispatch.Direct", {
  extend : qx.core.Object,
  implement : qx.event.IEventDispatcher,
  construct : function(manager){

    this._manager = manager;
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_LAST
  },
  members : {
    canDispatchEvent : function(target, event, type){

      return !event.getBubbles();
    },
    dispatchEvent : function(target, event, type){

      if(qx.core.Environment.get("qx.debug")){

        if(target instanceof qx.core.Object){

          var expectedEventClassName = qx.Class.getEventType(target.constructor, type);
          var expectedEventClass = qx.Class.getByName(expectedEventClassName);
          if(!expectedEventClass){

            this.error("The event type '" + type + "' declared in the class '" + target.constructor + " is not an available class': " + expectedEventClassName);
          } else if(!(event instanceof expectedEventClass)){

            this.error("Expected event type to be instanceof '" + expectedEventClassName + "' but found '" + event.classname + "'");
          };
        };
      };
      event.setEventPhase(qx.event.type.Event.AT_TARGET);
      var listeners = this._manager.getListeners(target, type, false);
      if(listeners){

        for(var i = 0,l = listeners.length;i < l;i++){

          var context = listeners[i].context || target;
          if(qx.core.Environment.get("qx.debug")){

            if(context && context.isDisposed && context.isDisposed()){

              this.warn("The context object '" + context + "' for the event '" + type + "' of '" + target + "'is already disposed.");
            };
          };
          listeners[i].handler.call(context, event);
        };
      };
    }
  },
  defer : function(statics){

    qx.event.Registration.addDispatcher(statics);
  }
});

qx.Class.define("qx.event.type.Data", {
  extend : qx.event.type.Event,
  members : {
    __data : null,
    __old : null,
    init : function(data, old, cancelable){

      this.base(arguments, false, cancelable);
      this.__data = data;
      this.__old = old;
      return this;
    },
    clone : function(embryo){

      var clone = this.base(arguments, embryo);
      clone.__data = this.__data;
      clone.__old = this.__old;
      return clone;
    },
    getData : function(){

      return this.__data;
    },
    getOldData : function(){

      return this.__old;
    }
  },
  destruct : function(){

    this.__data = this.__old = null;
  }
});

qx.Mixin.define("qx.locale.MTranslation", {
  members : {
    tr : function(messageId, varargs){

      var nlsManager = qx.locale.Manager;
      if(nlsManager){

        return nlsManager.tr.apply(nlsManager, arguments);
      };
      throw new Error("To enable localization please include qx.locale.Manager into your build!");
    },
    trn : function(singularMessageId, pluralMessageId, count, varargs){

      var nlsManager = qx.locale.Manager;
      if(nlsManager){

        return nlsManager.trn.apply(nlsManager, arguments);
      };
      throw new Error("To enable localization please include qx.locale.Manager into your build!");
    },
    trc : function(hint, messageId, varargs){

      var nlsManager = qx.locale.Manager;
      if(nlsManager){

        return nlsManager.trc.apply(nlsManager, arguments);
      };
      throw new Error("To enable localization please include qx.locale.Manager into your build!");
    },
    trnc : function(hint, singularMessageId, pluralMessageId, count, varargs){

      var nlsManager = qx.locale.Manager;
      if(nlsManager){

        return nlsManager.trnc.apply(nlsManager, arguments);
      };
      throw new Error("To enable localization please include qx.locale.Manager into your build!");
    },
    marktr : function(messageId){

      var nlsManager = qx.locale.Manager;
      if(nlsManager){

        return nlsManager.marktr.apply(nlsManager, arguments);
      };
      throw new Error("To enable localization please include qx.locale.Manager into your build!");
    }
  }
});

qx.Interface.define("qx.application.IApplication", {
  members : {
    main : function(){
    },
    finalize : function(){
    },
    close : function(){
    },
    terminate : function(){
    }
  }
});

qx.Class.define("qx.core.BaseInit", {
  statics : {
    __application : null,
    getApplication : function(){

      return this.__application || null;
    },
    ready : function(){

      if(this.__application){

        return;
      };
      if(qx.core.Environment.get("engine.name") == ""){

        qx.log.Logger.warn("Could not detect engine!");
      };
      if(qx.core.Environment.get("engine.version") == ""){

        qx.log.Logger.warn("Could not detect the version of the engine!");
      };
      if(qx.core.Environment.get("os.name") == ""){

        qx.log.Logger.warn("Could not detect operating system!");
      };
      qx.log.Logger.debug(this, "Load runtime: " + (new Date - qx.Bootstrap.LOADSTART) + "ms");
      var app = qx.core.Environment.get("qx.application");
      var clazz = qx.Class.getByName(app);
      if(clazz){

        this.__application = new clazz;
        var start = new Date;
        this.__application.main();
        qx.log.Logger.debug(this, "Main runtime: " + (new Date - start) + "ms");
        var start = new Date;
        this.__application.finalize();
        qx.log.Logger.debug(this, "Finalize runtime: " + (new Date - start) + "ms");
      } else {

        qx.log.Logger.warn("Missing application class: " + app);
      };
    },
    __close : function(e){

      var app = this.__application;
      if(app){

        app.close();
      };
    },
    __shutdown : function(){

      var app = this.__application;
      if(app){

        app.terminate();
      };
      qx.core.ObjectRegistry.shutdown();
    }
  }
});

qx.Class.define("qx.event.type.Native", {
  extend : qx.event.type.Event,
  members : {
    init : function(nativeEvent, target, relatedTarget, canBubble, cancelable){

      this.base(arguments, canBubble, cancelable);
      this._target = target || qx.bom.Event.getTarget(nativeEvent);
      this._relatedTarget = relatedTarget || qx.bom.Event.getRelatedTarget(nativeEvent);
      if(nativeEvent.timeStamp){

        this._timeStamp = nativeEvent.timeStamp;
      };
      this._native = nativeEvent;
      this._returnValue = null;
      return this;
    },
    clone : function(embryo){

      var clone = this.base(arguments, embryo);
      var nativeClone = {
      };
      clone._native = this._cloneNativeEvent(this._native, nativeClone);
      clone._returnValue = this._returnValue;
      return clone;
    },
    _cloneNativeEvent : function(nativeEvent, clone){

      clone.preventDefault = (function(){
      });
      return clone;
    },
    preventDefault : function(){

      this.base(arguments);
      qx.bom.Event.preventDefault(this._native);
    },
    getNativeEvent : function(){

      return this._native;
    },
    setReturnValue : function(returnValue){

      this._returnValue = returnValue;
    },
    getReturnValue : function(){

      return this._returnValue;
    }
  },
  destruct : function(){

    this._native = this._returnValue = null;
  }
});

qx.Class.define("qx.event.handler.Window", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  construct : function(manager){

    this.base(arguments);
    this._manager = manager;
    this._window = manager.getWindow();
    this._initWindowObserver();
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      error : 1,
      load : 1,
      beforeunload : 1,
      unload : 1,
      resize : 1,
      scroll : 1,
      beforeshutdown : 1
    },
    TARGET_CHECK : qx.event.IEventHandler.TARGET_WINDOW,
    IGNORE_CAN_HANDLE : true
  },
  members : {
    canHandleEvent : function(target, type){
    },
    registerEvent : function(target, type, capture){
    },
    unregisterEvent : function(target, type, capture){
    },
    _initWindowObserver : function(){

      this._onNativeWrapper = qx.lang.Function.listener(this._onNative, this);
      var types = qx.event.handler.Window.SUPPORTED_TYPES;
      for(var key in types){

        qx.bom.Event.addNativeListener(this._window, key, this._onNativeWrapper);
      };
    },
    _stopWindowObserver : function(){

      var types = qx.event.handler.Window.SUPPORTED_TYPES;
      for(var key in types){

        qx.bom.Event.removeNativeListener(this._window, key, this._onNativeWrapper);
      };
    },
    _onNative : qx.event.GlobalError.observeMethod(function(e){

      if(this.isDisposed()){

        return;
      };
      var win = this._window;
      try{

        var doc = win.document;
      } catch(ex) {

        return;
      };
      var html = doc.documentElement;
      var target = qx.bom.Event.getTarget(e);
      if(target == null || target === win || target === doc || target === html){

        var event = qx.event.Registration.createEvent(e.type, qx.event.type.Native, [e, win]);
        qx.event.Registration.dispatchEvent(win, event);
        var result = event.getReturnValue();
        if(result != null){

          e.returnValue = result;
          return result;
        };
      };
    })
  },
  destruct : function(){

    this._stopWindowObserver();
    this._manager = this._window = null;
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
  }
});

qx.Class.define("qx.event.handler.Application", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  construct : function(manager){

    this.base(arguments);
    this._window = manager.getWindow();
    this.__domReady = false;
    this.__loaded = false;
    this.__isReady = false;
    this.__isUnloaded = false;
    this._initObserver();
    qx.event.handler.Application.$$instance = this;
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      ready : 1,
      shutdown : 1
    },
    TARGET_CHECK : qx.event.IEventHandler.TARGET_WINDOW,
    IGNORE_CAN_HANDLE : true,
    onScriptLoaded : function(){

      var inst = qx.event.handler.Application.$$instance;
      if(inst){

        inst.__fireReady();
      };
    }
  },
  members : {
    canHandleEvent : function(target, type){
    },
    registerEvent : function(target, type, capture){
    },
    unregisterEvent : function(target, type, capture){
    },
    __isReady : null,
    __domReady : null,
    __loaded : null,
    __isUnloaded : null,
    __fireReady : function(){

      if(!this.__isReady && this.__domReady && qx.$$loader.scriptLoaded){

        if((qx.core.Environment.get("engine.name") == "mshtml")){

          if(qx.event.Registration.hasListener(this._window, "ready")){

            this.__isReady = true;
            qx.event.Registration.fireEvent(this._window, "ready");
          };
        } else {

          this.__isReady = true;
          qx.event.Registration.fireEvent(this._window, "ready");
        };
      };
    },
    isApplicationReady : function(){

      return this.__isReady;
    },
    _initObserver : function(){

      if(qx.$$domReady || document.readyState == "complete" || document.readyState == "ready"){

        this.__domReady = true;
        this.__fireReady();
      } else {

        this._onNativeLoadWrapped = qx.lang.Function.bind(this._onNativeLoad, this);
        if(qx.core.Environment.get("engine.name") == "gecko" || qx.core.Environment.get("engine.name") == "opera" || qx.core.Environment.get("engine.name") == "webkit" || (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") > 8)){

          qx.bom.Event.addNativeListener(this._window, "DOMContentLoaded", this._onNativeLoadWrapped);
        } else {

          var self = this;
          var timer = function(){

            try{

              document.documentElement.doScroll("left");
              if(document.body){

                self._onNativeLoadWrapped();
              };
            } catch(error) {

              window.setTimeout(timer, 100);
            };
          };
          timer();
        };
        qx.bom.Event.addNativeListener(this._window, "load", this._onNativeLoadWrapped);
      };
      this._onNativeUnloadWrapped = qx.lang.Function.bind(this._onNativeUnload, this);
      qx.bom.Event.addNativeListener(this._window, "unload", this._onNativeUnloadWrapped);
    },
    _stopObserver : function(){

      if(this._onNativeLoadWrapped){

        qx.bom.Event.removeNativeListener(this._window, "load", this._onNativeLoadWrapped);
      };
      qx.bom.Event.removeNativeListener(this._window, "unload", this._onNativeUnloadWrapped);
      this._onNativeLoadWrapped = null;
      this._onNativeUnloadWrapped = null;
    },
    _onNativeLoad : qx.event.GlobalError.observeMethod(function(){

      this.__domReady = true;
      this.__fireReady();
    }),
    _onNativeUnload : qx.event.GlobalError.observeMethod(function(){

      if(!this.__isUnloaded){

        this.__isUnloaded = true;
        try{

          qx.event.Registration.fireEvent(this._window, "shutdown");
        } catch(e) {

          throw e;
        }finally{

          qx.core.ObjectRegistry.shutdown();
        };
      };
    })
  },
  destruct : function(){

    this._stopObserver();
    this._window = null;
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
  }
});

qx.Class.define("qx.core.Init", {
  statics : {
    getApplication : qx.core.BaseInit.getApplication,
    ready : qx.core.BaseInit.ready,
    __close : function(e){

      var app = this.getApplication();
      if(app){

        e.setReturnValue(app.close());
      };
    },
    __shutdown : function(){

      var app = this.getApplication();
      if(app){

        app.terminate();
      };
    }
  },
  defer : function(statics){

    qx.event.Registration.addListener(window, "ready", statics.ready, statics);
    qx.event.Registration.addListener(window, "shutdown", statics.__shutdown, statics);
    qx.event.Registration.addListener(window, "beforeunload", statics.__close, statics);
  }
});

qx.Class.define("qx.application.Mobile", {
  extend : qx.core.Object,
  implement : [qx.application.IApplication],
  include : qx.locale.MTranslation,
  construct : function(){

    this.base(arguments);
  },
  events : {
    "start" : "qx.event.type.Event",
    "stop" : "qx.event.type.Event",
    "back" : "qx.event.type.Data",
    "popup" : "qx.event.type.Event"
  },
  members : {
    __root : null,
    __routing : null,
    main : function(){

      this.__root = this._createRootWidget();
      if(qx.core.Environment.get("qx.mobile.nativescroll") == false){

        this.__root.setShowScrollbarY(false);
      };
    },
    getRoot : function(){

      return this.__root;
    },
    getRouting : function(){

      if(!this.__routing){

        this.__routing = new qx.application.Routing();
      };
      return this.__routing;
    },
    _createRootWidget : function(){

      return new qx.ui.mobile.core.Root();
    },
    finalize : function(){
    },
    close : function(){
    },
    terminate : function(){
    }
  },
  destruct : function(){

    this.__root = this.__routing = null;
  }
});

qx.Bootstrap.define("qx.application.Routing", {
  construct : function(){

    this.__messaging = new qx.event.Messaging();
    this.__navigationHandler = qx.bom.History.getInstance();
    this.__navigationHandler.addListener("changeState", this.__onChangeHash, this);
  },
  statics : {
    DEFAULT_PATH : "/",
    __back : [],
    __forward : []
  },
  members : {
    __navigationHandler : null,
    __messaging : null,
    __currentGetPath : null,
    init : function(defaultPath){

      if(qx.core.Environment.get("qx.debug")){

        if(defaultPath != null){

          qx.core.Assert.assertString(defaultPath, "Invalid argument 'defaultPath'");
        };
      };
      var path = this.getState();
      path = this._getPathOrFallback(path, defaultPath);
      this._executeGet(path, null, true);
    },
    _getPathOrFallback : function(path, defaultPath){

      if(path == "" || path == null || !this.__messaging.has("get", path)){

        path = defaultPath || qx.application.Routing.DEFAULT_PATH;
      };
      return path;
    },
    onGet : function(route, handler, scope){

      return this.__messaging.on("get", route, handler, scope);
    },
    on : function(route, handler, scope){

      return this.onGet(route, handler, scope);
    },
    onPost : function(route, handler, scope){

      return this.__messaging.on("post", route, handler, scope);
    },
    onPut : function(route, handler, scope){

      return this.__messaging.on("put", route, handler, scope);
    },
    onDelete : function(route, handler, scope){

      return this.__messaging.on("delete", route, handler, scope);
    },
    onAny : function(route, handler, scope){

      return this.__messaging.onAny(route, handler, scope);
    },
    remove : function(id){

      this.__messaging.remove(id);
    },
    __onChangeHash : function(evt){

      var path = evt.getData();
      path = this._getPathOrFallback(path);
      if(path != this.__currentGetPath){

        this._executeGet(path, null, true);
      };
    },
    _executeGet : function(path, customData, fromEvent){

      this.__currentGetPath = path;
      var history = this.__getFromHistory(path);
      if(history){

        if(!customData){

          customData = history.data.customData || {
          };
          customData.fromHistory = true;
          customData.action = history.action;
          customData.fromEvent = fromEvent;
        } else {

          this.__replaceCustomData(path, customData);
        };
      } else {

        this.__addToHistory(path, customData);
        qx.application.Routing.__forward = [];
      };
      this.__navigationHandler.setState(path);
      this.__messaging.emit("get", path, null, customData);
    },
    executeGet : function(path, customData){

      this._executeGet(path, customData);
    },
    execute : function(path, customData){

      this.executeGet(path, customData);
    },
    executePost : function(path, params, customData){

      this.__messaging.emit("post", path, params, customData);
    },
    executePut : function(path, params, customData){

      this.__messaging.emit("put", path, params, customData);
    },
    executeDelete : function(path, params, customData){

      this.__messaging.emit("delete", path, params, customData);
    },
    getState : function(){

      return this.__navigationHandler.getState();
    },
    __addToHistory : function(path, customData){

      qx.application.Routing.__back.unshift({
        path : path,
        customData : customData
      });
    },
    __replaceCustomData : function(path, customData){

      var register = [qx.application.Routing.__back, qx.application.Routing.__forward];
      for(var i = 0;i < register.length;i++){

        for(var j = 0;j < register[i].length;j++){

          if(register[i][j].path == path){

            register[i][j].customData = customData;
          };
        };
      };
    },
    __getFromHistory : function(path){

      var back = qx.application.Routing.__back;
      var forward = qx.application.Routing.__forward;
      var found = false;
      var entry = null;
      var length = back.length;
      for(var i = 0;i < length;i++){

        if(back[i].path == path){

          entry = back[i];
          var toForward = back.splice(0, i);
          for(var a = 0;a < toForward.length;a++){

            forward.unshift(toForward[a]);
          };
          found = true;
          break;
        };
      };
      if(found){

        return {
          data : entry,
          action : "back"
        };
      };
      var length = forward.length;
      for(var i = 0;i < length;i++){

        if(forward[i].path == path){

          entry = forward[i];
          var toBack = forward.splice(0, i + 1);
          for(var a = 0;a < toBack.length;a++){

            back.unshift(toBack[a]);
          };
          break;
        };
      };
      if(entry){

        return {
          data : entry,
          action : "forward"
        };
      };
      return entry;
    },
    back : function(customData){

      var data = customData;
      if(data){

        data["action"] = "back";
      } else {

        data = {
          "action" : "back"
        };
      };
      var path,back = qx.application.Routing.__back;
      if(back.length > 0){

        back.shift();
      };
      if(back.length > 0){

        var state = back.shift();
        this._executeGet(state.path, data);
      } else if(data.defaultPath){

        path = data.defaultPath;
        delete data.defaultPath;
        this._executeGet(path, data);
      } else if(qx.application.Routing.DEFAULT_PATH){

        this._executeGet(qx.application.Routing.DEFAULT_PATH, data);
      };;
    },
    dispose : function(){

      this.__navigationHandler.removeListener("changeState", this.__onChangeHash, this);
    }
  }
});

qx.Bootstrap.define("qx.event.Messaging", {
  construct : function(){

    this._listener = {
    } , this.__listenerIdCount = 0;
    this.__channelToIdMapping = {
    };
  },
  members : {
    _listener : null,
    __listenerIdCount : null,
    __channelToIdMapping : null,
    on : function(channel, type, handler, scope){

      return this._addListener(channel, type, handler, scope);
    },
    onAny : function(type, handler, scope){

      return this._addListener("any", type, handler, scope);
    },
    _addListener : function(channel, type, handler, scope){

      var listeners = this._listener[channel] = this._listener[channel] || {
      };
      var id = this.__listenerIdCount++;
      var params = [];
      var param = null;
      if(qx.lang.Type.isString(type)){

        var paramsRegexp = /\{([\w\d]+)\}/g;
        while((param = paramsRegexp.exec(type)) !== null){

          params.push(param[1]);
        };
        type = new RegExp("^" + type.replace(paramsRegexp, "([^\/]+)") + "$");
      };
      listeners[id] = {
        regExp : type,
        params : params,
        handler : handler,
        scope : scope
      };
      this.__channelToIdMapping[id] = channel;
      return id;
    },
    remove : function(id){

      var channel = this.__channelToIdMapping[id];
      var listener = this._listener[channel];
      delete listener[id];
      delete this.__channelToIdMapping[id];
    },
    has : function(channel, path){

      var listeners = this._listener[channel];
      if(!listeners || qx.lang.Object.isEmpty(listeners)){

        return false;
      };
      for(var id in listeners){

        var listener = listeners[id];
        if(listener.regExp.test(path)){

          return true;
        };
      };
      return false;
    },
    emit : function(channel, path, params, customData){

      this._emit(channel, path, params, customData);
    },
    _emit : function(channel, path, params, customData){

      var listenerMatchedAny = false;
      var listener = this._listener["any"];
      listenerMatchedAny = this._emitListeners(channel, path, listener, params, customData);
      var listenerMatched = false;
      listener = this._listener[channel];
      listenerMatched = this._emitListeners(channel, path, listener, params, customData);
      if(!listenerMatched && !listenerMatchedAny){

        qx.Bootstrap.info("No listener found for " + path);
      };
    },
    _emitListeners : function(channel, path, listeners, params, customData){

      if(!listeners || qx.lang.Object.isEmpty(listeners)){

        return false;
      };
      var listenerMatched = false;
      for(var id in listeners){

        var listener = listeners[id];
        listenerMatched |= this._emitRoute(channel, path, listener, params, customData);
      };
      return listenerMatched;
    },
    _emitRoute : function(channel, path, listener, params, customData){

      var match = listener.regExp.exec(path);
      if(match){

        var params = params || {
        };
        var param = null;
        var value = null;
        match.shift();
        for(var i = 0;i < match.length;i++){

          value = match[i];
          param = listener.params[i];
          if(param){

            params[param] = value;
          } else {

            params[i] = value;
          };
        };
        listener.handler.call(listener.scope, {
          path : path,
          params : params,
          customData : customData
        });
      };
      return match != undefined;
    }
  }
});

qx.Bootstrap.define("qx.lang.Object", {
  statics : {
    empty : function(map){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert && qx.core.Assert.assertMap(map, "Invalid argument 'map'");
      };
      for(var key in map){

        if(map.hasOwnProperty(key)){

          delete map[key];
        };
      };
    },
    isEmpty : function(map){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert && qx.core.Assert.assertMap(map, "Invalid argument 'map'");
      };
      for(var key in map){

        return false;
      };
      return true;
    },
    getLength : qx.Bootstrap.objectGetLength,
    getValues : function(map){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert && qx.core.Assert.assertMap(map, "Invalid argument 'map'");
      };
      var arr = [];
      var keys = Object.keys(map);
      for(var i = 0,l = keys.length;i < l;i++){

        arr.push(map[keys[i]]);
      };
      return arr;
    },
    mergeWith : qx.Bootstrap.objectMergeWith,
    clone : function(source, deep){

      if(qx.lang.Type.isObject(source)){

        var clone = {
        };
        for(var key in source){

          if(deep){

            clone[key] = qx.lang.Object.clone(source[key], deep);
          } else {

            clone[key] = source[key];
          };
        };
        return clone;
      } else if(qx.lang.Type.isArray(source)){

        var clone = [];
        for(var i = 0;i < source.length;i++){

          if(deep){

            clone[i] = qx.lang.Object.clone(source[i]);
          } else {

            clone[i] = source[i];
          };
        };
        return clone;
      };
      return source;
    },
    equals : function(object1, object2){

      return qx.lang.Object.__equals(object1, object2, [], []);
    },
    __equals : function(object1, object2, aStack, bStack){

      if(object1 === object2){

        return object1 !== 0 || 1 / object1 == 1 / object2;
      };
      if(object1 == null || object2 == null){

        return object1 === object2;
      };
      var className = Object.prototype.toString.call(object1);
      if(className != Object.prototype.toString.call(object2)){

        return false;
      };
      switch(className){case '[object String]':
      return object1 == String(object2);case '[object Number]':
      return object1 != +object1 ? object2 != +object2 : (object1 == 0 ? 1 / object1 == 1 / object2 : object1 == +object2);case '[object Date]':case '[object Boolean]':
      return +object1 == +object2;case '[object RegExp]':
      return object1.source == object2.source && object1.global == object2.global && object1.multiline == object2.multiline && object1.ignoreCase == object2.ignoreCase;};
      if(typeof object1 != 'object' || typeof object2 != 'object'){

        return false;
      };
      var length = aStack.length;
      while(length--){

        if(aStack[length] == object1){

          return bStack[length] == object2;
        };
      };
      var aCtor = object1.constructor,bCtor = object2.constructor;
      if(aCtor !== bCtor && !(qx.Bootstrap.isFunction(aCtor) && (aCtor instanceof aCtor) && qx.Bootstrap.isFunction(bCtor) && (bCtor instanceof bCtor)) && ('constructor' in object1 && 'constructor' in object2)){

        return false;
      };
      aStack.push(object1);
      bStack.push(object2);
      var size = 0,result = true;
      if(className == '[object Array]'){

        size = object1.length;
        result = size == object2.length;
        if(result){

          while(size--){

            if(!(result = qx.lang.Object.__equals(object1[size], object2[size], aStack, bStack))){

              break;
            };
          };
        };
      } else {

        for(var key in object1){

          if(Object.prototype.hasOwnProperty.call(object1, key)){

            size++;
            if(!(result = Object.prototype.hasOwnProperty.call(object2, key) && qx.lang.Object.__equals(object1[key], object2[key], aStack, bStack))){

              break;
            };
          };
        };
        if(result){

          for(key in object2){

            if(Object.prototype.hasOwnProperty.call(object2, key) && !(size--)){

              break;
            };
          };
          result = !size;
        };
      };
      aStack.pop();
      bStack.pop();
      return result;
    },
    invert : function(map){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert && qx.core.Assert.assertMap(map, "Invalid argument 'map'");
      };
      var result = {
      };
      for(var key in map){

        result[map[key].toString()] = key;
      };
      return result;
    },
    getKeyFromValue : function(map, value){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert && qx.core.Assert.assertMap(map, "Invalid argument 'map'");
      };
      for(var key in map){

        if(map.hasOwnProperty(key) && map[key] === value){

          return key;
        };
      };
      return null;
    },
    contains : function(map, value){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert && qx.core.Assert.assertMap(map, "Invalid argument 'map'");
      };
      return this.getKeyFromValue(map, value) !== null;
    },
    fromArray : function(array){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert && qx.core.Assert.assertArray(array, "Invalid argument 'array'");
      };
      var obj = {
      };
      for(var i = 0,l = array.length;i < l;i++){

        if(qx.core.Environment.get("qx.debug")){

          switch(typeof array[i]){case "object":case "function":case "undefined":
          throw new Error("Could not convert complex objects like " + array[i] + " at array index " + i + " to map syntax");};
        };
        obj[array[i].toString()] = true;
      };
      return obj;
    }
  }
});

qx.Bootstrap.define("qx.bom.client.Event", {
  statics : {
    getTouch : function(){

      return ("ontouchstart" in window);
    },
    getMsPointer : function(){

      if("pointerEnabled" in window.navigator){

        return window.navigator.pointerEnabled;
      } else if("msPointerEnabled" in window.navigator){

        return window.navigator.msPointerEnabled;
      };
      return false;
    },
    getHelp : function(){

      return ("onhelp" in document);
    },
    getHashChange : function(){

      var engine = qx.bom.client.Engine.getName();
      var hashchange = "onhashchange" in window;
      return (engine !== "mshtml" && hashchange) || (engine === "mshtml" && "documentMode" in document && document.documentMode >= 8 && hashchange);
    },
    getDispatchEvent : function(){

      return typeof document.dispatchEvent == "function";
    },
    getCustomEvent : function(){

      if(!window.CustomEvent){

        return false;
      };
      try{

        new window.CustomEvent("foo");
        return true;
      } catch(ex) {

        return false;
      };
    },
    getMouseEvent : function(){

      if(!window.MouseEvent){

        return false;
      };
      try{

        new window.MouseEvent("foo");
        return true;
      } catch(ex) {

        return false;
      };
    },
    getMouseWheel : function(win){

      if(!win){

        win = window;
      };
      var targets = [win, win.document, win.document.body];
      var target = win;
      var type = "DOMMouseScroll";
      for(var i = 0;i < targets.length;i++){

        if(qx.bom.Event.supportsEvent(targets[i], "wheel")){

          type = "wheel";
          target = targets[i];
          break;
        };
        if(qx.bom.Event.supportsEvent(targets[i], "mousewheel")){

          type = "mousewheel";
          target = targets[i];
          break;
        };
      };
      return {
        type : type,
        target : target
      };
    }
  },
  defer : function(statics){

    qx.core.Environment.add("event.touch", statics.getTouch);
    qx.core.Environment.add("event.mspointer", statics.getMsPointer);
    qx.core.Environment.add("event.help", statics.getHelp);
    qx.core.Environment.add("event.hashchange", statics.getHashChange);
    qx.core.Environment.add("event.mousewheel", statics.getMouseWheel);
  }
});

qx.Class.define("qx.bom.History", {
  extend : qx.core.Object,
  type : "abstract",
  construct : function(){

    this.base(arguments);
    this._baseUrl = window.location.href.split('#')[0] + '#';
    this._titles = {
    };
    this._setInitialState();
  },
  events : {
    "request" : "qx.event.type.Data"
  },
  statics : {
    SUPPORTS_HASH_CHANGE_EVENT : qx.core.Environment.get("event.hashchange"),
    getInstance : function(){

      var runsInIframe = !(window == window.top);
      if(!this.$$instance){

        if(runsInIframe && qx.core.Environment.get("browser.documentmode") == 9){

          this.$$instance = new qx.bom.HashHistory();
        } else if(runsInIframe && qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 9){

          this.$$instance = new qx.bom.IframeHistory();
        } else if(this.SUPPORTS_HASH_CHANGE_EVENT){

          this.$$instance = new qx.bom.NativeHistory();
        } else if((qx.core.Environment.get("engine.name") == "mshtml")){

          this.$$instance = new qx.bom.IframeHistory();
        } else {

          this.$$instance = new qx.bom.NativeHistory();
        };;;
      };
      return this.$$instance;
    }
  },
  properties : {
    title : {
      check : "String",
      event : "changeTitle",
      nullable : true,
      apply : "_applyTitle"
    },
    state : {
      check : "String",
      event : "changeState",
      nullable : true,
      apply : "_applyState"
    }
  },
  members : {
    _titles : null,
    _applyState : function(value, old){

      this._writeState(value);
    },
    _setInitialState : function(){

      this.setState(this._readState());
    },
    _encode : function(value){

      if(qx.lang.Type.isString(value)){

        return encodeURIComponent(value);
      };
      return "";
    },
    _decode : function(value){

      if(qx.lang.Type.isString(value)){

        return decodeURIComponent(value);
      };
      return "";
    },
    _applyTitle : function(title){

      if(title != null){

        document.title = title || "";
      };
    },
    addToHistory : function(state, newTitle){

      if(!qx.lang.Type.isString(state)){

        state = state + "";
      };
      if(qx.lang.Type.isString(newTitle)){

        this.setTitle(newTitle);
        this._titles[state] = newTitle;
      };
      if(this.getState() !== state){

        this._writeState(state);
      };
    },
    navigateBack : function(){

      qx.event.Timer.once(function(){

        history.back();
      }, this, 100);
    },
    navigateForward : function(){

      qx.event.Timer.once(function(){

        history.forward();
      }, this, 100);
    },
    _onHistoryLoad : function(state){

      this.setState(state);
      this.fireDataEvent("request", state);
      if(this._titles[state] != null){

        this.setTitle(this._titles[state]);
      };
    },
    _readState : function(){

      throw new Error("Abstract method call");
    },
    _writeState : function(){

      throw new Error("Abstract method call");
    },
    _setHash : function(value){

      var url = this._baseUrl + (value || "");
      var loc = window.location;
      if(url != loc.href){

        loc.href = url;
      };
    },
    _getHash : function(){

      var hash = /#(.*)$/.exec(window.location.href);
      return hash && hash[1] ? hash[1] : "";
    }
  },
  destruct : function(){

    this._titles = null;
  }
});

qx.Class.define("qx.bom.HashHistory", {
  extend : qx.bom.History,
  construct : function(){

    this.base(arguments);
    this._baseUrl = null;
    this.__initIframe();
  },
  members : {
    __checkOnHashChange : null,
    __iframe : null,
    __iframeReady : false,
    addToHistory : function(state, newTitle){

      if(!qx.lang.Type.isString(state)){

        state = state + "";
      };
      if(qx.lang.Type.isString(newTitle)){

        this.setTitle(newTitle);
        this._titles[state] = newTitle;
      };
      if(this.getState() !== state){

        this._writeState(state);
      };
    },
    __initIframe : function(){

      this.__iframe = this.__createIframe();
      document.body.appendChild(this.__iframe);
      this.__waitForIFrame(function(){

        this._baseUrl = this.__iframe.contentWindow.document.location.href;
        this.__attachListeners();
      }, this);
    },
    __createIframe : function(){

      var iframe = qx.bom.Iframe.create({
        src : qx.util.ResourceManager.getInstance().toUri(qx.core.Environment.get("qx.blankpage")) + "#"
      });
      iframe.style.visibility = "hidden";
      iframe.style.position = "absolute";
      iframe.style.left = "-1000px";
      iframe.style.top = "-1000px";
      return iframe;
    },
    __waitForIFrame : function(callback, context, retry){

      if(typeof retry === "undefined"){

        retry = 0;
      };
      if(!this.__iframe.contentWindow || !this.__iframe.contentWindow.document){

        if(retry > 20){

          throw new Error("can't initialize iframe");
        };
        qx.event.Timer.once(function(){

          this.__waitForIFrame(callback, context, ++retry);
        }, this, 10);
        return;
      };
      this.__iframeReady = true;
      callback.call(context || window);
    },
    __attachListeners : function(){

      qx.event.Idle.getInstance().addListener("interval", this.__onHashChange, this);
    },
    __detatchListeners : function(){

      qx.event.Idle.getInstance().removeListener("interval", this.__onHashChange, this);
    },
    __onHashChange : function(){

      var currentState = this._readState();
      if(qx.lang.Type.isString(currentState) && currentState != this.getState()){

        this._onHistoryLoad(currentState);
      };
    },
    _readState : function(){

      var hash = !this._getHash() ? "" : this._getHash().substr(1);
      return this._decode(hash);
    },
    _getHash : function(){

      if(!this.__iframeReady){

        return null;
      };
      return this.__iframe.contentWindow.document.location.hash;
    },
    _writeState : function(state){

      this._setHash(this._encode(state));
    },
    _setHash : function(value){

      if(!this.__iframe || !this._baseUrl){

        return;
      };
      var hash = !this.__iframe.contentWindow.document.location.hash ? "" : this.__iframe.contentWindow.document.location.hash.substr(1);
      if(value != hash){

        this.__iframe.contentWindow.document.location.hash = value;
      };
    }
  },
  destruct : function(){

    this.__detatchListeners();
    this.__iframe = null;
  }
});

qx.Class.define("qx.event.handler.Iframe", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      load : 1,
      navigate : 1
    },
    TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE,
    IGNORE_CAN_HANDLE : false,
    onevent : qx.event.GlobalError.observeMethod(function(target){

      var currentUrl = qx.bom.Iframe.queryCurrentUrl(target);
      if(currentUrl !== target.$$url){

        qx.event.Registration.fireEvent(target, "navigate", qx.event.type.Data, [currentUrl]);
        target.$$url = currentUrl;
      };
      qx.event.Registration.fireEvent(target, "load");
    })
  },
  members : {
    canHandleEvent : function(target, type){

      return target.tagName.toLowerCase() === "iframe";
    },
    registerEvent : function(target, type, capture){
    },
    unregisterEvent : function(target, type, capture){
    }
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
  }
});

qx.Class.define("qx.bom.Iframe", {
  statics : {
    DEFAULT_ATTRIBUTES : {
      onload : "qx.event.handler.Iframe.onevent(this)",
      frameBorder : 0,
      frameSpacing : 0,
      marginWidth : 0,
      marginHeight : 0,
      hspace : 0,
      vspace : 0,
      border : 0,
      allowTransparency : true
    },
    create : function(attributes, win){

      var attributes = attributes ? qx.lang.Object.clone(attributes) : {
      };
      var initValues = qx.bom.Iframe.DEFAULT_ATTRIBUTES;
      for(var key in initValues){

        if(attributes[key] == null){

          attributes[key] = initValues[key];
        };
      };
      return qx.dom.Element.create("iframe", attributes, win);
    },
    getWindow : function(iframe){

      try{

        return iframe.contentWindow;
      } catch(ex) {

        return null;
      };
    },
    getDocument : function(iframe){

      if("contentDocument" in iframe){

        try{

          return iframe.contentDocument;
        } catch(ex) {

          return null;
        };
      };
      try{

        var win = this.getWindow(iframe);
        return win ? win.document : null;
      } catch(ex) {

        return null;
      };
    },
    getBody : function(iframe){

      try{

        var doc = this.getDocument(iframe);
        return doc ? doc.getElementsByTagName("body")[0] : null;
      } catch(ex) {

        return null;
      };
    },
    setSource : function(iframe, source){

      try{

        if(this.getWindow(iframe) && qx.dom.Hierarchy.isRendered(iframe)){

          try{

            if((qx.core.Environment.get("engine.name") == "webkit") && qx.core.Environment.get("os.name") == "osx"){

              var contentWindow = this.getWindow(iframe);
              if(contentWindow){

                contentWindow.stop();
              };
            };
            this.getWindow(iframe).location.replace(source);
          } catch(ex) {

            iframe.src = source;
          };
        } else {

          iframe.src = source;
        };
        this.__rememberUrl(iframe);
      } catch(ex) {

        qx.log.Logger.warn("Iframe source could not be set!");
      };
    },
    queryCurrentUrl : function(iframe){

      var doc = this.getDocument(iframe);
      try{

        if(doc && doc.location){

          return doc.location.href;
        };
      } catch(ex) {
      };
      return "";
    },
    __rememberUrl : function(iframe){

      var callback = function(){

        qx.bom.Event.removeNativeListener(iframe, "load", callback);
        iframe.$$url = qx.bom.Iframe.queryCurrentUrl(iframe);
      };
      qx.bom.Event.addNativeListener(iframe, "load", callback);
    }
  }
});

qx.Bootstrap.define("qx.dom.Element", {
  statics : {
    hasChild : function(parent, child){

      return child.parentNode === parent;
    },
    hasChildren : function(element){

      return !!element.firstChild;
    },
    hasChildElements : function(element){

      element = element.firstChild;
      while(element){

        if(element.nodeType === 1){

          return true;
        };
        element = element.nextSibling;
      };
      return false;
    },
    getParentElement : function(element){

      return element.parentNode;
    },
    isInDom : function(element, win){

      if(!win){

        win = window;
      };
      var domElements = win.document.getElementsByTagName(element.nodeName);
      for(var i = 0,l = domElements.length;i < l;i++){

        if(domElements[i] === element){

          return true;
        };
      };
      return false;
    },
    insertAt : function(node, parent, index){

      var ref = parent.childNodes[index];
      if(ref){

        parent.insertBefore(node, ref);
      } else {

        parent.appendChild(node);
      };
      return true;
    },
    insertBegin : function(node, parent){

      if(parent.firstChild){

        this.insertBefore(node, parent.firstChild);
      } else {

        parent.appendChild(node);
      };
      return true;
    },
    insertEnd : function(node, parent){

      parent.appendChild(node);
      return true;
    },
    insertBefore : function(node, ref){

      ref.parentNode.insertBefore(node, ref);
      return true;
    },
    insertAfter : function(node, ref){

      var parent = ref.parentNode;
      if(ref == parent.lastChild){

        parent.appendChild(node);
      } else {

        return this.insertBefore(node, ref.nextSibling);
      };
      return true;
    },
    remove : function(node){

      if(!node.parentNode){

        return false;
      };
      node.parentNode.removeChild(node);
      return true;
    },
    removeChild : function(node, parent){

      if(node.parentNode !== parent){

        return false;
      };
      parent.removeChild(node);
      return true;
    },
    removeChildAt : function(index, parent){

      var child = parent.childNodes[index];
      if(!child){

        return false;
      };
      parent.removeChild(child);
      return true;
    },
    replaceChild : function(newNode, oldNode){

      if(!oldNode.parentNode){

        return false;
      };
      oldNode.parentNode.replaceChild(newNode, oldNode);
      return true;
    },
    replaceAt : function(newNode, index, parent){

      var oldNode = parent.childNodes[index];
      if(!oldNode){

        return false;
      };
      parent.replaceChild(newNode, oldNode);
      return true;
    },
    __helperElement : {
    },
    getHelperElement : function(win){

      if(!win){

        win = window;
      };
      var key = win.location.href;
      if(!qx.dom.Element.__helperElement[key]){

        var helper = qx.dom.Element.__helperElement[key] = win.document.createElement("div");
        if(qx.core.Environment.get("engine.name") == "webkit"){

          helper.style.display = "none";
          win.document.body.appendChild(helper);
        };
      };
      return qx.dom.Element.__helperElement[key];
    },
    create : function(name, attributes, win){

      if(!win){

        win = window;
      };
      if(!name){

        throw new Error("The tag name is missing!");
      };
      var element = win.document.createElement(name);
      for(var key in attributes){

        qx.bom.element.Attribute.set(element, key, attributes[key]);
      };
      return element;
    },
    empty : function(element){

      return element.innerHTML = "";
    }
  }
});

qx.Bootstrap.define("qx.bom.client.Html", {
  statics : {
    getWebWorker : function(){

      return window.Worker != null;
    },
    getFileReader : function(){

      return window.FileReader != null;
    },
    getGeoLocation : function(){

      return "geolocation" in navigator;
    },
    getAudio : function(){

      return !!document.createElement('audio').canPlayType;
    },
    getAudioOgg : function(){

      if(!qx.bom.client.Html.getAudio()){

        return "";
      };
      var a = document.createElement("audio");
      return a.canPlayType("audio/ogg");
    },
    getAudioMp3 : function(){

      if(!qx.bom.client.Html.getAudio()){

        return "";
      };
      var a = document.createElement("audio");
      return a.canPlayType("audio/mpeg");
    },
    getAudioWav : function(){

      if(!qx.bom.client.Html.getAudio()){

        return "";
      };
      var a = document.createElement("audio");
      return a.canPlayType("audio/x-wav");
    },
    getAudioAu : function(){

      if(!qx.bom.client.Html.getAudio()){

        return "";
      };
      var a = document.createElement("audio");
      return a.canPlayType("audio/basic");
    },
    getAudioAif : function(){

      if(!qx.bom.client.Html.getAudio()){

        return "";
      };
      var a = document.createElement("audio");
      return a.canPlayType("audio/x-aiff");
    },
    getVideo : function(){

      return !!document.createElement('video').canPlayType;
    },
    getVideoOgg : function(){

      if(!qx.bom.client.Html.getVideo()){

        return "";
      };
      var v = document.createElement("video");
      return v.canPlayType('video/ogg; codecs="theora, vorbis"');
    },
    getVideoH264 : function(){

      if(!qx.bom.client.Html.getVideo()){

        return "";
      };
      var v = document.createElement("video");
      return v.canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
    },
    getVideoWebm : function(){

      if(!qx.bom.client.Html.getVideo()){

        return "";
      };
      var v = document.createElement("video");
      return v.canPlayType('video/webm; codecs="vp8, vorbis"');
    },
    getLocalStorage : function(){

      try{

        var has = window.localStorage != null;
        if(has){

          window.sessionStorage.setItem("$qx_check", "test");
          window.sessionStorage.removeItem("$qx_check");
        };
        return has;
      } catch(exc) {

        return false;
      };
    },
    getSessionStorage : function(){

      try{

        var has = window.sessionStorage != null;
        if(has){

          window.sessionStorage.setItem("$qx_check", "test");
          window.sessionStorage.removeItem("$qx_check");
        };
        return has;
      } catch(exc) {

        return false;
      };
    },
    getUserDataStorage : function(){

      var el = document.createElement("div");
      el.style["display"] = "none";
      document.getElementsByTagName("head")[0].appendChild(el);
      var supported = false;
      try{

        el.addBehavior("#default#userdata");
        el.load("qxtest");
        supported = true;
      } catch(e) {
      };
      document.getElementsByTagName("head")[0].removeChild(el);
      return supported;
    },
    getClassList : function(){

      return !!(document.documentElement.classList && qx.Bootstrap.getClass(document.documentElement.classList) === "DOMTokenList");
    },
    getXPath : function(){

      return !!document.evaluate;
    },
    getXul : function(){

      try{

        document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "label");
        return true;
      } catch(e) {

        return false;
      };
    },
    getSvg : function(){

      return document.implementation && document.implementation.hasFeature && (document.implementation.hasFeature("org.w3c.dom.svg", "1.0") || document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"));
    },
    getVml : function(){

      var el = document.createElement("div");
      document.body.appendChild(el);
      el.innerHTML = '<v:shape id="vml_flag1" adj="1" />';
      el.firstChild.style.behavior = "url(#default#VML)";
      var hasVml = typeof el.firstChild.adj == "object";
      document.body.removeChild(el);
      return hasVml;
    },
    getCanvas : function(){

      return !!window.CanvasRenderingContext2D;
    },
    getDataUrl : function(callback){

      var data = new Image();
      data.onload = data.onerror = function(){

        window.setTimeout(function(){

          callback.call(null, (data.width == 1 && data.height == 1));
        }, 0);
      };
      data.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
    },
    getDataset : function(){

      return !!document.documentElement.dataset;
    },
    getContains : function(){

      return (typeof document.documentElement.contains !== "undefined");
    },
    getCompareDocumentPosition : function(){

      return (typeof document.documentElement.compareDocumentPosition === "function");
    },
    getTextContent : function(){

      var el = document.createElement("span");
      return (typeof el.textContent !== "undefined");
    },
    getConsole : function(){

      return typeof window.console !== "undefined";
    },
    getNaturalDimensions : function(){

      var img = document.createElement("img");
      return typeof img.naturalHeight === "number" && typeof img.naturalWidth === "number";
    },
    getHistoryState : function(){

      return (typeof window.onpopstate !== "undefined" && typeof window.history.replaceState !== "undefined" && typeof window.history.pushState !== "undefined");
    },
    getSelection : function(){

      if(typeof window.getSelection === "function"){

        return "getSelection";
      };
      if(typeof document.selection === "object"){

        return "selection";
      };
      return null;
    },
    getIsEqualNode : function(){

      return typeof document.documentElement.isEqualNode === "function";
    }
  },
  defer : function(statics){

    qx.core.Environment.add("html.webworker", statics.getWebWorker);
    qx.core.Environment.add("html.filereader", statics.getFileReader);
    qx.core.Environment.add("html.geolocation", statics.getGeoLocation);
    qx.core.Environment.add("html.audio", statics.getAudio);
    qx.core.Environment.add("html.audio.ogg", statics.getAudioOgg);
    qx.core.Environment.add("html.audio.mp3", statics.getAudioMp3);
    qx.core.Environment.add("html.audio.wav", statics.getAudioWav);
    qx.core.Environment.add("html.audio.au", statics.getAudioAu);
    qx.core.Environment.add("html.audio.aif", statics.getAudioAif);
    qx.core.Environment.add("html.video", statics.getVideo);
    qx.core.Environment.add("html.video.ogg", statics.getVideoOgg);
    qx.core.Environment.add("html.video.h264", statics.getVideoH264);
    qx.core.Environment.add("html.video.webm", statics.getVideoWebm);
    qx.core.Environment.add("html.storage.local", statics.getLocalStorage);
    qx.core.Environment.add("html.storage.session", statics.getSessionStorage);
    qx.core.Environment.add("html.storage.userdata", statics.getUserDataStorage);
    qx.core.Environment.add("html.classlist", statics.getClassList);
    qx.core.Environment.add("html.xpath", statics.getXPath);
    qx.core.Environment.add("html.xul", statics.getXul);
    qx.core.Environment.add("html.canvas", statics.getCanvas);
    qx.core.Environment.add("html.svg", statics.getSvg);
    qx.core.Environment.add("html.vml", statics.getVml);
    qx.core.Environment.add("html.dataset", statics.getDataset);
    qx.core.Environment.addAsync("html.dataurl", statics.getDataUrl);
    qx.core.Environment.add("html.element.contains", statics.getContains);
    qx.core.Environment.add("html.element.compareDocumentPosition", statics.getCompareDocumentPosition);
    qx.core.Environment.add("html.element.textcontent", statics.getTextContent);
    qx.core.Environment.add("html.console", statics.getConsole);
    qx.core.Environment.add("html.image.naturaldimensions", statics.getNaturalDimensions);
    qx.core.Environment.add("html.history.state", statics.getHistoryState);
    qx.core.Environment.add("html.selection", statics.getSelection);
    qx.core.Environment.add("html.node.isequalnode", statics.getIsEqualNode);
  }
});

qx.Bootstrap.define("qx.bom.element.Attribute", {
  statics : {
    __hints : {
      names : {
        "class" : "className",
        "for" : "htmlFor",
        html : "innerHTML",
        text : qx.core.Environment.get("html.element.textcontent") ? "textContent" : "innerText",
        colspan : "colSpan",
        rowspan : "rowSpan",
        valign : "vAlign",
        datetime : "dateTime",
        accesskey : "accessKey",
        tabindex : "tabIndex",
        maxlength : "maxLength",
        readonly : "readOnly",
        longdesc : "longDesc",
        cellpadding : "cellPadding",
        cellspacing : "cellSpacing",
        frameborder : "frameBorder",
        usemap : "useMap"
      },
      runtime : {
        "html" : 1,
        "text" : 1
      },
      bools : {
        compact : 1,
        nowrap : 1,
        ismap : 1,
        declare : 1,
        noshade : 1,
        checked : 1,
        disabled : 1,
        readOnly : 1,
        multiple : 1,
        selected : 1,
        noresize : 1,
        defer : 1,
        allowTransparency : 1
      },
      property : {
        $$html : 1,
        $$widget : 1,
        checked : 1,
        readOnly : 1,
        multiple : 1,
        selected : 1,
        value : 1,
        maxLength : 1,
        className : 1,
        innerHTML : 1,
        innerText : 1,
        textContent : 1,
        htmlFor : 1,
        tabIndex : 1
      },
      qxProperties : {
        $$widget : 1,
        $$html : 1
      },
      propertyDefault : {
        disabled : false,
        checked : false,
        readOnly : false,
        multiple : false,
        selected : false,
        value : "",
        className : "",
        innerHTML : "",
        innerText : "",
        textContent : "",
        htmlFor : "",
        tabIndex : 0,
        maxLength : qx.core.Environment.select("engine.name", {
          "mshtml" : 2147483647,
          "webkit" : 524288,
          "default" : -1
        })
      },
      removeableProperties : {
        disabled : 1,
        multiple : 1,
        maxLength : 1
      }
    },
    compile : function(map){

      var html = [];
      var runtime = this.__hints.runtime;
      for(var key in map){

        if(!runtime[key]){

          html.push(key, "='", map[key], "'");
        };
      };
      return html.join("");
    },
    get : function(element, name){

      var hints = this.__hints;
      var value;
      name = hints.names[name] || name;
      if(hints.property[name]){

        value = element[name];
        if(typeof hints.propertyDefault[name] !== "undefined" && value == hints.propertyDefault[name]){

          if(typeof hints.bools[name] === "undefined"){

            return null;
          } else {

            return value;
          };
        };
      } else {

        value = element.getAttribute(name);
        if(hints.bools[name] && !(qx.core.Environment.get("engine.name") == "mshtml" && parseInt(qx.core.Environment.get("browser.documentmode"), 10) <= 8)){

          return qx.Bootstrap.isString(value);
        };
      };
      if(hints.bools[name]){

        return !!value;
      };
      return value;
    },
    set : function(element, name, value){

      if(typeof value === "undefined"){

        return;
      };
      var hints = this.__hints;
      name = hints.names[name] || name;
      if(hints.bools[name] && !qx.lang.Type.isBoolean(value)){

        value = qx.lang.Type.isString(value);
      };
      if(hints.property[name] && (!(element[name] === undefined) || hints.qxProperties[name])){

        if(value == null){

          if(hints.removeableProperties[name]){

            element.removeAttribute(name);
            return;
          } else if(typeof hints.propertyDefault[name] !== "undefined"){

            value = hints.propertyDefault[name];
          };
        };
        element[name] = value;
      } else {

        if(value === true){

          element.setAttribute(name, name);
        } else if(value === false || value === null){

          element.removeAttribute(name);
        } else {

          element.setAttribute(name, value);
        };
      };
    },
    reset : function(element, name){

      this.set(element, name, null);
    }
  }
});

qx.Bootstrap.define("qx.dom.Hierarchy", {
  statics : {
    getNodeIndex : function(node){

      var index = 0;
      while(node && (node = node.previousSibling)){

        index++;
      };
      return index;
    },
    getElementIndex : function(element){

      var index = 0;
      var type = qx.dom.Node.ELEMENT;
      while(element && (element = element.previousSibling)){

        if(element.nodeType == type){

          index++;
        };
      };
      return index;
    },
    getNextElementSibling : function(element){

      while(element && (element = element.nextSibling) && !qx.dom.Node.isElement(element)){

        continue;
      };
      return element || null;
    },
    getPreviousElementSibling : function(element){

      while(element && (element = element.previousSibling) && !qx.dom.Node.isElement(element)){

        continue;
      };
      return element || null;
    },
    contains : function(element, target){

      if(qx.core.Environment.get("html.element.contains")){

        if(qx.dom.Node.isDocument(element)){

          var doc = qx.dom.Node.getDocument(target);
          return element && doc == element;
        } else if(qx.dom.Node.isDocument(target)){

          return false;
        } else {

          return element.contains(target);
        };
      } else if(qx.core.Environment.get("html.element.compareDocumentPosition")){

        return !!(element.compareDocumentPosition(target) & 16);
      } else {

        while(target){

          if(element == target){

            return true;
          };
          target = target.parentNode;
        };
        return false;
      };
    },
    isRendered : function(element){

      var doc = element.ownerDocument || element.document;
      if(qx.core.Environment.get("html.element.contains")){

        if(!element.parentNode){

          return false;
        };
        return doc.body.contains(element);
      } else if(qx.core.Environment.get("html.element.compareDocumentPosition")){

        return !!(doc.compareDocumentPosition(element) & 16);
      } else {

        while(element){

          if(element == doc.body){

            return true;
          };
          element = element.parentNode;
        };
        return false;
      };
    },
    isDescendantOf : function(element, ancestor){

      return this.contains(ancestor, element);
    },
    getCommonParent : function(element1, element2){

      if(element1 === element2){

        return element1;
      };
      if(qx.core.Environment.get("html.element.contains")){

        while(element1 && qx.dom.Node.isElement(element1)){

          if(element1.contains(element2)){

            return element1;
          };
          element1 = element1.parentNode;
        };
        return null;
      } else {

        var known = [];
        while(element1 || element2){

          if(element1){

            if(qx.lang.Array.contains(known, element1)){

              return element1;
            };
            known.push(element1);
            element1 = element1.parentNode;
          };
          if(element2){

            if(qx.lang.Array.contains(known, element2)){

              return element2;
            };
            known.push(element2);
            element2 = element2.parentNode;
          };
        };
        return null;
      };
    },
    getAncestors : function(element){

      return this._recursivelyCollect(element, "parentNode");
    },
    getChildElements : function(element){

      element = element.firstChild;
      if(!element){

        return [];
      };
      var arr = this.getNextSiblings(element);
      if(element.nodeType === 1){

        arr.unshift(element);
      };
      return arr;
    },
    getDescendants : function(element){

      return qx.lang.Array.fromCollection(element.getElementsByTagName("*"));
    },
    getFirstDescendant : function(element){

      element = element.firstChild;
      while(element && element.nodeType != 1){

        element = element.nextSibling;
      };
      return element;
    },
    getLastDescendant : function(element){

      element = element.lastChild;
      while(element && element.nodeType != 1){

        element = element.previousSibling;
      };
      return element;
    },
    getPreviousSiblings : function(element){

      return this._recursivelyCollect(element, "previousSibling");
    },
    getNextSiblings : function(element){

      return this._recursivelyCollect(element, "nextSibling");
    },
    _recursivelyCollect : function(element, property){

      var list = [];
      while(element = element[property]){

        if(element.nodeType == 1){

          list.push(element);
        };
      };
      return list;
    },
    getSiblings : function(element){

      return this.getPreviousSiblings(element).reverse().concat(this.getNextSiblings(element));
    },
    isEmpty : function(element){

      element = element.firstChild;
      while(element){

        if(element.nodeType === qx.dom.Node.ELEMENT || element.nodeType === qx.dom.Node.TEXT){

          return false;
        };
        element = element.nextSibling;
      };
      return true;
    },
    cleanWhitespace : function(element){

      var node = element.firstChild;
      while(node){

        var nextNode = node.nextSibling;
        if(node.nodeType == 3 && !/\S/.test(node.nodeValue)){

          element.removeChild(node);
        };
        node = nextNode;
      };
    }
  }
});

qx.Class.define("qx.util.LibraryManager", {
  extend : qx.core.Object,
  type : "singleton",
  statics : {
    __libs : qx.$$libraries || {
    }
  },
  members : {
    has : function(namespace){

      return !!this.self(arguments).__libs[namespace];
    },
    get : function(namespace, key){

      return this.self(arguments).__libs[namespace][key] ? this.self(arguments).__libs[namespace][key] : null;
    },
    set : function(namespace, key, value){

      this.self(arguments).__libs[namespace][key] = value;
    }
  }
});

qx.Bootstrap.define("qx.bom.client.Transport", {
  statics : {
    getMaxConcurrentRequestCount : function(){

      var maxConcurrentRequestCount;
      var versionParts = qx.bom.client.Engine.getVersion().split(".");
      var versionMain = 0;
      var versionMajor = 0;
      var versionMinor = 0;
      if(versionParts[0]){

        versionMain = versionParts[0];
      };
      if(versionParts[1]){

        versionMajor = versionParts[1];
      };
      if(versionParts[2]){

        versionMinor = versionParts[2];
      };
      if(window.maxConnectionsPerServer){

        maxConcurrentRequestCount = window.maxConnectionsPerServer;
      } else if(qx.bom.client.Engine.getName() == "opera"){

        maxConcurrentRequestCount = 8;
      } else if(qx.bom.client.Engine.getName() == "webkit"){

        maxConcurrentRequestCount = 4;
      } else if(qx.bom.client.Engine.getName() == "gecko" && ((versionMain > 1) || ((versionMain == 1) && (versionMajor > 9)) || ((versionMain == 1) && (versionMajor == 9) && (versionMinor >= 1)))){

        maxConcurrentRequestCount = 6;
      } else {

        maxConcurrentRequestCount = 2;
      };;;
      return maxConcurrentRequestCount;
    },
    getSsl : function(){

      return window.location.protocol === "https:";
    },
    getXmlHttpRequest : function(){

      var supports = window.ActiveXObject ? (function(){

        if(window.location.protocol !== "file:"){

          try{

            new window.XMLHttpRequest();
            return "xhr";
          } catch(noXhr) {
          };
        };
        try{

          new window.ActiveXObject("Microsoft.XMLHTTP");
          return "activex";
        } catch(noActiveX) {
        };
      })() : (function(){

        try{

          new window.XMLHttpRequest();
          return "xhr";
        } catch(noXhr) {
        };
      })();
      return supports || "";
    }
  },
  defer : function(statics){

    qx.core.Environment.add("io.maxrequests", statics.getMaxConcurrentRequestCount);
    qx.core.Environment.add("io.ssl", statics.getSsl);
    qx.core.Environment.add("io.xhr", statics.getXmlHttpRequest);
  }
});

qx.Class.define("qx.util.ResourceManager", {
  extend : qx.core.Object,
  type : "singleton",
  construct : function(){

    this.base(arguments);
  },
  statics : {
    __registry : qx.$$resources || {
    },
    __urlPrefix : {
    }
  },
  members : {
    has : function(id){

      return !!this.self(arguments).__registry[id];
    },
    getData : function(id){

      return this.self(arguments).__registry[id] || null;
    },
    getImageWidth : function(id){

      var entry = this.self(arguments).__registry[id];
      return entry ? entry[0] : null;
    },
    getImageHeight : function(id){

      var entry = this.self(arguments).__registry[id];
      return entry ? entry[1] : null;
    },
    getImageFormat : function(id){

      var entry = this.self(arguments).__registry[id];
      return entry ? entry[2] : null;
    },
    getCombinedFormat : function(id){

      var clippedtype = "";
      var entry = this.self(arguments).__registry[id];
      var isclipped = entry && entry.length > 4 && typeof (entry[4]) == "string" && this.constructor.__registry[entry[4]];
      if(isclipped){

        var combId = entry[4];
        var combImg = this.constructor.__registry[combId];
        clippedtype = combImg[2];
      };
      return clippedtype;
    },
    toUri : function(id){

      if(id == null){

        return id;
      };
      var entry = this.self(arguments).__registry[id];
      if(!entry){

        return id;
      };
      if(typeof entry === "string"){

        var lib = entry;
      } else {

        var lib = entry[3];
        if(!lib){

          return id;
        };
      };
      var urlPrefix = "";
      if((qx.core.Environment.get("engine.name") == "mshtml") && qx.core.Environment.get("io.ssl")){

        urlPrefix = this.self(arguments).__urlPrefix[lib];
      };
      return urlPrefix + qx.util.LibraryManager.getInstance().get(lib, "resourceUri") + "/" + id;
    },
    toDataUri : function(resid){

      var resentry = this.constructor.__registry[resid];
      var combined = this.constructor.__registry[resentry[4]];
      var uri;
      if(combined){

        var resstruct = combined[4][resid];
        uri = "data:image/" + resstruct["type"] + ";" + resstruct["encoding"] + "," + resstruct["data"];
      } else {

        uri = this.toUri(resid);
      };
      return uri;
    }
  },
  defer : function(statics){

    if((qx.core.Environment.get("engine.name") == "mshtml")){

      if(qx.core.Environment.get("io.ssl")){

        for(var lib in qx.$$libraries){

          var resourceUri;
          if(qx.util.LibraryManager.getInstance().get(lib, "resourceUri")){

            resourceUri = qx.util.LibraryManager.getInstance().get(lib, "resourceUri");
          } else {

            statics.__urlPrefix[lib] = "";
            continue;
          };
          if(resourceUri.match(/^\/\//) != null){

            statics.__urlPrefix[lib] = window.location.protocol;
          } else if(resourceUri.match(/^\//) != null){

            statics.__urlPrefix[lib] = window.location.protocol + "//" + window.location.host;
          } else if(resourceUri.match(/^\.\//) != null){

            var url = document.URL;
            statics.__urlPrefix[lib] = url.substring(0, url.lastIndexOf("/") + 1);
          } else if(resourceUri.match(/^http/) != null){

            statics.__urlPrefix[lib] = "";
          } else {

            var index = window.location.href.indexOf("?");
            var href;
            if(index == -1){

              href = window.location.href;
            } else {

              href = window.location.href.substring(0, index);
            };
            statics.__urlPrefix[lib] = href.substring(0, href.lastIndexOf("/") + 1);
          };;;
        };
      };
    };
  }
});

qx.Class.define("qx.event.Timer", {
  extend : qx.core.Object,
  construct : function(interval){

    this.base(arguments);
    this.setEnabled(false);
    if(interval != null){

      this.setInterval(interval);
    };
    var self = this;
    this.__oninterval = function(){

      self._oninterval.call(self);
    };
  },
  events : {
    "interval" : "qx.event.type.Event"
  },
  statics : {
    once : function(func, obj, timeout){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert.assertFunction(func, "func is not a function");
        qx.core.Assert.assertNotUndefined(timeout, "No timeout given");
      };
      var timer = new qx.event.Timer(timeout);
      timer.__onceFunc = func;
      timer.addListener("interval", function(e){

        timer.stop();
        func.call(obj, e);
        timer.dispose();
        obj = null;
      }, obj);
      timer.start();
      return timer;
    }
  },
  properties : {
    enabled : {
      init : true,
      check : "Boolean",
      apply : "_applyEnabled"
    },
    interval : {
      check : "Integer",
      init : 1000,
      apply : "_applyInterval"
    }
  },
  members : {
    __intervalHandler : null,
    __oninterval : null,
    _applyInterval : function(value, old){

      if(this.getEnabled()){

        this.restart();
      };
    },
    _applyEnabled : function(value, old){

      if(old){

        window.clearInterval(this.__intervalHandler);
        this.__intervalHandler = null;
      } else if(value){

        this.__intervalHandler = window.setInterval(this.__oninterval, this.getInterval());
      };
    },
    start : function(){

      this.setEnabled(true);
    },
    startWith : function(interval){

      this.setInterval(interval);
      this.start();
    },
    stop : function(){

      this.setEnabled(false);
    },
    restart : function(){

      this.stop();
      this.start();
    },
    restartWith : function(interval){

      this.stop();
      this.startWith(interval);
    },
    _oninterval : qx.event.GlobalError.observeMethod(function(){

      if(this.$$disposed){

        return;
      };
      if(this.getEnabled()){

        this.fireEvent("interval");
      };
    })
  },
  destruct : function(){

    if(this.__intervalHandler){

      window.clearInterval(this.__intervalHandler);
    };
    this.__intervalHandler = this.__oninterval = null;
  }
});

qx.Class.define("qx.event.Idle", {
  extend : qx.core.Object,
  type : "singleton",
  construct : function(){

    this.base(arguments);
    var timer = new qx.event.Timer(this.getTimeoutInterval());
    timer.addListener("interval", this._onInterval, this);
    timer.start();
    this.__timer = timer;
  },
  events : {
    "interval" : "qx.event.type.Event"
  },
  properties : {
    timeoutInterval : {
      check : "Number",
      init : 100,
      apply : "_applyTimeoutInterval"
    }
  },
  members : {
    __timer : null,
    _applyTimeoutInterval : function(value){

      this.__timer.setInterval(value);
    },
    _onInterval : function(){

      this.fireEvent("interval");
    }
  },
  destruct : function(){

    if(this.__timer){

      this.__timer.stop();
    };
    this.__timer = null;
  }
});

qx.Class.define("qx.bom.IframeHistory", {
  extend : qx.bom.History,
  construct : function(){

    this.base(arguments);
    this.__initTimer();
  },
  members : {
    __iframe : null,
    __iframeReady : false,
    __writeStateTimner : null,
    __dontApplyState : null,
    __locationState : null,
    _setInitialState : function(){

      this.base(arguments);
      this.__locationState = this._getHash();
    },
    _setHash : function(value){

      this.base(arguments, value);
      this.__locationState = this._encode(value);
    },
    addToHistory : function(state, newTitle){

      if(!qx.lang.Type.isString(state)){

        state = state + "";
      };
      if(qx.lang.Type.isString(newTitle)){

        this.setTitle(newTitle);
        this._titles[state] = newTitle;
      };
      if(this.getState() !== state){

        this.setState(state);
      };
      this.fireDataEvent("request", state);
    },
    _onHistoryLoad : function(state){

      this._setState(state);
      this.fireDataEvent("request", state);
      if(this._titles[state] != null){

        this.setTitle(this._titles[state]);
      };
    },
    _setState : function(state){

      this.__dontApplyState = true;
      this.setState(state);
      this.__dontApplyState = false;
    },
    _applyState : function(value, old){

      if(this.__dontApplyState){

        return;
      };
      this._writeState(value);
    },
    _readState : function(){

      if(!this.__iframeReady){

        return this._decode(this._getHash());
      };
      var doc = this.__iframe.contentWindow.document;
      var elem = doc.getElementById("state");
      return elem ? this._decode(elem.innerText) : "";
    },
    _writeState : function(state){

      if(!this.__iframeReady){

        this.__clearWriteSateTimer();
        this.__writeStateTimner = qx.event.Timer.once(function(){

          this._writeState(state);
        }, this, 50);
        return;
      };
      this.__clearWriteSateTimer();
      var state = this._encode(state);
      if(qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.version") != 8){

        this._setHash(state);
      };
      var doc = this.__iframe.contentWindow.document;
      doc.open();
      doc.write('<html><body><div id="state">' + state + '</div></body></html>');
      doc.close();
    },
    __clearWriteSateTimer : function(){

      if(this.__writeStateTimner){

        this.__writeStateTimner.stop();
        this.__writeStateTimner.dispose();
      };
    },
    __initTimer : function(){

      this.__initIframe(function(){

        qx.event.Idle.getInstance().addListener("interval", this.__onHashChange, this);
      });
    },
    __onHashChange : function(e){

      var currentState = null;
      var locationState = this._getHash();
      if(!this.__isCurrentLocationState(locationState)){

        currentState = this.__storeLocationState(locationState);
      } else {

        currentState = this._readState();
      };
      if(qx.lang.Type.isString(currentState) && currentState != this.getState()){

        this._onHistoryLoad(currentState);
      };
    },
    __storeLocationState : function(locationState){

      locationState = this._decode(locationState);
      this._writeState(locationState);
      return locationState;
    },
    __isCurrentLocationState : function(locationState){

      return qx.lang.Type.isString(locationState) && locationState == this.__locationState;
    },
    __initIframe : function(handler){

      this.__iframe = this.__createIframe();
      document.body.appendChild(this.__iframe);
      this.__waitForIFrame(function(){

        this._writeState(this.getState());
        if(handler){

          handler.call(this);
        };
      }, this);
    },
    __createIframe : function(){

      var iframe = qx.bom.Iframe.create({
        src : qx.util.ResourceManager.getInstance().toUri(qx.core.Environment.get("qx.blankpage"))
      });
      iframe.style.visibility = "hidden";
      iframe.style.position = "absolute";
      iframe.style.left = "-1000px";
      iframe.style.top = "-1000px";
      return iframe;
    },
    __waitForIFrame : function(callback, context, retry){

      if(typeof retry === "undefined"){

        retry = 0;
      };
      if(!this.__iframe.contentWindow || !this.__iframe.contentWindow.document){

        if(retry > 20){

          throw new Error("can't initialize iframe");
        };
        qx.event.Timer.once(function(){

          this.__waitForIFrame(callback, context, ++retry);
        }, this, 10);
        return;
      };
      this.__iframeReady = true;
      callback.call(context || window);
    }
  },
  destruct : function(){

    this.__iframe = null;
    if(this.__writeStateTimner){

      this.__writeStateTimner.dispose();
      this.__writeStateTimner = null;
    };
    qx.event.Idle.getInstance().removeListener("interval", this.__onHashChange, this);
  }
});

qx.Class.define("qx.bom.NativeHistory", {
  extend : qx.bom.History,
  construct : function(){

    this.base(arguments);
    this.__attachListeners();
  },
  members : {
    __checkOnHashChange : null,
    __attachListeners : function(){

      if(qx.bom.History.SUPPORTS_HASH_CHANGE_EVENT){

        var boundFunc = qx.lang.Function.bind(this.__onHashChange, this);
        this.__checkOnHashChange = qx.event.GlobalError.observeMethod(boundFunc);
        qx.bom.Event.addNativeListener(window, "hashchange", this.__checkOnHashChange);
      } else {

        qx.event.Idle.getInstance().addListener("interval", this.__onHashChange, this);
      };
    },
    __detatchListeners : function(){

      if(qx.bom.History.SUPPORTS_HASH_CHANGE_EVENT){

        qx.bom.Event.removeNativeListener(window, "hashchange", this.__checkOnHashChange);
      } else {

        qx.event.Idle.getInstance().removeListener("interval", this.__onHashChange, this);
      };
    },
    __onHashChange : function(){

      var currentState = this._readState();
      if(qx.lang.Type.isString(currentState) && currentState != this.getState()){

        this._onHistoryLoad(currentState);
      };
    },
    _readState : function(){

      return this._decode(this._getHash());
    },
    _writeState : qx.core.Environment.select("engine.name", {
      "opera" : function(state){

        qx.event.Timer.once(function(){

          this._setHash(this._encode(state));
        }, this, 0);
      },
      "default" : function(state){

        this._setHash(this._encode(state));
      }
    })
  },
  destruct : function(){

    this.__detatchListeners();
  }
});

qx.Mixin.define("qx.ui.mobile.core.MLayoutHandling", {
  members : {
    setLayout : function(layout){

      this._setLayout(layout);
    },
    getLayout : function(){

      return this._getLayout();
    }
  },
  statics : {
    remap : function(members){

      members.getLayout = members._getLayout;
      members.setLayout = members._setLayout;
    }
  }
});

qx.Mixin.define("qx.ui.mobile.core.MChildrenHandling", {
  members : {
    getChildren : function(){

      return this._getChildren();
    },
    hasChildren : function(){

      return this._hasChildren();
    },
    indexOf : function(child){

      return this._indexOf(child);
    },
    add : function(child, layoutProperties){

      this._add(child, layoutProperties);
    },
    addAt : function(child, index, options){

      this._addAt(child, index, options);
    },
    addBefore : function(child, before, layoutProperties){

      this._addBefore(child, before, layoutProperties);
    },
    addAfter : function(child, after, layoutProperties){

      this._addAfter(child, after, layoutProperties);
    },
    remove : function(child){

      this._remove(child);
    },
    removeAt : function(index){

      this._removeAt(index);
    },
    removeAll : function(){

      this._removeAll();
    }
  },
  statics : {
    remap : function(members){

      members.getChildren = members._getChildren;
      members.hasChildren = members._hasChildren;
      members.indexOf = members._indexOf;
      members.add = members._add;
      members.addAt = members._addAt;
      members.addBefore = members._addBefore;
      members.addAfter = members._addAfter;
      members.remove = members._remove;
      members.removeAt = members._removeAt;
      members.removeAll = members._removeAll;
    }
  }
});

qx.Class.define("qx.bom.Lifecycle", {
  statics : {
    onReady : function(callback, context){

      var Registration = qx.event.Registration;
      var appHandler = Registration.getManager(window).getHandler(qx.event.handler.Application);
      if(appHandler && appHandler.isApplicationReady()){

        callback.call(context);
      } else {

        Registration.addListener(window, "ready", callback, context);
      };
    },
    onShutdown : function(callback, context){

      qx.event.Registration.addListener(window, "shutdown", callback, context);
    }
  }
});

qx.Class.define("qx.ui.mobile.core.Widget", {
  extend : qx.core.Object,
  include : [qx.locale.MTranslation],
  construct : function(){

    this.base(arguments);
    this._setContainerElement(this._createContainerElement());
    this.__children = [];
    this.setId(this.getId());
    this.initDefaultCssClass();
    this.initName();
    this.initAnonymous();
    this.initActivatable();
  },
  events : {
    mousemove : "qx.event.type.Mouse",
    mouseover : "qx.event.type.Mouse",
    mouseout : "qx.event.type.Mouse",
    mousedown : "qx.event.type.Mouse",
    mouseup : "qx.event.type.Mouse",
    click : "qx.event.type.Mouse",
    dblclick : "qx.event.type.Mouse",
    contextmenu : "qx.event.type.Mouse",
    beforeContextmenuOpen : "qx.event.type.Mouse",
    mousewheel : "qx.event.type.MouseWheel",
    touchstart : "qx.event.type.Touch",
    touchend : "qx.event.type.Touch",
    touchmove : "qx.event.type.Touch",
    touchcancel : "qx.event.type.Touch",
    tap : "qx.event.type.Tap",
    longtap : "qx.event.type.Tap",
    swipe : "qx.event.type.Touch",
    rotate : "qx.event.type.Rotate",
    pinch : "qx.event.type.Pinch",
    track : "qx.event.type.Track",
    keyup : "qx.event.type.KeySequence",
    keydown : "qx.event.type.KeySequence",
    keypress : "qx.event.type.KeySequence",
    keyinput : "qx.event.type.KeyInput",
    domupdated : "qx.event.type.Event",
    appear : "qx.event.type.Event",
    disappear : "qx.event.type.Event",
    focus : "qx.event.type.Focus",
    blur : "qx.event.type.Focus",
    focusin : "qx.event.type.Focus",
    focusout : "qx.event.type.Focus",
    activate : "qx.event.type.Focus",
    deactivate : "qx.event.type.Focus",
    roll : "qx.event.type.Roll"
  },
  properties : {
    defaultCssClass : {
      check : "String",
      init : null,
      nullable : true,
      apply : "_applyDefaultCssClass"
    },
    enabled : {
      init : true,
      check : "Boolean",
      nullable : false,
      event : "changeEnabled",
      apply : "_applyEnabled"
    },
    name : {
      check : "String",
      init : null,
      nullable : true,
      apply : "_applyAttribute"
    },
    anonymous : {
      check : "Boolean",
      init : null,
      nullable : true,
      apply : "_applyStyle"
    },
    id : {
      check : "String",
      init : null,
      nullable : true,
      apply : "_applyId",
      transform : "_transformId",
      event : "changeId"
    },
    visibility : {
      check : ["visible", "hidden", "excluded"],
      init : "visible",
      apply : "_applyVisibility",
      event : "changeVisibility"
    },
    activatable : {
      check : "Boolean",
      init : false,
      apply : "_applyAttribute"
    },
    rotation : {
      check : "Number",
      nullable : true,
      init : null,
      apply : "_transform"
    },
    transformUnit : {
      check : ["rem", "px"],
      nullable : false,
      init : "rem",
      apply : "_transform"
    },
    scaleX : {
      check : "Number",
      nullable : true,
      init : null,
      apply : "_transform"
    },
    scaleY : {
      check : "Number",
      nullable : true,
      init : null,
      apply : "_transform"
    },
    translateX : {
      check : "Number",
      nullable : true,
      init : 0,
      apply : "_transform"
    },
    translateY : {
      check : "Number",
      nullable : true,
      init : 0,
      apply : "_transform"
    },
    translateZ : {
      check : "Number",
      nullable : true,
      init : 0,
      apply : "_transform"
    }
  },
  statics : {
    ID_PREFIX : "qx_id_",
    __registry : {
    },
    __idCounter : 0,
    __domUpdatedScheduleId : null,
    onShutdown : function(){

      window.clearTimeout(qx.ui.mobile.core.Widget.__domUpdatedScheduleId);
      delete qx.ui.mobile.core.Widget.__registry;
    },
    getCurrentId : function(){

      return qx.ui.mobile.core.Widget.__idCounter;
    },
    registerWidget : function(widget){

      var id = widget.getId();
      var registry = qx.ui.mobile.core.Widget.__registry;
      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert.assertUndefined(registry[id], "Widget with the id '" + id + "' is already registered");
      };
      registry[id] = widget;
    },
    unregisterWidget : function(id){

      delete qx.ui.mobile.core.Widget.__registry[id];
    },
    getWidgetById : function(id){

      return qx.ui.mobile.core.Widget.__registry[id];
    },
    scheduleDomUpdated : function(){

      if(qx.ui.mobile.core.Widget.__domUpdatedScheduleId == null){

        qx.ui.mobile.core.Widget.__domUpdatedScheduleId = window.setTimeout(qx.ui.mobile.core.Widget.domUpdated, 0);
      };
    },
    domUpdated : qx.event.GlobalError.observeMethod(function(){

      var clazz = qx.ui.mobile.core.Widget;
      window.clearTimeout(clazz.__domUpdatedScheduleId);
      clazz.__domUpdatedScheduleId = null;
      qx.event.handler.Appear.refresh();
      qx.ui.mobile.core.DomUpdatedHandler.refresh();
    }),
    addAttributeMapping : function(property, attribute, values){

      if(qx.core.Environment.get("qx.debug")){

        var attributeMapping = qx.ui.mobile.core.Widget.ATTRIBUTE_MAPPING;
        qx.core.Assert.assertUndefined(attributeMapping[property], "Attribute mapping for " + property + " already exists");
      };
      qx.ui.mobile.core.Widget.ATTRIBUTE_MAPPING[property] = {
        attribute : attribute,
        values : values
      };
    },
    addStyleMapping : function(property, style, values){

      if(qx.core.Environment.get("qx.debug")){

        var styleMapping = qx.ui.mobile.core.Widget.STYLE_MAPPING;
        qx.core.Assert.assertUndefined(styleMapping[property], "Style mapping for " + property + " already exists");
      };
      qx.ui.mobile.core.Widget.STYLE_MAPPING[property] = {
        style : style,
        values : values
      };
    },
    ATTRIBUTE_MAPPING : {
      "selectable" : {
        attribute : "data-selectable",
        values : {
          "true" : null,
          "false" : "false"
        }
      },
      "activatable" : {
        attribute : "data-activatable",
        values : {
          "true" : "true",
          "false" : null
        }
      },
      "readOnly" : {
        attribute : "readonly"
      }
    },
    STYLE_MAPPING : {
      "anonymous" : {
        style : "pointerEvents",
        values : {
          "true" : "none",
          "false" : null
        }
      }
    }
  },
  members : {
    __containerElement : null,
    __contentElement : null,
    __layoutParent : null,
    __children : null,
    __layoutManager : null,
    _getTagName : function(){

      return "div";
    },
    _createContainerElement : function(){

      return qx.dom.Element.create(this._getTagName());
    },
    _domUpdated : function(){

      qx.ui.mobile.core.Widget.scheduleDomUpdated();
    },
    _transformId : function(value){

      if(value == null){

        var clazz = qx.ui.mobile.core.Widget;
        value = clazz.ID_PREFIX + clazz.__idCounter++;
      };
      return value;
    },
    _applyId : function(value, old){

      if(old != null){

        qx.ui.mobile.core.Widget.unregisterWidget(old);
      };
      var element = this.getContainerElement();
      element.id = value;
      qx.ui.mobile.core.Widget.registerWidget(this);
    },
    _applyEnabled : function(value, old){

      if(value){

        this.removeCssClass("disabled");
        this._setStyle('anonymous', this.getAnonymous());
      } else {

        this.addCssClass("disabled");
        this._setStyle('anonymous', true);
      };
    },
    _add : function(child, layoutProperties){

      if(qx.core.Environment.get("qx.debug")){

        if(child.getLayoutParent() === this){

          throw new Error("The widget is already added this widget. Please remove it first.");
        };
      };
      this._initializeChildLayout(child, layoutProperties);
      this.getContentElement().appendChild(child.getContainerElement());
      this.__children.push(child);
      this._domUpdated();
    },
    _addAt : function(child, index, options){

      if(child.getLayoutParent() == this){

        qx.lang.Array.remove(this.__children, child);
      };
      var ref = this.__children[index];
      if(ref){

        this._addBefore(child, ref, options);
      } else {

        this._add(child, options);
      };
    },
    _addBefore : function(child, beforeWidget, layoutProperties){

      if(qx.core.Environment.get("qx.debug")){

        if(child.getLayoutParent() === this){

          throw new Error("The widget is already added this widget. Please remove it first.");
        };
        this.assertInArray(beforeWidget, this._getChildren(), "The 'before' widget is not a child of this widget!");
      };
      if(child == beforeWidget){

        return;
      };
      this._initializeChildLayout(child, layoutProperties);
      this.getContentElement().insertBefore(child.getContainerElement(), beforeWidget.getContainerElement());
      qx.lang.Array.insertBefore(this.__children, child, beforeWidget);
      this._domUpdated();
    },
    _addAfter : function(child, afterWidget, layoutProperties){

      if(qx.core.Environment.get("qx.debug")){

        if(child.getLayoutParent() === this){

          throw new Error("The child is already added to this widget. Please remove it first.");
        };
        this.assertInArray(afterWidget, this._getChildren(), "The 'after' widget is not a child of this widget!");
      };
      if(child == afterWidget){

        return;
      };
      this._initializeChildLayout(child, layoutProperties);
      var length = this._getChildren().length;
      var index = this._indexOf(afterWidget);
      if(index == length - 1){

        this.getContentElement().appendChild(child.getContainerElement());
      } else {

        var beforeWidget = this._getChildren()[index + 1];
        this.getContentElement().insertBefore(child.getContainerElement(), beforeWidget.getContainerElement());
      };
      qx.lang.Array.insertAfter(this.__children, child, afterWidget);
      this._domUpdated();
    },
    _remove : function(child){

      child.setLayoutParent(null);
      this._domUpdated();
    },
    _removeAt : function(index){

      if(!this.__children){

        throw new Error("This widget has no children!");
      };
      var child = this.__children[index];
      this._remove(child);
    },
    _removeAll : function(){

      var children = this.__children.concat();
      for(var i = 0,l = children.length;i < l;i++){

        this._remove(children[i]);
      };
      return children;
    },
    _indexOf : function(child){

      var children = this.__children;
      if(!children){

        return -1;
      };
      return children.indexOf(child);
    },
    setLayoutParent : function(parent){

      if(this.__layoutParent === parent){

        return;
      };
      var oldParent = this.__layoutParent;
      if(oldParent && !oldParent.$$disposed){

        this.__layoutParent.removeChild(this);
      };
      this.__layoutParent = parent || null;
    },
    removeChild : function(child){

      qx.lang.Array.remove(this.__children, child);
      this.getContentElement().removeChild(child.getContainerElement());
      var layout = this._getLayout();
      if(layout){

        layout.disconnectFromChildWidget(child);
      };
    },
    getLayoutParent : function(){

      return this.__layoutParent;
    },
    _getChildren : function(){

      return this.__children;
    },
    _hasChildren : function(){

      return this.__children && this.__children.length > 0;
    },
    _setLayout : function(layout){

      if(qx.core.Environment.get("qx.debug")){

        if(layout){

          this.assertInstance(layout, qx.ui.mobile.layout.Abstract);
        };
      };
      if(this.__layoutManager){

        this.__layoutManager.connectToWidget(null);
        for(var i = 0;i < this._getChildren().length;i++){

          var child = this._getChildren()[i];
          this.__layoutManager.disconnectFromChildWidget(child);
        };
      };
      if(layout){

        layout.connectToWidget(this);
      };
      this.__layoutManager = layout;
      this._domUpdated();
    },
    _initializeChildLayout : function(child, layoutProperties){

      child.setLayoutParent(this);
      child.setLayoutProperties(layoutProperties);
      var layout = this._getLayout();
      if(layout){

        layout.connectToChildWidget(child);
      };
    },
    _getLayout : function(){

      return this.__layoutManager;
    },
    setLayoutProperties : function(properties){

      var parent = this.getLayoutParent();
      if(parent){

        parent.updateLayoutProperties(this, properties);
      };
    },
    updateLayoutProperties : function(widget, properties){

      var layout = this._getLayout();
      if(layout){

        layout.setLayoutProperties(widget, properties);
      };
      this._domUpdated();
    },
    updateLayout : function(widget, action, properties){

      var layout = this._getLayout();
      if(layout){

        layout.updateLayout(widget, action, properties);
      };
      this._domUpdated();
    },
    _setHtml : function(value){

      this.getContentElement().innerHTML = value || "";
      this._domUpdated();
    },
    _transform : function(){

      var propertyValue = "";
      if(this.getRotation() != null){

        propertyValue = propertyValue + "rotate(" + this.getRotation() + "deg) ";
      };
      if(this.getScaleX() != null && this.getScaleY() != null){

        propertyValue = propertyValue + "scale(" + this.getScaleX() + "," + this.getScaleY() + ") ";
      };
      var resolutionFactor = 1;
      if(this.getTransformUnit() == "rem"){

        resolutionFactor = 16;
      };
      if(this.getTranslateX() != null && this.getTranslateY() != null){

        var isTransform3d = qx.core.Environment.get("css.transform.3d");
        if(isTransform3d && this.getTranslateZ() != null){

          propertyValue = propertyValue + "translate3d(" + (this.getTranslateX() / resolutionFactor) + this.getTransformUnit() + "," + (this.getTranslateY() / resolutionFactor) + this.getTransformUnit() + "," + (this.getTranslateZ() / resolutionFactor) + this.getTransformUnit() + ") ";
        } else {

          propertyValue = propertyValue + "translate(" + (this.getTranslateX() / resolutionFactor) + this.getTransformUnit() + "," + (this.getTranslateY() / resolutionFactor) + this.getTransformUnit() + ") ";
        };
      };
      qx.bom.element.Style.set(this.getContainerElement(), "transform", propertyValue);
    },
    _applyAttribute : function(value, old, attribute){

      this._setAttribute(attribute, value);
    },
    _setAttribute : function(attribute, value){

      var mapping = qx.ui.mobile.core.Widget.ATTRIBUTE_MAPPING[attribute];
      if(mapping){

        attribute = mapping.attribute || attribute;
        var values = mapping.values;
        value = values && typeof values[value] !== "undefined" ? values[value] : value;
      };
      var element = this.getContainerElement();
      if(value != null){

        qx.bom.element.Attribute.set(element, attribute, value);
      } else {

        qx.bom.element.Attribute.reset(element, attribute);
      };
      this._domUpdated();
    },
    _getAttribute : function(attribute){

      var element = this.getContainerElement();
      return qx.bom.element.Attribute.get(element, attribute);
    },
    _applyStyle : function(value, old, style){

      this._setStyle(style, value);
    },
    _setStyle : function(style, value){

      var mapping = qx.ui.mobile.core.Widget.STYLE_MAPPING[style];
      if(mapping){

        style = mapping.style || style;
        value = mapping.values[value];
      };
      var element = this.getContainerElement();
      if(value != null){

        qx.bom.element.Style.set(element, style, value);
      } else {

        qx.bom.element.Style.reset(element, style);
      };
      this._domUpdated();
    },
    _getStyle : function(style){

      var element = this.getContainerElement();
      return qx.bom.element.Style.get(element, style);
    },
    _applyDefaultCssClass : function(value, old){

      if(old){

        this.removeCssClass(old);
      };
      if(value){

        this.addCssClass(value);
      };
    },
    addCssClass : function(cssClass){

      qx.bom.element.Class.add(this.getContainerElement(), cssClass);
      this._domUpdated();
    },
    addCssClasses : function(cssClasses){

      if(cssClasses){

        qx.bom.element.Class.addClasses(this.getContainerElement(), cssClasses);
        this._domUpdated();
      };
    },
    removeCssClass : function(cssClass){

      qx.bom.element.Class.remove(this.getContainerElement(), cssClass);
      this._domUpdated();
    },
    removeCssClasses : function(cssClasses){

      if(cssClasses){

        qx.bom.element.Class.removeClasses(this.getContainerElement(), cssClasses);
        this._domUpdated();
      };
    },
    toggleCssClass : function(cssClass){

      if(this.hasCssClass(cssClass)){

        this.removeCssClass(cssClass);
      } else {

        this.addCssClass(cssClass);
      };
    },
    hasCssClass : function(cssClass){

      return qx.bom.element.Class.has(this.getContainerElement(), cssClass);
    },
    _applyVisibility : function(value, old){

      if(value == "excluded"){

        this.addCssClass("exclude");
      } else if(value == "visible"){

        this.removeCssClass("exclude");
        this._setStyle("visibility", "visible");
      } else if(value == "hidden"){

        this._setStyle("visibility", "hidden");
      };;
      this._domUpdated();
    },
    __setVisibility : function(action, properties){

      this.setVisibility(action);
      var parent = this.getLayoutParent();
      if(parent){

        parent.updateLayout(this, action, properties);
      };
    },
    show : function(properties){

      this.__setVisibility("visible", properties);
    },
    hide : function(properties){

      this.__setVisibility("hidden", properties);
    },
    exclude : function(properties){

      this.__setVisibility("excluded", properties);
    },
    isVisible : function(){

      return this.getVisibility() === "visible";
    },
    isHidden : function(){

      return this.getVisibility() !== "visible";
    },
    isExcluded : function(){

      return this.getVisibility() === "excluded";
    },
    isSeeable : function(){

      return this.getContainerElement().offsetWidth > 0;
    },
    _setContainerElement : function(element){

      this.__containerElement = element;
    },
    getContainerElement : function(){

      return this.__containerElement;
    },
    getContentElement : function(){

      if(!this.__contentElement){

        this.__contentElement = this._getContentElement();
      };
      return this.__contentElement;
    },
    _getContentElement : function(){

      return this.getContainerElement();
    },
    destroy : function(){

      if(this.$$disposed){

        return;
      };
      var parent = this.__layoutParent;
      if(parent){

        parent._remove(this);
      };
      this.dispose();
    }
  },
  destruct : function(){

    if(!qx.core.ObjectRegistry.inShutDown){

      qx.event.Registration.removeAllListeners(this);
      if(this.getId()){

        qx.ui.mobile.core.Widget.unregisterWidget(this.getId());
      };
    };
    this.__layoutParent = this.__containerElement = this.__contentElement = null;
    if(this.__layoutManager){

      this.__layoutManager.dispose();
    };
    this.__layoutManager = null;
  },
  defer : function(statics){

    qx.bom.Lifecycle.onShutdown(statics.onShutdown, statics);
  }
});

qx.Bootstrap.define("qx.event.handler.PointerCore", {
  extend : Object,
  statics : {
    MOUSE_TO_POINTER_MAPPING : {
      mousedown : "pointerdown",
      mouseup : "pointerup",
      mousemove : "pointermove",
      mouseout : "pointerout",
      mouseover : "pointerover"
    },
    TOUCH_TO_POINTER_MAPPING : {
      touchstart : "pointerdown",
      touchend : "pointerup",
      touchmove : "pointermove",
      touchcancel : "pointercancel"
    },
    MSPOINTER_TO_POINTER_MAPPING : {
      MSPointerDown : "pointerdown",
      MSPointerMove : "pointermove",
      MSPointerUp : "pointerup",
      MSPointerCancel : "pointercancel",
      MSPointerLeave : "pointerleave",
      MSPointerEnter : "pointerenter",
      MSPointerOver : "pointerover",
      MSPointerOut : "pointerout"
    },
    POINTER_TO_GESTURE_MAPPING : {
      pointerdown : "gesturebegin",
      pointerup : "gesturefinish",
      pointercancel : "gesturecancel",
      pointermove : "gesturemove"
    },
    SIM_MOUSE_DISTANCE : 25,
    SIM_MOUSE_DELAY : 2500,
    __lastTouch : null
  },
  construct : function(target, emitter){

    this.__defaultTarget = target;
    this.__emitter = emitter;
    this.__eventNames = [];
    this.__buttonStates = [];
    var engineName = qx.core.Environment.get("engine.name");
    var docMode = parseInt(qx.core.Environment.get("browser.documentmode"), 10);
    if(engineName == "mshtml" && docMode == 10){

      this.__eventNames = ["MSPointerDown", "MSPointerMove", "MSPointerUp", "MSPointerCancel", "MSPointerOver", "MSPointerOut"];
      this._initPointerObserver();
    } else {

      if(qx.core.Environment.get("event.mspointer")){

        this.__nativePointerEvents = true;
      };
      this.__eventNames = ["pointerdown", "pointermove", "pointerup", "pointercancel", "pointerover", "pointerout"];
      this._initPointerObserver();
    };
    if(!qx.core.Environment.get("event.mspointer")){

      if(qx.core.Environment.get("device.touch")){

        this.__eventNames = ["touchstart", "touchend", "touchmove", "touchcancel"];
        this._initObserver(this._onTouchEvent);
      };
      this.__eventNames = ["mousedown", "mouseup", "mousemove", "mouseover", "mouseout", "contextmenu"];
      this._initObserver(this._onMouseEvent);
    };
  },
  members : {
    __defaultTarget : null,
    __emitter : null,
    __eventNames : null,
    __nativePointerEvents : false,
    __wrappedListener : null,
    __lastButtonState : 0,
    __buttonStates : null,
    __primaryIdentifier : null,
    _initPointerObserver : function(){

      this._initObserver(this._onPointerEvent);
    },
    _initObserver : function(callback, useEmitter){

      this.__wrappedListener = qx.lang.Function.listener(callback, this);
      this.__eventNames.forEach(function(type){

        if(useEmitter && qx.dom.Node.isDocument(this.__defaultTarget)){

          if(!this.__defaultTarget.$$emitter){

            this.__defaultTarget.$$emitter = new qx.event.Emitter();
          };
          this.__defaultTarget.$$emitter.on(type, this.__wrappedListener);
        } else {

          qx.bom.Event.addNativeListener(this.__defaultTarget, type, this.__wrappedListener);
        };
      }.bind(this));
    },
    _onPointerEvent : function(domEvent){

      if(!qx.core.Environment.get("event.mspointer")){

        return;
      };
      if(!this.__nativePointerEvents){

        domEvent.stopPropagation();
      };
      var type = qx.event.handler.PointerCore.MSPOINTER_TO_POINTER_MAPPING[domEvent.type] || domEvent.type;
      var target = qx.bom.Event.getTarget(domEvent);
      var evt = new qx.event.type.dom.Pointer(type, domEvent);
      this._fireEvent(evt, type, target);
    },
    _onTouchEvent : function(domEvent){

      var type = qx.event.handler.PointerCore.TOUCH_TO_POINTER_MAPPING[domEvent.type];
      var changedTouches = domEvent.changedTouches;
      domEvent.stopPropagation();
      if(domEvent.type == "touchstart" && this.__primaryIdentifier === null){

        this.__primaryIdentifier = changedTouches[0].identifier;
      };
      for(var i = 0,l = changedTouches.length;i < l;i++){

        var touch = changedTouches[i];
        var touchProps = {
          clientX : touch.clientX,
          clientY : touch.clientY,
          pageX : touch.pageX,
          pageY : touch.pageY,
          identifier : touch.identifier,
          screenX : touch.screenX,
          screenY : touch.screenY,
          target : document.elementFromPoint(touch.clientX, touch.clientY),
          pointerType : "touch",
          pointerId : touch.identifier + 2
        };
        if(domEvent.type == "touchstart"){

          var overEvt = new qx.event.type.dom.Pointer("pointerover", domEvent, touchProps);
          this._fireEvent(overEvt, "pointerover", touchProps.target);
        };
        var evt = new qx.event.type.dom.Pointer(type, domEvent, touchProps);
        if(touch.identifier == this.__primaryIdentifier){

          evt.isPrimary = true;
          evt.button = 0;
          evt.buttons = 1;
          qx.event.handler.PointerCore.__lastTouch = {
            "x" : touch.clientX,
            "y" : touch.clientY,
            "time" : new Date().getTime()
          };
        };
        this._fireEvent(evt, type, touchProps.target);
        if(domEvent.type == "touchend" || domEvent.type == "touchcancel"){

          var outEvt = new qx.event.type.dom.Pointer("pointerout", domEvent, touchProps);
          this._fireEvent(outEvt, "pointerout", domEvent.target);
          if(this.__primaryIdentifier == touch.identifier){

            this.__primaryIdentifier = null;
          };
        };
      };
    },
    _onMouseEvent : function(domEvent){

      qx.bom.Event.stopPropagation(domEvent);
      if(this._isSimulatedMouseEvent(domEvent.clientX, domEvent.clientY)){

        return;
      };
      if(domEvent.type == "mousedown"){

        this.__buttonStates[domEvent.which] = 1;
      } else if(domEvent.type == "mouseup"){

        this.__buttonStates[domEvent.which] = 0;
      };
      var type = qx.event.handler.PointerCore.MOUSE_TO_POINTER_MAPPING[domEvent.type];
      var target = qx.bom.Event.getTarget(domEvent);
      var buttonsPressed = qx.lang.Array.sum(this.__buttonStates);
      var mouseProps = {
        pointerType : "mouse",
        pointerId : 1
      };
      if(this.__lastButtonState != buttonsPressed && buttonsPressed !== 0 && this.__lastButtonState !== 0){

        var moveEvt = new qx.event.type.dom.Pointer("pointermove", domEvent, mouseProps);
        this._fireEvent(moveEvt, "pointermove", target);
      };
      this.__lastButtonState = buttonsPressed;
      if(domEvent.type == "mousedown" && buttonsPressed > 1){

        return;
      };
      if(domEvent.type == "mouseup" && buttonsPressed > 0){

        return;
      };
      if(domEvent.type == "contextmenu"){

        this.__buttonStates[domEvent.which] = 0;
        return;
      };
      var evt = new qx.event.type.dom.Pointer(type, domEvent, mouseProps);
      this._fireEvent(evt, type, target);
    },
    _isSimulatedMouseEvent : function(x, y){

      var touch = qx.event.handler.PointerCore.__lastTouch;
      if(touch){

        var timeSinceTouch = new Date().getTime() - touch.time;
        var dist = qx.event.handler.PointerCore.SIM_MOUSE_DISTANCE;
        var distX = Math.abs(x - qx.event.handler.PointerCore.__lastTouch.x);
        var distY = Math.abs(y - qx.event.handler.PointerCore.__lastTouch.y);
        if(timeSinceTouch < qx.event.handler.PointerCore.SIM_MOUSE_DELAY){

          if(distX < dist || distY < dist){

            return true;
          };
        };
      };
      return false;
    },
    _stopObserver : function(){

      for(var i = 0;i < this.__eventNames.length;i++){

        qx.bom.Event.removeNativeListener(this.__defaultTarget, this.__eventNames[i], this.__wrappedListener);
      };
    },
    _fireEvent : function(domEvent, type, target){

      target = target || domEvent.target;
      type = type || domEvent.type;
      var gestureEvent;
      if(type == "pointerdown" || type == "pointerup" || type == "pointermove"){

        gestureEvent = new qx.event.type.dom.Pointer(qx.event.handler.PointerCore.POINTER_TO_GESTURE_MAPPING[type], domEvent);
        qx.event.type.dom.Pointer.normalize(gestureEvent);
        gestureEvent.srcElement = target;
      };
      if(qx.core.Environment.get("event.dispatchevent")){

        if(!this.__nativePointerEvents){

          target.dispatchEvent(domEvent);
        };
        if(gestureEvent){

          target.dispatchEvent(gestureEvent);
        };
      } else {

        domEvent.srcElement = target;
        while(target){

          if(target.$$emitter){

            domEvent.currentTarget = target;
            if(!domEvent._stopped){

              target.$$emitter.emit(type, domEvent);
            };
            if(gestureEvent && !gestureEvent._stopped){

              gestureEvent.currentTarget = target;
              target.$$emitter.emit(gestureEvent.type, gestureEvent);
            };
          };
          target = target.parentNode;
        };
      };
    },
    dispose : function(){

      this._stopObserver();
      this.__defaultTarget = this.__emitter = null;
    }
  }
});

qx.Bootstrap.define("qx.event.Emitter", {
  extend : Object,
  statics : {
    __storage : []
  },
  members : {
    __listener : null,
    __any : null,
    on : function(name, listener, ctx){

      var id = qx.event.Emitter.__storage.length;
      this.__getStorage(name).push({
        listener : listener,
        ctx : ctx,
        id : id
      });
      qx.event.Emitter.__storage.push({
        name : name,
        listener : listener,
        ctx : ctx
      });
      return id;
    },
    once : function(name, listener, ctx){

      var id = qx.event.Emitter.__storage.length;
      this.__getStorage(name).push({
        listener : listener,
        ctx : ctx,
        once : true,
        id : id
      });
      qx.event.Emitter.__storage.push({
        name : name,
        listener : listener,
        ctx : ctx
      });
      return id;
    },
    off : function(name, listener, ctx){

      var storage = this.__getStorage(name);
      for(var i = storage.length - 1;i >= 0;i--){

        var entry = storage[i];
        if(entry.listener == listener && entry.ctx == ctx){

          storage.splice(i, 1);
          qx.event.Emitter.__storage[entry.id] = null;
          return entry.id;
        };
      };
      return null;
    },
    offById : function(id){

      var entry = qx.event.Emitter.__storage[id];
      if(entry){

        this.off(entry.name, entry.listener, entry.ctx);
      };
      return null;
    },
    addListener : function(name, listener, ctx){

      return this.on(name, listener, ctx);
    },
    addListenerOnce : function(name, listener, ctx){

      return this.once(name, listener, ctx);
    },
    removeListener : function(name, listener, ctx){

      this.off(name, listener, ctx);
    },
    removeListenerById : function(id){

      this.offById(id);
    },
    emit : function(name, data){

      var storage = this.__getStorage(name);
      for(var i = 0;i < storage.length;i++){

        var entry = storage[i];
        entry.listener.call(entry.ctx, data);
        if(entry.once){

          storage.splice(i, 1);
          i--;
        };
      };
      storage = this.__getStorage("*");
      for(var i = storage.length - 1;i >= 0;i--){

        var entry = storage[i];
        entry.listener.call(entry.ctx, data);
      };
    },
    getListeners : function(){

      return this.__listener;
    },
    __getStorage : function(name){

      if(this.__listener == null){

        this.__listener = {
        };
      };
      if(this.__listener[name] == null){

        this.__listener[name] = [];
      };
      return this.__listener[name];
    }
  }
});

qx.Bootstrap.define("qx.event.type.dom.Custom", {
  extend : Object,
  statics : {
    PROPERTIES : {
      bubbles : false,
      cancelable : true
    }
  },
  construct : function(type, domEvent, customProps){

    this._type = type;
    this._event = this._createEvent();
    this._initEvent(domEvent, customProps);
    this._event._original = domEvent;
    this._event.preventDefault = function(){

      if(this._original.preventDefault){

        this._original.preventDefault();
      } else {

        try{

          this._original.returnValue = false;
        } catch(ex) {
        };
      };
    };
    if(this._event.stopPropagation){

      this._event._nativeStopPropagation = this._event.stopPropagation;
    };
    this._event.stopPropagation = function(){

      this._stopped = true;
      if(this._nativeStopPropagation){

        this._original.stopPropagation();
        this._nativeStopPropagation();
      } else {

        this._original.cancelBubble = true;
      };
    };
    return this._event;
  },
  members : {
    _type : null,
    _event : null,
    _createEvent : function(){

      var evt;
      if(qx.core.Environment.get("event.customevent")){

        evt = new window.CustomEvent(this._type);
      } else if(typeof document.createEvent == "function"){

        evt = document.createEvent("UIEvents");
      } else if(typeof document.createEventObject == "object"){

        evt = {
        };
        evt.type = this._type;
      };;
      return evt;
    },
    _initEvent : function(domEvent, customProps){

      var properties = qx.lang.Object.clone(qx.event.type.dom.Custom.PROPERTIES);
      for(var prop in customProps){

        properties[prop] = customProps[prop];
      };
      if(this._event.initEvent){

        this._event.initEvent(this._type, properties.bubbles, properties.cancelable);
      };
      for(var prop in properties){

        this._event[prop] = properties[prop];
      };
    }
  }
});

qx.Bootstrap.define("qx.event.type.dom.Pointer", {
  extend : qx.event.type.dom.Custom,
  statics : {
    MOUSE_PROPERTIES : ["bubbles", "cancelable", "view", "detail", "screenX", "screenY", "clientX", "clientY", "pageX", "pageY", "ctrlKey", "altKey", "shiftKey", "metaKey", "button", "which", "relatedTarget", "fromElement", "toElement"],
    POINTER_PROPERTIES : {
      pointerId : 1,
      width : 0,
      height : 0,
      pressure : 0.5,
      tiltX : 0,
      tiltY : 0,
      pointerType : "",
      isPrimary : false
    },
    BIND_METHODS : ["getPointerType", "getViewportLeft", "getViewportTop", "getDocumentLeft", "getDocumentTop", "getScreenLeft", "getScreenTop"],
    getPointerType : function(){

      if(typeof this.pointerType == "string"){

        return this.pointerType;
      };
      if(typeof this.pointerType == "number"){

        if(this.pointerType == this.MSPOINTER_TYPE_MOUSE){

          return "mouse";
        };
        if(this.pointerType == this.MSPOINTER_TYPE_PEN){

          return "pen";
        };
        if(this.pointerType == this.MSPOINTER_TYPE_TOUCH){

          return "touch";
        };
      };
      return "";
    },
    getViewportLeft : function(){

      return this.clientX;
    },
    getViewportTop : function(){

      return this.clientY;
    },
    getDocumentLeft : function(){

      if(this.pageX !== undefined){

        return this.pageX;
      } else {

        var win = qx.dom.Node.getWindow(this.srcElement);
        return this.clientX + qx.bom.Viewport.getScrollLeft(win);
      };
    },
    getDocumentTop : function(){

      if(this.pageY !== undefined){

        return this.pageY;
      } else {

        var win = qx.dom.Node.getWindow(this.srcElement);
        return this.clientY + qx.bom.Viewport.getScrollTop(win);
      };
    },
    getScreenLeft : function(){

      return this.screenX;
    },
    getScreenTop : function(){

      return this.screenY;
    },
    normalize : function(event){

      var bindMethods = qx.event.type.dom.Pointer.BIND_METHODS;
      for(var i = 0,l = bindMethods.length;i < l;i++){

        if(typeof event[bindMethods[i]] != "function"){

          event[bindMethods[i]] = qx.event.type.dom.Pointer[bindMethods[i]].bind(event);
        };
      };
    }
  },
  construct : function(type, domEvent, customProps){

    return this.base(arguments, type, domEvent, customProps);
  },
  members : {
    _createEvent : function(){

      var evt;
      if(qx.core.Environment.get("event.mouseevent")){

        evt = new window.MouseEvent(this._type);
      } else if(typeof document.createEvent == "function"){

        evt = document.createEvent("UIEvents");
      } else if(typeof document.createEventObject == "object"){

        evt = {
        };
        evt.type = this._type;
      };;
      return evt;
    },
    _initEvent : function(domEvent, customProps){

      var evt = this._event;
      qx.event.type.dom.Pointer.normalize(domEvent);
      var properties = {
      };
      var mousePropNames = qx.event.type.dom.Pointer.MOUSE_PROPERTIES;
      for(var i = 0;i < mousePropNames.length;i++){

        var propName = mousePropNames[i];
        if(propName in domEvent){

          properties[propName] = domEvent[propName];
        };
        if(customProps && customProps[propName] !== undefined){

          properties[propName] = customProps[propName];
        };
      };
      for(var pointerPropName in qx.event.type.dom.Pointer.POINTER_PROPERTIES){

        properties[pointerPropName] = qx.event.type.dom.Pointer.POINTER_PROPERTIES[pointerPropName];
        if(pointerPropName in domEvent){

          properties[pointerPropName] = domEvent[pointerPropName];
        };
        if(customProps && customProps[pointerPropName] !== undefined){

          properties[pointerPropName] = customProps[pointerPropName];
        };
      };
      var buttons;
      switch(domEvent.which){case 1:
      buttons = 1;
      break;case 2:
      buttons = 4;
      break;case 3:
      buttons = 2;
      break;default:
      buttons = 0;};
      if(buttons){

        properties.buttons = buttons;
        properties.pressure = buttons ? 0.5 : 0;
      };
      if(domEvent.pressure){

        properties.pressure = domEvent.pressure;
      };
      if(evt.initMouseEvent){

        evt.initMouseEvent(this._type, properties.bubbles, properties.cancelable, properties.view, properties.detail, properties.screenX, properties.screenY, properties.clientX, properties.clientY, properties.ctrlKey, properties.altKey, properties.shiftKey, properties.metaKey, properties.button, properties.relatedTarget);
      } else if(evt.initUIEvent){

        evt.initUIEvent(this._type, properties.bubbles, properties.cancelable, properties.view, properties.detail);
      };
      for(var prop in properties){

        evt[prop] = properties[prop];
      };
      switch(evt.pointerType){case domEvent.MSPOINTER_TYPE_MOUSE:
      evt.pointerType = "mouse";
      break;case domEvent.MSPOINTER_TYPE_PEN:
      evt.pointerType = "pen";
      break;case domEvent.MSPOINTER_TYPE_TOUCH:
      evt.pointerType = "touch";
      break;};
      if(evt.pointerType == "mouse"){

        evt.isPrimary = true;
      };
    }
  }
});

qx.Bootstrap.define("qx.bom.Viewport", {
  statics : {
    getWidth : function(win){

      var win = win || window;
      var doc = win.document;
      return qx.bom.Document.isStandardMode(win) ? doc.documentElement.clientWidth : doc.body.clientWidth;
    },
    getHeight : function(win){

      var win = win || window;
      var doc = win.document;
      if(qx.core.Environment.get("os.name") == "ios" && window.innerHeight != doc.documentElement.clientHeight){

        return window.innerHeight;
      };
      return qx.bom.Document.isStandardMode(win) ? doc.documentElement.clientHeight : doc.body.clientHeight;
    },
    getScrollLeft : function(win){

      var win = win ? win : window;
      if(typeof win.pageXOffset !== "undefined"){

        return win.pageXOffset;
      };
      var doc = win.document;
      return doc.documentElement.scrollLeft || doc.body.scrollLeft;
    },
    getScrollTop : function(win){

      var win = win ? win : window;
      if(typeof win.pageYOffset !== "undefined"){

        return win.pageYOffset;
      };
      var doc = win.document;
      return doc.documentElement.scrollTop || doc.body.scrollTop;
    },
    __getOrientationNormalizer : function(win){

      var currentOrientation = this.getWidth(win) > this.getHeight(win) ? 90 : 0;
      var deviceOrientation = win.orientation;
      if(deviceOrientation == null || Math.abs(deviceOrientation % 180) == currentOrientation){

        return {
          "-270" : 90,
          "-180" : 180,
          "-90" : -90,
          "0" : 0,
          "90" : 90,
          "180" : 180,
          "270" : -90
        };
      } else {

        return {
          "-270" : 180,
          "-180" : -90,
          "-90" : 0,
          "0" : 90,
          "90" : 180,
          "180" : -90,
          "270" : 0
        };
      };
    },
    __orientationNormalizer : null,
    getOrientation : function(win){

      var win = win || window.top;
      var orientation = win.orientation;
      if(orientation == null){

        orientation = this.getWidth(win) > this.getHeight(win) ? 90 : 0;
      } else {

        if(this.__orientationNormalizer == null){

          this.__orientationNormalizer = this.__getOrientationNormalizer(win);
        };
        orientation = this.__orientationNormalizer[orientation];
      };
      return orientation;
    },
    isLandscape : function(win){

      return this.getWidth(win) >= this.getHeight(win);
    },
    isPortrait : function(win){

      return this.getWidth(win) < this.getHeight(win);
    }
  }
});

qx.Bootstrap.define("qx.bom.Document", {
  statics : {
    isQuirksMode : qx.core.Environment.select("engine.name", {
      "mshtml" : function(win){

        if(qx.core.Environment.get("engine.version") >= 8){

          return (win || window).document.documentMode === 5;
        } else {

          return (win || window).document.compatMode !== "CSS1Compat";
        };
      },
      "webkit" : function(win){

        if(document.compatMode === undefined){

          var el = (win || window).document.createElement("div");
          el.style.cssText = "position:absolute;width:0;height:0;width:1";
          return el.style.width === "1px" ? true : false;
        } else {

          return (win || window).document.compatMode !== "CSS1Compat";
        };
      },
      "default" : function(win){

        return (win || window).document.compatMode !== "CSS1Compat";
      }
    }),
    isStandardMode : function(win){

      return !this.isQuirksMode(win);
    },
    getWidth : function(win){

      var doc = (win || window).document;
      var view = qx.bom.Viewport.getWidth(win);
      var scroll = this.isStandardMode(win) ? doc.documentElement.scrollWidth : doc.body.scrollWidth;
      return Math.max(scroll, view);
    },
    getHeight : function(win){

      var doc = (win || window).document;
      var view = qx.bom.Viewport.getHeight(win);
      var scroll = this.isStandardMode(win) ? doc.documentElement.scrollHeight : doc.body.scrollHeight;
      return Math.max(scroll, view);
    }
  }
});

qx.Bootstrap.define("qx.bom.client.Device", {
  statics : {
    __ids : {
      "iPod" : "ipod",
      "iPad" : "ipad",
      "iPhone" : "iphone",
      "PSP" : "psp",
      "PLAYSTATION 3" : "ps3",
      "Nintendo Wii" : "wii",
      "Nintendo DS" : "ds",
      "XBOX" : "xbox",
      "Xbox" : "xbox"
    },
    getName : function(){

      var str = [];
      for(var key in qx.bom.client.Device.__ids){

        str.push(key);
      };
      var reg = new RegExp("(" + str.join("|").replace(/\./g, "\.") + ")", "g");
      var match = reg.exec(navigator.userAgent);
      if(match && match[1]){

        return qx.bom.client.Device.__ids[match[1]];
      };
      return "pc";
    },
    getType : function(){

      return qx.bom.client.Device.detectDeviceType(navigator.userAgent);
    },
    detectDeviceType : function(userAgentString){

      if(qx.bom.client.Device.detectTabletDevice(userAgentString)){

        return "tablet";
      } else if(qx.bom.client.Device.detectMobileDevice(userAgentString)){

        return "mobile";
      };
      return "desktop";
    },
    detectMobileDevice : function(userAgentString){

      return /android.+mobile|ip(hone|od)|bada\/|blackberry|BB10|maemo|opera m(ob|in)i|fennec|NetFront|phone|psp|symbian|IEMobile|windows (ce|phone)|xda/i.test(userAgentString);
    },
    detectTabletDevice : function(userAgentString){

      var isIE10Tablet = (/MSIE 10/i.test(userAgentString)) && (/ARM/i.test(userAgentString)) && !(/windows phone/i.test(userAgentString));
      var isCommonTablet = (!(/android.+mobile|Tablet PC/i.test(userAgentString)) && (/Android|ipad|tablet|playbook|silk|kindle|psp/i.test(userAgentString)));
      return isIE10Tablet || isCommonTablet;
    },
    getDevicePixelRatio : function(){

      if(typeof window.devicePixelRatio !== "undefined"){

        return window.devicePixelRatio;
      };
      return 1;
    },
    getTouch : function(){

      return (("ontouchstart" in window) || window.navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0);
    }
  },
  defer : function(statics){

    qx.core.Environment.add("device.name", statics.getName);
    qx.core.Environment.add("device.touch", statics.getTouch);
    qx.core.Environment.add("device.type", statics.getType);
    qx.core.Environment.add("device.pixelRatio", statics.getDevicePixelRatio);
  }
});

qx.Class.define("qx.event.dispatch.AbstractBubbling", {
  extend : qx.core.Object,
  implement : qx.event.IEventDispatcher,
  type : "abstract",
  construct : function(manager){

    this._manager = manager;
  },
  members : {
    _getParent : function(target){

      throw new Error("Missing implementation");
    },
    canDispatchEvent : function(target, event, type){

      return event.getBubbles();
    },
    dispatchEvent : function(target, event, type){

      var parent = target;
      var manager = this._manager;
      var captureListeners,bubbleListeners;
      var localList;
      var listener,context;
      var currentTarget;
      var targetList = [];
      captureListeners = manager.getListeners(target, type, true);
      bubbleListeners = manager.getListeners(target, type, false);
      if(captureListeners){

        targetList.push(captureListeners);
      };
      if(bubbleListeners){

        targetList.push(bubbleListeners);
      };
      var parent = this._getParent(target);
      var bubbleList = [];
      var bubbleTargets = [];
      var captureList = [];
      var captureTargets = [];
      while(parent != null){

        captureListeners = manager.getListeners(parent, type, true);
        if(captureListeners){

          captureList.push(captureListeners);
          captureTargets.push(parent);
        };
        bubbleListeners = manager.getListeners(parent, type, false);
        if(bubbleListeners){

          bubbleList.push(bubbleListeners);
          bubbleTargets.push(parent);
        };
        parent = this._getParent(parent);
      };
      event.setEventPhase(qx.event.type.Event.CAPTURING_PHASE);
      for(var i = captureList.length - 1;i >= 0;i--){

        currentTarget = captureTargets[i];
        event.setCurrentTarget(currentTarget);
        localList = captureList[i];
        for(var j = 0,jl = localList.length;j < jl;j++){

          listener = localList[j];
          context = listener.context || currentTarget;
          if(qx.core.Environment.get("qx.debug")){

            if(context && context.isDisposed && context.isDisposed()){

              this.warn("The context object '" + context + "' for the event '" + type + "' of '" + currentTarget + "'is already disposed.");
            };
          };
          listener.handler.call(context, event);
        };
        if(event.getPropagationStopped()){

          return;
        };
      };
      event.setEventPhase(qx.event.type.Event.AT_TARGET);
      event.setCurrentTarget(target);
      for(var i = 0,il = targetList.length;i < il;i++){

        localList = targetList[i];
        for(var j = 0,jl = localList.length;j < jl;j++){

          listener = localList[j];
          context = listener.context || target;
          if(qx.core.Environment.get("qx.debug")){

            if(context && context.isDisposed && context.isDisposed()){

              this.warn("The context object '" + context + "' for the event '" + type + "' of '" + target + "'is already disposed.");
            };
          };
          listener.handler.call(context, event);
        };
        if(event.getPropagationStopped()){

          return;
        };
      };
      event.setEventPhase(qx.event.type.Event.BUBBLING_PHASE);
      for(var i = 0,il = bubbleList.length;i < il;i++){

        currentTarget = bubbleTargets[i];
        event.setCurrentTarget(currentTarget);
        localList = bubbleList[i];
        for(var j = 0,jl = localList.length;j < jl;j++){

          listener = localList[j];
          context = listener.context || currentTarget;
          if(qx.core.Environment.get("qx.debug")){

            if(context && context.isDisposed && context.isDisposed()){

              this.warn("The context object '" + context + "' for the event '" + type + "' of '" + currentTarget + "'is already disposed.");
            };
          };
          listener.handler.call(context, event);
        };
        if(event.getPropagationStopped()){

          return;
        };
      };
    }
  }
});

qx.Class.define("qx.event.dispatch.DomBubbling", {
  extend : qx.event.dispatch.AbstractBubbling,
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL
  },
  members : {
    _getParent : function(target){

      return target.parentNode;
    },
    canDispatchEvent : function(target, event, type){

      return target.nodeType !== undefined && event.getBubbles();
    }
  },
  defer : function(statics){

    qx.event.Registration.addDispatcher(statics);
  }
});

qx.Class.define("qx.event.type.Dom", {
  extend : qx.event.type.Native,
  statics : {
    SHIFT_MASK : 1,
    CTRL_MASK : 2,
    ALT_MASK : 4,
    META_MASK : 8
  },
  members : {
    _cloneNativeEvent : function(nativeEvent, clone){

      var clone = this.base(arguments, nativeEvent, clone);
      clone.shiftKey = nativeEvent.shiftKey;
      clone.ctrlKey = nativeEvent.ctrlKey;
      clone.altKey = nativeEvent.altKey;
      clone.metaKey = nativeEvent.metaKey;
      return clone;
    },
    getModifiers : function(){

      var mask = 0;
      var evt = this._native;
      if(evt.shiftKey){

        mask |= qx.event.type.Dom.SHIFT_MASK;
      };
      if(evt.ctrlKey){

        mask |= qx.event.type.Dom.CTRL_MASK;
      };
      if(evt.altKey){

        mask |= qx.event.type.Dom.ALT_MASK;
      };
      if(evt.metaKey){

        mask |= qx.event.type.Dom.META_MASK;
      };
      return mask;
    },
    isCtrlPressed : function(){

      return this._native.ctrlKey;
    },
    isShiftPressed : function(){

      return this._native.shiftKey;
    },
    isAltPressed : function(){

      return this._native.altKey;
    },
    isMetaPressed : function(){

      return this._native.metaKey;
    },
    isCtrlOrCommandPressed : function(){

      if(qx.core.Environment.get("os.name") == "osx" && qx.core.Environment.get("engine.name") != "opera"){

        return this._native.metaKey;
      } else {

        return this._native.ctrlKey;
      };
    }
  }
});

qx.Class.define("qx.event.type.Mouse", {
  extend : qx.event.type.Dom,
  members : {
    _cloneNativeEvent : function(nativeEvent, clone){

      var clone = this.base(arguments, nativeEvent, clone);
      clone.button = nativeEvent.button;
      clone.clientX = Math.round(nativeEvent.clientX);
      clone.clientY = Math.round(nativeEvent.clientY);
      clone.pageX = nativeEvent.pageX ? Math.round(nativeEvent.pageX) : undefined;
      clone.pageY = nativeEvent.pageY ? Math.round(nativeEvent.pageY) : undefined;
      clone.screenX = Math.round(nativeEvent.screenX);
      clone.screenY = Math.round(nativeEvent.screenY);
      clone.wheelDelta = nativeEvent.wheelDelta;
      clone.wheelDeltaX = nativeEvent.wheelDeltaX;
      clone.wheelDeltaY = nativeEvent.wheelDeltaY;
      clone.delta = nativeEvent.delta;
      clone.deltaX = nativeEvent.deltaX;
      clone.deltaY = nativeEvent.deltaY;
      clone.deltaZ = nativeEvent.deltaZ;
      clone.detail = nativeEvent.detail;
      clone.axis = nativeEvent.axis;
      clone.wheelX = nativeEvent.wheelX;
      clone.wheelY = nativeEvent.wheelY;
      clone.HORIZONTAL_AXIS = nativeEvent.HORIZONTAL_AXIS;
      clone.srcElement = nativeEvent.srcElement;
      clone.target = nativeEvent.target;
      return clone;
    },
    __buttonsDom2EventModel : {
      '0' : "left",
      '2' : "right",
      '1' : "middle"
    },
    __buttonsDom3EventModel : {
      '0' : "none",
      '1' : "left",
      '2' : "right",
      '4' : "middle"
    },
    __buttonsMshtmlEventModel : {
      '1' : "left",
      '2' : "right",
      '4' : "middle"
    },
    stop : function(){

      this.stopPropagation();
    },
    getButton : function(){

      switch(this._type){case "contextmenu":
      return "right";case "click":
      if(qx.core.Environment.get("browser.name") === "ie" && qx.core.Environment.get("browser.documentmode") < 9){

        return "left";
      };default:
      if(!(qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") <= 8)){

        if(this._native.button === -1){

          return this.__buttonsDom3EventModel[this._native.buttons] || "none";
        };
        return this.__buttonsDom2EventModel[this._native.button] || "none";
      } else {

        return this.__buttonsMshtmlEventModel[this._native.button] || "none";
      };};
    },
    isLeftPressed : function(){

      return this.getButton() === "left";
    },
    isMiddlePressed : function(){

      return this.getButton() === "middle";
    },
    isRightPressed : function(){

      return this.getButton() === "right";
    },
    getRelatedTarget : function(){

      return this._relatedTarget;
    },
    getViewportLeft : function(){

      return Math.round(this._native.clientX);
    },
    getViewportTop : function(){

      return Math.round(this._native.clientY);
    },
    getDocumentLeft : function(){

      if(this._native.pageX !== undefined){

        return Math.round(this._native.pageX);
      } else if(this._native.srcElement){

        var win = qx.dom.Node.getWindow(this._native.srcElement);
        return Math.round(this._native.clientX) + qx.bom.Viewport.getScrollLeft(win);
      } else {

        return Math.round(this._native.clientX) + qx.bom.Viewport.getScrollLeft(window);
      };
    },
    getDocumentTop : function(){

      if(this._native.pageY !== undefined){

        return Math.round(this._native.pageY);
      } else if(this._native.srcElement){

        var win = qx.dom.Node.getWindow(this._native.srcElement);
        return Math.round(this._native.clientY) + qx.bom.Viewport.getScrollTop(win);
      } else {

        return Math.round(this._native.clientY) + qx.bom.Viewport.getScrollTop(window);
      };
    },
    getScreenLeft : function(){

      return Math.round(this._native.screenX);
    },
    getScreenTop : function(){

      return Math.round(this._native.screenY);
    }
  }
});

qx.Class.define("qx.event.type.Pointer", {
  extend : qx.event.type.Mouse,
  members : {
    _cloneNativeEvent : function(nativeEvent, clone){

      clone = this.base(arguments, nativeEvent, clone);
      clone.pointerId = nativeEvent.pointerId;
      clone.width = nativeEvent.width;
      clone.height = nativeEvent.height;
      clone.pressure = nativeEvent.pressure;
      clone.tiltX = nativeEvent.tiltX;
      clone.tiltY = nativeEvent.tiltY;
      clone.pointerType = nativeEvent.pointerType;
      clone.isPrimary = nativeEvent.isPrimary;
      clone._original = nativeEvent._original;
      clone.MSPOINTER_TYPE_MOUSE = nativeEvent.MSPOINTER_TYPE_MOUSE;
      clone.MSPOINTER_TYPE_PEN = nativeEvent.MSPOINTER_TYPE_PEN;
      clone.MSPOINTER_TYPE_TOUCH = nativeEvent.MSPOINTER_TYPE_TOUCH;
      return clone;
    },
    getDocumentLeft : function(){

      var x = this.base(arguments);
      if(x == 0 && this.getPointerType() == "touch"){

        x = Math.round(this._native._original.changedTouches[0].pageX) || 0;
      };
      return x;
    },
    getDocumentTop : function(){

      var y = this.base(arguments);
      if(y == 0 && this.getPointerType() == "touch"){

        y = Math.round(this._native._original.changedTouches[0].pageY) || 0;
      };
      return y;
    },
    getPointerId : function(){

      return this._native.pointerId || 0;
    },
    getWidth : function(){

      return this._native.width || 0;
    },
    getHeight : function(){

      return this._native.height || 0;
    },
    getPressure : function(){

      return this._native.pressure || 0;
    },
    getTiltX : function(){

      return this._native.tiltX || 0;
    },
    getTiltY : function(){

      return this._native.tiltY || 0;
    },
    getOriginalTarget : function(){

      if(this._native && this._native._original){

        var orig = this._native._original;
        try{

          if(orig.type.indexOf("touch") == 0){

            if(orig.changedTouches[0]){

              return document.elementFromPoint(orig.changedTouches[0].clientX, orig.changedTouches[0].clientY);
            };
          };
        } catch(ex) {

          return qx.bom.Event.getTarget(this._native);
        };
        return qx.bom.Event.getTarget(orig);
      } else if(this._native){

        return qx.bom.Event.getTarget(this._native);
      };
      return this.base(arguments);
    },
    getPointerType : function(){

      if(typeof this._native.pointerType == "string"){

        return this._native.pointerType;
      };
      if(typeof this._native.pointerType == "number"){

        if(this._native.pointerType == this._native.MSPOINTER_TYPE_MOUSE){

          return "mouse";
        };
        if(this._native.pointerType == this._native.MSPOINTER_TYPE_PEN){

          return "pen";
        };
        if(this._native.pointerType == this._native.MSPOINTER_TYPE_TOUCH){

          return "touch";
        };
      };
      return "";
    },
    isPrimary : function(){

      return !!this._native.isPrimary;
    }
  }
});

qx.Class.define("qx.event.handler.Pointer", {
  extend : qx.event.handler.PointerCore,
  implement : qx.event.IEventHandler,
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      pointermove : 1,
      pointerover : 1,
      pointerout : 1,
      pointerdown : 1,
      pointerup : 1,
      pointercancel : 1,
      gesturebegin : 1,
      gesturemove : 1,
      gesturefinish : 1,
      gesturecancel : 1
    },
    TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE + qx.event.IEventHandler.TARGET_DOCUMENT,
    IGNORE_CAN_HANDLE : true
  },
  construct : function(manager){

    this.__manager = manager;
    this.__window = manager.getWindow();
    this.__root = this.__window.document;
    qx.event.handler.PointerCore.apply(this, [this.__root]);
    this.__root.$$pointerHandler = this;
  },
  members : {
    __manager : null,
    __window : null,
    __root : null,
    canHandleEvent : function(target, type){
    },
    registerEvent : function(target, type, capture){
    },
    unregisterEvent : function(target, type, capture){
    },
    _initPointerObserver : function(){

      var useEmitter = false;
      if(qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 9){

        useEmitter = true;
      };
      this._initObserver(this._onPointerEvent, useEmitter);
    },
    _fireEvent : function(domEvent, type, target){

      if(!target){

        target = qx.bom.Event.getTarget(domEvent);
      };
      if(!type){

        type = domEvent.type;
      };
      type = qx.event.handler.PointerCore.MSPOINTER_TO_POINTER_MAPPING[type] || type;
      if(target && target.nodeType){

        qx.event.type.dom.Pointer.normalize(domEvent);
        domEvent.srcElement = target;
        qx.event.Registration.fireEvent(target, type, qx.event.type.Pointer, [domEvent, target, null, true, true]);
        if(type == "pointerdown" || type == "pointerup" || type == "pointermove" || type == "pointercancel"){

          qx.event.Registration.fireEvent(this.__root, qx.event.handler.PointerCore.POINTER_TO_GESTURE_MAPPING[type], qx.event.type.Pointer, [domEvent, target, null, false, false]);
        };
        qx.event.Registration.fireEvent(this.__window, "useraction", qx.event.type.Data, [type]);
      };
    },
    _onPointerEvent : function(domEvent){

      var type = qx.event.handler.PointerCore.MSPOINTER_TO_POINTER_MAPPING[domEvent.type] || domEvent.type;
      this._fireEvent(domEvent, type, qx.bom.Event.getTarget(domEvent));
    },
    dispose : function(){

      this.__callBase("dispose");
      this.__manager = this.__window = this.__root = null;
    },
    __callBase : function(method, args){

      qx.event.handler.PointerCore.prototype[method].apply(this, args || []);
    }
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
    qx.event.Registration.getManager(document).getHandler(statics);
  }
});

qx.Class.define("qx.event.type.Tap", {
  extend : qx.event.type.Pointer
});

qx.Class.define("qx.event.type.Swipe", {
  extend : qx.event.type.Pointer,
  members : {
    _cloneNativeEvent : function(nativeEvent, clone){

      var clone = this.base(arguments, nativeEvent, clone);
      clone.swipe = nativeEvent.swipe;
      return clone;
    },
    getStartTime : function(){

      return this._native.swipe.startTime;
    },
    getDuration : function(){

      return this._native.swipe.duration;
    },
    getAxis : function(){

      return this._native.swipe.axis;
    },
    getDirection : function(){

      return this._native.swipe.direction;
    },
    getVelocity : function(){

      return this._native.swipe.velocity;
    },
    getDistance : function(){

      return this._native.swipe.distance;
    }
  }
});

qx.Class.define("qx.event.type.Rotate", {
  extend : qx.event.type.Pointer,
  members : {
    _cloneNativeEvent : function(nativeEvent, clone){

      var clone = this.base(arguments, nativeEvent, clone);
      clone.angle = nativeEvent.angle;
      return clone;
    },
    getAngle : function(){

      return this._native.angle;
    }
  }
});

qx.Class.define("qx.event.type.Pinch", {
  extend : qx.event.type.Pointer,
  members : {
    _cloneNativeEvent : function(nativeEvent, clone){

      var clone = this.base(arguments, nativeEvent, clone);
      clone.scale = nativeEvent.scale;
      return clone;
    },
    getScale : function(){

      return this._native.scale;
    }
  }
});

qx.Class.define("qx.event.handler.Orientation", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  construct : function(manager){

    this.base(arguments);
    this.__manager = manager;
    this.__window = manager.getWindow();
    this._initObserver();
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      orientationchange : 1
    },
    TARGET_CHECK : qx.event.IEventHandler.TARGET_WINDOW,
    IGNORE_CAN_HANDLE : true
  },
  members : {
    __manager : null,
    __window : null,
    __nativeEventType : null,
    _currentOrientation : null,
    __onNativeWrapper : null,
    canHandleEvent : function(target, type){
    },
    registerEvent : function(target, type, capture){
    },
    unregisterEvent : function(target, type, capture){
    },
    _initObserver : function(){

      this.__onNativeWrapper = qx.lang.Function.listener(this._onNative, this);
      this.__nativeEventType = qx.bom.Event.supportsEvent(this.__window, "orientationchange") ? "orientationchange" : "resize";
      var Event = qx.bom.Event;
      Event.addNativeListener(this.__window, this.__nativeEventType, this.__onNativeWrapper);
    },
    _stopObserver : function(){

      var Event = qx.bom.Event;
      Event.removeNativeListener(this.__window, this.__nativeEventType, this.__onNativeWrapper);
    },
    _onNative : qx.event.GlobalError.observeMethod(function(domEvent){

      var detectOrientationChangeDelay = 0;
      if(qx.core.Environment.get("os.name") == "android"){

        detectOrientationChangeDelay = 300;
      };
      qx.lang.Function.delay(this._onOrientationChange, detectOrientationChangeDelay, this, domEvent);
    }),
    _onOrientationChange : function(domEvent){

      var Viewport = qx.bom.Viewport;
      var orientation = Viewport.getOrientation(domEvent.target);
      if(this._currentOrientation != orientation){

        this._currentOrientation = orientation;
        var mode = Viewport.isLandscape(domEvent.target) ? "landscape" : "portrait";
        qx.event.Registration.fireEvent(this.__window, "orientationchange", qx.event.type.Orientation, [orientation, mode]);
      };
    }
  },
  destruct : function(){

    this._stopObserver();
    this.__manager = this.__window = null;
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
  }
});

qx.Class.define("qx.event.type.Orientation", {
  extend : qx.event.type.Event,
  members : {
    __orientation : null,
    __mode : null,
    init : function(orientation, mode){

      this.base(arguments, false, false);
      this.__orientation = orientation;
      this.__mode = mode;
      return this;
    },
    clone : function(embryo){

      var clone = this.base(arguments, embryo);
      clone.__orientation = this.__orientation;
      clone.__mode = this.__mode;
      return clone;
    },
    getOrientation : function(){

      return this.__orientation;
    },
    isLandscape : function(){

      return this.__mode == "landscape";
    },
    isPortrait : function(){

      return this.__mode == "portrait";
    }
  }
});

qx.Bootstrap.define("qx.event.handler.TouchCore", {
  extend : Object,
  statics : {
    TAP_MAX_DISTANCE : qx.core.Environment.get("os.name") != "android" ? 10 : 40,
    SWIPE_DIRECTION : {
      x : ["left", "right"],
      y : ["up", "down"]
    },
    SWIPE_MIN_DISTANCE : qx.core.Environment.get("os.name") != "android" ? 11 : 41,
    SWIPE_MIN_VELOCITY : 0,
    LONGTAP_TIME : 500
  },
  construct : function(target, emitter){

    this.__target = target;
    this.__emitter = emitter;
    this._initTouchObserver();
    this.__pointers = [];
    this.__touchStartPosition = {
    };
  },
  members : {
    __target : null,
    __emitter : null,
    __onTouchEventWrapper : null,
    __originalTarget : null,
    __touchStartPosition : null,
    __startTime : null,
    __beginScalingDistance : null,
    __beginRotation : null,
    __pointers : null,
    __touchEventNames : null,
    _initTouchObserver : function(){

      this.__onTouchEventWrapper = qx.lang.Function.listener(this._onTouchEvent, this);
      this.__touchEventNames = ["touchstart", "touchmove", "touchend", "touchcancel"];
      if(qx.core.Environment.get("event.mspointer")){

        var engineVersion = parseInt(qx.core.Environment.get("engine.version"), 10);
        if(engineVersion == 10){

          this.__touchEventNames = ["MSPointerDown", "MSPointerMove", "MSPointerUp", "MSPointerCancel"];
        } else {

          this.__touchEventNames = ["pointerdown", "pointermove", "pointerup", "pointercancel"];
        };
      };
      for(var i = 0;i < this.__touchEventNames.length;i++){

        qx.bom.Event.addNativeListener(this.__target, this.__touchEventNames[i], this.__onTouchEventWrapper);
      };
    },
    _stopTouchObserver : function(){

      for(var i = 0;i < this.__touchEventNames.length;i++){

        qx.bom.Event.removeNativeListener(this.__target, this.__touchEventNames[i], this.__onTouchEventWrapper);
      };
    },
    _onTouchEvent : function(domEvent){

      this._commonTouchEventHandler(domEvent);
    },
    _getScalingDistance : function(touch0, touch1){

      return (Math.sqrt(Math.pow(touch0.pageX - touch1.pageX, 2) + Math.pow(touch0.pageY - touch1.pageY, 2)));
    },
    _getRotationAngle : function(touch0, touch1){

      var x = touch0.pageX - touch1.pageX;
      var y = touch0.pageY - touch1.pageY;
      return (Math.atan2(y, x) * 180 / Math.PI);
    },
    _calcTouchesDelta : function(touches){

      var delta = [];
      for(var i = 0;i < touches.length;i++){

        delta.push(this._calcSingleTouchDelta(touches[i]));
      };
      return delta;
    },
    _calcSingleTouchDelta : function(touch){

      if(this.__touchStartPosition.hasOwnProperty(touch.identifier)){

        var touchStartPosition = this.__touchStartPosition[touch.identifier];
        var deltaX = Math.floor(touch.clientX - touchStartPosition[0]);
        var deltaY = Math.floor(touch.clientY - touchStartPosition[1]);
        var axis = "x";
        if(Math.abs(deltaX / deltaY) < 1){

          axis = "y";
        };
        return {
          "x" : deltaX,
          "y" : deltaY,
          "axis" : axis,
          "identifier" : touch.identifier
        };
      } else {

        return {
          "x" : 0,
          "y" : 0,
          "axis" : null,
          "identifier" : touch.identifier
        };
      };
    },
    _commonTouchEventHandler : function(domEvent, type){

      var type = type || domEvent.type;
      if(qx.core.Environment.get("event.mspointer")){

        type = this._mapPointerEvent(type);
        var touches = this._detectTouchesByPointer(domEvent, type);
        domEvent.changedTouches = touches;
        domEvent.targetTouches = touches;
        domEvent.touches = touches;
      };
      domEvent.delta = [];
      if(type == "touchstart"){

        this.__originalTarget = this._getTarget(domEvent);
        if(domEvent.touches && domEvent.touches.length > 1){

          this.__beginScalingDistance = this._getScalingDistance(domEvent.touches[0], domEvent.touches[1]);
          this.__beginRotation = this._getRotationAngle(domEvent.touches[0], domEvent.touches[1]);
        };
        for(var i = 0;i < domEvent.changedTouches.length;i++){

          var touch = domEvent.changedTouches[i];
          this.__touchStartPosition[touch.identifier] = [touch.clientX, touch.clientY];
        };
      };
      if(type == "touchmove"){

        if(typeof domEvent.scale == "undefined" && domEvent.targetTouches.length > 1){

          var currentScalingDistance = this._getScalingDistance(domEvent.targetTouches[0], domEvent.targetTouches[1]);
          domEvent.scale = currentScalingDistance / this.__beginScalingDistance;
        };
        if((typeof domEvent.rotation == "undefined" || qx.core.Environment.get("event.mspointer")) && domEvent.targetTouches.length > 1){

          var currentRotation = this._getRotationAngle(domEvent.targetTouches[0], domEvent.targetTouches[1]);
          domEvent._rotation = currentRotation - this.__beginRotation;
        };
        domEvent.delta = this._calcTouchesDelta(domEvent.targetTouches);
      };
      this._fireEvent(domEvent, type, this.__originalTarget);
      if(qx.core.Environment.get("event.mspointer")){

        if(type == "touchend" || type == "touchcancel"){

          delete this.__pointers[domEvent.pointerId];
        };
      };
      if(type == "touchend" || type == "touchcancel" && domEvent.changedTouches[0]){

        delete this.__touchStartPosition[domEvent.changedTouches[0].identifier];
      };
    },
    _detectTouchesByPointer : function(domEvent, type){

      var touches = [];
      if(type == "touchstart"){

        this.__pointers[domEvent.pointerId] = domEvent;
      } else if(type == "touchmove"){

        this.__pointers[domEvent.pointerId] = domEvent;
      };
      for(var pointerId in this.__pointers){

        var pointer = this.__pointers[pointerId];
        touches.push(pointer);
      };
      return touches;
    },
    _mapPointerEvent : function(type){

      type = type.toLowerCase();
      if(type.indexOf("pointerdown") !== -1){

        return "touchstart";
      } else if(type.indexOf("pointerup") !== -1){

        return "touchend";
      } else if(type.indexOf("pointermove") !== -1){

        return "touchmove";
      } else if(type.indexOf("pointercancel") !== -1){

        return "touchcancel";
      };;;
      return type;
    },
    _getTarget : function(domEvent){

      var target = qx.bom.Event.getTarget(domEvent);
      if(qx.core.Environment.get("engine.name") == "webkit"){

        if(target && target.nodeType == 3){

          target = target.parentNode;
        };
      } else if(qx.core.Environment.get("event.mspointer")){

        var targetForIE = this.__evaluateTarget(domEvent);
        if(targetForIE){

          target = targetForIE;
        };
      };
      return target;
    },
    __evaluateTarget : function(domEvent){

      var clientX = null;
      var clientY = null;
      if(domEvent && domEvent.touches && domEvent.touches.length !== 0){

        clientX = domEvent.touches[0].clientX;
        clientY = domEvent.touches[0].clientY;
      };
      var hitTargets = document.msElementsFromPoint(clientX, clientY);
      if(hitTargets){

        for(var i = 0;i < hitTargets.length;i++){

          var currentTarget = hitTargets[i];
          var pointerEvents = qx.bom.element.Style.get(currentTarget, "pointer-events", 3);
          if(pointerEvents != "none"){

            return currentTarget;
          };
        };
      };
      return null;
    },
    _fireEvent : function(domEvent, type, target){

      if(!target){

        target = this._getTarget(domEvent);
      };
      var type = type || domEvent.type;
      if(target && target.nodeType && this.__emitter){

        this.__emitter.emit(type, domEvent);
      };
    },
    dispose : function(){

      this._stopTouchObserver();
      this.__originalTarget = this.__target = this.__touchEventNames = this.__pointers = this.__emitter = this.__beginScalingDistance = this.__beginRotation = null;
    }
  }
});

qx.Bootstrap.define("qx.bom.element.BoxSizing", {
  statics : {
    __nativeBorderBox : {
      tags : {
        button : true,
        select : true
      },
      types : {
        search : true,
        button : true,
        submit : true,
        reset : true,
        checkbox : true,
        radio : true
      }
    },
    __usesNativeBorderBox : function(element){

      var map = this.__nativeBorderBox;
      return map.tags[element.tagName.toLowerCase()] || map.types[element.type];
    },
    compile : function(value){

      if(qx.core.Environment.get("css.boxsizing")){

        var prop = qx.bom.Style.getCssName(qx.core.Environment.get("css.boxsizing"));
        return prop + ":" + value + ";";
      } else {

        if(qx.core.Environment.get("qx.debug")){

          qx.log.Logger.warn(this, "This client does not support dynamic modification of the boxSizing property.");
          qx.log.Logger.trace();
        };
      };
    },
    get : function(element){

      if(qx.core.Environment.get("css.boxsizing")){

        return qx.bom.element.Style.get(element, "boxSizing", null, false) || "";
      };
      if(qx.bom.Document.isStandardMode(qx.dom.Node.getWindow(element))){

        if(!this.__usesNativeBorderBox(element)){

          return "content-box";
        };
      };
      return "border-box";
    },
    set : function(element, value){

      if(qx.core.Environment.get("css.boxsizing")){

        try{

          element.style[qx.core.Environment.get("css.boxsizing")] = value;
        } catch(ex) {

          if(qx.core.Environment.get("qx.debug")){

            qx.log.Logger.warn(this, "This client does not support the boxSizing value", value);
          };
        };
      } else {

        if(qx.core.Environment.get("qx.debug")){

          qx.log.Logger.warn(this, "This client does not support dynamic modification of the boxSizing property.");
        };
      };
    },
    reset : function(element){

      this.set(element, "");
    }
  }
});

qx.Bootstrap.define("qx.bom.element.Cursor", {
  statics : {
    __map : {
    },
    compile : function(cursor){

      return "cursor:" + (this.__map[cursor] || cursor) + ";";
    },
    get : function(element, mode){

      return qx.bom.element.Style.get(element, "cursor", mode, false);
    },
    set : function(element, value){

      element.style.cursor = this.__map[value] || value;
    },
    reset : function(element){

      element.style.cursor = "";
    }
  },
  defer : function(statics){

    if(qx.core.Environment.get("engine.name") == "mshtml" && ((parseFloat(qx.core.Environment.get("engine.version")) < 9 || qx.core.Environment.get("browser.documentmode") < 9) && !qx.core.Environment.get("browser.quirksmode"))){

      statics.__map["nesw-resize"] = "ne-resize";
      statics.__map["nwse-resize"] = "nw-resize";
      if(((parseFloat(qx.core.Environment.get("engine.version")) < 8 || qx.core.Environment.get("browser.documentmode") < 8) && !qx.core.Environment.get("browser.quirksmode"))){

        statics.__map["ew-resize"] = "e-resize";
        statics.__map["ns-resize"] = "n-resize";
      };
    } else if(qx.core.Environment.get("engine.name") == "opera" && parseInt(qx.core.Environment.get("engine.version")) < 12){

      statics.__map["nesw-resize"] = "ne-resize";
      statics.__map["nwse-resize"] = "nw-resize";
    };
  }
});

qx.Bootstrap.define("qx.bom.element.Opacity", {
  statics : {
    compile : qx.core.Environment.select("engine.name", {
      "mshtml" : function(opacity){

        if(opacity >= 1){

          opacity = 1;
        };
        if(opacity < 0.00001){

          opacity = 0;
        };
        if(qx.core.Environment.get("css.opacity")){

          return "opacity:" + opacity + ";";
        } else {

          return "zoom:1;filter:alpha(opacity=" + (opacity * 100) + ");";
        };
      },
      "default" : function(opacity){

        if(opacity >= 1){

          return "";
        };
        return "opacity:" + opacity + ";";
      }
    }),
    set : qx.core.Environment.select("engine.name", {
      "mshtml" : function(element, opacity){

        if(qx.core.Environment.get("css.opacity")){

          if(opacity >= 1){

            opacity = "";
          };
          element.style.opacity = opacity;
        } else {

          var filter = qx.bom.element.Style.get(element, "filter", qx.bom.element.Style.COMPUTED_MODE, false);
          if(opacity >= 1){

            opacity = 1;
          };
          if(opacity < 0.00001){

            opacity = 0;
          };
          if(!element.currentStyle || !element.currentStyle.hasLayout){

            element.style.zoom = 1;
          };
          element.style.filter = filter.replace(/alpha\([^\)]*\)/gi, "") + "alpha(opacity=" + opacity * 100 + ")";
        };
      },
      "default" : function(element, opacity){

        if(opacity >= 1){

          opacity = "";
        };
        element.style.opacity = opacity;
      }
    }),
    reset : qx.core.Environment.select("engine.name", {
      "mshtml" : function(element){

        if(qx.core.Environment.get("css.opacity")){

          element.style.opacity = "";
        } else {

          var filter = qx.bom.element.Style.get(element, "filter", qx.bom.element.Style.COMPUTED_MODE, false);
          element.style.filter = filter.replace(/alpha\([^\)]*\)/gi, "");
        };
      },
      "default" : function(element){

        element.style.opacity = "";
      }
    }),
    get : qx.core.Environment.select("engine.name", {
      "mshtml" : function(element, mode){

        if(qx.core.Environment.get("css.opacity")){

          var opacity = qx.bom.element.Style.get(element, "opacity", mode, false);
          if(opacity != null){

            return parseFloat(opacity);
          };
          return 1.0;
        } else {

          var filter = qx.bom.element.Style.get(element, "filter", mode, false);
          if(filter){

            var opacity = filter.match(/alpha\(opacity=(.*)\)/);
            if(opacity && opacity[1]){

              return parseFloat(opacity[1]) / 100;
            };
          };
          return 1.0;
        };
      },
      "default" : function(element, mode){

        var opacity = qx.bom.element.Style.get(element, "opacity", mode, false);
        if(opacity != null){

          return parseFloat(opacity);
        };
        return 1.0;
      }
    })
  }
});

qx.Bootstrap.define("qx.bom.element.Clip", {
  statics : {
    compile : function(map){

      if(!map){

        return "clip:auto;";
      };
      var left = map.left;
      var top = map.top;
      var width = map.width;
      var height = map.height;
      var right,bottom;
      if(left == null){

        right = (width == null ? "auto" : width + "px");
        left = "auto";
      } else {

        right = (width == null ? "auto" : left + width + "px");
        left = left + "px";
      };
      if(top == null){

        bottom = (height == null ? "auto" : height + "px");
        top = "auto";
      } else {

        bottom = (height == null ? "auto" : top + height + "px");
        top = top + "px";
      };
      return "clip:rect(" + top + "," + right + "," + bottom + "," + left + ");";
    },
    get : function(element, mode){

      var clip = qx.bom.element.Style.get(element, "clip", mode, false);
      var left,top,width,height;
      var right,bottom;
      if(typeof clip === "string" && clip !== "auto" && clip !== ""){

        clip = clip.trim();
        if(/\((.*)\)/.test(clip)){

          var result = RegExp.$1;
          if(/,/.test(result)){

            var split = result.split(",");
          } else {

            var split = result.split(" ");
          };
          top = split[0].trim();
          right = split[1].trim();
          bottom = split[2].trim();
          left = split[3].trim();
          if(left === "auto"){

            left = null;
          };
          if(top === "auto"){

            top = null;
          };
          if(right === "auto"){

            right = null;
          };
          if(bottom === "auto"){

            bottom = null;
          };
          if(top != null){

            top = parseInt(top, 10);
          };
          if(right != null){

            right = parseInt(right, 10);
          };
          if(bottom != null){

            bottom = parseInt(bottom, 10);
          };
          if(left != null){

            left = parseInt(left, 10);
          };
          if(right != null && left != null){

            width = right - left;
          } else if(right != null){

            width = right;
          };
          if(bottom != null && top != null){

            height = bottom - top;
          } else if(bottom != null){

            height = bottom;
          };
        } else {

          throw new Error("Could not parse clip string: " + clip);
        };
      };
      return {
        left : left || null,
        top : top || null,
        width : width || null,
        height : height || null
      };
    },
    set : function(element, map){

      if(!map){

        element.style.clip = "rect(auto,auto,auto,auto)";
        return;
      };
      var left = map.left;
      var top = map.top;
      var width = map.width;
      var height = map.height;
      var right,bottom;
      if(left == null){

        right = (width == null ? "auto" : width + "px");
        left = "auto";
      } else {

        right = (width == null ? "auto" : left + width + "px");
        left = left + "px";
      };
      if(top == null){

        bottom = (height == null ? "auto" : height + "px");
        top = "auto";
      } else {

        bottom = (height == null ? "auto" : top + height + "px");
        top = top + "px";
      };
      element.style.clip = "rect(" + top + "," + right + "," + bottom + "," + left + ")";
    },
    reset : function(element){

      element.style.clip = "rect(auto, auto, auto, auto)";
    }
  }
});

qx.Bootstrap.define("qx.bom.client.Css", {
  statics : {
    __WEBKIT_LEGACY_GRADIENT : null,
    getBoxModel : function(){

      var content = qx.bom.client.Engine.getName() !== "mshtml" || !qx.bom.client.Browser.getQuirksMode();
      return content ? "content" : "border";
    },
    getTextOverflow : function(){

      return qx.bom.Style.getPropertyName("textOverflow");
    },
    getPlaceholder : function(){

      var i = document.createElement("input");
      return "placeholder" in i;
    },
    getAppearance : function(){

      return qx.bom.Style.getPropertyName("appearance");
    },
    getBorderRadius : function(){

      return qx.bom.Style.getPropertyName("borderRadius");
    },
    getBoxShadow : function(){

      return qx.bom.Style.getPropertyName("boxShadow");
    },
    getBorderImage : function(){

      return qx.bom.Style.getPropertyName("borderImage");
    },
    getBorderImageSyntax : function(){

      var styleName = qx.bom.client.Css.getBorderImage();
      if(!styleName){

        return null;
      };
      var el = document.createElement("div");
      if(styleName === "borderImage"){

        el.style[styleName] = 'url("foo.png") 4 4 4 4 fill stretch';
        if(el.style.borderImageSource.indexOf("foo.png") >= 0 && el.style.borderImageSlice.indexOf("4 fill") >= 0 && el.style.borderImageRepeat.indexOf("stretch") >= 0){

          return true;
        };
      } else {

        el.style[styleName] = 'url("foo.png") 4 4 4 4 stretch';
        if(el.style[styleName].indexOf("foo.png") >= 0){

          return false;
        };
      };
      return null;
    },
    getUserSelect : function(){

      return qx.bom.Style.getPropertyName("userSelect");
    },
    getUserSelectNone : function(){

      var styleProperty = qx.bom.client.Css.getUserSelect();
      if(styleProperty){

        var el = document.createElement("span");
        el.style[styleProperty] = "-moz-none";
        return el.style[styleProperty] === "-moz-none" ? "-moz-none" : "none";
      };
      return null;
    },
    getUserModify : function(){

      return qx.bom.Style.getPropertyName("userModify");
    },
    getFloat : function(){

      var style = document.documentElement.style;
      return style.cssFloat !== undefined ? "cssFloat" : style.styleFloat !== undefined ? "styleFloat" : null;
    },
    getTranslate3d : function(){

      return 'WebKitCSSMatrix' in window && 'm11' in new WebKitCSSMatrix();
    },
    getLinearGradient : function(){

      qx.bom.client.Css.__WEBKIT_LEGACY_GRADIENT = false;
      var value = "linear-gradient(0deg, #fff, #000)";
      var el = document.createElement("div");
      var style = qx.bom.Style.getAppliedStyle(el, "backgroundImage", value);
      if(!style){

        value = "-webkit-gradient(linear,0% 0%,100% 100%,from(white), to(red))";
        var style = qx.bom.Style.getAppliedStyle(el, "backgroundImage", value, false);
        if(style){

          qx.bom.client.Css.__WEBKIT_LEGACY_GRADIENT = true;
        };
      };
      if(!style){

        return null;
      };
      var match = /(.*?)\(/.exec(style);
      return match ? match[1] : null;
    },
    getFilterGradient : function(){

      return qx.bom.client.Css.__isFilterSupported("DXImageTransform.Microsoft.Gradient", "startColorStr=#550000FF, endColorStr=#55FFFF00");
    },
    getRadialGradient : function(){

      var value = "radial-gradient(0px 0px, cover, red 50%, blue 100%)";
      var el = document.createElement("div");
      var style = qx.bom.Style.getAppliedStyle(el, "backgroundImage", value);
      if(!style){

        return null;
      };
      var match = /(.*?)\(/.exec(style);
      return match ? match[1] : null;
    },
    getLegacyWebkitGradient : function(){

      if(qx.bom.client.Css.__WEBKIT_LEGACY_GRADIENT === null){

        qx.bom.client.Css.getLinearGradient();
      };
      return qx.bom.client.Css.__WEBKIT_LEGACY_GRADIENT;
    },
    getRgba : function(){

      var el;
      try{

        el = document.createElement("div");
      } catch(ex) {

        el = document.createElement();
      };
      try{

        el.style["color"] = "rgba(1, 2, 3, 0.5)";
        if(el.style["color"].indexOf("rgba") != -1){

          return true;
        };
      } catch(ex) {
      };
      return false;
    },
    getBoxSizing : function(){

      return qx.bom.Style.getPropertyName("boxSizing");
    },
    getInlineBlock : function(){

      var el = document.createElement("span");
      el.style.display = "inline-block";
      if(el.style.display == "inline-block"){

        return "inline-block";
      };
      el.style.display = "-moz-inline-box";
      if(el.style.display !== "-moz-inline-box"){

        return "-moz-inline-box";
      };
      return null;
    },
    getOpacity : function(){

      return (typeof document.documentElement.style.opacity == "string");
    },
    getTextShadow : function(){

      return !!qx.bom.Style.getPropertyName("textShadow");
    },
    getFilterTextShadow : function(){

      return qx.bom.client.Css.__isFilterSupported("DXImageTransform.Microsoft.Shadow", "color=#666666,direction=45");
    },
    __isFilterSupported : function(filterClass, initParams){

      var supported = false;
      var value = "progid:" + filterClass + "(" + initParams + ");";
      var el = document.createElement("div");
      document.body.appendChild(el);
      el.style.filter = value;
      if(el.filters && el.filters.length > 0 && el.filters.item(filterClass).enabled == true){

        supported = true;
      };
      document.body.removeChild(el);
      return supported;
    },
    getAlphaImageLoaderNeeded : function(){

      return qx.bom.client.Engine.getName() == "mshtml" && qx.bom.client.Browser.getDocumentMode() < 9;
    },
    getPointerEvents : function(){

      var el = document.documentElement;
      if("pointerEvents" in el.style){

        var initial = el.style.pointerEvents;
        el.style.pointerEvents = "auto";
        el.style.pointerEvents = "foo";
        var supported = el.style.pointerEvents == "auto";
        el.style.pointerEvents = initial;
        return supported;
      };
      return false;
    },
    getFlexboxSyntax : function(){

      var detectedSyntax = null;
      var detector = document.createElement("detect");
      var flexSyntax = [{
        value : "flex",
        syntax : "flex"
      }, {
        value : "-ms-flexbox",
        syntax : "flexbox"
      }, {
        value : "-webkit-flex",
        syntax : "flex"
      }];
      for(var i = 0;i < flexSyntax.length;i++){

        try{

          detector.style.display = flexSyntax[i].value;
        } catch(ex) {

          return null;
        };
        if(detector.style.display === flexSyntax[i].value){

          detectedSyntax = flexSyntax[i].syntax;
          break;
        };
      };
      detector = null;
      return detectedSyntax;
    }
  },
  defer : function(statics){

    qx.core.Environment.add("css.textoverflow", statics.getTextOverflow);
    qx.core.Environment.add("css.placeholder", statics.getPlaceholder);
    qx.core.Environment.add("css.borderradius", statics.getBorderRadius);
    qx.core.Environment.add("css.boxshadow", statics.getBoxShadow);
    qx.core.Environment.add("css.gradient.linear", statics.getLinearGradient);
    qx.core.Environment.add("css.gradient.filter", statics.getFilterGradient);
    qx.core.Environment.add("css.gradient.radial", statics.getRadialGradient);
    qx.core.Environment.add("css.gradient.legacywebkit", statics.getLegacyWebkitGradient);
    qx.core.Environment.add("css.boxmodel", statics.getBoxModel);
    qx.core.Environment.add("css.rgba", statics.getRgba);
    qx.core.Environment.add("css.borderimage", statics.getBorderImage);
    qx.core.Environment.add("css.borderimage.standardsyntax", statics.getBorderImageSyntax);
    qx.core.Environment.add("css.usermodify", statics.getUserModify);
    qx.core.Environment.add("css.userselect", statics.getUserSelect);
    qx.core.Environment.add("css.userselect.none", statics.getUserSelectNone);
    qx.core.Environment.add("css.appearance", statics.getAppearance);
    qx.core.Environment.add("css.float", statics.getFloat);
    qx.core.Environment.add("css.boxsizing", statics.getBoxSizing);
    qx.core.Environment.add("css.inlineblock", statics.getInlineBlock);
    qx.core.Environment.add("css.opacity", statics.getOpacity);
    qx.core.Environment.add("css.textShadow", statics.getTextShadow);
    qx.core.Environment.add("css.textShadow.filter", statics.getFilterTextShadow);
    qx.core.Environment.add("css.alphaimageloaderneeded", statics.getAlphaImageLoaderNeeded);
    qx.core.Environment.add("css.pointerevents", statics.getPointerEvents);
    qx.core.Environment.add("css.flexboxSyntax", statics.getFlexboxSyntax);
  }
});

qx.Bootstrap.define("qx.bom.element.Style", {
  statics : {
    __styleNames : null,
    __cssNames : null,
    __detectVendorProperties : function(){

      var styleNames = {
        "appearance" : qx.core.Environment.get("css.appearance"),
        "userSelect" : qx.core.Environment.get("css.userselect"),
        "textOverflow" : qx.core.Environment.get("css.textoverflow"),
        "borderImage" : qx.core.Environment.get("css.borderimage"),
        "float" : qx.core.Environment.get("css.float"),
        "userModify" : qx.core.Environment.get("css.usermodify"),
        "boxSizing" : qx.core.Environment.get("css.boxsizing")
      };
      this.__cssNames = {
      };
      for(var key in qx.lang.Object.clone(styleNames)){

        if(!styleNames[key]){

          delete styleNames[key];
        } else {

          this.__cssNames[key] = key == "float" ? "float" : qx.bom.Style.getCssName(styleNames[key]);
        };
      };
      this.__styleNames = styleNames;
    },
    __getStyleName : function(name){

      var styleName = qx.bom.Style.getPropertyName(name);
      if(styleName){

        this.__styleNames[name] = styleName;
      };
      return styleName;
    },
    __mshtmlPixel : {
      width : "pixelWidth",
      height : "pixelHeight",
      left : "pixelLeft",
      right : "pixelRight",
      top : "pixelTop",
      bottom : "pixelBottom"
    },
    __special : {
      clip : qx.bom.element.Clip,
      cursor : qx.bom.element.Cursor,
      opacity : qx.bom.element.Opacity,
      boxSizing : qx.bom.element.BoxSizing
    },
    compile : function(map){

      var html = [];
      var special = this.__special;
      var cssNames = this.__cssNames;
      var name,value;
      for(name in map){

        value = map[name];
        if(value == null){

          continue;
        };
        name = this.__styleNames[name] || this.__getStyleName(name) || name;
        if(special[name]){

          html.push(special[name].compile(value));
        } else {

          if(!cssNames[name]){

            cssNames[name] = qx.bom.Style.getCssName(name);
          };
          html.push(cssNames[name], ":", value, ";");
        };
      };
      return html.join("");
    },
    setCss : function(element, value){

      if(qx.core.Environment.get("engine.name") === "mshtml" && parseInt(qx.core.Environment.get("browser.documentmode"), 10) < 8){

        element.style.cssText = value;
      } else {

        element.setAttribute("style", value);
      };
    },
    getCss : function(element){

      if(qx.core.Environment.get("engine.name") === "mshtml" && parseInt(qx.core.Environment.get("browser.documentmode"), 10) < 8){

        return element.style.cssText.toLowerCase();
      } else {

        return element.getAttribute("style");
      };
    },
    isPropertySupported : function(propertyName){

      return (this.__special[propertyName] || this.__styleNames[propertyName] || propertyName in document.documentElement.style);
    },
    COMPUTED_MODE : 1,
    CASCADED_MODE : 2,
    LOCAL_MODE : 3,
    set : function(element, name, value, smart){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert.assertElement(element, "Invalid argument 'element'");
        qx.core.Assert.assertString(name, "Invalid argument 'name'");
        if(smart !== undefined){

          qx.core.Assert.assertBoolean(smart, "Invalid argument 'smart'");
        };
      };
      name = this.__styleNames[name] || this.__getStyleName(name) || name;
      if(smart !== false && this.__special[name]){

        this.__special[name].set(element, value);
      } else {

        element.style[name] = value !== null ? value : "";
      };
    },
    setStyles : function(element, styles, smart){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert.assertElement(element, "Invalid argument 'element'");
        qx.core.Assert.assertMap(styles, "Invalid argument 'styles'");
        if(smart !== undefined){

          qx.core.Assert.assertBoolean(smart, "Invalid argument 'smart'");
        };
      };
      var styleNames = this.__styleNames;
      var special = this.__special;
      var style = element.style;
      for(var key in styles){

        var value = styles[key];
        var name = styleNames[key] || this.__getStyleName(key) || key;
        if(value === undefined){

          if(smart !== false && special[name]){

            special[name].reset(element);
          } else {

            style[name] = "";
          };
        } else {

          if(smart !== false && special[name]){

            special[name].set(element, value);
          } else {

            style[name] = value !== null ? value : "";
          };
        };
      };
    },
    reset : function(element, name, smart){

      name = this.__styleNames[name] || this.__getStyleName(name) || name;
      if(smart !== false && this.__special[name]){

        this.__special[name].reset(element);
      } else {

        element.style[name] = "";
      };
    },
    get : function(element, name, mode, smart){

      name = this.__styleNames[name] || this.__getStyleName(name) || name;
      if(smart !== false && this.__special[name]){

        return this.__special[name].get(element, mode);
      };
      switch(mode){case this.LOCAL_MODE:
      return element.style[name] || "";case this.CASCADED_MODE:
      if(element.currentStyle){

        return element.currentStyle[name] || "";
      };
      throw new Error("Cascaded styles are not supported in this browser!");default:
      var doc = qx.dom.Node.getDocument(element);
      var getStyle = doc.defaultView ? doc.defaultView.getComputedStyle : undefined;
      if(getStyle !== undefined){

        var computed = getStyle(element, null);
        if(computed && computed[name]){

          return computed[name];
        };
      } else {

        if(!element.currentStyle){

          return element.style[name] || "";
        };
        var currentStyle = element.currentStyle[name] || element.style[name] || "";
        if(/^-?[\.\d]+(px)?$/i.test(currentStyle)){

          return currentStyle;
        };
        var pixel = this.__mshtmlPixel[name];
        if(pixel && (pixel in element.style)){

          var localStyle = element.style[name];
          element.style[name] = currentStyle || 0;
          var value = element.style[pixel] + "px";
          element.style[name] = localStyle;
          return value;
        };
        return currentStyle;
      };
      return element.style[name] || "";};
    }
  },
  defer : function(statics){

    statics.__detectVendorProperties();
  }
});

qx.Class.define("qx.event.type.Track", {
  extend : qx.event.type.Pointer,
  members : {
    _cloneNativeEvent : function(nativeEvent, clone){

      var clone = this.base(arguments, nativeEvent, clone);
      clone.delta = nativeEvent.delta;
      return clone;
    },
    getDelta : function(){

      return this._native.delta;
    }
  }
});

qx.Class.define("qx.event.handler.UserAction", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  construct : function(manager){

    this.base(arguments);
    this.__manager = manager;
    this.__window = manager.getWindow();
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      useraction : 1
    },
    TARGET_CHECK : qx.event.IEventHandler.TARGET_WINDOW,
    IGNORE_CAN_HANDLE : true
  },
  members : {
    __manager : null,
    __window : null,
    canHandleEvent : function(target, type){
    },
    registerEvent : function(target, type, capture){
    },
    unregisterEvent : function(target, type, capture){
    }
  },
  destruct : function(){

    this.__manager = this.__window = null;
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
  }
});

qx.Class.define("qx.event.handler.Touch", {
  extend : qx.event.handler.TouchCore,
  implement : qx.event.IEventHandler,
  construct : function(manager){

    this.__manager = manager;
    this.__window = manager.getWindow();
    this.__root = this.__window.document;
    qx.event.handler.TouchCore.apply(this, [this.__root]);
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      touchstart : 1,
      touchmove : 1,
      touchend : 1,
      touchcancel : 1,
      tap : 1,
      longtap : 1,
      swipe : 1
    },
    TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE + qx.event.IEventHandler.TARGET_DOCUMENT,
    IGNORE_CAN_HANDLE : true,
    MOUSE_TO_TOUCH_MAPPING : {
      "mousedown" : "touchstart",
      "mousemove" : "touchmove",
      "mouseup" : "touchend"
    }
  },
  members : {
    __manager : null,
    __window : null,
    __root : null,
    __isInTouch : false,
    canHandleEvent : function(target, type){
    },
    registerEvent : function(target, type, capture){
    },
    unregisterEvent : function(target, type, capture){
    },
    _fireEvent : function(domEvent, type, target, eventTypeClass){

      if(!target){

        target = this._getTarget(domEvent);
      };
      var type = type || domEvent.type;
      if(target && target.nodeType){

        qx.event.Registration.fireEvent(target, type, eventTypeClass || qx.event.type.Touch, [domEvent, target, null, true, true]);
      };
      qx.event.Registration.fireEvent(this.__window, "useraction", qx.event.type.Data, [type]);
    },
    _onTouchEvent : qx.event.GlobalError.observeMethod(function(domEvent){

      this._commonTouchEventHandler(domEvent);
    }),
    dispose : function(){

      this.__callBase("dispose");
      this._stopMouseObserver();
      this.__manager = this.__window = this.__root = null;
    },
    __callBase : function(method, args){

      qx.event.handler.TouchCore.prototype[method].apply(this, args || []);
    }
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
    if(qx.core.Environment.get("event.touch")){

      qx.event.Registration.getManager(document).getHandler(statics);
    };
  }
});

qx.Class.define("qx.event.type.Touch", {
  extend : qx.event.type.Dom,
  members : {
    _cloneNativeEvent : function(nativeEvent, clone){

      var clone = this.base(arguments, nativeEvent, clone);
      clone.pageX = nativeEvent.pageX;
      clone.pageY = nativeEvent.pageY;
      clone.offsetX = nativeEvent.offsetX;
      clone.offsetY = nativeEvent.offsetY;
      clone.layerX = (nativeEvent.offsetX || nativeEvent.layerX);
      clone.layerY = (nativeEvent.offsetY || nativeEvent.layerY);
      clone.scale = nativeEvent.scale;
      clone.rotation = nativeEvent.rotation;
      clone._rotation = nativeEvent._rotation;
      clone.delta = nativeEvent.delta;
      clone.srcElement = nativeEvent.srcElement;
      clone.targetTouches = [];
      for(var i = 0;i < nativeEvent.targetTouches.length;i++){

        clone.targetTouches[i] = nativeEvent.targetTouches[i];
      };
      clone.changedTouches = [];
      for(i = 0;i < nativeEvent.changedTouches.length;i++){

        clone.changedTouches[i] = nativeEvent.changedTouches[i];
      };
      clone.touches = [];
      for(i = 0;i < nativeEvent.touches.length;i++){

        clone.touches[i] = nativeEvent.touches[i];
      };
      return clone;
    },
    stop : function(){

      this.stopPropagation();
    },
    getAllTouches : function(){

      return this._native.touches;
    },
    getTargetTouches : function(){

      return this._native.targetTouches;
    },
    getChangedTargetTouches : function(){

      return this._native.changedTouches;
    },
    isMultiTouch : function(){

      return this.__getEventSpecificTouches().length > 1;
    },
    getScale : function(){

      return this._native.scale;
    },
    getRotation : function(){

      if(typeof this._native._rotation === "undefined"){

        return this._native.rotation;
      } else {

        return this._native._rotation;
      };
    },
    getDelta : function(){

      return this._native.delta;
    },
    getDocumentLeft : function(touchIndex){

      return this.__getEventSpecificTouch(touchIndex).pageX;
    },
    getDocumentTop : function(touchIndex){

      return this.__getEventSpecificTouch(touchIndex).pageY;
    },
    getScreenLeft : function(touchIndex){

      return this.__getEventSpecificTouch(touchIndex).screenX;
    },
    getScreenTop : function(touchIndex){

      return this.__getEventSpecificTouch(touchIndex).screenY;
    },
    getViewportLeft : function(touchIndex){

      return this.__getEventSpecificTouch(touchIndex).clientX;
    },
    getViewportTop : function(touchIndex){

      return this.__getEventSpecificTouch(touchIndex).clientY;
    },
    getIdentifier : function(touchIndex){

      return this.__getEventSpecificTouch(touchIndex).identifier;
    },
    __getEventSpecificTouch : function(touchIndex){

      touchIndex = touchIndex == null ? 0 : touchIndex;
      return this.__getEventSpecificTouches()[touchIndex];
    },
    __getEventSpecificTouches : function(){

      var touches = (this._isTouchEnd() ? this.getChangedTargetTouches() : this.getTargetTouches());
      return touches;
    },
    _isTouchEnd : function(){

      return (this.getType() == "touchend" || this.getType() == "touchcancel");
    }
  }
});

qx.Class.define("qx.ui.mobile.core.EventHandler", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  construct : function(){

    this.base(arguments);
    this.__manager = qx.event.Registration.getManager(window);
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_FIRST,
    SUPPORTED_TYPES : {
      mousemove : 1,
      mouseover : 1,
      mouseout : 1,
      mousedown : 1,
      mouseup : 1,
      click : 1,
      dblclick : 1,
      contextmenu : 1,
      mousewheel : 1,
      keyup : 1,
      keydown : 1,
      keypress : 1,
      keyinput : 1,
      capture : 1,
      losecapture : 1,
      focusin : 1,
      focusout : 1,
      focus : 1,
      blur : 1,
      activate : 1,
      deactivate : 1,
      appear : 1,
      disappear : 1,
      dragstart : 1,
      dragend : 1,
      dragover : 1,
      dragleave : 1,
      drop : 1,
      drag : 1,
      dragchange : 1,
      droprequest : 1,
      roll : 1,
      touchstart : 1,
      touchend : 1,
      touchmove : 1,
      touchcancel : 1,
      tap : 1,
      longtap : 1,
      swipe : 1,
      dbltap : 1,
      track : 1,
      trackend : 1,
      trackstart : 1,
      pinch : 1,
      rotate : 1,
      pointermove : 1,
      pointerover : 1,
      pointerout : 1,
      pointerdown : 1,
      pointerup : 1,
      pointercancel : 1
    },
    IGNORE_CAN_HANDLE : false,
    __activeTarget : null,
    __scrollLeft : null,
    __scrollTop : null,
    __startY : null,
    __timer : null,
    __onPointerDown : function(domEvent){

      if(!domEvent.isPrimary()){

        return;
      };
      var EventHandler = qx.ui.mobile.core.EventHandler;
      EventHandler.__scrollLeft = qx.bom.Viewport.getScrollLeft();
      EventHandler.__scrollTop = qx.bom.Viewport.getScrollTop();
      EventHandler.__startY = domEvent.screenY;
      EventHandler.__cancelActiveStateTimer();
      var target = domEvent.getTarget();
      while(target && target.parentNode && target.parentNode.nodeType == 1 && qx.bom.element.Attribute.get(target, "data-activatable") != "true"){

        target = target.parentNode;
      };
      EventHandler.__activeTarget = target;
      EventHandler.___timer = window.setTimeout(function(){

        EventHandler.___timer = null;
        var target = EventHandler.__activeTarget;
        if(target && (qx.bom.element.Attribute.get(target, "data-selectable") != "false")){

          qx.bom.element.Class.add(target, "active");
        };
      }, 100);
    },
    __onPointerUp : function(domEvent){

      qx.ui.mobile.core.EventHandler.__removeActiveState();
    },
    __onPointerMove : function(domEvent){

      if(!domEvent.isPrimary()){

        return;
      };
      var EventHandler = qx.ui.mobile.core.EventHandler;
      var deltaY = domEvent.screenY - EventHandler.__startY;
      if(EventHandler.__activeTarget && Math.abs(deltaY) >= qx.event.handler.GestureCore.TAP_MAX_DISTANCE){

        EventHandler.__removeActiveState();
      };
      if(EventHandler.__activeTarget && (EventHandler.__scrollLeft != qx.bom.Viewport.getScrollLeft() || EventHandler.__scrollTop != qx.bom.Viewport.getScrollTop())){

        EventHandler.__removeActiveState();
      };
    },
    __cancelActiveStateTimer : function(){

      var EventHandler = qx.ui.mobile.core.EventHandler;
      if(EventHandler.___timer){

        window.clearTimeout(EventHandler.___timer);
        EventHandler.___timer = null;
      };
    },
    __removeActiveState : function(){

      var EventHandler = qx.ui.mobile.core.EventHandler;
      EventHandler.__cancelActiveStateTimer();
      var activeTarget = EventHandler.__activeTarget;
      if(activeTarget){

        qx.bom.element.Class.remove(activeTarget, "active");
      };
      EventHandler.__activeTarget = null;
    }
  },
  members : {
    __manager : null,
    canHandleEvent : function(target, type){

      return target instanceof qx.ui.mobile.core.Widget;
    },
    registerEvent : function(target, type, capture){

      var element = target.getContainerElement();
      qx.event.Registration.addListener(element, type, this._dispatchEvent, this, capture);
    },
    unregisterEvent : function(target, type, capture){

      var element = target.getContainerElement();
      qx.event.Registration.removeListener(element, type, this._dispatchEvent, this, capture);
    },
    _dispatchEvent : function(domEvent){

      var domTarget = domEvent.getTarget();
      if(!domTarget || domTarget.id == null){

        return;
      };
      var widgetTarget = qx.ui.mobile.core.Widget.getWidgetById(domTarget.id);
      if(domEvent.getRelatedTarget){

        var domRelatedTarget = domEvent.getRelatedTarget();
        if(domRelatedTarget && domRelatedTarget.id){

          var widgetRelatedTarget = qx.ui.mobile.core.Widget.getWidgetById(domRelatedTarget.id);
        };
      };
      var currentTarget = domEvent.getCurrentTarget();
      var currentWidget = qx.ui.mobile.core.Widget.getWidgetById(currentTarget.id);
      if(!currentWidget){

        return;
      };
      var capture = domEvent.getEventPhase() == qx.event.type.Event.CAPTURING_PHASE;
      var type = domEvent.getType();
      var listeners = this.__manager.getListeners(currentWidget, type, capture);
      if(!listeners || listeners.length === 0){

        return;
      };
      var widgetEvent = qx.event.Pool.getInstance().getObject(domEvent.constructor);
      domEvent.clone(widgetEvent);
      widgetEvent.setTarget(widgetTarget);
      widgetEvent.setRelatedTarget(widgetRelatedTarget || null);
      widgetEvent.setCurrentTarget(currentWidget);
      var orig = domEvent.getOriginalTarget();
      if(orig && orig.id){

        var widgetOriginalTarget = qx.ui.mobile.core.Widget.getWidgetById(orig.id);
        widgetEvent.setOriginalTarget(widgetOriginalTarget);
      } else {

        widgetEvent.setOriginalTarget(domTarget);
      };
      for(var i = 0,l = listeners.length;i < l;i++){

        var context = listeners[i].context || currentWidget;
        listeners[i].handler.call(context, widgetEvent);
      };
      if(widgetEvent.getPropagationStopped()){

        domEvent.stopPropagation();
      };
      if(widgetEvent.getDefaultPrevented()){

        domEvent.preventDefault();
      };
      qx.event.Pool.getInstance().poolObject(widgetEvent);
    }
  },
  destruct : function(){

    this.__manager = null;
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
    qx.event.Registration.addListener(document, "pointerdown", statics.__onPointerDown);
    qx.event.Registration.addListener(document, "pointerup", statics.__onPointerUp);
    qx.event.Registration.addListener(document, "pointercancel", statics.__onPointerUp);
    qx.event.Registration.addListener(document, "pointermove", statics.__onPointerMove);
  }
});

qx.Bootstrap.define("qx.bom.element.Class", {
  statics : {
    __splitter : /\s+/g,
    __trim : /^\s+|\s+$/g,
    add : {
      "native" : function(element, name){

        element.classList.add(name);
        return name;
      },
      "default" : function(element, name){

        if(!this.has(element, name)){

          element.className += (element.className ? " " : "") + name;
        };
        return name;
      }
    }[qx.core.Environment.get("html.classlist") ? "native" : "default"],
    addClasses : {
      "native" : function(element, classes){

        for(var i = 0;i < classes.length;i++){

          element.classList.add(classes[i]);
        };
        return element.className;
      },
      "default" : function(element, classes){

        var keys = {
        };
        var result;
        var old = element.className;
        if(old){

          result = old.split(this.__splitter);
          for(var i = 0,l = result.length;i < l;i++){

            keys[result[i]] = true;
          };
          for(var i = 0,l = classes.length;i < l;i++){

            if(!keys[classes[i]]){

              result.push(classes[i]);
            };
          };
        } else {

          result = classes;
        };
        return element.className = result.join(" ");
      }
    }[qx.core.Environment.get("html.classlist") ? "native" : "default"],
    get : function(element){

      var className = element.className;
      if(typeof className.split !== 'function'){

        if(typeof className === 'object'){

          if(qx.Bootstrap.getClass(className) == 'SVGAnimatedString'){

            className = className.baseVal;
          } else {

            if(qx.core.Environment.get("qx.debug")){

              qx.log.Logger.warn(this, "className for element " + element + " cannot be determined");
            };
            className = '';
          };
        };
        if(typeof className === 'undefined'){

          if(qx.core.Environment.get("qx.debug")){

            qx.log.Logger.warn(this, "className for element " + element + " is undefined");
          };
          className = '';
        };
      };
      return className;
    },
    has : {
      "native" : function(element, name){

        return element.classList.contains(name);
      },
      "default" : function(element, name){

        var regexp = new RegExp("(^|\\s)" + name + "(\\s|$)");
        return regexp.test(element.className);
      }
    }[qx.core.Environment.get("html.classlist") ? "native" : "default"],
    remove : {
      "native" : function(element, name){

        element.classList.remove(name);
        return name;
      },
      "default" : function(element, name){

        var regexp = new RegExp("(^|\\s)" + name + "(\\s|$)");
        element.className = element.className.replace(regexp, "$2");
        return name;
      }
    }[qx.core.Environment.get("html.classlist") ? "native" : "default"],
    removeClasses : {
      "native" : function(element, classes){

        for(var i = 0;i < classes.length;i++){

          element.classList.remove(classes[i]);
        };
        return element.className;
      },
      "default" : function(element, classes){

        var reg = new RegExp("\\b" + classes.join("\\b|\\b") + "\\b", "g");
        return element.className = element.className.replace(reg, "").replace(this.__trim, "").replace(this.__splitter, " ");
      }
    }[qx.core.Environment.get("html.classlist") ? "native" : "default"],
    replace : function(element, oldName, newName){

      if(!this.has(element, oldName)){

        return "";
      };
      this.remove(element, oldName);
      return this.add(element, newName);
    },
    toggle : {
      "native" : function(element, name, toggle){

        if(toggle === undefined){

          element.classList.toggle(name);
        } else {

          toggle ? this.add(element, name) : this.remove(element, name);
        };
        return name;
      },
      "default" : function(element, name, toggle){

        if(toggle == null){

          toggle = !this.has(element, name);
        };
        toggle ? this.add(element, name) : this.remove(element, name);
        return name;
      }
    }[qx.core.Environment.get("html.classlist") ? "native" : "default"]
  }
});

qx.Bootstrap.define("qx.event.handler.GestureCore", {
  extend : Object,
  statics : {
    TYPES : ["tap", "swipe", "longtap", "dbltap", "track", "trackstart", "trackend", "rotate", "pinch", "roll"],
    GESTURE_EVENTS : ["gesturebegin", "gesturefinish", "gesturemove", "gesturecancel"],
    TAP_MAX_DISTANCE : {
      "touch" : 40,
      "mouse" : 50,
      "pen" : 20
    },
    SWIPE_DIRECTION : {
      x : ["left", "right"],
      y : ["up", "down"]
    },
    LONGTAP_TIME : 500,
    DOUBLETAP_TIME : 500,
    ROLL_FACTOR : 18
  },
  construct : function(target, emitter){

    this.__defaultTarget = target;
    this.__emitter = emitter;
    this.__gesture = {
    };
    this.__lastTap = {
    };
    this.__stopMomentum = {
    };
    this._initObserver();
  },
  members : {
    __defaultTarget : null,
    __emitter : null,
    __gesture : null,
    __eventName : null,
    __primaryTarget : null,
    __isMultiPointerGesture : null,
    __initialAngle : null,
    __lastTap : null,
    __rollImpulseId : null,
    __stopMomentum : null,
    __initialDistance : null,
    _initObserver : function(){

      qx.event.handler.GestureCore.TYPES.forEach(function(type){

        if(!this.__defaultTarget["on" + type]){

          this.__defaultTarget["on" + type] = true;
        };
      }.bind(this));
      qx.event.handler.GestureCore.GESTURE_EVENTS.forEach(function(gestureType){

        qxWeb(this.__defaultTarget).on(gestureType, this.checkAndFireGesture, this);
      }.bind(this));
      if(qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 9){

        qxWeb(this.__defaultTarget).on("dblclick", this._onDblClick, this);
      };
      var data = qx.core.Environment.get("event.mousewheel");
      qxWeb(data.target).on(data.type, this._fireRoll, this);
    },
    _stopObserver : function(){

      qx.event.handler.GestureCore.GESTURE_EVENTS.forEach(function(pointerType){

        qxWeb(this.__defaultTarget).off(pointerType, this.checkAndFireGesture, this);
      }.bind(this));
      if(qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 9){

        qxWeb(this.__defaultTarget).off("dblclick", this._onDblClick, this);
      };
      var data = qx.core.Environment.get("event.mousewheel");
      qxWeb(data.target).off(data.type, this._fireRoll, this);
    },
    checkAndFireGesture : function(domEvent, type, target){

      if(!type){

        type = domEvent.type;
      };
      if(!target){

        target = qx.bom.Event.getTarget(domEvent);
      };
      if(type == "gesturebegin"){

        this.gestureBegin(domEvent, target);
      } else if(type == "gesturemove"){

        this.gestureMove(domEvent, target);
      } else if(type == "gesturefinish"){

        this.gestureFinish(domEvent, target);
      } else if(type == "gesturecancel"){

        this.gestureCancel(domEvent.pointerId);
      };;;
    },
    gestureBegin : function(domEvent, target){

      if(this.__gesture[domEvent.pointerId]){

        this.__stopLongTapTimer(this.__gesture[domEvent.pointerId]);
        delete this.__gesture[domEvent.pointerId];
      };
      this.__gesture[domEvent.pointerId] = {
        "startTime" : new Date().getTime(),
        "lastEventTime" : new Date().getTime(),
        "startX" : domEvent.clientX,
        "startY" : domEvent.clientY,
        "clientX" : domEvent.clientX,
        "clientY" : domEvent.clientY,
        "velocityX" : 0,
        "velocityY" : 0,
        "target" : target,
        "isTap" : true,
        "isPrimary" : domEvent.isPrimary,
        "longTapTimer" : window.setTimeout(this.__fireLongTap.bind(this, domEvent, target), qx.event.handler.GestureCore.LONGTAP_TIME)
      };
      if(domEvent.isPrimary){

        this.__isMultiPointerGesture = false;
        this.__primaryTarget = target;
        this.__fireTrack("trackstart", domEvent, target);
      } else {

        this.__isMultiPointerGesture = true;
        if(Object.keys(this.__gesture).length === 2){

          this.__initialAngle = this._calcAngle();
          this.__initialDistance = this._calcDistance();
        };
      };
    },
    gestureMove : function(domEvent, target){

      var gesture = this.__gesture[domEvent.pointerId];
      if(gesture){

        var oldClientX = gesture.clientX;
        var oldClientY = gesture.clientY;
        gesture.clientX = domEvent.clientX;
        gesture.clientY = domEvent.clientY;
        gesture.lastEventTime = new Date().getTime();
        if(oldClientX){

          gesture.velocityX = gesture.clientX - oldClientX;
        };
        if(oldClientY){

          gesture.velocityY = gesture.clientY - oldClientY;
        };
        if(Object.keys(this.__gesture).length === 2){

          this.__fireRotate(domEvent, gesture.target);
          this.__firePinch(domEvent, gesture.target);
        };
        if(!this.__isMultiPointerGesture){

          this.__fireTrack("track", domEvent, gesture.target);
          this._fireRoll(domEvent, "touch", gesture.target);
        };
        if(gesture.isTap){

          gesture.isTap = this._isBelowTapMaxDistance(domEvent);
          if(!gesture.isTap){

            this.__stopLongTapTimer(gesture);
          };
        };
      };
    },
    _hasIntermediaryHandler : function(target){

      while(target && target !== this.__defaultTarget){

        if(target.$$gestureHandler){

          return true;
        };
        target = target.parentNode;
      };
      return false;
    },
    gestureFinish : function(domEvent, target){

      if(!this.__gesture[domEvent.pointerId]){

        return;
      };
      var gesture = this.__gesture[domEvent.pointerId];
      this.__stopLongTapTimer(gesture);
      if(this._hasIntermediaryHandler(target)){

        return;
      };
      this.__handleRollImpulse(gesture.velocityX, gesture.velocityY, domEvent, gesture.target);
      this.__fireTrack("trackend", domEvent, gesture.target);
      if(gesture.isTap){

        if(target !== gesture.target){

          delete this.__gesture[domEvent.pointerId];
          return;
        };
        this._fireEvent(domEvent, "tap", domEvent.target || target);
        if(Object.keys(this.__lastTap).length > 0){

          var limit = Date.now() - qx.event.handler.GestureCore.DOUBLETAP_TIME;
          for(var time in this.__lastTap){

            if(time < limit){

              delete this.__lastTap[time];
            } else {

              if(this.__isBelowDoubleTapDistance(this.__lastTap[time].x, this.__lastTap[time].y, domEvent.clientX, domEvent.clientY, domEvent.getPointerType())){

                this._fireEvent(domEvent, "dbltap", domEvent.target || target);
              };
            };
          };
        };
        this.__lastTap[Date.now()] = {
          x : domEvent.clientX,
          y : domEvent.clientY
        };
      } else if(!this._isBelowTapMaxDistance(domEvent)){

        var swipe = this.__getSwipeGesture(domEvent, target);
        if(swipe){

          domEvent.swipe = swipe;
          this._fireEvent(domEvent, "swipe", domEvent.target || target);
        };
      };
      delete this.__gesture[domEvent.pointerId];
    },
    stopMomentum : function(id){

      this.__stopMomentum[id] = true;
    },
    gestureCancel : function(id){

      if(this.__gesture[id]){

        this.__stopLongTapTimer(this.__gesture[id]);
        delete this.__gesture[id];
      };
    },
    updateGestureTarget : function(id, target){

      this.__gesture[id].target = target;
    },
    __handleRollImpulse : function(deltaX, deltaY, domEvent, target, time){

      var oldTimeoutId = domEvent.timeoutId;
      if((Math.abs(deltaY) < 1 && Math.abs(deltaX) < 1) || this.__stopMomentum[oldTimeoutId]){

        delete this.__stopMomentum[oldTimeoutId];
        return;
      };
      if(!time){

        time = 1;
        var startFactor = 2.8;
        deltaY = deltaY / startFactor;
        deltaX = deltaX / startFactor;
      };
      time += 0.0006;
      deltaY = deltaY / time;
      deltaX = deltaX / time;
      var timeoutId = qx.bom.AnimationFrame.request(qx.lang.Function.bind(function(deltaX, deltaY, domEvent, target, time){

        this.__handleRollImpulse(deltaX, deltaY, domEvent, target, time);
      }, this, deltaX, deltaY, domEvent, target, time));
      deltaX = Math.round(deltaX * 100) / 100;
      deltaY = Math.round(deltaY * 100) / 100;
      domEvent.delta = {
        x : -deltaX,
        y : -deltaY
      };
      domEvent.momentum = true;
      domEvent.timeoutId = timeoutId;
      this._fireEvent(domEvent, "roll", domEvent.target || target);
    },
    _calcAngle : function(){

      var pointerA = null;
      var pointerB = null;
      for(var pointerId in this.__gesture){

        var gesture = this.__gesture[pointerId];
        if(pointerA === null){

          pointerA = gesture;
        } else {

          pointerB = gesture;
        };
      };
      var x = pointerA.clientX - pointerB.clientX;
      var y = pointerA.clientY - pointerB.clientY;
      return (360 + Math.atan2(y, x) * (180 / Math.PI)) % 360;
    },
    _calcDistance : function(){

      var pointerA = null;
      var pointerB = null;
      for(var pointerId in this.__gesture){

        var gesture = this.__gesture[pointerId];
        if(pointerA === null){

          pointerA = gesture;
        } else {

          pointerB = gesture;
        };
      };
      var scale = Math.sqrt(Math.pow(pointerA.clientX - pointerB.clientX, 2) + Math.pow(pointerA.clientY - pointerB.clientY, 2));
      return scale;
    },
    _isBelowTapMaxDistance : function(domEvent){

      var delta = this._getDeltaCoordinates(domEvent);
      var maxDistance = qx.event.handler.GestureCore.TAP_MAX_DISTANCE[domEvent.getPointerType()];
      if(!delta){

        return null;
      };
      return (Math.abs(delta.x) <= maxDistance && Math.abs(delta.y) <= maxDistance);
    },
    __isBelowDoubleTapDistance : function(x1, y1, x2, y2, type){

      var clazz = qx.event.handler.GestureCore;
      var inX = Math.abs(x1 - x2) < clazz.TAP_MAX_DISTANCE[type];
      var inY = Math.abs(y1 - y2) < clazz.TAP_MAX_DISTANCE[type];
      return inX && inY;
    },
    _getDeltaCoordinates : function(domEvent){

      var gesture = this.__gesture[domEvent.pointerId];
      if(!gesture){

        return null;
      };
      var deltaX = domEvent.clientX - gesture.startX;
      var deltaY = domEvent.clientY - gesture.startY;
      var axis = "x";
      if(Math.abs(deltaX / deltaY) < 1){

        axis = "y";
      };
      return {
        "x" : deltaX,
        "y" : deltaY,
        "axis" : axis
      };
    },
    _fireEvent : function(domEvent, type, target){

      if(!this.__defaultTarget){

        return;
      };
      var evt;
      if(qx.core.Environment.get("event.dispatchevent")){

        evt = new qx.event.type.dom.Custom(type, domEvent, {
          bubbles : true,
          swipe : domEvent.swipe,
          scale : domEvent.scale,
          angle : domEvent.angle,
          delta : domEvent.delta,
          pointerType : domEvent.pointerType,
          momentum : domEvent.momentum
        });
        target.dispatchEvent(evt);
      } else if(this.__emitter){

        evt = new qx.event.type.dom.Custom(type, domEvent, {
          target : this.__defaultTarget,
          currentTarget : this.__defaultTarget,
          srcElement : this.__defaultTarget,
          swipe : domEvent.swipe,
          scale : domEvent.scale,
          angle : domEvent.angle,
          delta : domEvent.delta,
          pointerType : domEvent.pointerType,
          momentum : domEvent.momentum
        });
        this.__emitter.emit(type, domEvent);
      };
    },
    _onDblClick : function(domEvent){

      var target = qx.bom.Event.getTarget(domEvent);
      this._fireEvent(domEvent, "tap", target);
      this._fireEvent(domEvent, "dbltap", target);
    },
    __getSwipeGesture : function(domEvent, target){

      var gesture = this.__gesture[domEvent.pointerId];
      if(!gesture){

        return null;
      };
      var clazz = qx.event.handler.GestureCore;
      var deltaCoordinates = this._getDeltaCoordinates(domEvent);
      var duration = new Date().getTime() - gesture.startTime;
      var axis = (Math.abs(deltaCoordinates.x) >= Math.abs(deltaCoordinates.y)) ? "x" : "y";
      var distance = deltaCoordinates[axis];
      var direction = clazz.SWIPE_DIRECTION[axis][distance < 0 ? 0 : 1];
      var velocity = (duration !== 0) ? distance / duration : 0;
      var swipe = {
        startTime : gesture.startTime,
        duration : duration,
        axis : axis,
        direction : direction,
        distance : distance,
        velocity : velocity
      };
      return swipe;
    },
    __fireTrack : function(type, domEvent, target){

      domEvent.delta = this._getDeltaCoordinates(domEvent);
      this._fireEvent(domEvent, type, domEvent.target || target);
    },
    _fireRoll : function(domEvent, type, target){

      if(domEvent.type === qx.core.Environment.get("event.mousewheel").type){

        domEvent.delta = {
          x : qx.util.Wheel.getDelta(domEvent, "x") * qx.event.handler.GestureCore.ROLL_FACTOR,
          y : qx.util.Wheel.getDelta(domEvent, "y") * qx.event.handler.GestureCore.ROLL_FACTOR
        };
        domEvent.delta.axis = Math.abs(domEvent.delta.x / domEvent.delta.y) < 1 ? "y" : "x";
        domEvent.pointerType = "wheel";
      } else {

        var gesture = this.__gesture[domEvent.pointerId];
        domEvent.delta = {
          x : -gesture.velocityX,
          y : -gesture.velocityY,
          axis : Math.abs(gesture.velocityX / gesture.velocityY) < 1 ? "y" : "x"
        };
      };
      this._fireEvent(domEvent, "roll", domEvent.target || target);
    },
    __fireRotate : function(domEvent, target){

      if(!domEvent.isPrimary){

        var angle = this._calcAngle();
        domEvent.angle = Math.round((angle - this.__initialAngle) % 360);
        this._fireEvent(domEvent, "rotate", this.__primaryTarget);
      };
    },
    __firePinch : function(domEvent, target){

      if(!domEvent.isPrimary){

        var distance = this._calcDistance();
        var scale = distance / this.__initialDistance;
        domEvent.scale = (Math.round(scale * 100) / 100);
        this._fireEvent(domEvent, "pinch", this.__primaryTarget);
      };
    },
    __fireLongTap : function(domEvent, target){

      var gesture = this.__gesture[domEvent.pointerId];
      if(gesture){

        this._fireEvent(domEvent, "longtap", domEvent.target || target);
        gesture.longTapTimer = null;
        gesture.isTap = false;
      };
    },
    __stopLongTapTimer : function(gesture){

      if(gesture.longTapTimer){

        window.clearTimeout(gesture.longTapTimer);
        gesture.longTapTimer = null;
      };
    },
    isBelowTapMaxDistance : function(event){

      var deltaCoordinates = this._calcDelta(event);
      var clazz = qx.event.handler.GestureCore;
      return (Math.abs(deltaCoordinates.x) <= clazz.TAP_MAX_DISTANCE && Math.abs(deltaCoordinates.y) <= clazz.TAP_MAX_DISTANCE);
    },
    dispose : function(){

      for(var gesture in this.__gesture){

        this.__stopLongTapTimer(gesture);
      };
      this._stopObserver();
      this.__defaultTarget = this.__emitter = null;
    }
  }
});

qx.Bootstrap.define("qx.type.BaseArray", {
  extend : Array,
  construct : function(length_or_items){
  },
  members : {
    toArray : null,
    valueOf : null,
    pop : null,
    push : null,
    reverse : null,
    shift : null,
    sort : null,
    splice : null,
    unshift : null,
    concat : null,
    join : null,
    slice : null,
    toString : null,
    indexOf : null,
    lastIndexOf : null,
    forEach : null,
    filter : null,
    map : null,
    some : null,
    every : null
  }
});
(function(){

  function createStackConstructor(stack){

    if((qx.core.Environment.get("engine.name") == "mshtml")){

      Stack.prototype = {
        length : 0,
        $$isArray : true
      };
      var args = "pop.push.reverse.shift.sort.splice.unshift.join.slice".split(".");
      for(var length = args.length;length;){

        Stack.prototype[args[--length]] = Array.prototype[args[length]];
      };
    };
    var slice = Array.prototype.slice;
    Stack.prototype.concat = function(){

      var constructor = this.slice(0);
      for(var i = 0,length = arguments.length;i < length;i++){

        var copy;
        if(arguments[i] instanceof Stack){

          copy = slice.call(arguments[i], 0);
        } else if(arguments[i] instanceof Array){

          copy = arguments[i];
        } else {

          copy = [arguments[i]];
        };
        constructor.push.apply(constructor, copy);
      };
      return constructor;
    };
    Stack.prototype.toString = function(){

      return slice.call(this, 0).toString();
    };
    Stack.prototype.toLocaleString = function(){

      return slice.call(this, 0).toLocaleString();
    };
    Stack.prototype.constructor = Stack;
    Stack.prototype.indexOf = Array.prototype.indexOf;
    Stack.prototype.lastIndexOf = Array.prototype.lastIndexOf;
    Stack.prototype.forEach = Array.prototype.forEach;
    Stack.prototype.some = Array.prototype.some;
    Stack.prototype.every = Array.prototype.every;
    var filter = Array.prototype.filter;
    var map = Array.prototype.map;
    Stack.prototype.filter = function(){

      var ret = new this.constructor;
      ret.push.apply(ret, filter.apply(this, arguments));
      return ret;
    };
    Stack.prototype.map = function(){

      var ret = new this.constructor;
      ret.push.apply(ret, map.apply(this, arguments));
      return ret;
    };
    Stack.prototype.slice = function(){

      var ret = new this.constructor;
      ret.push.apply(ret, Array.prototype.slice.apply(this, arguments));
      return ret;
    };
    Stack.prototype.splice = function(){

      var ret = new this.constructor;
      ret.push.apply(ret, Array.prototype.splice.apply(this, arguments));
      return ret;
    };
    Stack.prototype.toArray = function(){

      return Array.prototype.slice.call(this, 0);
    };
    Stack.prototype.valueOf = function(){

      return this.length;
    };
    return Stack;
  };
  function Stack(length){

    if(arguments.length === 1 && typeof length === "number"){

      this.length = -1 < length && length === length >> .5 ? length : this.push(length);
    } else if(arguments.length){

      this.push.apply(this, arguments);
    };
  };
  function PseudoArray(){
  };
  PseudoArray.prototype = [];
  Stack.prototype = new PseudoArray;
  Stack.prototype.length = 0;
  qx.type.BaseArray = createStackConstructor(Stack);
})();

qx.Bootstrap.define("qxWeb", {
  extend : qx.type.BaseArray,
  statics : {
    __init : [],
    $$qx : qx,
    $init : function(arg, clazz){

      var clean = [];
      for(var i = 0;i < arg.length;i++){

        var isNode = !!(arg[i] && (arg[i].nodeType === 1 || arg[i].nodeType === 9 || arg[i].nodeType === 11));
        if(isNode){

          clean.push(arg[i]);
          continue;
        };
        var isWindow = !!(arg[i] && arg[i].history && arg[i].location && arg[i].document);
        if(isWindow){

          clean.push(arg[i]);
        };
      };
      if(arg[0] && arg[0].getAttribute && arg[0].getAttribute("data-qx-class")){

        clazz = qx.Bootstrap.getByName(arg[0].getAttribute("data-qx-class")) || clazz;
      };
      var col = qx.lang.Array.cast(clean, clazz);
      for(var i = 0;i < qxWeb.__init.length;i++){

        qxWeb.__init[i].call(col);
      };
      return col;
    },
    $attach : function(module){

      for(var name in module){

        if(qx.core.Environment.get("qx.debug")){

          if(qxWeb.prototype[name] != undefined && Array.prototype[name] == undefined){

            throw new Error("Method '" + name + "' already available.");
          };
        };
        qxWeb.prototype[name] = module[name];
      };
    },
    $attachStatic : function(module){

      for(var name in module){

        if(qx.core.Environment.get("qx.debug")){

          if(qxWeb[name] != undefined){

            throw new Error("Method '" + name + "' already available as static method.");
          };
        };
        qxWeb[name] = module[name];
      };
    },
    $attachInit : function(init){

      this.__init.push(init);
    },
    define : function(name, config){

      if(config == undefined){

        config = name;
        name = null;
      };
      return qx.Bootstrap.define.call(qx.Bootstrap, name, config);
    }
  },
  construct : function(selector, context){

    if(!selector && this instanceof qxWeb){

      return this;
    };
    if(!selector){

      selector = [];
    } else if(qx.Bootstrap.isString(selector)){

      if(context instanceof qxWeb){

        context = context[0];
      };
      selector = qx.bom.Selector.query(selector, context);
    } else if((selector.nodeType === 1 || selector.nodeType === 9 || selector.nodeType === 11) || (selector.history && selector.location && selector.document)){

      selector = [selector];
    };;
    return qxWeb.$init(selector, qxWeb);
  },
  members : {
    filter : function(selector){

      if(qx.lang.Type.isFunction(selector)){

        return qxWeb.$init(Array.prototype.filter.call(this, selector), this.constructor);
      };
      return qxWeb.$init(qx.bom.Selector.matches(selector, this), this.constructor);
    },
    unique : function(){

      var unique = qx.lang.Array.unique(this);
      return qxWeb.$init(unique, this.constructor);
    },
    slice : function(begin, end){

      if(end !== undefined){

        return qxWeb.$init(Array.prototype.slice.call(this, begin, end), this.constructor);
      };
      return qxWeb.$init(Array.prototype.slice.call(this, begin), this.constructor);
    },
    splice : function(index, howMany, varargs){

      return qxWeb.$init(Array.prototype.splice.apply(this, arguments), this.constructor);
    },
    map : function(callback, thisarg){

      return qxWeb.$init(Array.prototype.map.apply(this, arguments), qxWeb);
    },
    concat : function(varargs){

      var clone = Array.prototype.slice.call(this, 0);
      for(var i = 0;i < arguments.length;i++){

        if(arguments[i] instanceof qxWeb){

          clone = clone.concat(Array.prototype.slice.call(arguments[i], 0));
        } else {

          clone.push(arguments[i]);
        };
      };
      return qxWeb.$init(clone, this.constructor);
    },
    indexOf : function(elem){

      if(!elem){

        return -1;
      };
      if(qx.Bootstrap.isArray(elem)){

        elem = elem[0];
      };
      for(var i = 0,l = this.length;i < l;i++){

        if(this[i] === elem){

          return i;
        };
      };
      return -1;
    },
    debug : function(){

      debugger;
      return this;
    },
    _forEachElement : function(func, ctx){

      for(var i = 0,l = this.length;i < l;i++){

        if(this[i] && (this[i].nodeType === 1 || this[i].nodeType === 11)){

          func.apply(ctx || this, [this[i], i, this]);
        };
      };
      return this;
    },
    _forEachElementWrapped : function(func, ctx){

      this._forEachElement(function(item, idx, arr){

        func.apply(this, [qxWeb(item), idx, arr]);
      }, ctx);
      return this;
    }
  },
  defer : function(statics){

    if(window.q == undefined){

      q = statics;
    };
  }
});

qx.Bootstrap.define("qx.bom.Selector", {
  statics : {
    query : null,
    matches : null
  }
});
(function(window){

  var i,support,Expr,getText,isXML,compile,select,outermostContext,sortInput,hasDuplicate,setDocument,document,docElem,documentIsHTML,rbuggyQSA,rbuggyMatches,matches,contains,expando = "sizzle" + -(new Date()),preferredDoc = window.document,dirruns = 0,done = 0,classCache = createCache(),tokenCache = createCache(),compilerCache = createCache(),sortOrder = function(a, b){

    if(a === b){

      hasDuplicate = true;
    };
    return 0;
  },strundefined = typeof undefined,MAX_NEGATIVE = 1 << 31,hasOwn = ({
  }).hasOwnProperty,arr = [],pop = arr.pop,push_native = arr.push,push = arr.push,slice = arr.slice,indexOf = arr.indexOf || function(elem){

    var i = 0,len = this.length;
    for(;i < len;i++){

      if(this[i] === elem){

        return i;
      };
    };
    return -1;
  },booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",whitespace = "[\\x20\\t\\r\\n\\f]",characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",identifier = characterEncoding.replace("w", "w#"),attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace + "*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace(3, 8) + ")*)|.*)\\)|)",rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),rpseudo = new RegExp(pseudos),ridentifier = new RegExp("^" + identifier + "$"),matchExpr = {
    "ID" : new RegExp("^#(" + characterEncoding + ")"),
    "CLASS" : new RegExp("^\\.(" + characterEncoding + ")"),
    "TAG" : new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
    "ATTR" : new RegExp("^" + attributes),
    "PSEUDO" : new RegExp("^" + pseudos),
    "CHILD" : new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
    "bool" : new RegExp("^(?:" + booleans + ")$", "i"),
    "needsContext" : new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
  },rinputs = /^(?:input|select|textarea|button)$/i,rheader = /^h\d$/i,rnative = /^[^{]+\{\s*\[native \w/,rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,rsibling = /[+~]/,rescape = /'|\\/g,runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),funescape = function(_, escaped, escapedWhitespace){

    var high = "0x" + escaped - 0x10000;
    return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
  };
  try{

    push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
    arr[preferredDoc.childNodes.length].nodeType;
  } catch(e) {

    push = {
      apply : arr.length ? function(target, els){

        push_native.apply(target, slice.call(els));
      } : function(target, els){

        var j = target.length,i = 0;
        while((target[j++] = els[i++])){
        };
        target.length = j - 1;
      }
    };
  };
  function Sizzle(selector, context, results, seed){

    var match,elem,m,nodeType,i,groups,old,nid,newContext,newSelector;
    if((context ? context.ownerDocument || context : preferredDoc) !== document){

      setDocument(context);
    };
    context = context || document;
    results = results || [];
    if(!selector || typeof selector !== "string"){

      return results;
    };
    if((nodeType = context.nodeType) !== 1 && nodeType !== 9){

      return [];
    };
    if(documentIsHTML && !seed){

      if((match = rquickExpr.exec(selector))){

        if((m = match[1])){

          if(nodeType === 9){

            elem = context.getElementById(m);
            if(elem && elem.parentNode){

              if(elem.id === m){

                results.push(elem);
                return results;
              };
            } else {

              return results;
            };
          } else {

            if(context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m){

              results.push(elem);
              return results;
            };
          };
        } else if(match[2]){

          push.apply(results, context.getElementsByTagName(selector));
          return results;
        } else if((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName){

          push.apply(results, context.getElementsByClassName(m));
          return results;
        };;
      };
      if(support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))){

        nid = old = expando;
        newContext = context;
        newSelector = nodeType === 9 && selector;
        if(nodeType === 1 && context.nodeName.toLowerCase() !== "object"){

          groups = tokenize(selector);
          if((old = context.getAttribute("id"))){

            nid = old.replace(rescape, "\\$&");
          } else {

            context.setAttribute("id", nid);
          };
          nid = "[id='" + nid + "'] ";
          i = groups.length;
          while(i--){

            groups[i] = nid + toSelector(groups[i]);
          };
          newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
          newSelector = groups.join(",");
        };
        if(newSelector){

          try{

            push.apply(results, newContext.querySelectorAll(newSelector));
            return results;
          } catch(qsaError) {
          }finally{

            if(!old){

              context.removeAttribute("id");
            };
          };
        };
      };
    };
    return select(selector.replace(rtrim, "$1"), context, results, seed);
  };
  function createCache(){

    var keys = [];
    function cache(key, value){

      if(keys.push(key + " ") > Expr.cacheLength){

        delete cache[keys.shift()];
      };
      return (cache[key + " "] = value);
    };
    return cache;
  };
  function markFunction(fn){

    fn[expando] = true;
    return fn;
  };
  function assert(fn){

    var div = document.createElement("div");
    try{

      return !!fn(div);
    } catch(e) {

      return false;
    }finally{

      if(div.parentNode){

        div.parentNode.removeChild(div);
      };
      div = null;
    };
  };
  function addHandle(attrs, handler){

    var arr = attrs.split("|"),i = attrs.length;
    while(i--){

      Expr.attrHandle[arr[i]] = handler;
    };
  };
  function siblingCheck(a, b){

    var cur = b && a,diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
    if(diff){

      return diff;
    };
    if(cur){

      while((cur = cur.nextSibling)){

        if(cur === b){

          return -1;
        };
      };
    };
    return a ? 1 : -1;
  };
  function createInputPseudo(type){

    return function(elem){

      var name = elem.nodeName.toLowerCase();
      return name === "input" && elem.type === type;
    };
  };
  function createButtonPseudo(type){

    return function(elem){

      var name = elem.nodeName.toLowerCase();
      return (name === "input" || name === "button") && elem.type === type;
    };
  };
  function createPositionalPseudo(fn){

    return markFunction(function(argument){

      argument = +argument;
      return markFunction(function(seed, matches){

        var j,matchIndexes = fn([], seed.length, argument),i = matchIndexes.length;
        while(i--){

          if(seed[(j = matchIndexes[i])]){

            seed[j] = !(matches[j] = seed[j]);
          };
        };
      });
    });
  };
  function testContext(context){

    return context && typeof context.getElementsByTagName !== strundefined && context;
  };
  support = Sizzle.support = {
  };
  isXML = Sizzle.isXML = function(elem){

    var documentElement = elem && (elem.ownerDocument || elem).documentElement;
    return documentElement ? documentElement.nodeName !== "HTML" : false;
  };
  setDocument = Sizzle.setDocument = function(node){

    var hasCompare,doc = node ? node.ownerDocument || node : preferredDoc,parent = doc.defaultView;
    if(doc === document || doc.nodeType !== 9 || !doc.documentElement){

      return document;
    };
    document = doc;
    docElem = doc.documentElement;
    documentIsHTML = !isXML(doc);
    if(parent && parent !== parent.top){

      if(parent.addEventListener){

        parent.addEventListener("unload", function(){

          setDocument();
        }, false);
      } else if(parent.attachEvent){

        parent.attachEvent("onunload", function(){

          setDocument();
        });
      };
    };
    support.attributes = assert(function(div){

      div.className = "i";
      return !div.getAttribute("className");
    });
    support.getElementsByTagName = assert(function(div){

      div.appendChild(doc.createComment(""));
      return !div.getElementsByTagName("*").length;
    });
    support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function(div){

      div.innerHTML = "<div class='a'></div><div class='a i'></div>";
      div.firstChild.className = "i";
      return div.getElementsByClassName("i").length === 2;
    });
    support.getById = assert(function(div){

      docElem.appendChild(div).id = expando;
      return !doc.getElementsByName || !doc.getElementsByName(expando).length;
    });
    if(support.getById){

      Expr.find["ID"] = function(id, context){

        if(typeof context.getElementById !== strundefined && documentIsHTML){

          var m = context.getElementById(id);
          return m && m.parentNode ? [m] : [];
        };
      };
      Expr.filter["ID"] = function(id){

        var attrId = id.replace(runescape, funescape);
        return function(elem){

          return elem.getAttribute("id") === attrId;
        };
      };
    } else {

      delete Expr.find["ID"];
      Expr.filter["ID"] = function(id){

        var attrId = id.replace(runescape, funescape);
        return function(elem){

          var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
          return node && node.value === attrId;
        };
      };
    };
    Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context){

      if(typeof context.getElementsByTagName !== strundefined){

        return context.getElementsByTagName(tag);
      };
    } : function(tag, context){

      var elem,tmp = [],i = 0,results = context.getElementsByTagName(tag);
      if(tag === "*"){

        while((elem = results[i++])){

          if(elem.nodeType === 1){

            tmp.push(elem);
          };
        };
        return tmp;
      };
      return results;
    };
    Expr.find["CLASS"] = support.getElementsByClassName && function(className, context){

      if(typeof context.getElementsByClassName !== strundefined && documentIsHTML){

        return context.getElementsByClassName(className);
      };
    };
    rbuggyMatches = [];
    rbuggyQSA = [];
    if((support.qsa = rnative.test(doc.querySelectorAll))){

      assert(function(div){

        div.innerHTML = "<select t=''><option selected=''></option></select>";
        if(div.querySelectorAll("[t^='']").length){

          rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
        };
        if(!div.querySelectorAll("[selected]").length){

          rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
        };
        if(!div.querySelectorAll(":checked").length){

          rbuggyQSA.push(":checked");
        };
      });
      assert(function(div){

        var input = doc.createElement("input");
        input.setAttribute("type", "hidden");
        div.appendChild(input).setAttribute("name", "D");
        if(div.querySelectorAll("[name=d]").length){

          rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
        };
        if(!div.querySelectorAll(":enabled").length){

          rbuggyQSA.push(":enabled", ":disabled");
        };
        div.querySelectorAll("*,:x");
        rbuggyQSA.push(",.*:");
      });
    };
    if((support.matchesSelector = rnative.test((matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))){

      assert(function(div){

        support.disconnectedMatch = matches.call(div, "div");
        matches.call(div, "[s!='']:x");
        rbuggyMatches.push("!=", pseudos);
      });
    };
    rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
    rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
    hasCompare = rnative.test(docElem.compareDocumentPosition);
    contains = hasCompare || rnative.test(docElem.contains) ? function(a, b){

      var adown = a.nodeType === 9 ? a.documentElement : a,bup = b && b.parentNode;
      return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
    } : function(a, b){

      if(b){

        while((b = b.parentNode)){

          if(b === a){

            return true;
          };
        };
      };
      return false;
    };
    sortOrder = hasCompare ? function(a, b){

      if(a === b){

        hasDuplicate = true;
        return 0;
      };
      var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
      if(compare){

        return compare;
      };
      compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
      if(compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)){

        if(a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)){

          return -1;
        };
        if(b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)){

          return 1;
        };
        return sortInput ? (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) : 0;
      };
      return compare & 4 ? -1 : 1;
    } : function(a, b){

      if(a === b){

        hasDuplicate = true;
        return 0;
      };
      var cur,i = 0,aup = a.parentNode,bup = b.parentNode,ap = [a],bp = [b];
      if(!aup || !bup){

        return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) : 0;
      } else if(aup === bup){

        return siblingCheck(a, b);
      };
      cur = a;
      while((cur = cur.parentNode)){

        ap.unshift(cur);
      };
      cur = b;
      while((cur = cur.parentNode)){

        bp.unshift(cur);
      };
      while(ap[i] === bp[i]){

        i++;
      };
      return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
    };
    return doc;
  };
  Sizzle.matches = function(expr, elements){

    return Sizzle(expr, null, null, elements);
  };
  Sizzle.matchesSelector = function(elem, expr){

    if((elem.ownerDocument || elem) !== document){

      setDocument(elem);
    };
    expr = expr.replace(rattributeQuotes, "='$1']");
    if(support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))){

      try{

        var ret = matches.call(elem, expr);
        if(ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11){

          return ret;
        };
      } catch(e) {
      };
    };
    return Sizzle(expr, document, null, [elem]).length > 0;
  };
  Sizzle.contains = function(context, elem){

    if((context.ownerDocument || context) !== document){

      setDocument(context);
    };
    return contains(context, elem);
  };
  Sizzle.attr = function(elem, name){

    if((elem.ownerDocument || elem) !== document){

      setDocument(elem);
    };
    var fn = Expr.attrHandle[name.toLowerCase()],val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
    return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
  };
  Sizzle.error = function(msg){

    throw new Error("Syntax error, unrecognized expression: " + msg);
  };
  Sizzle.uniqueSort = function(results){

    var elem,duplicates = [],j = 0,i = 0;
    hasDuplicate = !support.detectDuplicates;
    sortInput = !support.sortStable && results.slice(0);
    results.sort(sortOrder);
    if(hasDuplicate){

      while((elem = results[i++])){

        if(elem === results[i]){

          j = duplicates.push(i);
        };
      };
      while(j--){

        results.splice(duplicates[j], 1);
      };
    };
    sortInput = null;
    return results;
  };
  getText = Sizzle.getText = function(elem){

    var node,ret = "",i = 0,nodeType = elem.nodeType;
    if(!nodeType){

      while((node = elem[i++])){

        ret += getText(node);
      };
    } else if(nodeType === 1 || nodeType === 9 || nodeType === 11){

      if(typeof elem.textContent === "string"){

        return elem.textContent;
      } else {

        for(elem = elem.firstChild;elem;elem = elem.nextSibling){

          ret += getText(elem);
        };
      };
    } else if(nodeType === 3 || nodeType === 4){

      return elem.nodeValue;
    };;
    return ret;
  };
  Expr = Sizzle.selectors = {
    cacheLength : 50,
    createPseudo : markFunction,
    match : matchExpr,
    attrHandle : {
    },
    find : {
    },
    relative : {
      ">" : {
        dir : "parentNode",
        first : true
      },
      " " : {
        dir : "parentNode"
      },
      "+" : {
        dir : "previousSibling",
        first : true
      },
      "~" : {
        dir : "previousSibling"
      }
    },
    preFilter : {
      "ATTR" : function(match){

        match[1] = match[1].replace(runescape, funescape);
        match[3] = (match[4] || match[5] || "").replace(runescape, funescape);
        if(match[2] === "~="){

          match[3] = " " + match[3] + " ";
        };
        return match.slice(0, 4);
      },
      "CHILD" : function(match){

        match[1] = match[1].toLowerCase();
        if(match[1].slice(0, 3) === "nth"){

          if(!match[3]){

            Sizzle.error(match[0]);
          };
          match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
          match[5] = +((match[7] + match[8]) || match[3] === "odd");
        } else if(match[3]){

          Sizzle.error(match[0]);
        };
        return match;
      },
      "PSEUDO" : function(match){

        var excess,unquoted = !match[5] && match[2];
        if(matchExpr["CHILD"].test(match[0])){

          return null;
        };
        if(match[3] && match[4] !== undefined){

          match[2] = match[4];
        } else if(unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)){

          match[0] = match[0].slice(0, excess);
          match[2] = unquoted.slice(0, excess);
        };
        return match.slice(0, 3);
      }
    },
    filter : {
      "TAG" : function(nodeNameSelector){

        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
        return nodeNameSelector === "*" ? function(){

          return true;
        } : function(elem){

          return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
        };
      },
      "CLASS" : function(className){

        var pattern = classCache[className + " "];
        return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem){

          return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "");
        });
      },
      "ATTR" : function(name, operator, check){

        return function(elem){

          var result = Sizzle.attr(elem, name);
          if(result == null){

            return operator === "!=";
          };
          if(!operator){

            return true;
          };
          result += "";
          return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
        };
      },
      "CHILD" : function(type, what, argument, first, last){

        var simple = type.slice(0, 3) !== "nth",forward = type.slice(-4) !== "last",ofType = what === "of-type";
        return first === 1 && last === 0 ? function(elem){

          return !!elem.parentNode;
        } : function(elem, context, xml){

          var cache,outerCache,node,diff,nodeIndex,start,dir = simple !== forward ? "nextSibling" : "previousSibling",parent = elem.parentNode,name = ofType && elem.nodeName.toLowerCase(),useCache = !xml && !ofType;
          if(parent){

            if(simple){

              while(dir){

                node = elem;
                while((node = node[dir])){

                  if(ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1){

                    return false;
                  };
                };
                start = dir = type === "only" && !start && "nextSibling";
              };
              return true;
            };
            start = [forward ? parent.firstChild : parent.lastChild];
            if(forward && useCache){

              outerCache = parent[expando] || (parent[expando] = {
              });
              cache = outerCache[type] || [];
              nodeIndex = cache[0] === dirruns && cache[1];
              diff = cache[0] === dirruns && cache[2];
              node = nodeIndex && parent.childNodes[nodeIndex];
              while((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())){

                if(node.nodeType === 1 && ++diff && node === elem){

                  outerCache[type] = [dirruns, nodeIndex, diff];
                  break;
                };
              };
            } else if(useCache && (cache = (elem[expando] || (elem[expando] = {
            }))[type]) && cache[0] === dirruns){

              diff = cache[1];
            } else {

              while((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())){

                if((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff){

                  if(useCache){

                    (node[expando] || (node[expando] = {
                    }))[type] = [dirruns, diff];
                  };
                  if(node === elem){

                    break;
                  };
                };
              };
            };
            diff -= last;
            return diff === first || (diff % first === 0 && diff / first >= 0);
          };
        };
      },
      "PSEUDO" : function(pseudo, argument){

        var args,fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
        if(fn[expando]){

          return fn(argument);
        };
        if(fn.length > 1){

          args = [pseudo, pseudo, "", argument];
          return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches){

            var idx,matched = fn(seed, argument),i = matched.length;
            while(i--){

              idx = indexOf.call(seed, matched[i]);
              seed[idx] = !(matches[idx] = matched[i]);
            };
          }) : function(elem){

            return fn(elem, 0, args);
          };
        };
        return fn;
      }
    },
    pseudos : {
      "not" : markFunction(function(selector){

        var input = [],results = [],matcher = compile(selector.replace(rtrim, "$1"));
        return matcher[expando] ? markFunction(function(seed, matches, context, xml){

          var elem,unmatched = matcher(seed, null, xml, []),i = seed.length;
          while(i--){

            if((elem = unmatched[i])){

              seed[i] = !(matches[i] = elem);
            };
          };
        }) : function(elem, context, xml){

          input[0] = elem;
          matcher(input, null, xml, results);
          return !results.pop();
        };
      }),
      "has" : markFunction(function(selector){

        return function(elem){

          return Sizzle(selector, elem).length > 0;
        };
      }),
      "contains" : markFunction(function(text){

        return function(elem){

          return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
        };
      }),
      "lang" : markFunction(function(lang){

        if(!ridentifier.test(lang || "")){

          Sizzle.error("unsupported lang: " + lang);
        };
        lang = lang.replace(runescape, funescape).toLowerCase();
        return function(elem){

          var elemLang;
          do {

            if((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))){

              elemLang = elemLang.toLowerCase();
              return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
            };
          }while(((elem = elem.parentNode) && elem.nodeType === 1));
          return false;
        };
      }),
      "target" : function(elem){

        var hash = window.location && window.location.hash;
        return hash && hash.slice(1) === elem.id;
      },
      "root" : function(elem){

        return elem === docElem;
      },
      "focus" : function(elem){

        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
      },
      "enabled" : function(elem){

        return elem.disabled === false;
      },
      "disabled" : function(elem){

        return elem.disabled === true;
      },
      "checked" : function(elem){

        var nodeName = elem.nodeName.toLowerCase();
        return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
      },
      "selected" : function(elem){

        if(elem.parentNode){

          elem.parentNode.selectedIndex;
        };
        return elem.selected === true;
      },
      "empty" : function(elem){

        for(elem = elem.firstChild;elem;elem = elem.nextSibling){

          if(elem.nodeType < 6){

            return false;
          };
        };
        return true;
      },
      "parent" : function(elem){

        return !Expr.pseudos["empty"](elem);
      },
      "header" : function(elem){

        return rheader.test(elem.nodeName);
      },
      "input" : function(elem){

        return rinputs.test(elem.nodeName);
      },
      "button" : function(elem){

        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === "button" || name === "button";
      },
      "text" : function(elem){

        var attr;
        return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
      },
      "first" : createPositionalPseudo(function(){

        return [0];
      }),
      "last" : createPositionalPseudo(function(matchIndexes, length){

        return [length - 1];
      }),
      "eq" : createPositionalPseudo(function(matchIndexes, length, argument){

        return [argument < 0 ? argument + length : argument];
      }),
      "even" : createPositionalPseudo(function(matchIndexes, length){

        var i = 0;
        for(;i < length;i += 2){

          matchIndexes.push(i);
        };
        return matchIndexes;
      }),
      "odd" : createPositionalPseudo(function(matchIndexes, length){

        var i = 1;
        for(;i < length;i += 2){

          matchIndexes.push(i);
        };
        return matchIndexes;
      }),
      "lt" : createPositionalPseudo(function(matchIndexes, length, argument){

        var i = argument < 0 ? argument + length : argument;
        for(;--i >= 0;){

          matchIndexes.push(i);
        };
        return matchIndexes;
      }),
      "gt" : createPositionalPseudo(function(matchIndexes, length, argument){

        var i = argument < 0 ? argument + length : argument;
        for(;++i < length;){

          matchIndexes.push(i);
        };
        return matchIndexes;
      })
    }
  };
  Expr.pseudos["nth"] = Expr.pseudos["eq"];
  for(i in {
    radio : true,
    checkbox : true,
    file : true,
    password : true,
    image : true
  }){

    Expr.pseudos[i] = createInputPseudo(i);
  };
  for(i in {
    submit : true,
    reset : true
  }){

    Expr.pseudos[i] = createButtonPseudo(i);
  };
  function setFilters(){
  };
  setFilters.prototype = Expr.filters = Expr.pseudos;
  Expr.setFilters = new setFilters();
  function tokenize(selector, parseOnly){

    var matched,match,tokens,type,soFar,groups,preFilters,cached = tokenCache[selector + " "];
    if(cached){

      return parseOnly ? 0 : cached.slice(0);
    };
    soFar = selector;
    groups = [];
    preFilters = Expr.preFilter;
    while(soFar){

      if(!matched || (match = rcomma.exec(soFar))){

        if(match){

          soFar = soFar.slice(match[0].length) || soFar;
        };
        groups.push((tokens = []));
      };
      matched = false;
      if((match = rcombinators.exec(soFar))){

        matched = match.shift();
        tokens.push({
          value : matched,
          type : match[0].replace(rtrim, " ")
        });
        soFar = soFar.slice(matched.length);
      };
      for(type in Expr.filter){

        if((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))){

          matched = match.shift();
          tokens.push({
            value : matched,
            type : type,
            matches : match
          });
          soFar = soFar.slice(matched.length);
        };
      };
      if(!matched){

        break;
      };
    };
    return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
  };
  function toSelector(tokens){

    var i = 0,len = tokens.length,selector = "";
    for(;i < len;i++){

      selector += tokens[i].value;
    };
    return selector;
  };
  function addCombinator(matcher, combinator, base){

    var dir = combinator.dir,checkNonElements = base && dir === "parentNode",doneName = done++;
    return combinator.first ? function(elem, context, xml){

      while((elem = elem[dir])){

        if(elem.nodeType === 1 || checkNonElements){

          return matcher(elem, context, xml);
        };
      };
    } : function(elem, context, xml){

      var oldCache,outerCache,newCache = [dirruns, doneName];
      if(xml){

        while((elem = elem[dir])){

          if(elem.nodeType === 1 || checkNonElements){

            if(matcher(elem, context, xml)){

              return true;
            };
          };
        };
      } else {

        while((elem = elem[dir])){

          if(elem.nodeType === 1 || checkNonElements){

            outerCache = elem[expando] || (elem[expando] = {
            });
            if((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName){

              return (newCache[2] = oldCache[2]);
            } else {

              outerCache[dir] = newCache;
              if((newCache[2] = matcher(elem, context, xml))){

                return true;
              };
            };
          };
        };
      };
    };
  };
  function elementMatcher(matchers){

    return matchers.length > 1 ? function(elem, context, xml){

      var i = matchers.length;
      while(i--){

        if(!matchers[i](elem, context, xml)){

          return false;
        };
      };
      return true;
    } : matchers[0];
  };
  function multipleContexts(selector, contexts, results){

    var i = 0,len = contexts.length;
    for(;i < len;i++){

      Sizzle(selector, contexts[i], results);
    };
    return results;
  };
  function condense(unmatched, map, filter, context, xml){

    var elem,newUnmatched = [],i = 0,len = unmatched.length,mapped = map != null;
    for(;i < len;i++){

      if((elem = unmatched[i])){

        if(!filter || filter(elem, context, xml)){

          newUnmatched.push(elem);
          if(mapped){

            map.push(i);
          };
        };
      };
    };
    return newUnmatched;
  };
  function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector){

    if(postFilter && !postFilter[expando]){

      postFilter = setMatcher(postFilter);
    };
    if(postFinder && !postFinder[expando]){

      postFinder = setMatcher(postFinder, postSelector);
    };
    return markFunction(function(seed, results, context, xml){

      var temp,i,elem,preMap = [],postMap = [],preexisting = results.length,elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
      if(matcher){

        matcher(matcherIn, matcherOut, context, xml);
      };
      if(postFilter){

        temp = condense(matcherOut, postMap);
        postFilter(temp, [], context, xml);
        i = temp.length;
        while(i--){

          if((elem = temp[i])){

            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
          };
        };
      };
      if(seed){

        if(postFinder || preFilter){

          if(postFinder){

            temp = [];
            i = matcherOut.length;
            while(i--){

              if((elem = matcherOut[i])){

                temp.push((matcherIn[i] = elem));
              };
            };
            postFinder(null, (matcherOut = []), temp, xml);
          };
          i = matcherOut.length;
          while(i--){

            if((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1){

              seed[temp] = !(results[temp] = elem);
            };
          };
        };
      } else {

        matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
        if(postFinder){

          postFinder(null, results, matcherOut, xml);
        } else {

          push.apply(results, matcherOut);
        };
      };
    });
  };
  function matcherFromTokens(tokens){

    var checkContext,matcher,j,len = tokens.length,leadingRelative = Expr.relative[tokens[0].type],implicitRelative = leadingRelative || Expr.relative[" "],i = leadingRelative ? 1 : 0,matchContext = addCombinator(function(elem){

      return elem === checkContext;
    }, implicitRelative, true),matchAnyContext = addCombinator(function(elem){

      return indexOf.call(checkContext, elem) > -1;
    }, implicitRelative, true),matchers = [function(elem, context, xml){

      return (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
    }];
    for(;i < len;i++){

      if((matcher = Expr.relative[tokens[i].type])){

        matchers = [addCombinator(elementMatcher(matchers), matcher)];
      } else {

        matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
        if(matcher[expando]){

          j = ++i;
          for(;j < len;j++){

            if(Expr.relative[tokens[j].type]){

              break;
            };
          };
          return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
            value : tokens[i - 2].type === " " ? "*" : ""
          })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
        };
        matchers.push(matcher);
      };
    };
    return elementMatcher(matchers);
  };
  function matcherFromGroupMatchers(elementMatchers, setMatchers){

    var bySet = setMatchers.length > 0,byElement = elementMatchers.length > 0,superMatcher = function(seed, context, xml, results, outermost){

      var elem,j,matcher,matchedCount = 0,i = "0",unmatched = seed && [],setMatched = [],contextBackup = outermostContext,elems = seed || byElement && Expr.find["TAG"]("*", outermost),dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),len = elems.length;
      if(outermost){

        outermostContext = context !== document && context;
      };
      for(;i !== len && (elem = elems[i]) != null;i++){

        if(byElement && elem){

          j = 0;
          while((matcher = elementMatchers[j++])){

            if(matcher(elem, context, xml)){

              results.push(elem);
              break;
            };
          };
          if(outermost){

            dirruns = dirrunsUnique;
          };
        };
        if(bySet){

          if((elem = !matcher && elem)){

            matchedCount--;
          };
          if(seed){

            unmatched.push(elem);
          };
        };
      };
      matchedCount += i;
      if(bySet && i !== matchedCount){

        j = 0;
        while((matcher = setMatchers[j++])){

          matcher(unmatched, setMatched, context, xml);
        };
        if(seed){

          if(matchedCount > 0){

            while(i--){

              if(!(unmatched[i] || setMatched[i])){

                setMatched[i] = pop.call(results);
              };
            };
          };
          setMatched = condense(setMatched);
        };
        push.apply(results, setMatched);
        if(outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1){

          Sizzle.uniqueSort(results);
        };
      };
      if(outermost){

        dirruns = dirrunsUnique;
        outermostContext = contextBackup;
      };
      return unmatched;
    };
    return bySet ? markFunction(superMatcher) : superMatcher;
  };
  compile = Sizzle.compile = function(selector, match){

    var i,setMatchers = [],elementMatchers = [],cached = compilerCache[selector + " "];
    if(!cached){

      if(!match){

        match = tokenize(selector);
      };
      i = match.length;
      while(i--){

        cached = matcherFromTokens(match[i]);
        if(cached[expando]){

          setMatchers.push(cached);
        } else {

          elementMatchers.push(cached);
        };
      };
      cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
      cached.selector = selector;
    };
    return cached;
  };
  select = Sizzle.select = function(selector, context, results, seed){

    var i,tokens,token,type,find,compiled = typeof selector === "function" && selector,match = !seed && tokenize((selector = compiled.selector || selector));
    results = results || [];
    if(match.length === 1){

      tokens = match[0] = match[0].slice(0);
      if(tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]){

        context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
        if(!context){

          return results;
        } else if(compiled){

          context = context.parentNode;
        };
        selector = selector.slice(tokens.shift().value.length);
      };
      i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
      while(i--){

        token = tokens[i];
        if(Expr.relative[(type = token.type)]){

          break;
        };
        if((find = Expr.find[type])){

          if((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))){

            tokens.splice(i, 1);
            selector = seed.length && toSelector(tokens);
            if(!selector){

              push.apply(results, seed);
              return results;
            };
            break;
          };
        };
      };
    };
    (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
    return results;
  };
  support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
  support.detectDuplicates = !!hasDuplicate;
  setDocument();
  support.sortDetached = assert(function(div1){

    return div1.compareDocumentPosition(document.createElement("div")) & 1;
  });
  if(!assert(function(div){

    div.innerHTML = "<a href='#'></a>";
    return div.firstChild.getAttribute("href") === "#";
  })){

    addHandle("type|href|height|width", function(elem, name, isXML){

      if(!isXML){

        return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
      };
    });
  };
  if(!support.attributes || !assert(function(div){

    div.innerHTML = "<input/>";
    div.firstChild.setAttribute("value", "");
    return div.firstChild.getAttribute("value") === "";
  })){

    addHandle("value", function(elem, name, isXML){

      if(!isXML && elem.nodeName.toLowerCase() === "input"){

        return elem.defaultValue;
      };
    });
  };
  if(!assert(function(div){

    return div.getAttribute("disabled") == null;
  })){

    addHandle(booleans, function(elem, name, isXML){

      var val;
      if(!isXML){

        return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
      };
    });
  };
  qx.bom.Selector.query = function(selector, context){

    return Sizzle(selector, context);
  };
  qx.bom.Selector.matches = function(selector, set){

    return Sizzle(selector, null, null, set);
  };
})(window);

qx.Bootstrap.define("qx.bom.AnimationFrame", {
  extend : qx.event.Emitter,
  events : {
    "end" : undefined,
    "frame" : "Number"
  },
  members : {
    __canceled : false,
    startSequence : function(duration){

      this.__canceled = false;
      var start = +(new Date());
      var clb = function(time){

        if(this.__canceled){

          this.id = null;
          return;
        };
        if(time >= start + duration){

          this.emit("end");
          this.id = null;
        } else {

          var timePassed = Math.max(time - start, 0);
          this.emit("frame", timePassed);
          this.id = qx.bom.AnimationFrame.request(clb, this);
        };
      };
      this.id = qx.bom.AnimationFrame.request(clb, this);
    },
    cancelSequence : function(){

      this.__canceled = true;
    }
  },
  statics : {
    TIMEOUT : 30,
    calculateTiming : function(func, x){

      if(func == "ease-in"){

        var a = [3.1223e-7, 0.0757, 1.2646, -0.167, -0.4387, 0.2654];
      } else if(func == "ease-out"){

        var a = [-7.0198e-8, 1.652, -0.551, -0.0458, 0.1255, -0.1807];
      } else if(func == "linear"){

        return x;
      } else if(func == "ease-in-out"){

        var a = [2.482e-7, -0.2289, 3.3466, -1.0857, -1.7354, 0.7034];
      } else {

        var a = [-0.0021, 0.2472, 9.8054, -21.6869, 17.7611, -5.1226];
      };;;
      var y = 0;
      for(var i = 0;i < a.length;i++){

        y += a[i] * Math.pow(x, i);
      };
      return y;
    },
    request : function(callback, context){

      var req = qx.core.Environment.get("css.animation.requestframe");
      var clb = function(time){

        if(time < 1e10){

          time = this.__start + time;
        };
        time = time || +(new Date());
        callback.call(context, time);
      };
      if(req){

        return window[req](clb);
      } else {

        return window.setTimeout(function(){

          clb();
        }, qx.bom.AnimationFrame.TIMEOUT);
      };
    }
  },
  defer : function(statics){

    statics.__start = window.performance && performance.timing && performance.timing.navigationStart;
    if(!statics.__start){

      statics.__start = Date.now();
    };
  }
});

qx.Bootstrap.define("qx.bom.Stylesheet", {
  statics : {
    includeFile : function(href, doc){

      if(!doc){

        doc = document;
      };
      var el = doc.createElement("link");
      el.type = "text/css";
      el.rel = "stylesheet";
      el.href = href;
      var head = doc.getElementsByTagName("head")[0];
      head.appendChild(el);
    },
    createElement : function(text){

      if(qx.core.Environment.get("html.stylesheet.createstylesheet")){

        var sheet = document.createStyleSheet();
        if(text){

          sheet.cssText = text;
        };
        return sheet;
      } else {

        var elem = document.createElement("style");
        elem.type = "text/css";
        if(text){

          elem.appendChild(document.createTextNode(text));
        };
        document.getElementsByTagName("head")[0].appendChild(elem);
        return elem.sheet;
      };
    },
    addRule : function(sheet, selector, entry){

      if(qx.core.Environment.get('qx.debug')){

        var msg = "qx.bom.Stylesheet.addRule: The rule '" + entry + "' for the selector '" + selector + "' must not be enclosed in braces";
        qx.core.Assert.assertFalse(/^\s*?\{.*?\}\s*?$/.test(entry), msg);
      };
      if(qx.core.Environment.get("html.stylesheet.insertrule")){

        sheet.insertRule(selector + "{" + entry + "}", sheet.cssRules.length);
      } else {

        sheet.addRule(selector, entry);
      };
    },
    removeRule : function(sheet, selector){

      if(qx.core.Environment.get("html.stylesheet.deleterule")){

        var rules = sheet.cssRules;
        var len = rules.length;
        for(var i = len - 1;i >= 0;--i){

          if(rules[i].selectorText == selector){

            sheet.deleteRule(i);
          };
        };
      } else {

        var rules = sheet.rules;
        var len = rules.length;
        for(var i = len - 1;i >= 0;--i){

          if(rules[i].selectorText == selector){

            sheet.removeRule(i);
          };
        };
      };
    },
    removeSheet : function(sheet){

      var owner = sheet.ownerNode ? sheet.ownerNode : sheet.owningElement;
      qx.dom.Element.removeChild(owner, owner.parentNode);
    },
    removeAllRules : function(sheet){

      if(qx.core.Environment.get("html.stylesheet.deleterule")){

        var rules = sheet.cssRules;
        var len = rules.length;
        for(var i = len - 1;i >= 0;i--){

          sheet.deleteRule(i);
        };
      } else {

        var rules = sheet.rules;
        var len = rules.length;
        for(var i = len - 1;i >= 0;i--){

          sheet.removeRule(i);
        };
      };
    },
    addImport : function(sheet, url){

      if(qx.core.Environment.get("html.stylesheet.addimport")){

        sheet.addImport(url);
      } else {

        sheet.insertRule('@import "' + url + '";', sheet.cssRules.length);
      };
    },
    removeImport : function(sheet, url){

      if(qx.core.Environment.get("html.stylesheet.removeimport")){

        var imports = sheet.imports;
        var len = imports.length;
        for(var i = len - 1;i >= 0;i--){

          if(imports[i].href == url || imports[i].href == qx.util.Uri.getAbsolute(url)){

            sheet.removeImport(i);
          };
        };
      } else {

        var rules = sheet.cssRules;
        var len = rules.length;
        for(var i = len - 1;i >= 0;i--){

          if(rules[i].href == url){

            sheet.deleteRule(i);
          };
        };
      };
    },
    removeAllImports : function(sheet){

      if(qx.core.Environment.get("html.stylesheet.removeimport")){

        var imports = sheet.imports;
        var len = imports.length;
        for(var i = len - 1;i >= 0;i--){

          sheet.removeImport(i);
        };
      } else {

        var rules = sheet.cssRules;
        var len = rules.length;
        for(var i = len - 1;i >= 0;i--){

          if(rules[i].type == rules[i].IMPORT_RULE){

            sheet.deleteRule(i);
          };
        };
      };
    }
  }
});

qx.Bootstrap.define("qx.util.Uri", {
  statics : {
    parseUri : function(str, strict){

      var options = {
        key : ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
        q : {
          name : "queryKey",
          parser : /(?:^|&)([^&=]*)=?([^&]*)/g
        },
        parser : {
          strict : /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
          loose : /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
      };
      var o = options,m = options.parser[strict ? "strict" : "loose"].exec(str),uri = {
      },i = 14;
      while(i--){

        uri[o.key[i]] = m[i] || "";
      };
      uri[o.q.name] = {
      };
      uri[o.key[12]].replace(o.q.parser, function($0, $1, $2){

        if($1){

          uri[o.q.name][$1] = $2;
        };
      });
      return uri;
    },
    appendParamsToUrl : function(url, params){

      if(params === undefined){

        return url;
      };
      if(qx.core.Environment.get("qx.debug")){

        if(!(qx.lang.Type.isString(params) || qx.lang.Type.isObject(params))){

          throw new Error("params must be either string or object");
        };
      };
      if(qx.lang.Type.isObject(params)){

        params = qx.util.Uri.toParameter(params);
      };
      if(!params){

        return url;
      };
      return url += (/\?/).test(url) ? "&" + params : "?" + params;
    },
    toParameter : function(obj, post){

      var key,parts = [];
      for(key in obj){

        if(obj.hasOwnProperty(key)){

          var value = obj[key];
          if(value instanceof Array){

            for(var i = 0;i < value.length;i++){

              this.__toParameterPair(key, value[i], parts, post);
            };
          } else {

            this.__toParameterPair(key, value, parts, post);
          };
        };
      };
      return parts.join("&");
    },
    __toParameterPair : function(key, value, parts, post){

      var encode = window.encodeURIComponent;
      if(post){

        parts.push(encode(key).replace(/%20/g, "+") + "=" + encode(value).replace(/%20/g, "+"));
      } else {

        parts.push(encode(key) + "=" + encode(value));
      };
    },
    getAbsolute : function(uri){

      var div = document.createElement("div");
      div.innerHTML = '<a href="' + uri + '">0</a>';
      return div.firstChild.href;
    }
  }
});

qx.Bootstrap.define("qx.bom.client.Stylesheet", {
  statics : {
    __getStylesheet : function(){

      if(!qx.bom.client.Stylesheet.__stylesheet){

        qx.bom.client.Stylesheet.__stylesheet = qx.bom.Stylesheet.createElement();
      };
      return qx.bom.client.Stylesheet.__stylesheet;
    },
    getCreateStyleSheet : function(){

      return typeof document.createStyleSheet === "object";
    },
    getInsertRule : function(){

      return typeof qx.bom.client.Stylesheet.__getStylesheet().insertRule === "function";
    },
    getDeleteRule : function(){

      return typeof qx.bom.client.Stylesheet.__getStylesheet().deleteRule === "function";
    },
    getAddImport : function(){

      return (typeof qx.bom.client.Stylesheet.__getStylesheet().addImport === "object");
    },
    getRemoveImport : function(){

      return (typeof qx.bom.client.Stylesheet.__getStylesheet().removeImport === "object");
    }
  },
  defer : function(statics){

    qx.core.Environment.add("html.stylesheet.createstylesheet", statics.getCreateStyleSheet);
    qx.core.Environment.add("html.stylesheet.insertrule", statics.getInsertRule);
    qx.core.Environment.add("html.stylesheet.deleterule", statics.getDeleteRule);
    qx.core.Environment.add("html.stylesheet.addimport", statics.getAddImport);
    qx.core.Environment.add("html.stylesheet.removeimport", statics.getRemoveImport);
  }
});

qx.Bootstrap.define("qx.bom.client.CssAnimation", {
  statics : {
    getSupport : function(){

      var name = qx.bom.client.CssAnimation.getName();
      if(name != null){

        return {
          "name" : name,
          "play-state" : qx.bom.client.CssAnimation.getPlayState(),
          "start-event" : qx.bom.client.CssAnimation.getAnimationStart(),
          "iteration-event" : qx.bom.client.CssAnimation.getAnimationIteration(),
          "end-event" : qx.bom.client.CssAnimation.getAnimationEnd(),
          "fill-mode" : qx.bom.client.CssAnimation.getFillMode(),
          "keyframes" : qx.bom.client.CssAnimation.getKeyFrames()
        };
      };
      return null;
    },
    getFillMode : function(){

      return qx.bom.Style.getPropertyName("AnimationFillMode");
    },
    getPlayState : function(){

      return qx.bom.Style.getPropertyName("AnimationPlayState");
    },
    getName : function(){

      return qx.bom.Style.getPropertyName("animation");
    },
    getAnimationStart : function(){

      var mapping = {
        "msAnimation" : "MSAnimationStart",
        "WebkitAnimation" : "webkitAnimationStart",
        "MozAnimation" : "animationstart",
        "OAnimation" : "oAnimationStart",
        "animation" : "animationstart"
      };
      return mapping[this.getName()];
    },
    getAnimationIteration : function(){

      var mapping = {
        "msAnimation" : "MSAnimationIteration",
        "WebkitAnimation" : "webkitAnimationIteration",
        "MozAnimation" : "animationiteration",
        "OAnimation" : "oAnimationIteration",
        "animation" : "animationiteration"
      };
      return mapping[this.getName()];
    },
    getAnimationEnd : function(){

      var mapping = {
        "msAnimation" : "MSAnimationEnd",
        "WebkitAnimation" : "webkitAnimationEnd",
        "MozAnimation" : "animationend",
        "OAnimation" : "oAnimationEnd",
        "animation" : "animationend"
      };
      return mapping[this.getName()];
    },
    getKeyFrames : function(){

      var prefixes = qx.bom.Style.VENDOR_PREFIXES;
      var keyFrames = [];
      for(var i = 0;i < prefixes.length;i++){

        var key = "@" + qx.bom.Style.getCssName(prefixes[i]) + "-keyframes";
        keyFrames.push(key);
      };
      keyFrames.unshift("@keyframes");
      var sheet = qx.bom.Stylesheet.createElement();
      for(var i = 0;i < keyFrames.length;i++){

        try{

          qx.bom.Stylesheet.addRule(sheet, keyFrames[i] + " name", "");
          return keyFrames[i];
        } catch(e) {
        };
      };
      return null;
    },
    getRequestAnimationFrame : function(){

      var choices = ["requestAnimationFrame", "msRequestAnimationFrame", "webkitRequestAnimationFrame", "mozRequestAnimationFrame", "oRequestAnimationFrame"];
      for(var i = 0;i < choices.length;i++){

        if(window[choices[i]] != undefined){

          return choices[i];
        };
      };
      return null;
    }
  },
  defer : function(statics){

    qx.core.Environment.add("css.animation", statics.getSupport);
    qx.core.Environment.add("css.animation.requestframe", statics.getRequestAnimationFrame);
  }
});

qx.Bootstrap.define("qx.util.Wheel", {
  statics : {
    MAXSCROLL : null,
    MINSCROLL : null,
    FACTOR : 1,
    getDelta : function(domEvent, axis){

      if(axis === undefined){

        var delta = 0;
        if(domEvent.wheelDelta !== undefined){

          delta = -domEvent.wheelDelta;
        } else if(domEvent.detail !== 0){

          delta = domEvent.detail;
        } else if(domEvent.deltaY !== undefined){

          delta = domEvent.deltaY;
        };;
        return this.__normalize(delta);
      };
      if(axis === "x"){

        var x = 0;
        if(domEvent.wheelDelta !== undefined){

          if(domEvent.wheelDeltaX !== undefined){

            x = domEvent.wheelDeltaX ? this.__normalize(-domEvent.wheelDeltaX) : 0;
          };
        } else {

          if(domEvent.axis && domEvent.axis == domEvent.HORIZONTAL_AXIS){

            if((domEvent.detail !== undefined) && (domEvent.detail > 0)){

              x = this.__normalize(domEvent.detail);
            } else if(domEvent.deltaX !== undefined){

              x = this.__normalize(domEvent.deltaX);
            };
          };
        };
        return x;
      };
      if(axis === "y"){

        var y = 0;
        if(domEvent.wheelDelta !== undefined){

          if(domEvent.wheelDeltaY !== undefined){

            y = domEvent.wheelDeltaY ? this.__normalize(-domEvent.wheelDeltaY) : 0;
          } else {

            y = this.__normalize(-domEvent.wheelDelta);
          };
        } else {

          if(!(domEvent.axis && domEvent.axis == domEvent.HORIZONTAL_AXIS)){

            if((domEvent.detail !== undefined) && (domEvent.detail > 0)){

              y = this.__normalize(domEvent.detail);
            } else if(domEvent.deltaY !== undefined){

              y = this.__normalize(domEvent.deltaY);
            };
          };
        };
        return y;
      };
      return 0;
    },
    __normalize : function(delta){

      var absDelta = Math.abs(delta);
      if(qx.util.Wheel.MINSCROLL == null || qx.util.Wheel.MINSCROLL > absDelta){

        qx.util.Wheel.MINSCROLL = absDelta;
        this.__recalculateMultiplicator();
      };
      if(qx.util.Wheel.MAXSCROLL == null || qx.util.Wheel.MAXSCROLL < absDelta){

        qx.util.Wheel.MAXSCROLL = absDelta;
        this.__recalculateMultiplicator();
      };
      if(qx.util.Wheel.MAXSCROLL === absDelta && qx.util.Wheel.MINSCROLL === absDelta){

        return 2 * (delta / absDelta);
      };
      var range = qx.util.Wheel.MAXSCROLL - qx.util.Wheel.MINSCROLL;
      var ret = (delta / range) * Math.log(range) * qx.util.Wheel.FACTOR;
      return ret < 0 ? Math.min(ret, -1) : Math.max(ret, 1);
    },
    __recalculateMultiplicator : function(){

      var max = qx.util.Wheel.MAXSCROLL || 0;
      var min = qx.util.Wheel.MINSCROLL || max;
      if(max <= min){

        return;
      };
      var range = max - min;
      var maxRet = (max / range) * Math.log(range);
      if(maxRet == 0){

        maxRet = 1;
      };
      qx.util.Wheel.FACTOR = 6 / maxRet;
    }
  }
});

qx.Class.define("qx.event.handler.Appear", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  construct : function(manager){

    this.base(arguments);
    this.__manager = manager;
    this.__targets = {
    };
    qx.event.handler.Appear.__instances[this.$$hash] = this;
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      appear : true,
      disappear : true
    },
    TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE,
    IGNORE_CAN_HANDLE : true,
    __instances : {
    },
    refresh : function(){

      var all = this.__instances;
      for(var hash in all){

        all[hash].refresh();
      };
    }
  },
  members : {
    __manager : null,
    __targets : null,
    canHandleEvent : function(target, type){
    },
    registerEvent : function(target, type, capture){

      var hash = qx.core.ObjectRegistry.toHashCode(target) + type;
      var targets = this.__targets;
      if(targets && !targets[hash]){

        targets[hash] = target;
        target.$$displayed = target.offsetWidth > 0;
      };
    },
    unregisterEvent : function(target, type, capture){

      var hash = qx.core.ObjectRegistry.toHashCode(target) + type;
      var targets = this.__targets;
      if(!targets){

        return;
      };
      if(targets[hash]){

        delete targets[hash];
      };
    },
    refresh : function(){

      var targets = this.__targets;
      var elem;
      var legacyIe = qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 9;
      for(var hash in targets){

        elem = targets[hash];
        var displayed = elem.offsetWidth > 0;
        if(!displayed && legacyIe){

          displayed = elem.offsetWidth > 0;
        };
        if((!!elem.$$displayed) !== displayed){

          elem.$$displayed = displayed;
          var evt = qx.event.Registration.createEvent(displayed ? "appear" : "disappear");
          this.__manager.dispatchEvent(elem, evt);
        };
      };
    }
  },
  destruct : function(){

    this.__manager = this.__targets = null;
    delete qx.event.handler.Appear.__instances[this.$$hash];
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
  }
});

qx.Class.define("qx.ui.mobile.core.DomUpdatedHandler", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  construct : function(manager){

    this.base(arguments);
    this.__manager = manager;
    this.__targets = {
    };
    qx.ui.mobile.core.DomUpdatedHandler.__instances[this.$$hash] = this;
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      domupdated : 1
    },
    IGNORE_CAN_HANDLE : false,
    __instances : {
    },
    refresh : function(){

      var all = this.__instances;
      for(var hash in all){

        all[hash].refresh();
      };
    }
  },
  members : {
    __manager : null,
    __targets : null,
    canHandleEvent : function(target, type){

      return target instanceof qx.ui.mobile.core.Widget;
    },
    registerEvent : function(target, type, capture){

      var hash = target.$$hash;
      var targets = this.__targets;
      if(targets && !targets[hash]){

        targets[hash] = target;
      };
    },
    unregisterEvent : function(target, type, capture){

      var hash = target.$$hash;
      var targets = this.__targets;
      if(!targets){

        return;
      };
      if(targets[hash]){

        delete targets[hash];
      };
    },
    refresh : function(){

      var targets = this.__targets;
      var target;
      for(var hash in targets){

        target = targets[hash];
        if(target && !target.$$disposed && target.isSeeable()){

          var evt = qx.event.Registration.createEvent("domupdated");
          this.__manager.dispatchEvent(target, evt);
        };
      };
    }
  },
  destruct : function(){

    this.__manager = this.__targets = null;
    delete qx.ui.mobile.core.DomUpdatedHandler.__instances[this.$$hash];
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
  }
});

qx.Class.define("qx.ui.mobile.layout.Abstract", {
  extend : qx.core.Object,
  type : "abstract",
  events : {
    updateLayout : "qx.event.type.Data"
  },
  members : {
    _widget : null,
    __cachedProperties : null,
    __cachedChildLayoutProperties : null,
    _getCssClasses : function(){

      if(qx.core.Environment.get("qx.debug")){

        throw new Error("Abstract method call");
      };
    },
    _getSupportedChildLayoutProperties : function(){

      return null;
    },
    _setLayoutProperty : function(widget, property, value){

      if(qx.core.Environment.get("qx.debug")){

        throw new Error("Abstract method call");
      };
    },
    setLayoutProperties : function(widget, properties){

      if(properties == null){

        return;
      };
      var supportedChildLayoutProperties = this._getSupportedChildLayoutProperties();
      if(!supportedChildLayoutProperties){

        return;
      };
      for(var property in properties){

        if(!supportedChildLayoutProperties[property]){

          throw new Error("The layout does not support the " + property + " property");
        };
        var value = properties[property];
        this._setLayoutProperty(widget, property, value);
        this._addPropertyToChildLayoutCache(widget, property, value);
      };
    },
    connectToWidget : function(widget){

      if(this._widget){

        this._widget.removeCssClasses(this._getCssClasses());
      };
      this._widget = widget;
      if(widget){

        widget.addCssClasses(this._getCssClasses());
        if(this.__cachedProperties){

          for(var property in this.__cachedProperties){

            this.reset(property);
            this.set(property, this.__cachedProperties[property]);
          };
        };
      } else {

        this.__cachedProperties = null;
      };
    },
    connectToChildWidget : function(widget){
    },
    disconnectFromChildWidget : function(widget){
    },
    updateLayout : function(widget, action, properties){

      this.fireDataEvent("updateLayout", {
        widget : widget,
        action : action,
        properties : properties
      });
    },
    _addCachedProperty : function(property, value){

      if(!this.__cachedProperties){

        this.__cachedProperties = {
        };
      };
      this.__cachedProperties[property] = value;
    },
    _getChildLayoutPropertyValue : function(widget, property){

      var cache = this.__getChildLayoutPropertyCache(widget);
      return cache[property];
    },
    _addPropertyToChildLayoutCache : function(widget, property, value){

      var cache = this.__getChildLayoutPropertyCache(widget);
      if(value == null){

        delete cache[property];
      } else {

        cache[property] = value;
      };
    },
    __getChildLayoutPropertyCache : function(widget){

      if(!this.__cachedChildLayoutProperties){

        this.__cachedChildLayoutProperties = {
        };
      };
      var cache = this.__cachedChildLayoutProperties;
      var hash = widget.toHashCode();
      if(!cache[hash]){

        cache[hash] = {
        };
      };
      return cache[hash];
    }
  },
  destruct : function(){

    this._widget = null;
  }
});

qx.Bootstrap.define("qx.bom.client.CssTransform", {
  statics : {
    getSupport : function(){

      var name = qx.bom.client.CssTransform.getName();
      if(name != null){

        return {
          "name" : name,
          "style" : qx.bom.client.CssTransform.getStyle(),
          "origin" : qx.bom.client.CssTransform.getOrigin(),
          "3d" : qx.bom.client.CssTransform.get3D(),
          "perspective" : qx.bom.client.CssTransform.getPerspective(),
          "perspective-origin" : qx.bom.client.CssTransform.getPerspectiveOrigin(),
          "backface-visibility" : qx.bom.client.CssTransform.getBackFaceVisibility()
        };
      };
      return null;
    },
    getStyle : function(){

      return qx.bom.Style.getPropertyName("transformStyle");
    },
    getPerspective : function(){

      return qx.bom.Style.getPropertyName("perspective");
    },
    getPerspectiveOrigin : function(){

      return qx.bom.Style.getPropertyName("perspectiveOrigin");
    },
    getBackFaceVisibility : function(){

      return qx.bom.Style.getPropertyName("backfaceVisibility");
    },
    getOrigin : function(){

      return qx.bom.Style.getPropertyName("transformOrigin");
    },
    getName : function(){

      return qx.bom.Style.getPropertyName("transform");
    },
    get3D : function(){

      return qx.bom.client.CssTransform.getPerspective() != null;
    }
  },
  defer : function(statics){

    qx.core.Environment.add("css.transform", statics.getSupport);
    qx.core.Environment.add("css.transform.3d", statics.get3D);
  }
});

qx.Class.define("qx.ui.mobile.container.Composite", {
  extend : qx.ui.mobile.core.Widget,
  include : [qx.ui.mobile.core.MChildrenHandling, qx.ui.mobile.core.MLayoutHandling],
  construct : function(layout){

    this.base(arguments);
    if(layout){

      this.setLayout(layout);
    };
  },
  defer : function(statics, members){

    qx.ui.mobile.core.MChildrenHandling.remap(members);
    qx.ui.mobile.core.MLayoutHandling.remap(members);
  }
});

qx.Class.define("qx.ui.mobile.core.Root", {
  extend : qx.ui.mobile.container.Composite,
  construct : function(root, layout){

    this.__root = root || document.body;
    this.base(arguments, layout || new qx.ui.mobile.layout.VBox());
    this.addCssClass("mobile");
    this.addCssClass(qx.core.Environment.get("os.name"));
    this.addCssClass("v" + qx.core.Environment.get("os.version").charAt(0));
    qx.event.Registration.addListener(window, "orientationchange", this._onOrientationChange, this);
    if(qx.core.Environment.get("os.name") == "ios"){

      this.addListener("touchmove", qx.bom.Event.preventDefault, this);
      if(window.innerHeight != document.documentElement.clientHeight){

        this.addCssClass("ios-viewport-fix");
      };
    };
    var flexboxSyntax = qx.core.Environment.get("css.flexboxSyntax");
    if(flexboxSyntax === "flex" || flexboxSyntax === "flexbox"){

      this.addCssClass("flex-ready");
    };
    this._onOrientationChange();
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "root"
    },
    showScrollbarY : {
      check : "Boolean",
      init : true,
      apply : "_applyShowScrollbarY"
    }
  },
  events : {
    "changeAppScale" : "qx.event.type.Event"
  },
  members : {
    __root : null,
    _createContainerElement : function(){

      return this.__root;
    },
    _applyShowScrollbarY : function(value, old){

      this._setStyle("overflow-y", value ? "auto" : "hidden");
    },
    getAppScale : function(){

      var pixelRatio = parseFloat(qx.bom.client.Device.getDevicePixelRatio().toFixed(2));
      var fontScale = this.getFontScale();
      if(!isNaN(pixelRatio * fontScale)){

        return parseFloat((pixelRatio * fontScale).toFixed(2));
      } else {

        return null;
      };
    },
    getFontScale : function(){

      var fontScale = null;
      var appScale = 1;
      var fontSize = document.documentElement.style.fontSize;
      if(fontSize.indexOf("%") !== -1){

        appScale = (parseInt(fontSize, 10) / 100);
      };
      fontSize = qx.bom.element.Style.get(document.documentElement, "fontSize");
      if(fontSize.indexOf("px") !== -1){

        fontSize = parseFloat(fontSize);
        if(fontSize > 15 && fontSize < 17){

          fontSize = 16;
        };
        if(appScale !== 1){

          fontSize = Math.round(fontSize / appScale);
        };
        fontScale = (fontSize / 16);
        fontScale *= appScale;
        fontScale = parseFloat(fontScale.toFixed(3));
      };
      return fontScale;
    },
    setFontScale : function(value){

      if(qx.core.Environment.get("qx.debug")){

        this.assertNumber(value, "The scale factor is asserted to be of type Number");
      };
      var docElement = document.documentElement;
      docElement.style.fontSize = value * 100 + "%";
      setTimeout(function(){

        docElement.style.display = "none";
        docElement.clientWidth = docElement.clientWidth;
        docElement.style.display = "";
      }, 0);
      this.fireEvent("changeAppScale");
    },
    getWidth : function(){

      return qx.bom.element.Dimension.getWidth(this.__root);
    },
    getHeight : function(){

      return qx.bom.element.Dimension.getHeight(this.__root);
    },
    _onOrientationChange : function(evt){

      var isPortrait = null;
      if(evt){

        isPortrait = evt.isPortrait();
      } else {

        isPortrait = qx.bom.Viewport.isPortrait();
      };
      if(isPortrait){

        this.addCssClass("portrait");
        this.removeCssClass("landscape");
      } else {

        this.addCssClass("landscape");
        this.removeCssClass("portrait");
      };
    }
  },
  destruct : function(){

    this.__root = null;
    this.removeListener("touchmove", qx.bom.Event.preventDefault, this);
    qx.event.Registration.removeListener(window, "orientationchange", this._onOrientationChange, this);
  }
});

qx.Class.define("qx.ui.mobile.layout.AbstractBox", {
  extend : qx.ui.mobile.layout.Abstract,
  type : "abstract",
  construct : function(alignX, alignY, reversed){

    this.base(arguments);
    if(alignX){

      this.setAlignX(alignX);
    };
    if(alignY){

      this.setAlignY(alignY);
    };
    if(reversed){

      this.setReversed(reversed);
    };
  },
  properties : {
    alignX : {
      check : ["left", "center", "right"],
      nullable : true,
      init : null,
      apply : "_applyLayoutChange"
    },
    alignY : {
      check : ["top", "middle", "bottom"],
      nullable : true,
      init : null,
      apply : "_applyLayoutChange"
    },
    reversed : {
      check : "Boolean",
      nullable : true,
      init : null,
      apply : "_applyLayoutChange"
    }
  },
  statics : {
    PROPERTY_CSS_MAPPING : {
      "alignX" : {
        "hbox" : {
          "left" : "flex-justify-start",
          "center" : "flex-justify-center",
          "right" : "flex-justify-end"
        },
        "vbox" : {
          "left" : "flex-align-start",
          "center" : "flex-align-center",
          "right" : "flex-align-end"
        }
      },
      "alignY" : {
        "hbox" : {
          "top" : "flex-align-start",
          "middle" : "flex-align-center",
          "bottom" : "flex-align-end"
        },
        "vbox" : {
          "top" : "flex-justify-start",
          "middle" : "flex-justify-center",
          "bottom" : "flex-justify-end"
        }
      },
      "reversed" : {
        "hbox" : {
          "true" : "flex-reverse",
          "false" : null
        },
        "vbox" : {
          "true" : "flex-reverse",
          "false" : null
        }
      }
    },
    SUPPORTED_CHILD_LAYOUT_PROPERTIES : {
      "flex" : 1
    }
  },
  members : {
    _getSupportedChildLayoutProperties : function(){

      return qx.ui.mobile.layout.AbstractBox.SUPPORTED_CHILD_LAYOUT_PROPERTIES;
    },
    _setLayoutProperty : function(widget, property, value){

      if(property == "flex"){

        var old = this._getChildLayoutPropertyValue(widget, property);
        if(old != null){

          widget.removeCssClass("flex" + value);
        };
        widget.addCssClass("flex" + value);
      };
    },
    connectToWidget : function(widget){

      if(this._widget){

        this.resetAlignX();
        this.resetAlignY();
        this.resetReversed();
      };
      this.base(arguments, widget);
    },
    disconnectFromChildWidget : function(widget){

      this.base(arguments);
      for(var i = 0;i <= 6;i++){

        widget.removeCssClass("flex" + i);
      };
    },
    _applyLayoutChange : function(value, old, property){

      if(this._widget){

        var layoutCss = this._getCssClasses()[0];
        var CSS_MAPPING = qx.ui.mobile.layout.AbstractBox.PROPERTY_CSS_MAPPING[property][layoutCss];
        if(old){

          var oldCssClass = CSS_MAPPING[old];
          if(oldCssClass){

            this._widget.removeCssClass(oldCssClass);
          };
        };
        if(value){

          var cssClass = CSS_MAPPING[value];
          if(cssClass){

            this._widget.addCssClass(cssClass);
          };
        };
      } else {

        if(value){

          this._addCachedProperty(property, value);
        };
      };
    }
  }
});

qx.Class.define("qx.ui.mobile.layout.VBox", {
  extend : qx.ui.mobile.layout.AbstractBox,
  members : {
    _getCssClasses : function(){

      return ["vbox"];
    }
  }
});

qx.Bootstrap.define("qx.bom.element.Dimension", {
  statics : {
    getWidth : function(element){

      var rect = element.getBoundingClientRect();
      return Math.round(rect.right - rect.left);
    },
    getHeight : function(element){

      var rect = element.getBoundingClientRect();
      return Math.round(rect.bottom - rect.top);
    },
    getSize : function(element){

      return {
        width : this.getWidth(element),
        height : this.getHeight(element)
      };
    },
    __hiddenScrollbars : {
      visible : true,
      hidden : true
    },
    getContentWidth : function(element){

      var Style = qx.bom.element.Style;
      var overflowX = qx.bom.element.Style.get(element, "overflowX");
      var paddingLeft = parseInt(Style.get(element, "paddingLeft") || "0px", 10);
      var paddingRight = parseInt(Style.get(element, "paddingRight") || "0px", 10);
      if(this.__hiddenScrollbars[overflowX]){

        var contentWidth = element.clientWidth;
        if((qx.core.Environment.get("engine.name") == "opera") || qx.dom.Node.isBlockNode(element)){

          contentWidth = contentWidth - paddingLeft - paddingRight;
        };
        if(qx.core.Environment.get("engine.name") == "mshtml"){

          if(contentWidth === 0 && element.offsetHeight === 0){

            return element.offsetWidth;
          };
        };
        return contentWidth;
      } else {

        if(element.clientWidth >= element.scrollWidth){

          return Math.max(element.clientWidth, element.scrollWidth) - paddingLeft - paddingRight;
        } else {

          var width = element.scrollWidth - paddingLeft;
          if(qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("engine.version") >= 6){

            width -= paddingRight;
          };
          return width;
        };
      };
    },
    getContentHeight : function(element){

      var Style = qx.bom.element.Style;
      var overflowY = qx.bom.element.Style.get(element, "overflowY");
      var paddingTop = parseInt(Style.get(element, "paddingTop") || "0px", 10);
      var paddingBottom = parseInt(Style.get(element, "paddingBottom") || "0px", 10);
      if(this.__hiddenScrollbars[overflowY]){

        return element.clientHeight - paddingTop - paddingBottom;
      } else {

        if(element.clientHeight >= element.scrollHeight){

          return Math.max(element.clientHeight, element.scrollHeight) - paddingTop - paddingBottom;
        } else {

          var height = element.scrollHeight - paddingTop;
          if(qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("engine.version") == 6){

            height -= paddingBottom;
          };
          return height;
        };
      };
    },
    getContentSize : function(element){

      return {
        width : this.getContentWidth(element),
        height : this.getContentHeight(element)
      };
    }
  }
});

qx.Bootstrap.define("qx.bom.client.Scroll", {
  statics : {
    scrollBarOverlayed : function(){

      var scrollBarWidth = qx.bom.element.Scroll.getScrollbarWidth();
      var osx = qx.bom.client.OperatingSystem.getName() === "osx";
      var nativeScrollBars = qx.core.Environment.get("qx.nativeScrollBars");
      return scrollBarWidth === 0 && osx && nativeScrollBars;
    },
    getNativeScroll : function(){

      if(qx.core.Environment.get("os.name") == "ios" && parseInt(qx.core.Environment.get("browser.version"), 10) > 4){

        return true;
      };
      if(qx.core.Environment.get("browser.name") == "firefox"){

        return true;
      };
      if(qx.core.Environment.get("os.name") == "android"){

        var osVersion = qx.core.Environment.get("os.version");
        var splitVersion = osVersion.split(".");
        if(splitVersion[0] > 4 || (splitVersion.length > 1 && splitVersion[0] > 3 && splitVersion[1] > 3)){

          return true;
        };
      };
      if(qx.core.Environment.get("event.mspointer")){

        return true;
      };
      return false;
    }
  },
  defer : function(statics){

    qx.core.Environment.add("os.scrollBarOverlayed", statics.scrollBarOverlayed);
    qx.core.Environment.add("qx.mobile.nativescroll", statics.getNativeScroll);
  }
});

qx.Class.define("qx.bom.element.Scroll", {
  statics : {
    __scrollbarSize : null,
    getScrollbarWidth : function(){

      if(this.__scrollbarSize !== null){

        return this.__scrollbarSize;
      };
      var Style = qx.bom.element.Style;
      var getStyleSize = function(el, propertyName){

        return parseInt(Style.get(el, propertyName), 10) || 0;
      };
      var getBorderRight = function(el){

        return (Style.get(el, "borderRightStyle") == "none" ? 0 : getStyleSize(el, "borderRightWidth"));
      };
      var getBorderLeft = function(el){

        return (Style.get(el, "borderLeftStyle") == "none" ? 0 : getStyleSize(el, "borderLeftWidth"));
      };
      var getInsetRight = qx.core.Environment.select("engine.name", {
        "mshtml" : function(el){

          if(Style.get(el, "overflowY") == "hidden" || el.clientWidth == 0){

            return getBorderRight(el);
          };
          return Math.max(0, el.offsetWidth - el.clientLeft - el.clientWidth);
        },
        "default" : function(el){

          if(el.clientWidth == 0){

            var ov = Style.get(el, "overflow");
            var sbv = (ov == "scroll" || ov == "-moz-scrollbars-vertical" ? 16 : 0);
            return Math.max(0, getBorderRight(el) + sbv);
          };
          return Math.max(0, (el.offsetWidth - el.clientWidth - getBorderLeft(el)));
        }
      });
      var getScrollBarSizeRight = function(el){

        return getInsetRight(el) - getBorderRight(el);
      };
      var t = document.createElement("div");
      var s = t.style;
      s.height = s.width = "100px";
      s.overflow = "scroll";
      document.body.appendChild(t);
      var c = getScrollBarSizeRight(t);
      this.__scrollbarSize = c;
      document.body.removeChild(t);
      return this.__scrollbarSize;
    },
    intoViewX : function(element, stop, align){

      var parent = element.parentNode;
      var doc = qx.dom.Node.getDocument(element);
      var body = doc.body;
      var parentLocation,parentLeft,parentRight;
      var parentOuterWidth,parentClientWidth,parentScrollWidth;
      var parentLeftBorder,parentRightBorder,parentScrollBarWidth;
      var elementLocation,elementLeft,elementRight,elementWidth;
      var leftOffset,rightOffset,scrollDiff;
      var alignLeft = align === "left";
      var alignRight = align === "right";
      stop = stop ? stop.parentNode : doc;
      while(parent && parent != stop){

        if(parent.scrollWidth > parent.clientWidth && (parent === body || qx.bom.element.Style.get(parent, "overflowY") != "visible")){

          if(parent === body){

            parentLeft = parent.scrollLeft;
            parentRight = parentLeft + qx.bom.Viewport.getWidth();
            parentOuterWidth = qx.bom.Viewport.getWidth();
            parentClientWidth = parent.clientWidth;
            parentScrollWidth = parent.scrollWidth;
            parentLeftBorder = 0;
            parentRightBorder = 0;
            parentScrollBarWidth = 0;
          } else {

            parentLocation = qx.bom.element.Location.get(parent);
            parentLeft = parentLocation.left;
            parentRight = parentLocation.right;
            parentOuterWidth = parent.offsetWidth;
            parentClientWidth = parent.clientWidth;
            parentScrollWidth = parent.scrollWidth;
            parentLeftBorder = parseInt(qx.bom.element.Style.get(parent, "borderLeftWidth"), 10) || 0;
            parentRightBorder = parseInt(qx.bom.element.Style.get(parent, "borderRightWidth"), 10) || 0;
            parentScrollBarWidth = parentOuterWidth - parentClientWidth - parentLeftBorder - parentRightBorder;
          };
          elementLocation = qx.bom.element.Location.get(element);
          elementLeft = elementLocation.left;
          elementRight = elementLocation.right;
          elementWidth = element.offsetWidth;
          leftOffset = elementLeft - parentLeft - parentLeftBorder;
          rightOffset = elementRight - parentRight + parentRightBorder;
          scrollDiff = 0;
          if(alignLeft){

            scrollDiff = leftOffset;
          } else if(alignRight){

            scrollDiff = rightOffset + parentScrollBarWidth;
          } else if(leftOffset < 0 || elementWidth > parentClientWidth){

            scrollDiff = leftOffset;
          } else if(rightOffset > 0){

            scrollDiff = rightOffset + parentScrollBarWidth;
          };;;
          parent.scrollLeft += scrollDiff;
          qx.event.Registration.fireNonBubblingEvent(parent, "scroll");
        };
        if(parent === body){

          break;
        };
        parent = parent.parentNode;
      };
    },
    intoViewY : function(element, stop, align){

      var parent = element.parentNode;
      var doc = qx.dom.Node.getDocument(element);
      var body = doc.body;
      var parentLocation,parentTop,parentBottom;
      var parentOuterHeight,parentClientHeight,parentScrollHeight;
      var parentTopBorder,parentBottomBorder,parentScrollBarHeight;
      var elementLocation,elementTop,elementBottom,elementHeight;
      var topOffset,bottomOffset,scrollDiff;
      var alignTop = align === "top";
      var alignBottom = align === "bottom";
      stop = stop ? stop.parentNode : doc;
      while(parent && parent != stop){

        if(parent.scrollHeight > parent.clientHeight && (parent === body || qx.bom.element.Style.get(parent, "overflowY") != "visible")){

          if(parent === body){

            parentTop = parent.scrollTop;
            parentBottom = parentTop + qx.bom.Viewport.getHeight();
            parentOuterHeight = qx.bom.Viewport.getHeight();
            parentClientHeight = parent.clientHeight;
            parentScrollHeight = parent.scrollHeight;
            parentTopBorder = 0;
            parentBottomBorder = 0;
            parentScrollBarHeight = 0;
          } else {

            parentLocation = qx.bom.element.Location.get(parent);
            parentTop = parentLocation.top;
            parentBottom = parentLocation.bottom;
            parentOuterHeight = parent.offsetHeight;
            parentClientHeight = parent.clientHeight;
            parentScrollHeight = parent.scrollHeight;
            parentTopBorder = parseInt(qx.bom.element.Style.get(parent, "borderTopWidth"), 10) || 0;
            parentBottomBorder = parseInt(qx.bom.element.Style.get(parent, "borderBottomWidth"), 10) || 0;
            parentScrollBarHeight = parentOuterHeight - parentClientHeight - parentTopBorder - parentBottomBorder;
          };
          elementLocation = qx.bom.element.Location.get(element);
          elementTop = elementLocation.top;
          elementBottom = elementLocation.bottom;
          elementHeight = element.offsetHeight;
          topOffset = elementTop - parentTop - parentTopBorder;
          bottomOffset = elementBottom - parentBottom + parentBottomBorder;
          scrollDiff = 0;
          if(alignTop){

            scrollDiff = topOffset;
          } else if(alignBottom){

            scrollDiff = bottomOffset + parentScrollBarHeight;
          } else if(topOffset < 0 || elementHeight > parentClientHeight){

            scrollDiff = topOffset;
          } else if(bottomOffset > 0){

            scrollDiff = bottomOffset + parentScrollBarHeight;
          };;;
          parent.scrollTop += scrollDiff;
          qx.event.Registration.fireNonBubblingEvent(parent, "scroll");
        };
        if(parent === body){

          break;
        };
        parent = parent.parentNode;
      };
    },
    intoView : function(element, stop, alignX, alignY){

      this.intoViewX(element, stop, alignX);
      this.intoViewY(element, stop, alignY);
    }
  }
});

qx.Bootstrap.define("qx.bom.element.Location", {
  statics : {
    __style : function(elem, style){

      return qx.bom.element.Style.get(elem, style, qx.bom.element.Style.COMPUTED_MODE, false);
    },
    __num : function(elem, style){

      return parseInt(qx.bom.element.Style.get(elem, style, qx.bom.element.Style.COMPUTED_MODE, false), 10) || 0;
    },
    __computeScroll : function(elem){

      var left = 0,top = 0;
      var win = qx.dom.Node.getWindow(elem);
      left -= qx.bom.Viewport.getScrollLeft(win);
      top -= qx.bom.Viewport.getScrollTop(win);
      return {
        left : left,
        top : top
      };
    },
    __computeBody : qx.core.Environment.select("engine.name", {
      "mshtml" : function(elem){

        var doc = qx.dom.Node.getDocument(elem);
        var body = doc.body;
        var left = 0;
        var top = 0;
        left -= body.clientLeft + doc.documentElement.clientLeft;
        top -= body.clientTop + doc.documentElement.clientTop;
        if(!qx.core.Environment.get("browser.quirksmode")){

          left += this.__num(body, "borderLeftWidth");
          top += this.__num(body, "borderTopWidth");
        };
        return {
          left : left,
          top : top
        };
      },
      "webkit" : function(elem){

        var doc = qx.dom.Node.getDocument(elem);
        var body = doc.body;
        var left = body.offsetLeft;
        var top = body.offsetTop;
        if(parseFloat(qx.core.Environment.get("engine.version")) < 530.17){

          left += this.__num(body, "borderLeftWidth");
          top += this.__num(body, "borderTopWidth");
        };
        return {
          left : left,
          top : top
        };
      },
      "gecko" : function(elem){

        var body = qx.dom.Node.getDocument(elem).body;
        var left = body.offsetLeft;
        var top = body.offsetTop;
        if(parseFloat(qx.core.Environment.get("engine.version")) < 1.9){

          left += this.__num(body, "marginLeft");
          top += this.__num(body, "marginTop");
        };
        if(qx.bom.element.BoxSizing.get(body) !== "border-box"){

          left += this.__num(body, "borderLeftWidth");
          top += this.__num(body, "borderTopWidth");
        };
        return {
          left : left,
          top : top
        };
      },
      "default" : function(elem){

        var body = qx.dom.Node.getDocument(elem).body;
        var left = body.offsetLeft;
        var top = body.offsetTop;
        return {
          left : left,
          top : top
        };
      }
    }),
    __computeOffset : function(elem){

      var rect = elem.getBoundingClientRect();
      return {
        left : Math.round(rect.left),
        top : Math.round(rect.top)
      };
    },
    get : function(elem, mode){

      if(elem.tagName == "BODY"){

        var location = this.__getBodyLocation(elem);
        var left = location.left;
        var top = location.top;
      } else {

        var body = this.__computeBody(elem);
        var offset = this.__computeOffset(elem);
        var scroll = this.__computeScroll(elem);
        var left = offset.left + body.left - scroll.left;
        var top = offset.top + body.top - scroll.top;
      };
      var right = left + elem.offsetWidth;
      var bottom = top + elem.offsetHeight;
      if(mode){

        if(mode == "padding" || mode == "scroll"){

          var overX = qx.bom.element.Style.get(elem, "overflowX");
          if(overX == "scroll" || overX == "auto"){

            right += elem.scrollWidth - elem.offsetWidth + this.__num(elem, "borderLeftWidth") + this.__num(elem, "borderRightWidth");
          };
          var overY = qx.bom.element.Style.get(elem, "overflowY");
          if(overY == "scroll" || overY == "auto"){

            bottom += elem.scrollHeight - elem.offsetHeight + this.__num(elem, "borderTopWidth") + this.__num(elem, "borderBottomWidth");
          };
        };
        switch(mode){case "padding":
        left += this.__num(elem, "paddingLeft");
        top += this.__num(elem, "paddingTop");
        right -= this.__num(elem, "paddingRight");
        bottom -= this.__num(elem, "paddingBottom");case "scroll":
        left -= elem.scrollLeft;
        top -= elem.scrollTop;
        right -= elem.scrollLeft;
        bottom -= elem.scrollTop;case "border":
        left += this.__num(elem, "borderLeftWidth");
        top += this.__num(elem, "borderTopWidth");
        right -= this.__num(elem, "borderRightWidth");
        bottom -= this.__num(elem, "borderBottomWidth");
        break;case "margin":
        left -= this.__num(elem, "marginLeft");
        top -= this.__num(elem, "marginTop");
        right += this.__num(elem, "marginRight");
        bottom += this.__num(elem, "marginBottom");
        break;};
      };
      return {
        left : left,
        top : top,
        right : right,
        bottom : bottom
      };
    },
    __getBodyLocation : function(body){

      var top = body.offsetTop;
      var left = body.offsetLeft;
      if(qx.core.Environment.get("engine.name") !== "mshtml" || !((parseFloat(qx.core.Environment.get("engine.version")) < 8 || qx.core.Environment.get("browser.documentmode") < 8) && !qx.core.Environment.get("browser.quirksmode"))){

        top += this.__num(body, "marginTop");
        left += this.__num(body, "marginLeft");
      };
      if(qx.core.Environment.get("engine.name") === "gecko"){

        top += this.__num(body, "borderLeftWidth");
        left += this.__num(body, "borderTopWidth");
      };
      return {
        left : left,
        top : top
      };
    },
    getLeft : function(elem, mode){

      return this.get(elem, mode).left;
    },
    getTop : function(elem, mode){

      return this.get(elem, mode).top;
    },
    getRight : function(elem, mode){

      return this.get(elem, mode).right;
    },
    getBottom : function(elem, mode){

      return this.get(elem, mode).bottom;
    },
    getRelative : function(elem1, elem2, mode1, mode2){

      var loc1 = this.get(elem1, mode1);
      var loc2 = this.get(elem2, mode2);
      return {
        left : loc1.left - loc2.left,
        top : loc1.top - loc2.top,
        right : loc1.right - loc2.right,
        bottom : loc1.bottom - loc2.bottom
      };
    },
    getPosition : function(elem){

      return this.getRelative(elem, this.getOffsetParent(elem));
    },
    getOffsetParent : function(element){

      var offsetParent = element.offsetParent || document.body;
      var Style = qx.bom.element.Style;
      while(offsetParent && (!/^body|html$/i.test(offsetParent.tagName) && Style.get(offsetParent, "position") === "static")){

        offsetParent = offsetParent.offsetParent;
      };
      return offsetParent;
    }
  }
});

qx.Class.define("mobile.Application", {
  extend : qx.application.Mobile,
  members : {
    main : function(){

      this.base(arguments);
      if(qx.core.Environment.get("qx.debug")){

        qx.log.appender.Native;
        qx.log.appender.Console;
      };
      var login = new mobile.page.Login();
      var overview = new mobile.page.Overview();
      var basic = new mobile.page.Basic();
      var testhtml = new mobile.page.Testhtml();
      var manager = new qx.ui.mobile.page.Manager(false);
      manager.addMaster(overview);
      manager.addDetail([basic, login, testhtml]);
      if(qx.core.Environment.get("device.type") == "tablet" || qx.core.Environment.get("device.type") == "desktop"){

        this.getRouting().onGet("/.*", this._show, overview);
        this.getRouting().onGet("/", this._show, basic);
      };
      this.getRouting().onGet("/", this._show, overview);
      this.getRouting().onGet("/basic", this._show, basic);
      this.getRouting().onGet("/login", this._show, login);
      this.getRouting().onGet("/testhtml", this._show, testhtml);
      this.getRouting().init();
    },
    _show : function(data){

      this.show(data.customData);
    }
  }
});

qx.Bootstrap.define("qx.log.appender.Util", {
  statics : {
    toHtml : function(entry){

      var output = [];
      var item,msg,sub,list;
      output.push("<span class='offset'>", this.formatOffset(entry.offset, 6), "</span> ");
      if(entry.object){

        var obj = entry.win.qx.core.ObjectRegistry.fromHashCode(entry.object);
        if(obj){

          output.push("<span class='object' title='Object instance with hash code: " + obj.$$hash + "'>", obj.classname, "[", obj.$$hash, "]</span>: ");
        };
      } else if(entry.clazz){

        output.push("<span class='object'>" + entry.clazz.classname, "</span>: ");
      };
      var items = entry.items;
      for(var i = 0,il = items.length;i < il;i++){

        item = items[i];
        msg = item.text;
        if(msg instanceof Array){

          var list = [];
          for(var j = 0,jl = msg.length;j < jl;j++){

            sub = msg[j];
            if(typeof sub === "string"){

              list.push("<span>" + this.escapeHTML(sub) + "</span>");
            } else if(sub.key){

              list.push("<span class='type-key'>" + sub.key + "</span>:<span class='type-" + sub.type + "'>" + this.escapeHTML(sub.text) + "</span>");
            } else {

              list.push("<span class='type-" + sub.type + "'>" + this.escapeHTML(sub.text) + "</span>");
            };
          };
          output.push("<span class='type-" + item.type + "'>");
          if(item.type === "map"){

            output.push("{", list.join(", "), "}");
          } else {

            output.push("[", list.join(", "), "]");
          };
          output.push("</span>");
        } else {

          output.push("<span class='type-" + item.type + "'>" + this.escapeHTML(msg) + "</span> ");
        };
      };
      var wrapper = document.createElement("DIV");
      wrapper.innerHTML = output.join("");
      wrapper.className = "level-" + entry.level;
      return wrapper;
    },
    formatOffset : function(offset, length){

      var str = offset.toString();
      var diff = (length || 6) - str.length;
      var pad = "";
      for(var i = 0;i < diff;i++){

        pad += "0";
      };
      return pad + str;
    },
    escapeHTML : function(value){

      return String(value).replace(/[<>&"']/g, this.__escapeHTMLReplace);
    },
    __escapeHTMLReplace : function(ch){

      var map = {
        "<" : "&lt;",
        ">" : "&gt;",
        "&" : "&amp;",
        "'" : "&#39;",
        '"' : "&quot;"
      };
      return map[ch] || "?";
    },
    toText : function(entry){

      return this.toTextArray(entry).join(" ");
    },
    toTextArray : function(entry){

      var output = [];
      output.push(this.formatOffset(entry.offset, 6));
      if(entry.object){

        var obj = entry.win.qx.core.ObjectRegistry.fromHashCode(entry.object);
        if(obj){

          output.push(obj.classname + "[" + obj.$$hash + "]:");
        };
      } else if(entry.clazz){

        output.push(entry.clazz.classname + ":");
      };
      var items = entry.items;
      var item,msg;
      for(var i = 0,il = items.length;i < il;i++){

        item = items[i];
        msg = item.text;
        if(item.trace && item.trace.length > 0){

          if(typeof (this.FORMAT_STACK) == "function"){

            qx.log.Logger.deprecatedConstantWarning(qx.log.appender.Util, "FORMAT_STACK", "Use qx.dev.StackTrace.FORMAT_STACKTRACE instead");
            msg += "\n" + this.FORMAT_STACK(item.trace);
          } else {

            msg += "\n" + item.trace;
          };
        };
        if(msg instanceof Array){

          var list = [];
          for(var j = 0,jl = msg.length;j < jl;j++){

            list.push(msg[j].text);
          };
          if(item.type === "map"){

            output.push("{", list.join(", "), "}");
          } else {

            output.push("[", list.join(", "), "]");
          };
        } else {

          output.push(msg);
        };
      };
      return output;
    }
  }
});

qx.Bootstrap.define("qx.log.appender.Native", {
  statics : {
    process : function(entry){

      if(qx.core.Environment.get("html.console")){

        var level = console[entry.level] ? entry.level : "log";
        if(console[level]){

          var args = qx.log.appender.Util.toText(entry);
          console[level](args);
        };
      };
    }
  },
  defer : function(statics){

    qx.log.Logger.register(statics);
  }
});

qx.Class.define("qx.event.type.Roll", {
  extend : qx.event.type.Pointer,
  members : {
    stop : function(){

      this.stopPropagation();
      this.preventDefault();
    },
    _cloneNativeEvent : function(nativeEvent, clone){

      var clone = this.base(arguments, nativeEvent, clone);
      clone.delta = nativeEvent.delta;
      clone.momentum = nativeEvent.momentum;
      clone.timeoutId = nativeEvent.timeoutId;
      return clone;
    },
    getMomentum : function(){

      return this._native.momentum;
    },
    stopMomentum : function(){

      if(this._native.timeoutId){

        qx.event.Registration.getManager(this._originalTarget).getHandler(qx.event.handler.Gesture).stopMomentum(this._native.timeoutId);
      };
    },
    getDelta : function(){

      return this._native.delta;
    }
  }
});

qx.Class.define("qx.event.handler.Gesture", {
  extend : qx.event.handler.GestureCore,
  implement : qx.event.IEventHandler,
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      tap : 1,
      swipe : 1,
      longtap : 1,
      dbltap : 1,
      rotate : 1,
      pinch : 1,
      track : 1,
      trackstart : 1,
      trackend : 1,
      roll : 1
    },
    GESTURE_EVENTS : ["gesturebegin", "gesturefinish", "gesturemove", "gesturecancel"],
    TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE + qx.event.IEventHandler.TARGET_DOCUMENT,
    IGNORE_CAN_HANDLE : true,
    EVENT_CLASSES : {
      "tap" : qx.event.type.Tap,
      "longtap" : qx.event.type.Tap,
      "dbltap" : qx.event.type.Tap,
      "swipe" : qx.event.type.Swipe,
      "rotate" : qx.event.type.Rotate,
      "pinch" : qx.event.type.Pinch,
      "track" : qx.event.type.Track,
      "trackstart" : qx.event.type.Track,
      "trackend" : qx.event.type.Track,
      "roll" : qx.event.type.Roll
    }
  },
  construct : function(manager){

    this.__manager = manager;
    this.__window = manager.getWindow();
    this.__root = this.__window.document;
    qx.event.handler.GestureCore.apply(this, [this.__root]);
  },
  members : {
    __manager : null,
    __window : null,
    __root : null,
    __listener : null,
    __onDblClickWrapped : null,
    __fireRollWrapped : null,
    canHandleEvent : function(target, type){
    },
    registerEvent : function(target, type, capture){
    },
    unregisterEvent : function(target, type, capture){
    },
    _initObserver : function(){

      this.__listener = qx.lang.Function.listener(this.checkAndFireGesture, this);
      qx.event.handler.Gesture.GESTURE_EVENTS.forEach(function(type){

        qx.event.Registration.addListener(this.__root, type, this.__listener, this);
      }.bind(this));
      if(qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 9){

        this.__onDblClickWrapped = qx.lang.Function.listener(this._onDblClick, this);
        qx.bom.Event.addNativeListener(this.__root, "dblclick", this.__onDblClickWrapped);
      };
      var data = qx.bom.client.Event.getMouseWheel(this.__window);
      this.__fireRollWrapped = qx.lang.Function.listener(this._fireRoll, this);
      qx.bom.Event.addNativeListener(data.target, data.type, this.__fireRollWrapped, this);
    },
    checkAndFireGesture : function(pointerEvent, type, target){

      this.__callBase("checkAndFireGesture", [pointerEvent.getNativeEvent(), pointerEvent.getType(), pointerEvent.getTarget()]);
    },
    _stopObserver : function(){

      qx.event.handler.Gesture.GESTURE_EVENTS.forEach(function(type){

        qx.event.Registration.removeListener(this.__root, type, this.__listener);
      }.bind(this));
      if(qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 9){

        qx.bom.Event.removeNativeListener(this.__root, "dblclick", this.__onDblClickWrapped);
      };
      var data = qx.bom.client.Event.getMouseWheel(this.__window);
      qx.bom.Event.removeNativeListener(data.target, data.type, this.__fireRollWrapped);
    },
    _hasIntermediaryHandler : function(target){

      return false;
    },
    _fireEvent : function(domEvent, type, target){

      if(!target){

        target = qx.bom.Event.getTarget(domEvent);
      };
      if(!type){

        type = domEvent.type;
      };
      var eventTypeClass = qx.event.handler.Gesture.EVENT_CLASSES[type] || qx.event.type.Pointer;
      if(target && target.nodeType){

        qx.event.Registration.fireEvent(target, type, eventTypeClass, [domEvent, target, null, true, true]);
      };
      qx.event.Registration.fireEvent(this.__window, "useraction", qx.event.type.Data, [type]);
    },
    dispose : function(){

      this._stopObserver();
      this.__callBase("dispose");
      this.__manager = this.__window = this.__root = this.__onDblClickWrapped = null;
    },
    __callBase : function(method, args){

      qx.event.handler.GestureCore.prototype[method].apply(this, args || []);
    }
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
    qx.event.Registration.getManager(document).getHandler(statics);
  }
});

qx.Class.define("qx.event.handler.Keyboard", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  construct : function(manager){

    this.base(arguments);
    this.__manager = manager;
    this.__window = manager.getWindow();
    if((qx.core.Environment.get("engine.name") == "gecko")){

      this.__root = this.__window;
    } else {

      this.__root = this.__window.document.documentElement;
    };
    this.__lastUpDownType = {
    };
    this._initKeyObserver();
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      keyup : 1,
      keydown : 1,
      keypress : 1,
      keyinput : 1
    },
    TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE,
    IGNORE_CAN_HANDLE : true
  },
  members : {
    __onKeyUpDownWrapper : null,
    __manager : null,
    __window : null,
    __root : null,
    __lastUpDownType : null,
    __lastKeyCode : null,
    __inputListeners : null,
    __onKeyPressWrapper : null,
    canHandleEvent : function(target, type){
    },
    registerEvent : function(target, type, capture){
    },
    unregisterEvent : function(target, type, capture){
    },
    _fireInputEvent : function(domEvent, charCode){

      var target = this.__getEventTarget();
      if(target && target.offsetWidth != 0){

        var event = qx.event.Registration.createEvent("keyinput", qx.event.type.KeyInput, [domEvent, target, charCode]);
        this.__manager.dispatchEvent(target, event);
      };
      if(this.__window){

        qx.event.Registration.fireEvent(this.__window, "useraction", qx.event.type.Data, ["keyinput"]);
      };
    },
    _fireSequenceEvent : function(domEvent, type, keyIdentifier){

      var target = this.__getEventTarget();
      var keyCode = domEvent.keyCode;
      var event = qx.event.Registration.createEvent(type, qx.event.type.KeySequence, [domEvent, target, keyIdentifier]);
      this.__manager.dispatchEvent(target, event);
      if(qx.core.Environment.get("engine.name") == "mshtml" || qx.core.Environment.get("engine.name") == "webkit"){

        if(type == "keydown" && event.getDefaultPrevented()){

          if(!qx.event.util.Keyboard.isNonPrintableKeyCode(keyCode) && !this._emulateKeyPress[keyCode]){

            this._fireSequenceEvent(domEvent, "keypress", keyIdentifier);
          };
        };
      };
      if(this.__window){

        qx.event.Registration.fireEvent(this.__window, "useraction", qx.event.type.Data, [type]);
      };
    },
    __getEventTarget : function(){

      var focusHandler = this.__manager.getHandler(qx.event.handler.Focus);
      var target = focusHandler.getActive();
      if(!target || target.offsetWidth == 0){

        target = focusHandler.getFocus();
      };
      if(!target || target.offsetWidth == 0){

        target = this.__manager.getWindow().document.body;
      };
      return target;
    },
    _initKeyObserver : function(){

      this.__onKeyUpDownWrapper = qx.lang.Function.listener(this.__onKeyUpDown, this);
      this.__onKeyPressWrapper = qx.lang.Function.listener(this.__onKeyPress, this);
      var Event = qx.bom.Event;
      Event.addNativeListener(this.__root, "keyup", this.__onKeyUpDownWrapper);
      Event.addNativeListener(this.__root, "keydown", this.__onKeyUpDownWrapper);
      Event.addNativeListener(this.__root, "keypress", this.__onKeyPressWrapper);
    },
    _stopKeyObserver : function(){

      var Event = qx.bom.Event;
      Event.removeNativeListener(this.__root, "keyup", this.__onKeyUpDownWrapper);
      Event.removeNativeListener(this.__root, "keydown", this.__onKeyUpDownWrapper);
      Event.removeNativeListener(this.__root, "keypress", this.__onKeyPressWrapper);
      for(var key in (this.__inputListeners || {
      })){

        var listener = this.__inputListeners[key];
        Event.removeNativeListener(listener.target, "keypress", listener.callback);
      };
      delete (this.__inputListeners);
    },
    __onKeyUpDown : qx.event.GlobalError.observeMethod(qx.core.Environment.select("engine.name", {
      "mshtml" : function(domEvent){

        domEvent = window.event || domEvent;
        var keyCode = domEvent.keyCode;
        var charCode = 0;
        var type = domEvent.type;
        if(!(this.__lastUpDownType[keyCode] == "keydown" && type == "keydown")){

          this._idealKeyHandler(keyCode, charCode, type, domEvent);
        };
        if(type == "keydown"){

          if(qx.event.util.Keyboard.isNonPrintableKeyCode(keyCode) || this._emulateKeyPress[keyCode]){

            this._idealKeyHandler(keyCode, charCode, "keypress", domEvent);
          };
        };
        this.__lastUpDownType[keyCode] = type;
      },
      "gecko" : function(domEvent){

        var charCode = 0;
        var keyCode = domEvent.keyCode;
        var type = domEvent.type;
        var kbUtil = qx.event.util.Keyboard;
        if(qx.core.Environment.get("os.name") == "win"){

          var keyIdentifier = keyCode ? kbUtil.keyCodeToIdentifier(keyCode) : kbUtil.charCodeToIdentifier(charCode);
          if(!(this.__lastUpDownType[keyIdentifier] == "keydown" && type == "keydown")){

            this._idealKeyHandler(keyCode, charCode, type, domEvent);
          };
          this.__lastUpDownType[keyIdentifier] = type;
        } else {

          this._idealKeyHandler(keyCode, charCode, type, domEvent);
        };
        this.__firefoxInputFix(domEvent.target, type, keyCode);
      },
      "webkit" : function(domEvent){

        var keyCode = 0;
        var charCode = 0;
        var type = domEvent.type;
        keyCode = domEvent.keyCode;
        this._idealKeyHandler(keyCode, charCode, type, domEvent);
        if(type == "keydown"){

          if(qx.event.util.Keyboard.isNonPrintableKeyCode(keyCode) || this._emulateKeyPress[keyCode]){

            this._idealKeyHandler(keyCode, charCode, "keypress", domEvent);
          };
        };
        this.__lastUpDownType[keyCode] = type;
      },
      "opera" : function(domEvent){

        this.__lastKeyCode = domEvent.keyCode;
        this._idealKeyHandler(domEvent.keyCode, 0, domEvent.type, domEvent);
      }
    })),
    __firefoxInputFix : qx.core.Environment.select("engine.name", {
      "gecko" : function(target, type, keyCode){

        if(type === "keydown" && (keyCode == 33 || keyCode == 34 || keyCode == 38 || keyCode == 40) && target.type == "text" && target.tagName.toLowerCase() === "input" && target.getAttribute("autoComplete") !== "off"){

          if(!this.__inputListeners){

            this.__inputListeners = {
            };
          };
          var hash = qx.core.ObjectRegistry.toHashCode(target);
          if(this.__inputListeners[hash]){

            return;
          };
          var self = this;
          this.__inputListeners[hash] = {
            target : target,
            callback : function(domEvent){

              qx.bom.Event.stopPropagation(domEvent);
              self.__onKeyPress(domEvent);
            }
          };
          var listener = qx.event.GlobalError.observeMethod(this.__inputListeners[hash].callback);
          qx.bom.Event.addNativeListener(target, "keypress", listener);
        };
      },
      "default" : null
    }),
    __onKeyPress : qx.event.GlobalError.observeMethod(qx.core.Environment.select("engine.name", {
      "mshtml" : function(domEvent){

        domEvent = window.event || domEvent;
        if(this._charCode2KeyCode[domEvent.keyCode]){

          this._idealKeyHandler(this._charCode2KeyCode[domEvent.keyCode], 0, domEvent.type, domEvent);
        } else {

          this._idealKeyHandler(0, domEvent.keyCode, domEvent.type, domEvent);
        };
      },
      "gecko" : function(domEvent){

        var charCode = domEvent.charCode;
        var type = domEvent.type;
        this._idealKeyHandler(domEvent.keyCode, charCode, type, domEvent);
      },
      "webkit" : function(domEvent){

        if(this._charCode2KeyCode[domEvent.keyCode]){

          this._idealKeyHandler(this._charCode2KeyCode[domEvent.keyCode], 0, domEvent.type, domEvent);
        } else {

          this._idealKeyHandler(0, domEvent.keyCode, domEvent.type, domEvent);
        };
      },
      "opera" : function(domEvent){

        var keyCode = domEvent.keyCode;
        var type = domEvent.type;
        if(keyCode != this.__lastKeyCode){

          this._idealKeyHandler(0, this.__lastKeyCode, type, domEvent);
        } else {

          if(qx.event.util.Keyboard.keyCodeToIdentifierMap[domEvent.keyCode]){

            this._idealKeyHandler(domEvent.keyCode, 0, domEvent.type, domEvent);
          } else {

            this._idealKeyHandler(0, domEvent.keyCode, domEvent.type, domEvent);
          };
        };
      }
    })),
    _idealKeyHandler : function(keyCode, charCode, eventType, domEvent){

      var keyIdentifier;
      if(keyCode || (!keyCode && !charCode)){

        keyIdentifier = qx.event.util.Keyboard.keyCodeToIdentifier(keyCode);
        this._fireSequenceEvent(domEvent, eventType, keyIdentifier);
      } else {

        keyIdentifier = qx.event.util.Keyboard.charCodeToIdentifier(charCode);
        this._fireSequenceEvent(domEvent, "keypress", keyIdentifier);
        this._fireInputEvent(domEvent, charCode);
      };
    },
    _emulateKeyPress : qx.core.Environment.select("engine.name", {
      "mshtml" : {
        '8' : true,
        '9' : true
      },
      "webkit" : {
        '8' : true,
        '9' : true,
        '27' : true
      },
      "default" : {
      }
    }),
    _identifierToKeyCode : function(keyIdentifier){

      return qx.event.util.Keyboard.identifierToKeyCodeMap[keyIdentifier] || keyIdentifier.charCodeAt(0);
    }
  },
  destruct : function(){

    this._stopKeyObserver();
    this.__lastKeyCode = this.__manager = this.__window = this.__root = this.__lastUpDownType = null;
  },
  defer : function(statics, members){

    qx.event.Registration.addHandler(statics);
    if((qx.core.Environment.get("engine.name") == "mshtml") || qx.core.Environment.get("engine.name") == "webkit"){

      members._charCode2KeyCode = {
        '13' : 13,
        '27' : 27
      };
    };
  }
});

qx.Class.define("qx.event.type.KeyInput", {
  extend : qx.event.type.Dom,
  members : {
    init : function(domEvent, target, charCode){

      this.base(arguments, domEvent, target, null, true, true);
      this._charCode = charCode;
      return this;
    },
    clone : function(embryo){

      var clone = this.base(arguments, embryo);
      clone._charCode = this._charCode;
      return clone;
    },
    getCharCode : function(){

      return this._charCode;
    },
    getChar : function(){

      return String.fromCharCode(this._charCode);
    }
  }
});

qx.Class.define("qx.event.type.KeySequence", {
  extend : qx.event.type.Dom,
  members : {
    init : function(domEvent, target, identifier){

      this.base(arguments, domEvent, target, null, true, true);
      this._keyCode = domEvent.keyCode;
      this._identifier = identifier;
      return this;
    },
    clone : function(embryo){

      var clone = this.base(arguments, embryo);
      clone._keyCode = this._keyCode;
      clone._identifier = this._identifier;
      return clone;
    },
    getKeyIdentifier : function(){

      return this._identifier;
    },
    getKeyCode : function(){

      return this._keyCode;
    },
    isPrintable : function(){

      return qx.event.util.Keyboard.isPrintableKeyIdentifier(this._identifier);
    }
  }
});

qx.Bootstrap.define("qx.event.util.Keyboard", {
  statics : {
    specialCharCodeMap : {
      '8' : "Backspace",
      '9' : "Tab",
      '13' : "Enter",
      '27' : "Escape",
      '32' : "Space"
    },
    numpadToCharCode : {
      '96' : "0".charCodeAt(0),
      '97' : "1".charCodeAt(0),
      '98' : "2".charCodeAt(0),
      '99' : "3".charCodeAt(0),
      '100' : "4".charCodeAt(0),
      '101' : "5".charCodeAt(0),
      '102' : "6".charCodeAt(0),
      '103' : "7".charCodeAt(0),
      '104' : "8".charCodeAt(0),
      '105' : "9".charCodeAt(0),
      '106' : "*".charCodeAt(0),
      '107' : "+".charCodeAt(0),
      '109' : "-".charCodeAt(0),
      '110' : ",".charCodeAt(0),
      '111' : "/".charCodeAt(0)
    },
    keyCodeToIdentifierMap : {
      '16' : "Shift",
      '17' : "Control",
      '18' : "Alt",
      '20' : "CapsLock",
      '224' : "Meta",
      '37' : "Left",
      '38' : "Up",
      '39' : "Right",
      '40' : "Down",
      '33' : "PageUp",
      '34' : "PageDown",
      '35' : "End",
      '36' : "Home",
      '45' : "Insert",
      '46' : "Delete",
      '112' : "F1",
      '113' : "F2",
      '114' : "F3",
      '115' : "F4",
      '116' : "F5",
      '117' : "F6",
      '118' : "F7",
      '119' : "F8",
      '120' : "F9",
      '121' : "F10",
      '122' : "F11",
      '123' : "F12",
      '144' : "NumLock",
      '44' : "PrintScreen",
      '145' : "Scroll",
      '19' : "Pause",
      '91' : qx.core.Environment.get("os.name") == "osx" ? "cmd" : "Win",
      '92' : "Win",
      '93' : qx.core.Environment.get("os.name") == "osx" ? "cmd" : "Apps"
    },
    charCodeA : "A".charCodeAt(0),
    charCodeZ : "Z".charCodeAt(0),
    charCode0 : "0".charCodeAt(0),
    charCode9 : "9".charCodeAt(0),
    keyCodeToIdentifier : function(keyCode){

      if(this.isIdentifiableKeyCode(keyCode)){

        var numPadKeyCode = this.numpadToCharCode[keyCode];
        if(numPadKeyCode){

          return String.fromCharCode(numPadKeyCode);
        };
        return (this.keyCodeToIdentifierMap[keyCode] || this.specialCharCodeMap[keyCode] || String.fromCharCode(keyCode));
      } else {

        return "Unidentified";
      };
    },
    charCodeToIdentifier : function(charCode){

      return this.specialCharCodeMap[charCode] || String.fromCharCode(charCode).toUpperCase();
    },
    isIdentifiableKeyCode : function(keyCode){

      if(keyCode >= this.charCodeA && keyCode <= this.charCodeZ){

        return true;
      };
      if(keyCode >= this.charCode0 && keyCode <= this.charCode9){

        return true;
      };
      if(this.specialCharCodeMap[keyCode]){

        return true;
      };
      if(this.numpadToCharCode[keyCode]){

        return true;
      };
      if(this.isNonPrintableKeyCode(keyCode)){

        return true;
      };
      return false;
    },
    isNonPrintableKeyCode : function(keyCode){

      return this.keyCodeToIdentifierMap[keyCode] ? true : false;
    },
    isValidKeyIdentifier : function(keyIdentifier){

      if(this.identifierToKeyCodeMap[keyIdentifier]){

        return true;
      };
      if(keyIdentifier.length != 1){

        return false;
      };
      if(keyIdentifier >= "0" && keyIdentifier <= "9"){

        return true;
      };
      if(keyIdentifier >= "A" && keyIdentifier <= "Z"){

        return true;
      };
      switch(keyIdentifier){case "+":case "-":case "*":case "/":
      return true;default:
      return false;};
    },
    isPrintableKeyIdentifier : function(keyIdentifier){

      if(keyIdentifier === "Space"){

        return true;
      } else {

        return this.identifierToKeyCodeMap[keyIdentifier] ? false : true;
      };
    }
  },
  defer : function(statics, members){

    if(!statics.identifierToKeyCodeMap){

      statics.identifierToKeyCodeMap = {
      };
      for(var key in statics.keyCodeToIdentifierMap){

        statics.identifierToKeyCodeMap[statics.keyCodeToIdentifierMap[key]] = parseInt(key, 10);
      };
      for(var key in statics.specialCharCodeMap){

        statics.identifierToKeyCodeMap[statics.specialCharCodeMap[key]] = parseInt(key, 10);
      };
    };
  }
});

qx.Class.define("qx.event.handler.Focus", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  construct : function(manager){

    this.base(arguments);
    this._manager = manager;
    this._window = manager.getWindow();
    this._document = this._window.document;
    this._root = this._document.documentElement;
    this._body = this._document.body;
    if((qx.core.Environment.get("os.name") == "ios" && parseFloat(qx.core.Environment.get("os.version")) > 6) && (!qx.application.Inline || !qx.core.Init.getApplication() instanceof qx.application.Inline)){

      this.__needsScrollFix = true;
    };
    this._initObserver();
  },
  properties : {
    active : {
      apply : "_applyActive",
      nullable : true
    },
    focus : {
      apply : "_applyFocus",
      nullable : true
    }
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      focus : 1,
      blur : 1,
      focusin : 1,
      focusout : 1,
      activate : 1,
      deactivate : 1
    },
    IGNORE_CAN_HANDLE : true,
    FOCUSABLE_ELEMENTS : qx.core.Environment.select("engine.name", {
      "mshtml|gecko" : {
        a : 1,
        body : 1,
        button : 1,
        frame : 1,
        iframe : 1,
        img : 1,
        input : 1,
        object : 1,
        select : 1,
        textarea : 1
      },
      "opera|webkit" : {
        button : 1,
        input : 1,
        select : 1,
        textarea : 1
      }
    })
  },
  members : {
    __onNativeMouseDownWrapper : null,
    __onNativeMouseUpWrapper : null,
    __onNativeFocusWrapper : null,
    __onNativeBlurWrapper : null,
    __onNativeDragGestureWrapper : null,
    __onNativeSelectStartWrapper : null,
    __onNativeFocusInWrapper : null,
    __onNativeFocusOutWrapper : null,
    __previousFocus : null,
    __previousActive : null,
    __down : "",
    __up : "",
    __needsScrollFix : false,
    __relatedTarget : null,
    canHandleEvent : function(target, type){
    },
    registerEvent : function(target, type, capture){
    },
    unregisterEvent : function(target, type, capture){
    },
    focus : function(element){

      if((qx.core.Environment.get("engine.name") == "mshtml")){

        window.setTimeout(function(){

          try{

            element.focus();
            var selection = qx.bom.Selection.get(element);
            if(selection.length == 0){

              var textRange = element.createTextRange();
              textRange.moveStart('character', element.value.length);
              textRange.collapse();
              textRange.select();
            };
          } catch(ex) {
          };
        }, 0);
      } else {

        try{

          element.focus();
        } catch(ex) {
        };
      };
      this.setFocus(element);
      this.setActive(element);
    },
    activate : function(element){

      this.setActive(element);
    },
    blur : function(element){

      try{

        element.blur();
      } catch(ex) {
      };
      if(this.getActive() === element){

        this.resetActive();
      };
      if(this.getFocus() === element){

        this.resetFocus();
      };
    },
    deactivate : function(element){

      if(this.getActive() === element){

        this.resetActive();
      };
    },
    tryActivate : function(element){

      var active = this.__findActivatableElement(element);
      if(active){

        this.setActive(active);
      };
    },
    __fireEvent : function(target, related, type, bubbles){

      var Registration = qx.event.Registration;
      var evt = Registration.createEvent(type, qx.event.type.Focus, [target, related, bubbles]);
      Registration.dispatchEvent(target, evt);
    },
    _windowFocused : true,
    __doWindowBlur : function(){

      if(this._windowFocused){

        this._windowFocused = false;
        this.__fireEvent(this._window, null, "blur", false);
      };
    },
    __doWindowFocus : function(){

      if(!this._windowFocused){

        this._windowFocused = true;
        this.__fireEvent(this._window, null, "focus", false);
      };
    },
    _initObserver : qx.core.Environment.select("engine.name", {
      "gecko" : function(){

        this.__onNativeMouseDownWrapper = qx.lang.Function.listener(this.__onNativeMouseDown, this);
        this.__onNativeMouseUpWrapper = qx.lang.Function.listener(this.__onNativeMouseUp, this);
        this.__onNativeFocusWrapper = qx.lang.Function.listener(this.__onNativeFocus, this);
        this.__onNativeBlurWrapper = qx.lang.Function.listener(this.__onNativeBlur, this);
        this.__onNativeDragGestureWrapper = qx.lang.Function.listener(this.__onNativeDragGesture, this);
        qx.bom.Event.addNativeListener(this._document, "mousedown", this.__onNativeMouseDownWrapper, true);
        qx.bom.Event.addNativeListener(this._document, "mouseup", this.__onNativeMouseUpWrapper, true);
        qx.bom.Event.addNativeListener(this._window, "focus", this.__onNativeFocusWrapper, true);
        qx.bom.Event.addNativeListener(this._window, "blur", this.__onNativeBlurWrapper, true);
        qx.bom.Event.addNativeListener(this._window, "draggesture", this.__onNativeDragGestureWrapper, true);
      },
      "mshtml" : function(){

        this.__onNativeMouseDownWrapper = qx.lang.Function.listener(this.__onNativeMouseDown, this);
        this.__onNativeMouseUpWrapper = qx.lang.Function.listener(this.__onNativeMouseUp, this);
        this.__onNativeFocusInWrapper = qx.lang.Function.listener(this.__onNativeFocusIn, this);
        this.__onNativeFocusOutWrapper = qx.lang.Function.listener(this.__onNativeFocusOut, this);
        this.__onNativeSelectStartWrapper = qx.lang.Function.listener(this.__onNativeSelectStart, this);
        qx.bom.Event.addNativeListener(this._document, "mousedown", this.__onNativeMouseDownWrapper);
        qx.bom.Event.addNativeListener(this._document, "mouseup", this.__onNativeMouseUpWrapper);
        qx.bom.Event.addNativeListener(this._document, "focusin", this.__onNativeFocusInWrapper);
        qx.bom.Event.addNativeListener(this._document, "focusout", this.__onNativeFocusOutWrapper);
        qx.bom.Event.addNativeListener(this._document, "selectstart", this.__onNativeSelectStartWrapper);
      },
      "webkit" : function(){

        this.__onNativeMouseDownWrapper = qx.lang.Function.listener(this.__onNativeMouseDown, this);
        this.__onNativeMouseUpWrapper = qx.lang.Function.listener(this.__onNativeMouseUp, this);
        this.__onNativeFocusOutWrapper = qx.lang.Function.listener(this.__onNativeFocusOut, this);
        this.__onNativeFocusWrapper = qx.lang.Function.listener(this.__onNativeFocus, this);
        this.__onNativeBlurWrapper = qx.lang.Function.listener(this.__onNativeBlur, this);
        this.__onNativeSelectStartWrapper = qx.lang.Function.listener(this.__onNativeSelectStart, this);
        qx.bom.Event.addNativeListener(this._document, "mousedown", this.__onNativeMouseDownWrapper, true);
        qx.bom.Event.addNativeListener(this._document, "mouseup", this.__onNativeMouseUpWrapper, true);
        qx.bom.Event.addNativeListener(this._document, "selectstart", this.__onNativeSelectStartWrapper, false);
        qx.bom.Event.addNativeListener(this._window, "DOMFocusOut", this.__onNativeFocusOutWrapper, true);
        qx.bom.Event.addNativeListener(this._window, "focus", this.__onNativeFocusWrapper, true);
        qx.bom.Event.addNativeListener(this._window, "blur", this.__onNativeBlurWrapper, true);
      },
      "opera" : function(){

        this.__onNativeMouseDownWrapper = qx.lang.Function.listener(this.__onNativeMouseDown, this);
        this.__onNativeMouseUpWrapper = qx.lang.Function.listener(this.__onNativeMouseUp, this);
        this.__onNativeFocusInWrapper = qx.lang.Function.listener(this.__onNativeFocusIn, this);
        this.__onNativeFocusOutWrapper = qx.lang.Function.listener(this.__onNativeFocusOut, this);
        qx.bom.Event.addNativeListener(this._document, "mousedown", this.__onNativeMouseDownWrapper, true);
        qx.bom.Event.addNativeListener(this._document, "mouseup", this.__onNativeMouseUpWrapper, true);
        qx.bom.Event.addNativeListener(this._window, "DOMFocusIn", this.__onNativeFocusInWrapper, true);
        qx.bom.Event.addNativeListener(this._window, "DOMFocusOut", this.__onNativeFocusOutWrapper, true);
      }
    }),
    _stopObserver : qx.core.Environment.select("engine.name", {
      "gecko" : function(){

        qx.bom.Event.removeNativeListener(this._document, "mousedown", this.__onNativeMouseDownWrapper, true);
        qx.bom.Event.removeNativeListener(this._document, "mouseup", this.__onNativeMouseUpWrapper, true);
        qx.bom.Event.removeNativeListener(this._window, "focus", this.__onNativeFocusWrapper, true);
        qx.bom.Event.removeNativeListener(this._window, "blur", this.__onNativeBlurWrapper, true);
        qx.bom.Event.removeNativeListener(this._window, "draggesture", this.__onNativeDragGestureWrapper, true);
      },
      "mshtml" : function(){

        qx.bom.Event.removeNativeListener(this._document, "mousedown", this.__onNativeMouseDownWrapper);
        qx.bom.Event.removeNativeListener(this._document, "mouseup", this.__onNativeMouseUpWrapper);
        qx.bom.Event.removeNativeListener(this._document, "focusin", this.__onNativeFocusInWrapper);
        qx.bom.Event.removeNativeListener(this._document, "focusout", this.__onNativeFocusOutWrapper);
        qx.bom.Event.removeNativeListener(this._document, "selectstart", this.__onNativeSelectStartWrapper);
      },
      "webkit" : function(){

        qx.bom.Event.removeNativeListener(this._document, "mousedown", this.__onNativeMouseDownWrapper, true);
        qx.bom.Event.removeNativeListener(this._document, "mouseup", this.__onNativeMouseUpWrapper, true);
        qx.bom.Event.removeNativeListener(this._document, "selectstart", this.__onNativeSelectStartWrapper, false);
        qx.bom.Event.removeNativeListener(this._window, "DOMFocusOut", this.__onNativeFocusOutWrapper, true);
        qx.bom.Event.removeNativeListener(this._window, "focus", this.__onNativeFocusWrapper, true);
        qx.bom.Event.removeNativeListener(this._window, "blur", this.__onNativeBlurWrapper, true);
      },
      "opera" : function(){

        qx.bom.Event.removeNativeListener(this._document, "mousedown", this.__onNativeMouseDownWrapper, true);
        qx.bom.Event.removeNativeListener(this._document, "mouseup", this.__onNativeMouseUpWrapper, true);
        qx.bom.Event.removeNativeListener(this._window, "DOMFocusIn", this.__onNativeFocusInWrapper, true);
        qx.bom.Event.removeNativeListener(this._window, "DOMFocusOut", this.__onNativeFocusOutWrapper, true);
      }
    }),
    __onNativeDragGesture : qx.event.GlobalError.observeMethod(qx.core.Environment.select("engine.name", {
      "gecko" : function(domEvent){

        var target = qx.bom.Event.getTarget(domEvent);
        if(!this.__isSelectable(target)){

          qx.bom.Event.preventDefault(domEvent);
        };
      },
      "default" : null
    })),
    __onNativeFocusIn : qx.event.GlobalError.observeMethod(qx.core.Environment.select("engine.name", {
      "mshtml" : function(domEvent){

        this.__doWindowFocus();
        var target = qx.bom.Event.getTarget(domEvent);
        var focusTarget = this.__findFocusableElement(target);
        if(focusTarget){

          this.setFocus(focusTarget);
        };
        this.tryActivate(target);
      },
      "opera" : function(domEvent){

        var target = qx.bom.Event.getTarget(domEvent);
        if(target == this._document || target == this._window){

          this.__doWindowFocus();
          if(this.__previousFocus){

            this.setFocus(this.__previousFocus);
            delete this.__previousFocus;
          };
          if(this.__previousActive){

            this.setActive(this.__previousActive);
            delete this.__previousActive;
          };
        } else {

          this.setFocus(target);
          this.tryActivate(target);
          if(!this.__isSelectable(target)){

            target.selectionStart = 0;
            target.selectionEnd = 0;
          };
        };
      },
      "default" : null
    })),
    __onNativeFocusOut : qx.event.GlobalError.observeMethod(qx.core.Environment.select("engine.name", {
      "mshtml" : function(domEvent){

        var relatedTarget = qx.bom.Event.getRelatedTarget(domEvent);
        if(relatedTarget == null){

          this.__doWindowBlur();
          this.resetFocus();
          this.resetActive();
        };
      },
      "webkit" : function(domEvent){

        var target = qx.bom.Event.getTarget(domEvent);
        if(target === this.getFocus()){

          this.resetFocus();
        };
        if(target === this.getActive()){

          this.resetActive();
        };
      },
      "opera" : function(domEvent){

        var target = qx.bom.Event.getTarget(domEvent);
        if(target == this._document){

          this.__doWindowBlur();
          this.__previousFocus = this.getFocus();
          this.__previousActive = this.getActive();
          this.resetFocus();
          this.resetActive();
        } else {

          if(target === this.getFocus()){

            this.resetFocus();
          };
          if(target === this.getActive()){

            this.resetActive();
          };
        };
      },
      "default" : null
    })),
    __onNativeBlur : qx.event.GlobalError.observeMethod(qx.core.Environment.select("engine.name", {
      "gecko" : function(domEvent){

        var target = qx.bom.Event.getTarget(domEvent);
        if(target === this._window || target === this._document){

          this.__doWindowBlur();
          this.resetActive();
          this.resetFocus();
        };
      },
      "webkit" : function(domEvent){

        var target = qx.bom.Event.getTarget(domEvent);
        if(target === this._window || target === this._document){

          this.__doWindowBlur();
          this.__previousFocus = this.getFocus();
          this.__previousActive = this.getActive();
          this.resetActive();
          this.resetFocus();
        };
      },
      "default" : null
    })),
    __onNativeFocus : qx.event.GlobalError.observeMethod(qx.core.Environment.select("engine.name", {
      "gecko" : function(domEvent){

        var target = qx.bom.Event.getTarget(domEvent);
        if(target === this._window || target === this._document){

          this.__doWindowFocus();
          target = this._body;
        };
        this.setFocus(target);
        this.tryActivate(target);
      },
      "webkit" : function(domEvent){

        var target = qx.bom.Event.getTarget(domEvent);
        if(target === this._window || target === this._document){

          this.__doWindowFocus();
          if(this.__previousFocus){

            this.setFocus(this.__previousFocus);
            delete this.__previousFocus;
          };
          if(this.__previousActive){

            this.setActive(this.__previousActive);
            delete this.__previousActive;
          };
        } else {

          this.__relatedTarget = domEvent.relatedTarget;
          this.setFocus(target);
          this.__relatedTarget = null;
          this.tryActivate(target);
        };
      },
      "default" : null
    })),
    __onNativeMouseDown : qx.event.GlobalError.observeMethod(qx.core.Environment.select("engine.name", {
      "mshtml" : function(domEvent){

        var target = qx.bom.Event.getTarget(domEvent);
        var focusTarget = this.__findFocusableElement(target);
        if(focusTarget){

          if(!this.__isSelectable(target)){

            target.unselectable = "on";
            try{

              document.selection.empty();
            } catch(ex) {
            };
            try{

              focusTarget.focus();
            } catch(ex) {
            };
          };
        } else {

          qx.bom.Event.preventDefault(domEvent);
          if(!this.__isSelectable(target)){

            target.unselectable = "on";
          };
        };
      },
      "webkit|gecko" : function(domEvent){

        var target = qx.bom.Event.getTarget(domEvent);
        var focusTarget = this.__findFocusableElement(target);
        if(focusTarget){

          this.setFocus(focusTarget);
        } else {

          qx.bom.Event.preventDefault(domEvent);
        };
      },
      "opera" : function(domEvent){

        var target = qx.bom.Event.getTarget(domEvent);
        var focusTarget = this.__findFocusableElement(target);
        if(!this.__isSelectable(target)){

          qx.bom.Event.preventDefault(domEvent);
          if(focusTarget){

            var current = this.getFocus();
            if(current && current.selectionEnd){

              current.selectionStart = 0;
              current.selectionEnd = 0;
              current.blur();
            };
            if(focusTarget){

              this.setFocus(focusTarget);
            };
          };
        } else if(focusTarget){

          this.setFocus(focusTarget);
        };
      },
      "default" : null
    })),
    __onNativeMouseUp : qx.event.GlobalError.observeMethod(qx.core.Environment.select("engine.name", {
      "mshtml" : function(domEvent){

        var target = qx.bom.Event.getTarget(domEvent);
        if(target.unselectable){

          target.unselectable = "off";
        };
        this.tryActivate(this.__fixFocus(target));
      },
      "gecko" : function(domEvent){

        var target = qx.bom.Event.getTarget(domEvent);
        while(target && target.offsetWidth === undefined){

          target = target.parentNode;
        };
        if(target){

          this.tryActivate(target);
        };
      },
      "webkit|opera" : function(domEvent){

        var target = qx.bom.Event.getTarget(domEvent);
        this.tryActivate(this.__fixFocus(target));
      },
      "default" : null
    })),
    __fixFocus : qx.event.GlobalError.observeMethod(qx.core.Environment.select("engine.name", {
      "mshtml|webkit" : function(target){

        var focusedElement = this.getFocus();
        if(focusedElement && target != focusedElement && (focusedElement.nodeName.toLowerCase() === "input" || focusedElement.nodeName.toLowerCase() === "textarea")){

          target = focusedElement;
        };
        return target;
      },
      "default" : function(target){

        return target;
      }
    })),
    __onNativeSelectStart : qx.event.GlobalError.observeMethod(qx.core.Environment.select("engine.name", {
      "mshtml|webkit" : function(domEvent){

        var target = qx.bom.Event.getTarget(domEvent);
        if(!this.__isSelectable(target)){

          qx.bom.Event.preventDefault(domEvent);
        };
      },
      "default" : null
    })),
    __isFocusable : function(el){

      var index = qx.bom.element.Attribute.get(el, "tabIndex");
      if(index >= 1){

        return true;
      };
      var focusable = qx.event.handler.Focus.FOCUSABLE_ELEMENTS;
      if(index >= 0 && focusable[el.tagName]){

        return true;
      };
      return false;
    },
    __findFocusableElement : function(el){

      while(el && el.nodeType === 1){

        if(el.getAttribute("qxKeepFocus") == "on"){

          return null;
        };
        if(this.__isFocusable(el)){

          return el;
        };
        el = el.parentNode;
      };
      return this._body;
    },
    __findActivatableElement : function(el){

      var orig = el;
      while(el && el.nodeType === 1){

        if(el.getAttribute("qxKeepActive") == "on"){

          return null;
        };
        el = el.parentNode;
      };
      return orig;
    },
    __isSelectable : function(node){

      while(node && node.nodeType === 1){

        var attr = node.getAttribute("qxSelectable");
        if(attr != null){

          return attr === "on";
        };
        node = node.parentNode;
      };
      return true;
    },
    _applyActive : function(value, old){

      if(old){

        this.__fireEvent(old, value, "deactivate", true);
      };
      if(value){

        this.__fireEvent(value, old, "activate", true);
      };
      if(this.__needsScrollFix){

        window.scrollTo(0, 0);
      };
    },
    _applyFocus : function(value, old){

      if(old){

        this.__fireEvent(old, value, "focusout", true);
      };
      if(value){

        this.__fireEvent(value, old, "focusin", true);
      };
      if(old){

        this.__fireEvent(old, value, "blur", false);
      };
      if(value){

        this.__fireEvent(value, old || this.__relatedTarget, "focus", false);
      };
    }
  },
  destruct : function(){

    this._stopObserver();
    this._manager = this._window = this._document = this._root = this._body = this.__mouseActive = this.__relatedTarget = null;
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
    var focusable = statics.FOCUSABLE_ELEMENTS;
    for(var entry in focusable){

      focusable[entry.toUpperCase()] = 1;
    };
  }
});

qx.Bootstrap.define("qx.bom.Selection", {
  statics : {
    getSelectionObject : qx.core.Environment.select("html.selection", {
      "selection" : function(documentNode){

        return documentNode.selection;
      },
      "default" : function(documentNode){

        return qx.dom.Node.getWindow(documentNode).getSelection();
      }
    }),
    get : qx.core.Environment.select("html.selection", {
      "selection" : function(node){

        var rng = qx.bom.Range.get(qx.dom.Node.getDocument(node));
        return rng.text;
      },
      "default" : function(node){

        if(this.__isInputOrTextarea(node)){

          return node.value.substring(node.selectionStart, node.selectionEnd);
        } else {

          return this.getSelectionObject(qx.dom.Node.getDocument(node)).toString();
        };
      }
    }),
    getLength : qx.core.Environment.select("html.selection", {
      "selection" : function(node){

        var selectedValue = this.get(node);
        var split = qx.util.StringSplit.split(selectedValue, /\r\n/);
        return selectedValue.length - (split.length - 1);
      },
      "default" : function(node){

        if(qx.core.Environment.get("engine.name") == "opera"){

          var selectedValue,selectedLength,split;
          if(this.__isInputOrTextarea(node)){

            var start = node.selectionStart;
            var end = node.selectionEnd;
            selectedValue = node.value.substring(start, end);
            selectedLength = end - start;
          } else {

            selectedValue = qx.bom.Selection.get(node);
            selectedLength = selectedValue.length;
          };
          split = qx.util.StringSplit.split(selectedValue, /\r\n/);
          return selectedLength - (split.length - 1);
        };
        if(this.__isInputOrTextarea(node)){

          return node.selectionEnd - node.selectionStart;
        } else {

          return this.get(node).length;
        };
      }
    }),
    getStart : qx.core.Environment.select("html.selection", {
      "selection" : function(node){

        if(this.__isInputOrTextarea(node)){

          var documentRange = qx.bom.Range.get();
          if(!node.contains(documentRange.parentElement())){

            return -1;
          };
          var range = qx.bom.Range.get(node);
          var len = node.value.length;
          range.moveToBookmark(documentRange.getBookmark());
          range.moveEnd('character', len);
          return len - range.text.length;
        } else {

          var range = qx.bom.Range.get(node);
          var parentElement = range.parentElement();
          var elementRange = qx.bom.Range.get();
          try{

            elementRange.moveToElementText(parentElement);
          } catch(ex) {

            return 0;
          };
          var bodyRange = qx.bom.Range.get(qx.dom.Node.getBodyElement(node));
          bodyRange.setEndPoint("StartToStart", range);
          bodyRange.setEndPoint("EndToEnd", elementRange);
          if(elementRange.compareEndPoints("StartToStart", bodyRange) == 0){

            return 0;
          };
          var moved;
          var steps = 0;
          while(true){

            moved = bodyRange.moveStart("character", -1);
            if(elementRange.compareEndPoints("StartToStart", bodyRange) == 0){

              break;
            };
            if(moved == 0){

              break;
            } else {

              steps++;
            };
          };
          return ++steps;
        };
      },
      "default" : function(node){

        if(qx.core.Environment.get("engine.name") === "gecko" || qx.core.Environment.get("engine.name") === "webkit"){

          if(this.__isInputOrTextarea(node)){

            return node.selectionStart;
          } else {

            var documentElement = qx.dom.Node.getDocument(node);
            var documentSelection = this.getSelectionObject(documentElement);
            if(documentSelection.anchorOffset < documentSelection.focusOffset){

              return documentSelection.anchorOffset;
            } else {

              return documentSelection.focusOffset;
            };
          };
        };
        if(this.__isInputOrTextarea(node)){

          return node.selectionStart;
        } else {

          return qx.bom.Selection.getSelectionObject(qx.dom.Node.getDocument(node)).anchorOffset;
        };
      }
    }),
    getEnd : qx.core.Environment.select("html.selection", {
      "selection" : function(node){

        if(this.__isInputOrTextarea(node)){

          var documentRange = qx.bom.Range.get();
          if(!node.contains(documentRange.parentElement())){

            return -1;
          };
          var range = qx.bom.Range.get(node);
          var len = node.value.length;
          range.moveToBookmark(documentRange.getBookmark());
          range.moveStart('character', -len);
          return range.text.length;
        } else {

          var range = qx.bom.Range.get(node);
          var parentElement = range.parentElement();
          var elementRange = qx.bom.Range.get();
          try{

            elementRange.moveToElementText(parentElement);
          } catch(ex) {

            return 0;
          };
          var len = elementRange.text.length;
          var bodyRange = qx.bom.Range.get(qx.dom.Node.getBodyElement(node));
          bodyRange.setEndPoint("EndToEnd", range);
          bodyRange.setEndPoint("StartToStart", elementRange);
          if(elementRange.compareEndPoints("EndToEnd", bodyRange) == 0){

            return len - 1;
          };
          var moved;
          var steps = 0;
          while(true){

            moved = bodyRange.moveEnd("character", 1);
            if(elementRange.compareEndPoints("EndToEnd", bodyRange) == 0){

              break;
            };
            if(moved == 0){

              break;
            } else {

              steps++;
            };
          };
          return len - (++steps);
        };
      },
      "default" : function(node){

        if(qx.core.Environment.get("engine.name") === "gecko" || qx.core.Environment.get("engine.name") === "webkit"){

          if(this.__isInputOrTextarea(node)){

            return node.selectionEnd;
          } else {

            var documentElement = qx.dom.Node.getDocument(node);
            var documentSelection = this.getSelectionObject(documentElement);
            if(documentSelection.focusOffset > documentSelection.anchorOffset){

              return documentSelection.focusOffset;
            } else {

              return documentSelection.anchorOffset;
            };
          };
        };
        if(this.__isInputOrTextarea(node)){

          return node.selectionEnd;
        } else {

          return qx.bom.Selection.getSelectionObject(qx.dom.Node.getDocument(node)).focusOffset;
        };
      }
    }),
    __isInputOrTextarea : function(node){

      return qx.dom.Node.isElement(node) && (node.nodeName.toLowerCase() == "input" || node.nodeName.toLowerCase() == "textarea");
    },
    set : qx.core.Environment.select("html.selection", {
      "selection" : function(node, start, end){

        var rng;
        if(qx.dom.Node.isDocument(node)){

          node = node.body;
        };
        if(qx.dom.Node.isElement(node) || qx.dom.Node.isText(node)){

          switch(node.nodeName.toLowerCase()){case "input":case "textarea":case "button":
          if(end === undefined){

            end = node.value.length;
          };
          if(start >= 0 && start <= node.value.length && end >= 0 && end <= node.value.length){

            rng = qx.bom.Range.get(node);
            rng.collapse(true);
            rng.moveStart("character", start);
            rng.moveEnd("character", end - start);
            rng.select();
            return true;
          };
          break;case "#text":
          if(end === undefined){

            end = node.nodeValue.length;
          };
          if(start >= 0 && start <= node.nodeValue.length && end >= 0 && end <= node.nodeValue.length){

            rng = qx.bom.Range.get(qx.dom.Node.getBodyElement(node));
            rng.moveToElementText(node.parentNode);
            rng.collapse(true);
            rng.moveStart("character", start);
            rng.moveEnd("character", end - start);
            rng.select();
            return true;
          };
          break;default:
          if(end === undefined){

            end = node.childNodes.length - 1;
          };
          if(node.childNodes[start] && node.childNodes[end]){

            rng = qx.bom.Range.get(qx.dom.Node.getBodyElement(node));
            rng.moveToElementText(node.childNodes[start]);
            rng.collapse(true);
            var newRng = qx.bom.Range.get(qx.dom.Node.getBodyElement(node));
            newRng.moveToElementText(node.childNodes[end]);
            rng.setEndPoint("EndToEnd", newRng);
            rng.select();
            return true;
          };};
        };
        return false;
      },
      "default" : function(node, start, end){

        var nodeName = node.nodeName.toLowerCase();
        if(qx.dom.Node.isElement(node) && (nodeName == "input" || nodeName == "textarea")){

          if(end === undefined){

            end = node.value.length;
          };
          if(start >= 0 && start <= node.value.length && end >= 0 && end <= node.value.length){

            node.focus();
            node.select();
            node.setSelectionRange(start, end);
            return true;
          };
        } else {

          var validBoundaries = false;
          var sel = qx.dom.Node.getWindow(node).getSelection();
          var rng = qx.bom.Range.get(node);
          if(qx.dom.Node.isText(node)){

            if(end === undefined){

              end = node.length;
            };
            if(start >= 0 && start < node.length && end >= 0 && end <= node.length){

              validBoundaries = true;
            };
          } else if(qx.dom.Node.isElement(node)){

            if(end === undefined){

              end = node.childNodes.length - 1;
            };
            if(start >= 0 && node.childNodes[start] && end >= 0 && node.childNodes[end]){

              validBoundaries = true;
            };
          } else if(qx.dom.Node.isDocument(node)){

            node = node.body;
            if(end === undefined){

              end = node.childNodes.length - 1;
            };
            if(start >= 0 && node.childNodes[start] && end >= 0 && node.childNodes[end]){

              validBoundaries = true;
            };
          };;
          if(validBoundaries){

            if(!sel.isCollapsed){

              sel.collapseToStart();
            };
            rng.setStart(node, start);
            if(qx.dom.Node.isText(node)){

              rng.setEnd(node, end);
            } else {

              rng.setEndAfter(node.childNodes[end]);
            };
            if(sel.rangeCount > 0){

              sel.removeAllRanges();
            };
            sel.addRange(rng);
            return true;
          };
        };
        return false;
      }
    }),
    setAll : function(node){

      return qx.bom.Selection.set(node, 0);
    },
    clear : qx.core.Environment.select("html.selection", {
      "selection" : function(node){

        var rng = qx.bom.Range.get(node);
        var parent = rng.parentElement();
        var documentRange = qx.bom.Range.get(qx.dom.Node.getDocument(node));
        if(qx.dom.Node.isText(node)){

          node = node.parentNode;
        };
        if(parent == documentRange.parentElement() && parent == node){

          var sel = qx.bom.Selection.getSelectionObject(qx.dom.Node.getDocument(node));
          sel.empty();
        };
      },
      "default" : function(node){

        var sel = qx.bom.Selection.getSelectionObject(qx.dom.Node.getDocument(node));
        var nodeName = node.nodeName.toLowerCase();
        if(qx.dom.Node.isElement(node) && (nodeName == "input" || nodeName == "textarea")){

          node.setSelectionRange(0, 0);
          if(qx.bom.Element && qx.bom.Element.blur){

            qx.bom.Element.blur(node);
          };
        } else if(qx.dom.Node.isDocument(node) || nodeName == "body"){

          sel.collapse(node.body ? node.body : node, 0);
        } else {

          var rng = qx.bom.Range.get(node);
          if(!rng.collapsed){

            var compareNode;
            var commonAncestor = rng.commonAncestorContainer;
            if(qx.dom.Node.isElement(node) && qx.dom.Node.isText(commonAncestor)){

              compareNode = commonAncestor.parentNode;
            } else {

              compareNode = commonAncestor;
            };
            if(compareNode == node){

              sel.collapse(node, 0);
            };
          };
        };
      }
    })
  }
});

qx.Bootstrap.define("qx.bom.Range", {
  statics : {
    get : qx.core.Environment.select("html.selection", {
      "selection" : function(node){

        if(qx.dom.Node.isElement(node)){

          switch(node.nodeName.toLowerCase()){case "input":
          switch(node.type){case "text":case "password":case "hidden":case "button":case "reset":case "file":case "submit":
          return node.createTextRange();default:
          return qx.bom.Selection.getSelectionObject(qx.dom.Node.getDocument(node)).createRange();};
          break;case "textarea":case "body":case "button":
          return node.createTextRange();default:
          return qx.bom.Selection.getSelectionObject(qx.dom.Node.getDocument(node)).createRange();};
        } else {

          if(node == null){

            node = window;
          };
          return qx.bom.Selection.getSelectionObject(qx.dom.Node.getDocument(node)).createRange();
        };
      },
      "default" : function(node){

        var doc = qx.dom.Node.getDocument(node);
        var sel = qx.bom.Selection.getSelectionObject(doc);
        if(sel.rangeCount > 0){

          return sel.getRangeAt(0);
        } else {

          return doc.createRange();
        };
      }
    })
  }
});

qx.Bootstrap.define("qx.util.StringSplit", {
  statics : {
    split : function(str, separator, limit){

      if(Object.prototype.toString.call(separator) !== "[object RegExp]"){

        return String.prototype.split.call(str, separator, limit);
      };
      var output = [],lastLastIndex = 0,flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.sticky ? "y" : ""),separator = RegExp(separator.source, flags + "g"),separator2,match,lastIndex,lastLength,compliantExecNpcg = /()??/.exec("")[1] === undefined;
      str = str + "";
      if(!compliantExecNpcg){

        separator2 = RegExp("^" + separator.source + "$(?!\\s)", flags);
      };
      if(limit === undefined || +limit < 0){

        limit = Infinity;
      } else {

        limit = Math.floor(+limit);
        if(!limit){

          return [];
        };
      };
      while(match = separator.exec(str)){

        lastIndex = match.index + match[0].length;
        if(lastIndex > lastLastIndex){

          output.push(str.slice(lastLastIndex, match.index));
          if(!compliantExecNpcg && match.length > 1){

            match[0].replace(separator2, function(){

              for(var i = 1;i < arguments.length - 2;i++){

                if(arguments[i] === undefined){

                  match[i] = undefined;
                };
              };
            });
          };
          if(match.length > 1 && match.index < str.length){

            Array.prototype.push.apply(output, match.slice(1));
          };
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if(output.length >= limit){

            break;
          };
        };
        if(separator.lastIndex === match.index){

          separator.lastIndex++;
        };
      };
      if(lastLastIndex === str.length){

        if(lastLength || !separator.test("")){

          output.push("");
        };
      } else {

        output.push(str.slice(lastLastIndex));
      };
      return output.length > limit ? output.slice(0, limit) : output;
    }
  }
});

qx.Class.define("qx.event.type.Focus", {
  extend : qx.event.type.Event,
  members : {
    init : function(target, relatedTarget, canBubble){

      this.base(arguments, canBubble, false);
      this._target = target;
      this._relatedTarget = relatedTarget;
      return this;
    }
  }
});

qx.Class.define("qx.log.appender.Console", {
  statics : {
    __main : null,
    __log : null,
    __cmd : null,
    __lastCommand : null,
    init : function(){

      var style = ['.qxconsole{z-index:10000;width:600px;height:300px;top:0px;right:0px;position:absolute;border-left:1px solid black;color:black;border-bottom:1px solid black;color:black;font-family:Consolas,Monaco,monospace;font-size:11px;line-height:1.2;}', '.qxconsole .control{background:#cdcdcd;border-bottom:1px solid black;padding:4px 8px;}', '.qxconsole .control a{text-decoration:none;color:black;}', '.qxconsole .messages{background:white;height:100%;width:100%;overflow:auto;}', '.qxconsole .messages div{padding:0px 4px;}', '.qxconsole .messages .user-command{color:blue}', '.qxconsole .messages .user-result{background:white}', '.qxconsole .messages .user-error{background:#FFE2D5}', '.qxconsole .messages .level-debug{background:white}', '.qxconsole .messages .level-info{background:#DEEDFA}', '.qxconsole .messages .level-warn{background:#FFF7D5}', '.qxconsole .messages .level-error{background:#FFE2D5}', '.qxconsole .messages .level-user{background:#E3EFE9}', '.qxconsole .messages .type-string{color:black;font-weight:normal;}', '.qxconsole .messages .type-number{color:#155791;font-weight:normal;}', '.qxconsole .messages .type-boolean{color:#15BC91;font-weight:normal;}', '.qxconsole .messages .type-array{color:#CC3E8A;font-weight:bold;}', '.qxconsole .messages .type-map{color:#CC3E8A;font-weight:bold;}', '.qxconsole .messages .type-key{color:#565656;font-style:italic}', '.qxconsole .messages .type-class{color:#5F3E8A;font-weight:bold}', '.qxconsole .messages .type-instance{color:#565656;font-weight:bold}', '.qxconsole .messages .type-stringify{color:#565656;font-weight:bold}', '.qxconsole .command{background:white;padding:2px 4px;border-top:1px solid black;}', '.qxconsole .command input{width:100%;border:0 none;font-family:Consolas,Monaco,monospace;font-size:11px;line-height:1.2;}', '.qxconsole .command input:focus{outline:none;}'];
      qx.bom.Stylesheet.createElement(style.join(""));
      var markup = ['<div class="qxconsole">', '<div class="control"><a href="javascript:qx.log.appender.Console.clear()">Clear</a> | <a href="javascript:qx.log.appender.Console.toggle()">Hide</a></div>', '<div class="messages">', '</div>', '<div class="command">', '<input type="text"/>', '</div>', '</div>'];
      var wrapper = document.createElement("DIV");
      wrapper.innerHTML = markup.join("");
      var main = wrapper.firstChild;
      document.body.appendChild(wrapper.firstChild);
      this.__main = main;
      this.__log = main.childNodes[1];
      this.__cmd = main.childNodes[2].firstChild;
      this.__onResize();
      qx.log.Logger.register(this);
      qx.core.ObjectRegistry.register(this);
    },
    dispose : function(){

      qx.event.Registration.removeListener(document.documentElement, "keypress", this.__onKeyPress, this);
      qx.log.Logger.unregister(this);
    },
    clear : function(){

      this.__log.innerHTML = "";
    },
    process : function(entry){

      this.__log.appendChild(qx.log.appender.Util.toHtml(entry));
      this.__scrollDown();
    },
    __scrollDown : function(){

      this.__log.scrollTop = this.__log.scrollHeight;
    },
    __visible : true,
    toggle : function(){

      if(!this.__main){

        this.init();
      } else if(this.__main.style.display == "none"){

        this.show();
      } else {

        this.__main.style.display = "none";
      };
    },
    show : function(){

      if(!this.__main){

        this.init();
      } else {

        this.__main.style.display = "block";
        this.__log.scrollTop = this.__log.scrollHeight;
      };
    },
    __history : [],
    execute : function(){

      var value = this.__cmd.value;
      if(value == ""){

        return;
      };
      if(value == "clear"){

        this.clear();
        return;
      };
      var command = document.createElement("div");
      command.innerHTML = qx.log.appender.Util.escapeHTML(">>> " + value);
      command.className = "user-command";
      this.__history.push(value);
      this.__lastCommand = this.__history.length;
      this.__log.appendChild(command);
      this.__scrollDown();
      try{

        var ret = window.eval(value);
      } catch(ex) {

        qx.log.Logger.error(ex);
      };
      if(ret !== undefined){

        qx.log.Logger.debug(ret);
      };
    },
    __onResize : function(e){

      this.__log.style.height = (this.__main.clientHeight - this.__main.firstChild.offsetHeight - this.__main.lastChild.offsetHeight) + "px";
    },
    __onKeyPress : function(e){

      if(e instanceof qx.event.type.Tap || e instanceof qx.event.type.Pointer){

        var target = e.getTarget();
        if(target && target.className && target.className.indexOf && target.className.indexOf("navigationbar") != -1){

          this.toggle();
        };
        return;
      };
      var iden = e.getKeyIdentifier();
      if((iden == "F7") || (iden == "D" && e.isCtrlPressed())){

        this.toggle();
        e.preventDefault();
      };
      if(!this.__main){

        return;
      };
      if(!qx.dom.Hierarchy.contains(this.__main, e.getTarget())){

        return;
      };
      if(iden == "Enter" && this.__cmd.value != ""){

        this.execute();
        this.__cmd.value = "";
      };
      if(iden == "Up" || iden == "Down"){

        this.__lastCommand += iden == "Up" ? -1 : 1;
        this.__lastCommand = Math.min(Math.max(0, this.__lastCommand), this.__history.length);
        var entry = this.__history[this.__lastCommand];
        this.__cmd.value = entry || "";
        this.__cmd.select();
      };
    }
  },
  defer : function(statics){

    qx.event.Registration.addListener(document.documentElement, "keypress", statics.__onKeyPress, statics);
    qx.event.Registration.addListener(document.documentElement, "longtap", statics.__onKeyPress, statics);
  }
});

qx.Class.define("qx.ui.mobile.page.Manager", {
  extend : qx.core.Object,
  construct : function(isTablet, root){

    this.base(arguments);
    root = root || qx.core.Init.getApplication().getRoot();
    if(typeof isTablet !== "undefined" && isTablet !== null){

      this.__isTablet = isTablet;
    } else {

      this.__isTablet = qx.core.Environment.get("device.type") == "desktop" || qx.core.Environment.get("device.type") == "tablet";
    };
    this.__detailNavigation = this._createDetailNavigation();
    this.__detailNavigation.getNavigationBar().hide();
    if(this.__isTablet){

      this.__masterNavigation = this._createMasterNavigation();
      this.__masterNavigation.getNavigationBar().hide();
      this.__masterContainer = this._createMasterContainer();
      this.__detailContainer = this._createDetailContainer();
      this.__masterButton = this._createMasterButton();
      this.__masterButton.addListener("tap", this._onMasterButtonTap, this);
      this.__hideMasterButton = this._createHideMasterButton();
      this.__hideMasterButton.addListener("tap", this._onHideMasterButtonTap, this);
      this.__masterNavigation.addListener("update", this._onMasterContainerUpdate, this);
      this.__detailNavigation.addListener("update", this._onDetailContainerUpdate, this);
      root.add(this.__detailContainer, {
        flex : 1
      });
      this.__masterContainer.add(this.__masterNavigation, {
        flex : 1
      });
      this.__detailContainer.add(this.__detailNavigation, {
        flex : 1
      });
      qx.event.Registration.addListener(window, "orientationchange", this._onLayoutChange, this);
      this.__masterContainer.addListener("resize", this._onLayoutChange, this);
      this.__masterNavigation.getLayout().setShowAnimation(false);
      this.__detailNavigation.getLayout().setShowAnimation(false);
      this.__masterContainer.forceHide();
      setTimeout(function(){

        if(qx.bom.Viewport.isLandscape()){

          this.__masterContainer.show();
        };
      }.bind(this), 300);
    } else {

      root.add(this.__detailNavigation, {
        flex : 1
      });
    };
  },
  properties : {
    masterTitle : {
      init : "Master",
      check : "String",
      apply : "_applyMasterTitle"
    },
    hideMasterButtonCaption : {
      init : "Hide",
      check : "String",
      apply : "_applyHideMasterButtonCaption"
    },
    allowMasterHideOnLandscape : {
      init : true,
      check : "Boolean"
    },
    hideMasterOnDetailStart : {
      init : true,
      check : "Boolean"
    }
  },
  members : {
    __isTablet : null,
    __detailNavigation : null,
    __masterNavigation : null,
    __masterButton : null,
    __hideMasterButton : null,
    __masterPages : null,
    __detailPages : null,
    __masterContainer : null,
    __detailContainer : null,
    isMasterContainerHidden : function(){

      if(qx.core.Environment.get("qx.debug")){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, "The method 'isMasterContainerHidden()' is deprecated. Please use getMasterContainer().isHidden() instead.");
      };
      return this.__masterContainer.isHidden();
    },
    setMasterContainerHidden : function(value){

      if(qx.core.Environment.get("qx.debug")){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, "The method 'setMasterContainerHidden()' is deprecated. Please use getMasterContainer().show() / hide() instead.");
      };
      if(value){

        this.__masterContainer.hide();
      } else {

        this.__masterContainer.show();
      };
    },
    _createMasterContainer : function(){

      var masterContainer = new qx.ui.mobile.container.Drawer(null, new qx.ui.mobile.layout.HBox());
      masterContainer.addCssClass("master-detail-master");
      masterContainer.setHideOnParentTap(false);
      masterContainer.addListener("changeVisibility", this._onMasterChangeVisibility, this);
      return masterContainer;
    },
    _createDetailContainer : function(){

      var detailContainer = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox());
      detailContainer.setDefaultCssClass("master-detail-detail");
      return detailContainer;
    },
    getMasterContainer : function(){

      return this.__masterContainer;
    },
    getDetailContainer : function(){

      return this.__detailContainer;
    },
    getMasterButton : function(){

      return this.__masterButton;
    },
    getMasterNavigation : function(){

      return this.__masterNavigation;
    },
    getDetailNavigation : function(){

      return this.__detailNavigation;
    },
    _createMasterButton : function(){

      return new qx.ui.mobile.navigationbar.Button(this.getMasterTitle());
    },
    _createHideMasterButton : function(){

      return new qx.ui.mobile.navigationbar.Button("Hide");
    },
    _createMasterNavigation : function(){

      return new qx.ui.mobile.container.Navigation();
    },
    _createDetailNavigation : function(){

      return new qx.ui.mobile.container.Navigation();
    },
    addMaster : function(pages){

      if(this.__isTablet){

        if(pages){

          if(!qx.lang.Type.isArray(pages)){

            pages = [pages];
          };
          for(var i = 0;i < pages.length;i++){

            var masterPage = pages[i];
            masterPage.addListener("start", this._onMasterPageStart, this);
          };
          if(this.__masterPages){

            this.__masterPages.concat(pages);
          } else {

            this.__masterPages = pages;
          };
          this._add(pages, this.__masterNavigation);
        };
      } else {

        this.addDetail(pages);
      };
    },
    addDetail : function(pages){

      this._add(pages, this.__detailNavigation);
      if(pages && this.__isTablet){

        if(!qx.lang.Type.isArray(pages)){

          pages = [pages];
        };
        for(var i = 0;i < pages.length;i++){

          var detailPage = pages[i];
          detailPage.addListener("start", this._onDetailPageStart, this);
        };
        if(this.__detailPages){

          this.__detailPages.concat(pages);
        } else {

          this.__detailPages = pages;
        };
      };
    },
    _onDetailPageStart : function(evt){

      if(qx.bom.Viewport.isPortrait() && this.isHideMasterOnDetailStart()){

        this.__masterContainer.hide();
      };
    },
    _onMasterPageStart : function(evt){

      var masterPage = evt.getTarget();
      var masterPageTitle = masterPage.getTitle();
      this.setMasterTitle(masterPageTitle);
    },
    _add : function(pages, target){

      if(!qx.lang.Type.isArray(pages)){

        pages = [pages];
      };
      for(var i = 0;i < pages.length;i++){

        var page = pages[i];
        if(qx.core.Environment.get("qx.debug")){

          this.assertInstance(page, qx.ui.mobile.page.NavigationPage);
        };
        if(this.__isTablet && !page.getShowBackButtonOnTablet()){

          page.setShowBackButton(false);
        };
        page.setIsTablet(this.__isTablet);
        target.add(page);
      };
    },
    _onMasterContainerUpdate : function(evt){

      var widget = evt.getData();
      widget.getRightContainer().remove(this.__hideMasterButton);
      widget.getRightContainer().add(this.__hideMasterButton);
    },
    _onDetailContainerUpdate : function(evt){

      var widget = evt.getData();
      widget.getLeftContainer().remove(this.__masterButton);
      widget.getLeftContainer().add(this.__masterButton);
    },
    _onMasterButtonTap : function(){

      this.__masterContainer.show();
    },
    _onHideMasterButtonTap : function(){

      this._removeDetailContainerGap();
      this.__masterContainer.hide();
    },
    _onMasterChangeVisibility : function(evt){

      var isMasterVisible = ("visible" === evt.getData());
      if(qx.bom.Viewport.isLandscape()){

        if(this.isAllowMasterHideOnLandscape()){

          if(isMasterVisible){

            this._createDetailContainerGap();
            this.__masterButton.exclude();
            this.__hideMasterButton.show();
          } else {

            this.__masterButton.show();
            this.__hideMasterButton.show();
          };
        } else {

          this.__masterButton.exclude();
          this.__hideMasterButton.exclude();
        };
      } else {

        this._removeDetailContainerGap();
        this.__masterButton.show();
        this.__hideMasterButton.show();
      };
    },
    _onLayoutChange : function(){

      if(this.__isTablet){

        if(qx.bom.Viewport.isLandscape()){

          this.__masterContainer.setHideOnParentTap(false);
          if(this.__masterContainer.isHidden()){

            this.__masterContainer.show();
          } else {

            this._removeDetailContainerGap();
            this.__masterContainer.hide();
          };
        } else {

          this._removeDetailContainerGap();
          this.__masterContainer.setHideOnParentTap(true);
          this.__masterContainer.hide();
        };
      };
    },
    _getGapPropertyKey : function(){

      return "padding" + qx.lang.String.capitalize(this.__masterContainer.getOrientation());
    },
    _createDetailContainerGap : function(){

      qx.bom.element.Style.set(this.__detailContainer.getContainerElement(), this._getGapPropertyKey(), this.__masterContainer.getSize() / 16 + "rem");
      qx.event.Registration.fireEvent(window, "resize");
    },
    _removeDetailContainerGap : function(){

      qx.bom.element.Style.set(this.__detailContainer.getContainerElement(), this._getGapPropertyKey(), null);
      qx.event.Registration.fireEvent(window, "resize");
    },
    _applyHideMasterButtonCaption : function(value, old){

      if(this.__isTablet){

        this.__hideMasterButton.setLabel(value);
      };
    },
    _applyMasterTitle : function(value, old){

      if(this.__isTablet){

        this.__masterButton.setLabel(value);
      };
    }
  },
  destruct : function(){

    if(this.__masterPages){

      for(var i = 0;i < this.__masterPages.length;i++){

        var masterPage = this.__masterPages[i];
        masterPage.removeListener("start", this._onMasterPageStart, this);
      };
    };
    if(this.___detailPages){

      for(var j = 0;j < this.___detailPages.length;j++){

        var detailPage = this.___detailPages[j];
        detailPage.removeListener("start", this._onDetailPageStart, this);
      };
    };
    if(this.__isTablet){

      this.__masterContainer.removeListener("changeVisibility", this._onMasterChangeVisibility, this);
      this.__masterContainer.removeListener("resize", this._onLayoutChange, this);
      qx.event.Registration.removeListener(window, "orientationchange", this._onLayoutChange, this);
    };
    this.__masterPages = this.__detailPages = null;
    this._disposeObjects("__detailNavigation", "__masterNavigation", "__masterButton");
  }
});

qx.Class.define("qx.ui.mobile.container.Drawer", {
  extend : qx.ui.mobile.container.Composite,
  construct : function(parent, layout){

    this.base(arguments);
    if(layout){

      this.setLayout(layout);
    };
    this.initOrientation();
    this.initPositionZ();
    if(parent){

      if(qx.core.Environment.get("qx.debug")){

        this.assertInstance(parent, qx.ui.mobile.container.Composite);
      };
      parent.add(this);
      qx.core.Init.getApplication().addListener("back", this.forceHide, this);
    } else {

      qx.core.Init.getApplication().getRoot().add(this);
    };
    this.__parent = this.getLayoutParent();
    this.__parent.addCssClass("drawer-parent");
    this.__parent.addListener("swipe", this._onParentSwipe, this);
    this.__parent.addListener("pointerdown", this._onParentPointerDown, this);
    this.__pointerStartPosition = [0, 0];
    this.forceHide();
  },
  events : {
    resize : "qx.event.type.Data"
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "drawer"
    },
    orientation : {
      check : "String",
      init : "left",
      apply : "_applyOrientation"
    },
    size : {
      check : "Integer",
      init : 300,
      apply : "_applySize",
      event : "resize"
    },
    hideOnParentTap : {
      check : "Boolean",
      init : true
    },
    tapOffset : {
      check : "Integer",
      init : 20
    },
    transitionDuration : {
      check : "Integer",
      init : 500,
      apply : "_applyTransitionDuration"
    },
    positionZ : {
      check : ["above", "below"],
      init : "above",
      apply : "_applyPositionZ"
    }
  },
  members : {
    __pointerStartPosition : null,
    __parent : null,
    __transitionEnabled : null,
    __inTransition : null,
    _applyOrientation : function(value, old){

      this.removeCssClass(old);
      this.addCssClass(value);
      this._applySize(this.getSize());
    },
    _applyPositionZ : function(value, old){

      this.removeCssClass(old);
      this.addCssClass(value);
      if(this.__parent){

        this.__parent.setTranslateX(0);
        this.__parent.setTranslateY(0);
      };
    },
    setWidth : function(value){

      if(qx.core.Environment.get("qx.debug")){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, "The method 'setWidth()' is deprecated. Please use 'setSize()' instead.");
      };
      this.setSize(value);
    },
    getWidth : function(){

      if(qx.core.Environment.get("qx.debug")){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, "The method 'getWidth()' is deprecated. Please use 'getSize()' instead.");
      };
      return this.getSize();
    },
    resetWidth : function(){

      if(qx.core.Environment.get("qx.debug")){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, "The method 'resetWidth()' is deprecated. Please use 'resetSize()' instead.");
      };
      this.resetSize();
    },
    setHeight : function(value){

      if(qx.core.Environment.get("qx.debug")){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, "The method 'setHeight()' is deprecated. Please use 'setSize()' instead.");
      };
      this.setSize(value);
    },
    getHeight : function(){

      if(qx.core.Environment.get("qx.debug")){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, "The method 'getHeight()' is deprecated. Please use 'getSize()' instead.");
      };
      return this.getSize();
    },
    resetHeight : function(){

      if(qx.core.Environment.get("qx.debug")){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, "The method 'resetHeight()' is deprecated. Please use 'resetSize()' instead.");
      };
      this.resetSize();
    },
    _toggleParentBlockedState : function(){

      this.__parent.toggleCssClass("blocked");
    },
    _applySize : function(value){

      var height = null;
      var width = null;
      var remSize = (value / 16);
      if(this.getOrientation() == "left" || this.getOrientation() == "right"){

        width = remSize + "rem";
      } else {

        height = remSize + "rem";
      };
      this._setStyle("height", height);
      this._setStyle("width", width);
    },
    _applyTransitionDuration : function(value, old){

      this.__transitionEnabled = value > 0;
    },
    show : function(){

      if(!this.isHidden() || this.__inTransition === true){

        return;
      };
      this.__inTransition = true;
      this._setStyle("visibility", "visible");
      this.__parent.addCssClass("blocked");
      if(this.getPositionZ() == "below"){

        if(this.getOrientation() == "left"){

          this.__parent.setTranslateX(this.getSize());
        } else if(this.getOrientation() == "right"){

          this.__parent.setTranslateX(-this.getSize());
        } else if(this.getOrientation() == "top"){

          this.__parent.setTranslateY(this.getSize());
        } else if(this.getOrientation() == "bottom"){

          this.__parent.setTranslateY(-this.getSize());
        };;;
      };
      if(this.getTransitionDuration() > 0){

        this._enableTransition();
        var callArguments = arguments;
        var transitionTarget = this._getTransitionTarget().getContentElement();
        var listenerId = qx.bom.Element.addListener(transitionTarget, "transitionEnd", function(evt){

          this.base(callArguments);
          this._disableTransition();
          this.__inTransition = false;
          qx.bom.Element.removeListenerById(transitionTarget, listenerId);
        }, this);
        setTimeout(function(){

          this.removeCssClass("hidden");
        }.bind(this), 0);
      } else {

        this.base(arguments);
        this.__inTransition = false;
        this.removeCssClass("hidden");
      };
    },
    hide : function(){

      if(this.isHidden() || this.__inTransition === true){

        return;
      };
      this.__inTransition = true;
      if(this.getPositionZ() == "below"){

        this.__parent.setTranslateX(0);
        this.__parent.setTranslateY(0);
      };
      if(this.getTransitionDuration() > 0){

        this._enableTransition();
        var callArguments = arguments;
        var transitionTarget = this._getTransitionTarget().getContentElement();
        var listenerId = qx.bom.Element.addListener(transitionTarget, "transitionEnd", function(evt){

          this.base(callArguments);
          this._disableTransition();
          this.__parent.removeCssClass("blocked");
          this.__inTransition = false;
          qx.bom.Element.removeListenerById(transitionTarget, listenerId);
        }, this);
        setTimeout(function(){

          this.addCssClass("hidden");
        }.bind(this), 0);
      } else {

        this.base(arguments);
        this.addCssClass("hidden");
        this.__inTransition = false;
        this.__parent.removeCssClass("blocked");
      };
    },
    forceHide : function(){

      this._disableTransition();
      if(this.getPositionZ() == "below"){

        this.__parent.setTranslateX(0);
        this.__parent.setTranslateY(0);
      };
      this.__parent.removeCssClass("blocked");
      this.addCssClass("hidden");
    },
    isHidden : function(){

      return this.hasCssClass("hidden");
    },
    _enableTransition : function(){

      qx.bom.element.Style.set(this._getTransitionTarget().getContentElement(), "transition", "all " + this.getTransitionDuration() + "ms ease-in-out");
    },
    _disableTransition : function(){

      qx.bom.element.Style.set(this._getTransitionTarget().getContentElement(), "transition", null);
    },
    _getTransitionTarget : function(){

      if(this.getPositionZ() == "below"){

        return this.__parent;
      } else {

        return this;
      };
    },
    toggleVisibility : function(){

      if(this.isHidden()){

        this.show();
        return true;
      } else {

        this.hide();
        return false;
      };
    },
    _onParentPointerDown : function(evt){

      this.__pointerStartPosition = [evt.getViewportLeft(), evt.getViewportTop()];
      var isShown = !this.hasCssClass("hidden");
      if(isShown && this.isHideOnParentTap()){

        var location = qx.bom.element.Location.get(this.getContainerElement());
        var orientation = this.getOrientation();
        if(orientation == "left" && this.__pointerStartPosition[0] > location.right || orientation == "top" && this.__pointerStartPosition[1] > location.bottom || orientation == "bottom" && this.__pointerStartPosition[1] < location.top || orientation == "right" && this.__pointerStartPosition[0] < location.left){

          evt.preventDefault();
          this.hide();
        };
      };
    },
    _onParentSwipe : function(evt){

      var direction = evt.getDirection();
      var isHidden = this.hasCssClass("hidden");
      if(isHidden){

        var location = qx.bom.element.Location.get(this.getContainerElement());
        if((direction == "right" && this.getOrientation() == "left" && this.__pointerStartPosition[0] < location.right + this.getTapOffset() && this.__pointerStartPosition[0] > location.right) || (direction == "left" && this.getOrientation() == "right" && this.__pointerStartPosition[0] > location.left - this.getTapOffset() && this.__pointerStartPosition[0] < location.left) || (direction == "down" && this.getOrientation() == "top" && this.__pointerStartPosition[1] < this.getTapOffset() + location.bottom && this.__pointerStartPosition[1] > location.bottom) || (direction == "up" && this.getOrientation() == "bottom" && this.__pointerStartPosition[1] > location.top - this.getTapOffset() && this.__pointerStartPosition[1] < location.top)){

          this.show();
        };
      };
    }
  },
  destruct : function(){

    qx.core.Init.getApplication().removeListener("back", this.forceHide, this);
    this.__parent.removeListener("swipe", this._onParentSwipe, this);
    this.__parent.removeListener("pointerdown", this._onParentPointerDown, this);
    qx.util.DisposeUtil.destroyContainer(this);
    this.__pointerStartPosition = this.__parent = this.__transitionEnabled = null;
  }
});

qx.Class.define("qx.event.handler.Element", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  construct : function(manager){

    this.base(arguments);
    this._manager = manager;
    this._registeredEvents = {
    };
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      abort : true,
      load : true,
      scroll : true,
      select : true,
      reset : true,
      submit : true
    },
    CANCELABLE : {
      selectstart : true
    },
    TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE,
    IGNORE_CAN_HANDLE : false
  },
  members : {
    canHandleEvent : function(target, type){

      if(type === "load"){

        return target.tagName.toLowerCase() !== "iframe";
      } else {

        return true;
      };
    },
    registerEvent : function(target, type, capture){

      var elementId = qx.core.ObjectRegistry.toHashCode(target);
      var eventId = elementId + "-" + type;
      var listener = qx.lang.Function.listener(this._onNative, this, eventId);
      qx.bom.Event.addNativeListener(target, type, listener);
      this._registeredEvents[eventId] = {
        element : target,
        type : type,
        listener : listener
      };
    },
    unregisterEvent : function(target, type, capture){

      var events = this._registeredEvents;
      if(!events){

        return;
      };
      var elementId = qx.core.ObjectRegistry.toHashCode(target);
      var eventId = elementId + "-" + type;
      var eventData = this._registeredEvents[eventId];
      if(eventData){

        qx.bom.Event.removeNativeListener(target, type, eventData.listener);
      };
      delete this._registeredEvents[eventId];
    },
    _onNative : qx.event.GlobalError.observeMethod(function(nativeEvent, eventId){

      var events = this._registeredEvents;
      if(!events){

        return;
      };
      var eventData = events[eventId];
      var isCancelable = this.constructor.CANCELABLE[eventData.type];
      qx.event.Registration.fireNonBubblingEvent(eventData.element, eventData.type, qx.event.type.Native, [nativeEvent, undefined, undefined, undefined, isCancelable]);
    })
  },
  destruct : function(){

    var entry;
    var events = this._registeredEvents;
    for(var id in events){

      entry = events[id];
      qx.bom.Event.removeNativeListener(entry.element, entry.type, entry.listener);
    };
    this._manager = this._registeredEvents = null;
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
  }
});

qx.Class.define("qx.event.handler.Mouse", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  construct : function(manager){

    this.base(arguments);
    this.__manager = manager;
    this.__window = manager.getWindow();
    this.__root = this.__window.document;
    this._initButtonObserver();
    this._initMoveObserver();
    this._initWheelObserver();
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      mousemove : 1,
      mouseover : 1,
      mouseout : 1,
      mousedown : 1,
      mouseup : 1,
      click : 1,
      dblclick : 1,
      contextmenu : 1,
      mousewheel : 1
    },
    TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE + qx.event.IEventHandler.TARGET_DOCUMENT + qx.event.IEventHandler.TARGET_WINDOW,
    IGNORE_CAN_HANDLE : true
  },
  members : {
    __onButtonEventWrapper : null,
    __onMoveEventWrapper : null,
    __onWheelEventWrapper : null,
    __lastEventType : null,
    __lastMouseDownTarget : null,
    __manager : null,
    __window : null,
    __root : null,
    __preventNextClick : null,
    canHandleEvent : function(target, type){
    },
    registerEvent : qx.core.Environment.get("os.name") === "ios" ? function(target, type, capture){

      target["on" + type] = (function(){

        return null;
      });
    } : (function(){

      return null;
    }),
    unregisterEvent : qx.core.Environment.get("os.name") === "ios" ? function(target, type, capture){

      target["on" + type] = undefined;
    } : (function(){

      return null;
    }),
    __fireEvent : function(domEvent, type, target){

      if(!target){

        target = qx.bom.Event.getTarget(domEvent);
      };
      if(target && target.nodeType){

        qx.event.Registration.fireEvent(target, type || domEvent.type, type == "mousewheel" ? qx.event.type.MouseWheel : qx.event.type.Mouse, [domEvent, target, null, true, true]);
      };
      qx.event.Registration.fireEvent(this.__window, "useraction", qx.event.type.Data, [type || domEvent.type]);
    },
    preventNextClick : function(){

      this.__preventNextClick = true;
    },
    _initButtonObserver : function(){

      this.__onButtonEventWrapper = qx.lang.Function.listener(this._onButtonEvent, this);
      var Event = qx.bom.Event;
      Event.addNativeListener(this.__root, "mousedown", this.__onButtonEventWrapper);
      Event.addNativeListener(this.__root, "mouseup", this.__onButtonEventWrapper);
      Event.addNativeListener(this.__root, "click", this.__onButtonEventWrapper);
      Event.addNativeListener(this.__root, "dblclick", this.__onButtonEventWrapper);
      Event.addNativeListener(this.__root, "contextmenu", this.__onButtonEventWrapper);
    },
    _initMoveObserver : function(){

      this.__onMoveEventWrapper = qx.lang.Function.listener(this._onMoveEvent, this);
      var Event = qx.bom.Event;
      Event.addNativeListener(this.__root, "mousemove", this.__onMoveEventWrapper);
      Event.addNativeListener(this.__root, "mouseover", this.__onMoveEventWrapper);
      Event.addNativeListener(this.__root, "mouseout", this.__onMoveEventWrapper);
    },
    _initWheelObserver : function(){

      this.__onWheelEventWrapper = qx.lang.Function.listener(this._onWheelEvent, this);
      var data = qx.bom.client.Event.getMouseWheel(this.__window);
      qx.bom.Event.addNativeListener(data.target, data.type, this.__onWheelEventWrapper);
    },
    _stopButtonObserver : function(){

      var Event = qx.bom.Event;
      Event.removeNativeListener(this.__root, "mousedown", this.__onButtonEventWrapper);
      Event.removeNativeListener(this.__root, "mouseup", this.__onButtonEventWrapper);
      Event.removeNativeListener(this.__root, "click", this.__onButtonEventWrapper);
      Event.removeNativeListener(this.__root, "dblclick", this.__onButtonEventWrapper);
      Event.removeNativeListener(this.__root, "contextmenu", this.__onButtonEventWrapper);
    },
    _stopMoveObserver : function(){

      var Event = qx.bom.Event;
      Event.removeNativeListener(this.__root, "mousemove", this.__onMoveEventWrapper);
      Event.removeNativeListener(this.__root, "mouseover", this.__onMoveEventWrapper);
      Event.removeNativeListener(this.__root, "mouseout", this.__onMoveEventWrapper);
    },
    _stopWheelObserver : function(){

      var data = qx.bom.client.Event.getMouseWheel(this.__window);
      qx.bom.Event.removeNativeListener(data.target, data.type, this.__onWheelEventWrapper);
    },
    _onMoveEvent : qx.event.GlobalError.observeMethod(function(domEvent){

      this.__fireEvent(domEvent);
    }),
    _onButtonEvent : qx.event.GlobalError.observeMethod(function(domEvent){

      var type = domEvent.type;
      var target = qx.bom.Event.getTarget(domEvent);
      if(type == "click" && this.__preventNextClick){

        delete this.__preventNextClick;
        return;
      };
      if(qx.core.Environment.get("engine.name") == "gecko" || qx.core.Environment.get("engine.name") == "webkit"){

        if(target && target.nodeType == 3){

          target = target.parentNode;
        };
      };
      var isDrag = qx.event.handler.DragDrop && this.__manager.getHandler(qx.event.handler.DragDrop).isSessionActive();
      if(isDrag && type == "click"){

        return;
      };
      if(this.__rightClickFixPre){

        this.__rightClickFixPre(domEvent, type, target);
      };
      if(this.__doubleClickFixPre){

        this.__doubleClickFixPre(domEvent, type, target);
      };
      this.__fireEvent(domEvent, type, target);
      if(this.__rightClickFixPost){

        this.__rightClickFixPost(domEvent, type, target);
      };
      if(this.__differentTargetClickFixPost && !isDrag){

        this.__differentTargetClickFixPost(domEvent, type, target);
      };
      this.__lastEventType = type;
    }),
    _onWheelEvent : qx.event.GlobalError.observeMethod(function(domEvent){

      this.__fireEvent(domEvent, "mousewheel");
    }),
    __rightClickFixPre : qx.core.Environment.select("engine.name", {
      "webkit" : function(domEvent, type, target){

        if(parseFloat(qx.core.Environment.get("engine.version")) < 530){

          if(type == "contextmenu"){

            this.__fireEvent(domEvent, "mouseup", target);
          };
        };
      },
      "default" : null
    }),
    __rightClickFixPost : qx.core.Environment.select("engine.name", {
      "opera" : function(domEvent, type, target){

        if(type == "mouseup" && domEvent.button == 2){

          this.__fireEvent(domEvent, "contextmenu", target);
        };
      },
      "default" : null
    }),
    __doubleClickFixPre : qx.core.Environment.select("engine.name", {
      "mshtml" : function(domEvent, type, target){

        if(domEvent.target !== undefined){

          return;
        };
        if(type == "mouseup" && this.__lastEventType == "click"){

          this.__fireEvent(domEvent, "mousedown", target);
        } else if(type == "dblclick"){

          this.__fireEvent(domEvent, "click", target);
        };
      },
      "default" : null
    }),
    __differentTargetClickFixPost : qx.core.Environment.select("engine.name", {
      "mshtml" : null,
      "default" : function(domEvent, type, target){

        switch(type){case "mousedown":
        this.__lastMouseDownTarget = target;
        break;case "mouseup":
        if(target !== this.__lastMouseDownTarget){

          var commonParent = qx.dom.Hierarchy.getCommonParent(target, this.__lastMouseDownTarget);
          if(commonParent){

            this.__fireEvent(domEvent, "click", commonParent);
          };
        };};
      }
    })
  },
  destruct : function(){

    this._stopButtonObserver();
    this._stopMoveObserver();
    this._stopWheelObserver();
    this.__manager = this.__window = this.__root = this.__lastMouseDownTarget = null;
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
  }
});

qx.Class.define("qx.event.type.MouseWheel", {
  extend : qx.event.type.Mouse,
  members : {
    stop : function(){

      this.stopPropagation();
      this.preventDefault();
    },
    getWheelDelta : function(axis){

      return qx.util.Wheel.getDelta(this._native, axis);
    }
  }
});

qx.Class.define("qx.event.handler.Input", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  construct : function(){

    this.base(arguments);
    this._onChangeCheckedWrapper = qx.lang.Function.listener(this._onChangeChecked, this);
    this._onChangeValueWrapper = qx.lang.Function.listener(this._onChangeValue, this);
    this._onInputWrapper = qx.lang.Function.listener(this._onInput, this);
    this._onPropertyWrapper = qx.lang.Function.listener(this._onProperty, this);
    if((qx.core.Environment.get("engine.name") == "opera")){

      this._onKeyDownWrapper = qx.lang.Function.listener(this._onKeyDown, this);
      this._onKeyUpWrapper = qx.lang.Function.listener(this._onKeyUp, this);
      this._onBlurWrapper = qx.lang.Function.listener(this._onBlur, this);
    };
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      input : 1,
      change : 1
    },
    TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE,
    IGNORE_CAN_HANDLE : false
  },
  members : {
    __enter : false,
    __onInputTimeoutId : null,
    __oldValue : null,
    __oldInputValue : null,
    canHandleEvent : function(target, type){

      var lower = target.tagName.toLowerCase();
      if(type === "input" && (lower === "input" || lower === "textarea")){

        return true;
      };
      if(type === "change" && (lower === "input" || lower === "textarea" || lower === "select")){

        return true;
      };
      return false;
    },
    registerEvent : function(target, type, capture){

      if(qx.core.Environment.get("engine.name") == "mshtml" && (qx.core.Environment.get("engine.version") < 9 || (qx.core.Environment.get("engine.version") >= 9 && qx.core.Environment.get("browser.documentmode") < 9))){

        if(!target.__inputHandlerAttached){

          var tag = target.tagName.toLowerCase();
          var elementType = target.type;
          if(elementType === "text" || elementType === "password" || tag === "textarea" || elementType === "checkbox" || elementType === "radio"){

            qx.bom.Event.addNativeListener(target, "propertychange", this._onPropertyWrapper);
          };
          if(elementType !== "checkbox" && elementType !== "radio"){

            qx.bom.Event.addNativeListener(target, "change", this._onChangeValueWrapper);
          };
          if(elementType === "text" || elementType === "password"){

            this._onKeyPressWrapped = qx.lang.Function.listener(this._onKeyPress, this, target);
            qx.bom.Event.addNativeListener(target, "keypress", this._onKeyPressWrapped);
          };
          target.__inputHandlerAttached = true;
        };
      } else {

        if(type === "input"){

          this.__registerInputListener(target);
        } else if(type === "change"){

          if(target.type === "radio" || target.type === "checkbox"){

            qx.bom.Event.addNativeListener(target, "change", this._onChangeCheckedWrapper);
          } else {

            qx.bom.Event.addNativeListener(target, "change", this._onChangeValueWrapper);
          };
          if((qx.core.Environment.get("engine.name") == "opera") || (qx.core.Environment.get("engine.name") == "mshtml")){

            if(target.type === "text" || target.type === "password"){

              this._onKeyPressWrapped = qx.lang.Function.listener(this._onKeyPress, this, target);
              qx.bom.Event.addNativeListener(target, "keypress", this._onKeyPressWrapped);
            };
          };
        };
      };
    },
    __registerInputListener : qx.core.Environment.select("engine.name", {
      "mshtml" : function(target){

        if(qx.core.Environment.get("engine.version") >= 9 && qx.core.Environment.get("browser.documentmode") >= 9){

          qx.bom.Event.addNativeListener(target, "input", this._onInputWrapper);
          if(target.type === "text" || target.type === "password" || target.type === "textarea"){

            this._inputFixWrapper = qx.lang.Function.listener(this._inputFix, this, target);
            qx.bom.Event.addNativeListener(target, "keyup", this._inputFixWrapper);
          };
        };
      },
      "webkit" : function(target){

        var tag = target.tagName.toLowerCase();
        if(parseFloat(qx.core.Environment.get("engine.version")) < 532 && tag == "textarea"){

          qx.bom.Event.addNativeListener(target, "keypress", this._onInputWrapper);
        };
        qx.bom.Event.addNativeListener(target, "input", this._onInputWrapper);
      },
      "opera" : function(target){

        qx.bom.Event.addNativeListener(target, "keyup", this._onKeyUpWrapper);
        qx.bom.Event.addNativeListener(target, "keydown", this._onKeyDownWrapper);
        qx.bom.Event.addNativeListener(target, "blur", this._onBlurWrapper);
        qx.bom.Event.addNativeListener(target, "input", this._onInputWrapper);
      },
      "default" : function(target){

        qx.bom.Event.addNativeListener(target, "input", this._onInputWrapper);
      }
    }),
    unregisterEvent : function(target, type){

      if(qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("engine.version") < 9 && qx.core.Environment.get("browser.documentmode") < 9){

        if(target.__inputHandlerAttached){

          var tag = target.tagName.toLowerCase();
          var elementType = target.type;
          if(elementType === "text" || elementType === "password" || tag === "textarea" || elementType === "checkbox" || elementType === "radio"){

            qx.bom.Event.removeNativeListener(target, "propertychange", this._onPropertyWrapper);
          };
          if(elementType !== "checkbox" && elementType !== "radio"){

            qx.bom.Event.removeNativeListener(target, "change", this._onChangeValueWrapper);
          };
          if(elementType === "text" || elementType === "password"){

            qx.bom.Event.removeNativeListener(target, "keypress", this._onKeyPressWrapped);
          };
          try{

            delete target.__inputHandlerAttached;
          } catch(ex) {

            target.__inputHandlerAttached = null;
          };
        };
      } else {

        if(type === "input"){

          this.__unregisterInputListener(target);
        } else if(type === "change"){

          if(target.type === "radio" || target.type === "checkbox"){

            qx.bom.Event.removeNativeListener(target, "change", this._onChangeCheckedWrapper);
          } else {

            qx.bom.Event.removeNativeListener(target, "change", this._onChangeValueWrapper);
          };
        };
        if((qx.core.Environment.get("engine.name") == "opera") || (qx.core.Environment.get("engine.name") == "mshtml")){

          if(target.type === "text" || target.type === "password"){

            qx.bom.Event.removeNativeListener(target, "keypress", this._onKeyPressWrapped);
          };
        };
      };
    },
    __unregisterInputListener : qx.core.Environment.select("engine.name", {
      "mshtml" : function(target){

        if(qx.core.Environment.get("engine.version") >= 9 && qx.core.Environment.get("browser.documentmode") >= 9){

          qx.bom.Event.removeNativeListener(target, "input", this._onInputWrapper);
          if(target.type === "text" || target.type === "password" || target.type === "textarea"){

            qx.bom.Event.removeNativeListener(target, "keyup", this._inputFixWrapper);
          };
        };
      },
      "webkit" : function(target){

        var tag = target.tagName.toLowerCase();
        if(parseFloat(qx.core.Environment.get("engine.version")) < 532 && tag == "textarea"){

          qx.bom.Event.removeNativeListener(target, "keypress", this._onInputWrapper);
        };
        qx.bom.Event.removeNativeListener(target, "input", this._onInputWrapper);
      },
      "opera" : function(target){

        qx.bom.Event.removeNativeListener(target, "keyup", this._onKeyUpWrapper);
        qx.bom.Event.removeNativeListener(target, "keydown", this._onKeyDownWrapper);
        qx.bom.Event.removeNativeListener(target, "blur", this._onBlurWrapper);
        qx.bom.Event.removeNativeListener(target, "input", this._onInputWrapper);
      },
      "default" : function(target){

        qx.bom.Event.removeNativeListener(target, "input", this._onInputWrapper);
      }
    }),
    _onKeyPress : qx.core.Environment.select("engine.name", {
      "mshtml|opera" : function(e, target){

        if(e.keyCode === 13){

          if(target.value !== this.__oldValue){

            this.__oldValue = target.value;
            qx.event.Registration.fireEvent(target, "change", qx.event.type.Data, [target.value]);
          };
        };
      },
      "default" : null
    }),
    _inputFix : qx.core.Environment.select("engine.name", {
      "mshtml" : function(e, target){

        if(e.keyCode === 46 || e.keyCode === 8){

          if(target.value !== this.__oldInputValue){

            this.__oldInputValue = target.value;
            qx.event.Registration.fireEvent(target, "input", qx.event.type.Data, [target.value]);
          };
        };
      },
      "default" : null
    }),
    _onKeyDown : qx.core.Environment.select("engine.name", {
      "opera" : function(e){

        if(e.keyCode === 13){

          this.__enter = true;
        };
      },
      "default" : null
    }),
    _onKeyUp : qx.core.Environment.select("engine.name", {
      "opera" : function(e){

        if(e.keyCode === 13){

          this.__enter = false;
        };
      },
      "default" : null
    }),
    _onBlur : qx.core.Environment.select("engine.name", {
      "opera" : function(e){

        if(this.__onInputTimeoutId && qx.core.Environment.get("browser.version") < 10.6){

          window.clearTimeout(this.__onInputTimeoutId);
        };
      },
      "default" : null
    }),
    _onInput : qx.event.GlobalError.observeMethod(function(e){

      var target = qx.bom.Event.getTarget(e);
      var tag = target.tagName.toLowerCase();
      if(!this.__enter || tag !== "input"){

        if((qx.core.Environment.get("engine.name") == "opera") && qx.core.Environment.get("browser.version") < 10.6){

          this.__onInputTimeoutId = window.setTimeout(function(){

            qx.event.Registration.fireEvent(target, "input", qx.event.type.Data, [target.value]);
          }, 0);
        } else {

          qx.event.Registration.fireEvent(target, "input", qx.event.type.Data, [target.value]);
        };
      };
    }),
    _onChangeValue : qx.event.GlobalError.observeMethod(function(e){

      var target = qx.bom.Event.getTarget(e);
      var data = target.value;
      if(target.type === "select-multiple"){

        var data = [];
        for(var i = 0,o = target.options,l = o.length;i < l;i++){

          if(o[i].selected){

            data.push(o[i].value);
          };
        };
      };
      qx.event.Registration.fireEvent(target, "change", qx.event.type.Data, [data]);
    }),
    _onChangeChecked : qx.event.GlobalError.observeMethod(function(e){

      var target = qx.bom.Event.getTarget(e);
      if(target.type === "radio"){

        if(target.checked){

          qx.event.Registration.fireEvent(target, "change", qx.event.type.Data, [target.value]);
        };
      } else {

        qx.event.Registration.fireEvent(target, "change", qx.event.type.Data, [target.checked]);
      };
    }),
    _onProperty : qx.core.Environment.select("engine.name", {
      "mshtml" : qx.event.GlobalError.observeMethod(function(e){

        var target = qx.bom.Event.getTarget(e);
        var prop = e.propertyName;
        if(prop === "value" && (target.type === "text" || target.type === "password" || target.tagName.toLowerCase() === "textarea")){

          if(!target.$$inValueSet){

            qx.event.Registration.fireEvent(target, "input", qx.event.type.Data, [target.value]);
          };
        } else if(prop === "checked"){

          if(target.type === "checkbox"){

            qx.event.Registration.fireEvent(target, "change", qx.event.type.Data, [target.checked]);
          } else if(target.checked){

            qx.event.Registration.fireEvent(target, "change", qx.event.type.Data, [target.value]);
          };
        };
      }),
      "default" : function(){
      }
    })
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
  }
});

qx.Class.define("qx.event.handler.Capture", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      capture : true,
      losecapture : true
    },
    TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE,
    IGNORE_CAN_HANDLE : true
  },
  members : {
    canHandleEvent : function(target, type){
    },
    registerEvent : function(target, type, capture){
    },
    unregisterEvent : function(target, type, capture){
    }
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
  }
});

qx.Class.define("qx.event.handler.DragDrop", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  construct : function(manager){

    this.base(arguments);
    this.__manager = manager;
    this.__root = manager.getWindow().document.documentElement;
    this.__manager.addListener(this.__root, "longtap", this._onLongtap, this);
    this.__manager.addListener(this.__root, "trackstart", this._onTrackStart, this);
    this.__manager.addListener(this.__root, "track", this._onTrack, this);
    this.__manager.addListener(this.__root, "trackend", this._onTrackEnd, this);
    qx.event.Registration.addListener(window, "blur", this._onWindowBlur, this);
    this.__rebuildStructures();
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      dragstart : 1,
      dragend : 1,
      dragover : 1,
      dragleave : 1,
      drop : 1,
      drag : 1,
      dragchange : 1,
      droprequest : 1
    },
    IGNORE_CAN_HANDLE : true,
    ALLOWED_BUTTONS : ["left"],
    MIN_DRAG_DISTANCE : 5
  },
  properties : {
    cursor : {
      check : "qx.ui.core.Widget",
      nullable : true,
      init : null
    }
  },
  members : {
    __manager : null,
    __root : null,
    __dropTarget : null,
    __dragTarget : null,
    __types : null,
    __actions : null,
    __keys : null,
    __cache : null,
    __currentType : null,
    __currentAction : null,
    __sessionActive : false,
    __validDrop : false,
    __validAction : false,
    __dragTargetWidget : null,
    __startTargets : null,
    __escaped : false,
    canHandleEvent : function(target, type){
    },
    registerEvent : function(target, type, capture){
    },
    unregisterEvent : function(target, type, capture){
    },
    addType : function(type){

      this.__types[type] = true;
    },
    addAction : function(action){

      this.__actions[action] = true;
    },
    supportsType : function(type){

      return !!this.__types[type];
    },
    supportsAction : function(type){

      return !!this.__actions[type];
    },
    getData : function(type){

      if(!this.__validDrop || !this.__dropTarget){

        throw new Error("This method must not be used outside the drop event listener!");
      };
      if(!this.__types[type]){

        throw new Error("Unsupported data type: " + type + "!");
      };
      if(!this.__cache[type]){

        this.__currentType = type;
        this.__fireEvent("droprequest", this.__dragTarget, this.__dropTarget, false);
      };
      if(!this.__cache[type]){

        throw new Error("Please use a droprequest listener to the drag source to fill the manager with data!");
      };
      return this.__cache[type] || null;
    },
    getCurrentAction : function(){

      this.__detectAction();
      return this.__currentAction;
    },
    getDragTarget : function(){

      return this.__dragTargetWidget;
    },
    addData : function(type, data){

      this.__cache[type] = data;
    },
    getCurrentType : function(){

      return this.__currentType;
    },
    isSessionActive : function(){

      return this.__sessionActive;
    },
    __rebuildStructures : function(){

      this.__types = {
      };
      this.__actions = {
      };
      this.__keys = {
      };
      this.__cache = {
      };
    },
    __detectAction : function(){

      if(this.__dragTarget == null){

        return;
      };
      var actions = this.__actions;
      var keys = this.__keys;
      var current = null;
      if(this.__validDrop){

        if(keys.Shift && keys.Control && actions.alias){

          current = "alias";
        } else if(keys.Shift && keys.Alt && actions.copy){

          current = "copy";
        } else if(keys.Shift && actions.move){

          current = "move";
        } else if(keys.Alt && actions.alias){

          current = "alias";
        } else if(keys.Control && actions.copy){

          current = "copy";
        } else if(actions.move){

          current = "move";
        } else if(actions.copy){

          current = "copy";
        } else if(actions.alias){

          current = "alias";
        };;;;;;;
      };
      var old = this.__currentAction;
      if(current != old){

        if(this.__dropTarget){

          this.__currentAction = current;
          this.__validAction = this.__fireEvent("dragchange", this.__dropTarget, this.__dragTarget, true);
          if(!this.__validAction){

            current = null;
          };
        };
        if(current != old){

          this.__currentAction = current;
          this.__fireEvent("dragchange", this.__dragTarget, this.__dropTarget, false);
        };
      };
    },
    __fireEvent : function(type, target, relatedTarget, cancelable, original){

      var Registration = qx.event.Registration;
      var dragEvent = Registration.createEvent(type, qx.event.type.Drag, [cancelable, original]);
      if(target !== relatedTarget){

        dragEvent.setRelatedTarget(relatedTarget);
      };
      return Registration.dispatchEvent(target, dragEvent);
    },
    __findDraggable : function(elem){

      while(elem && elem.nodeType == 1){

        if(elem.getAttribute("qxDraggable") == "on"){

          return elem;
        };
        elem = elem.parentNode;
      };
      return null;
    },
    __findDroppable : function(elem){

      while(elem && elem.nodeType == 1){

        if(elem.getAttribute("qxDroppable") == "on"){

          return elem;
        };
        elem = elem.parentNode;
      };
      return null;
    },
    clearSession : function(){

      this.__manager.removeListener(this.__root, "keydown", this._onKeyDown, this, true);
      this.__manager.removeListener(this.__root, "keyup", this._onKeyUp, this, true);
      this.__manager.removeListener(this.__root, "keypress", this._onKeyPress, this, true);
      this.__manager.removeListener(this.__root, "roll", this._onRoll, this, true);
      if(this.__dragTarget){

        this.__fireEvent("dragend", this.__dragTarget, this.__dropTarget, false);
      };
      this.__validDrop = false;
      this.__dropTarget = null;
      if(this.__dragTargetWidget){

        this.__dragTargetWidget.removeState("drag");
        this.__dragTargetWidget = null;
      };
      this.__dragTarget = null;
      this.__sessionActive = false;
      this.__startTargets = null;
      this.__rebuildStructures();
    },
    _onLongtap : function(e){

      if(e.getPointerType() != "touch"){

        return;
      };
      this.__manager.addListener(this.__root, "roll", this._onRoll, this, true);
      this._start(e);
    },
    _start : function(e){

      var isButtonOk = qx.event.handler.DragDrop.ALLOWED_BUTTONS.indexOf(e.getButton()) !== -1;
      if(!e.isPrimary() || !isButtonOk){

        return;
      };
      var target = this.__startTargets ? this.__startTargets.target : e.getTarget();
      var dragable = this.__findDraggable(target);
      if(dragable){

        this.__dragTarget = dragable;
        var widgetOriginalTarget = qx.ui.core.Widget.getWidgetByElement(this.__startTargets.original);
        while(widgetOriginalTarget && widgetOriginalTarget.isAnonymous()){

          widgetOriginalTarget = widgetOriginalTarget.getLayoutParent();
        };
        if(widgetOriginalTarget){

          this.__dragTargetWidget = widgetOriginalTarget;
          widgetOriginalTarget.addState("drag");
        };
        if(!this.__fireEvent("dragstart", this.__dragTarget, this.__dropTarget, true, e)){

          this.__dragTargetWidget = null;
          return;
        };
        this.__manager.addListener(this.__root, "keydown", this._onKeyDown, this, true);
        this.__manager.addListener(this.__root, "keyup", this._onKeyUp, this, true);
        this.__manager.addListener(this.__root, "keypress", this._onKeyPress, this, true);
        this.__sessionActive = true;
      };
    },
    _onTrackStart : function(e){

      if(e.isPrimary()){

        this.__startTargets = {
          target : e.getTarget(),
          original : e.getOriginalTarget()
        };
      };
    },
    _onTrack : function(e){

      if(!e.isPrimary()){

        return;
      };
      if(this.__escaped){

        return;
      };
      if(!this.__sessionActive && e.getPointerType() == "mouse"){

        var delta = e.getDelta();
        var distance = qx.event.handler.DragDrop.MIN_DRAG_DISTANCE;
        if(Math.abs(delta.x) > distance || Math.abs(delta.y) > distance){

          this._start(e);
        };
      };
      if(!this.__sessionActive){

        return;
      };
      if(!this.__fireEvent("drag", this.__dragTarget, this.__dropTarget, true, e)){

        this.clearSession();
      };
      var doc = this.__manager.getWindow().document;
      var el = doc.elementFromPoint(e.getDocumentLeft(), e.getDocumentTop());
      var cursor = this.getCursor();
      if(!cursor){

        cursor = qx.ui.core.DragDropCursor.getInstance();
      };
      var cursorEl = cursor.getContentElement().getDomElement();
      if(el !== cursorEl){

        var droppable = this.__findDroppable(el);
        if(droppable && droppable != this.__dropTarget){

          if(this.__dropTarget){

            this.__fireEvent("dragleave", this.__dropTarget, this.__dragTarget, false, e);
          };
          this.__validDrop = true;
          this.__dropTarget = droppable;
          this.__validDrop = this.__fireEvent("dragover", droppable, this.__dragTarget, true, e);
        } else if(!droppable && this.__dropTarget){

          this.__fireEvent("dragleave", this.__dropTarget, this.__dragTarget, false, e);
          this.__dropTarget = null;
          this.__validDrop = false;
          qx.event.Timer.once(this.__detectAction, this, 0);
        };
      };
      var keys = this.__keys;
      keys.Control = e.isCtrlPressed();
      keys.Shift = e.isShiftPressed();
      keys.Alt = e.isAltPressed();
      this.__detectAction();
    },
    _onTrackEnd : function(e){

      if(!e.isPrimary()){

        return;
      };
      if(this.__validDrop && this.__validAction){

        this.__fireEvent("drop", this.__dropTarget, this.__dragTarget, false, e);
      };
      if(e.getTarget() == this.__dragTarget){

        e.stopPropagation();
      };
      this.clearSession();
      this.__escaped = false;
    },
    _onRoll : function(e){

      e.stop();
    },
    _onWindowBlur : function(e){

      this.clearSession();
    },
    _onKeyDown : function(e){

      var iden = e.getKeyIdentifier();
      switch(iden){case "Alt":case "Control":case "Shift":
      if(!this.__keys[iden]){

        this.__keys[iden] = true;
        this.__detectAction();
      };};
    },
    _onKeyUp : function(e){

      var iden = e.getKeyIdentifier();
      switch(iden){case "Alt":case "Control":case "Shift":
      if(this.__keys[iden]){

        this.__keys[iden] = false;
        this.__detectAction();
      };};
    },
    _onKeyPress : function(e){

      var iden = e.getKeyIdentifier();
      switch(iden){case "Escape":
      this.clearSession();
      this.__escaped = true;};
    }
  },
  destruct : function(){

    this.__dragTarget = this.__dropTarget = this.__manager = this.__root = this.__types = this.__actions = this.__keys = this.__cache = null;
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
  }
});

qx.Class.define("qx.event.type.Drag", {
  extend : qx.event.type.Event,
  members : {
    init : function(cancelable, originalEvent){

      this.base(arguments, true, cancelable);
      if(originalEvent){

        this._native = originalEvent.getNativeEvent() || null;
        this._originalTarget = originalEvent.getOriginalTarget() || null;
      } else {

        this._native = null;
        this._originalTarget = null;
      };
      return this;
    },
    clone : function(embryo){

      var clone = this.base(arguments, embryo);
      clone._native = this._native;
      return clone;
    },
    getDocumentLeft : function(){

      if(this._native == null){

        return 0;
      };
      var x = this._native.pageX;
      if(x !== undefined){

        if(x == 0 && this._native.pointerType == "touch"){

          x = this._native._original.changedTouches[0].pageX || 0;
        };
        return Math.round(x);
      } else {

        var win = qx.dom.Node.getWindow(this._native.srcElement);
        return Math.round(this._native.clientX) + qx.bom.Viewport.getScrollLeft(win);
      };
    },
    getDocumentTop : function(){

      if(this._native == null){

        return 0;
      };
      var y = this._native.pageY;
      if(y !== undefined){

        if(y == 0 && this._native.pointerType == "touch"){

          y = this._native._original.changedTouches[0].pageY || 0;
        };
        return Math.round(y);
      } else {

        var win = qx.dom.Node.getWindow(this._native.srcElement);
        return Math.round(this._native.clientY) + qx.bom.Viewport.getScrollTop(win);
      };
    },
    getManager : function(){

      return qx.event.Registration.getManager(this.getTarget()).getHandler(qx.event.handler.DragDrop);
    },
    addType : function(type){

      this.getManager().addType(type);
    },
    addAction : function(action){

      this.getManager().addAction(action);
    },
    supportsType : function(type){

      return this.getManager().supportsType(type);
    },
    supportsAction : function(action){

      return this.getManager().supportsAction(action);
    },
    addData : function(type, data){

      this.getManager().addData(type, data);
    },
    getData : function(type){

      return this.getManager().getData(type);
    },
    getCurrentType : function(){

      return this.getManager().getCurrentType();
    },
    getCurrentAction : function(){

      if(this.getDefaultPrevented()){

        return null;
      };
      return this.getManager().getCurrentAction();
    },
    getDragTarget : function(){

      return this.getManager().getDragTarget();
    },
    stopSession : function(){

      this.getManager().clearSession();
    }
  }
});

qx.Class.define("qx.ui.core.LayoutItem", {
  type : "abstract",
  extend : qx.core.Object,
  construct : function(){

    this.base(arguments);
    if(qx.core.Environment.get("qx.dyntheme")){

      qx.theme.manager.Appearance.getInstance().addListener("changeTheme", this._onChangeTheme, this);
      qx.theme.manager.Color.getInstance().addListener("changeTheme", this._onChangeTheme, this);
    };
  },
  properties : {
    minWidth : {
      check : "Integer",
      nullable : true,
      apply : "_applyDimension",
      init : null,
      themeable : true
    },
    width : {
      check : "Integer",
      event : "changeWidth",
      nullable : true,
      apply : "_applyDimension",
      init : null,
      themeable : true
    },
    maxWidth : {
      check : "Integer",
      nullable : true,
      apply : "_applyDimension",
      init : null,
      themeable : true
    },
    minHeight : {
      check : "Integer",
      nullable : true,
      apply : "_applyDimension",
      init : null,
      themeable : true
    },
    height : {
      check : "Integer",
      event : "changeHeight",
      nullable : true,
      apply : "_applyDimension",
      init : null,
      themeable : true
    },
    maxHeight : {
      check : "Integer",
      nullable : true,
      apply : "_applyDimension",
      init : null,
      themeable : true
    },
    allowGrowX : {
      check : "Boolean",
      apply : "_applyStretching",
      init : true,
      themeable : true
    },
    allowShrinkX : {
      check : "Boolean",
      apply : "_applyStretching",
      init : true,
      themeable : true
    },
    allowGrowY : {
      check : "Boolean",
      apply : "_applyStretching",
      init : true,
      themeable : true
    },
    allowShrinkY : {
      check : "Boolean",
      apply : "_applyStretching",
      init : true,
      themeable : true
    },
    allowStretchX : {
      group : ["allowGrowX", "allowShrinkX"],
      mode : "shorthand",
      themeable : true
    },
    allowStretchY : {
      group : ["allowGrowY", "allowShrinkY"],
      mode : "shorthand",
      themeable : true
    },
    marginTop : {
      check : "Integer",
      init : 0,
      apply : "_applyMargin",
      themeable : true
    },
    marginRight : {
      check : "Integer",
      init : 0,
      apply : "_applyMargin",
      themeable : true
    },
    marginBottom : {
      check : "Integer",
      init : 0,
      apply : "_applyMargin",
      themeable : true
    },
    marginLeft : {
      check : "Integer",
      init : 0,
      apply : "_applyMargin",
      themeable : true
    },
    margin : {
      group : ["marginTop", "marginRight", "marginBottom", "marginLeft"],
      mode : "shorthand",
      themeable : true
    },
    alignX : {
      check : ["left", "center", "right"],
      nullable : true,
      apply : "_applyAlign",
      themeable : true
    },
    alignY : {
      check : ["top", "middle", "bottom", "baseline"],
      nullable : true,
      apply : "_applyAlign",
      themeable : true
    }
  },
  members : {
    _onChangeTheme : qx.core.Environment.select("qx.dyntheme", {
      "true" : function(){

        var props = qx.util.PropertyUtil.getAllProperties(this.constructor);
        for(var name in props){

          var desc = props[name];
          if(desc.themeable){

            var userValue = qx.util.PropertyUtil.getUserValue(this, name);
            if(userValue == null){

              qx.util.PropertyUtil.resetThemed(this, name);
            };
          };
        };
      },
      "false" : null
    }),
    __computedHeightForWidth : null,
    __computedLayout : null,
    __hasInvalidLayout : null,
    __sizeHint : null,
    __updateMargin : null,
    __userBounds : null,
    __layoutProperties : null,
    getBounds : function(){

      return this.__userBounds || this.__computedLayout || null;
    },
    clearSeparators : function(){
    },
    renderSeparator : function(separator, bounds){
    },
    renderLayout : function(left, top, width, height){

      if(qx.core.Environment.get("qx.debug")){

        var msg = "Something went wrong with the layout of " + this.toString() + "!";
        this.assertInteger(left, "Wrong 'left' argument. " + msg);
        this.assertInteger(top, "Wrong 'top' argument. " + msg);
        this.assertInteger(width, "Wrong 'width' argument. " + msg);
        this.assertInteger(height, "Wrong 'height' argument. " + msg);
      };
      var flowHeight = null;
      if(this.getHeight() == null && this._hasHeightForWidth()){

        var flowHeight = this._getHeightForWidth(width);
      };
      if(flowHeight != null && flowHeight !== this.__computedHeightForWidth){

        this.__computedHeightForWidth = flowHeight;
        qx.ui.core.queue.Layout.add(this);
        return null;
      };
      var computed = this.__computedLayout;
      if(!computed){

        computed = this.__computedLayout = {
        };
      };
      var changes = {
      };
      if(left !== computed.left || top !== computed.top){

        changes.position = true;
        computed.left = left;
        computed.top = top;
      };
      if(width !== computed.width || height !== computed.height){

        changes.size = true;
        computed.width = width;
        computed.height = height;
      };
      if(this.__hasInvalidLayout){

        changes.local = true;
        delete this.__hasInvalidLayout;
      };
      if(this.__updateMargin){

        changes.margin = true;
        delete this.__updateMargin;
      };
      return changes;
    },
    isExcluded : function(){

      return false;
    },
    hasValidLayout : function(){

      return !this.__hasInvalidLayout;
    },
    scheduleLayoutUpdate : function(){

      qx.ui.core.queue.Layout.add(this);
    },
    invalidateLayoutCache : function(){

      this.__hasInvalidLayout = true;
      this.__sizeHint = null;
    },
    getSizeHint : function(compute){

      var hint = this.__sizeHint;
      if(hint){

        return hint;
      };
      if(compute === false){

        return null;
      };
      hint = this.__sizeHint = this._computeSizeHint();
      if(this._hasHeightForWidth() && this.__computedHeightForWidth && this.getHeight() == null){

        hint.height = this.__computedHeightForWidth;
      };
      if(hint.minWidth > hint.width){

        hint.width = hint.minWidth;
      };
      if(hint.maxWidth < hint.width){

        hint.width = hint.maxWidth;
      };
      if(!this.getAllowGrowX()){

        hint.maxWidth = hint.width;
      };
      if(!this.getAllowShrinkX()){

        hint.minWidth = hint.width;
      };
      if(hint.minHeight > hint.height){

        hint.height = hint.minHeight;
      };
      if(hint.maxHeight < hint.height){

        hint.height = hint.maxHeight;
      };
      if(!this.getAllowGrowY()){

        hint.maxHeight = hint.height;
      };
      if(!this.getAllowShrinkY()){

        hint.minHeight = hint.height;
      };
      return hint;
    },
    _computeSizeHint : function(){

      var minWidth = this.getMinWidth() || 0;
      var minHeight = this.getMinHeight() || 0;
      var width = this.getWidth() || minWidth;
      var height = this.getHeight() || minHeight;
      var maxWidth = this.getMaxWidth() || Infinity;
      var maxHeight = this.getMaxHeight() || Infinity;
      return {
        minWidth : minWidth,
        width : width,
        maxWidth : maxWidth,
        minHeight : minHeight,
        height : height,
        maxHeight : maxHeight
      };
    },
    _hasHeightForWidth : function(){

      var layout = this._getLayout();
      if(layout){

        return layout.hasHeightForWidth();
      };
      return false;
    },
    _getHeightForWidth : function(width){

      var layout = this._getLayout();
      if(layout && layout.hasHeightForWidth()){

        return layout.getHeightForWidth(width);
      };
      return null;
    },
    _getLayout : function(){

      return null;
    },
    _applyMargin : function(){

      this.__updateMargin = true;
      var parent = this.$$parent;
      if(parent){

        parent.updateLayoutProperties();
      };
    },
    _applyAlign : function(){

      var parent = this.$$parent;
      if(parent){

        parent.updateLayoutProperties();
      };
    },
    _applyDimension : function(){

      qx.ui.core.queue.Layout.add(this);
    },
    _applyStretching : function(){

      qx.ui.core.queue.Layout.add(this);
    },
    hasUserBounds : function(){

      return !!this.__userBounds;
    },
    setUserBounds : function(left, top, width, height){

      this.__userBounds = {
        left : left,
        top : top,
        width : width,
        height : height
      };
      qx.ui.core.queue.Layout.add(this);
    },
    resetUserBounds : function(){

      delete this.__userBounds;
      qx.ui.core.queue.Layout.add(this);
    },
    __emptyProperties : {
    },
    setLayoutProperties : function(props){

      if(props == null){

        return;
      };
      var storage = this.__layoutProperties;
      if(!storage){

        storage = this.__layoutProperties = {
        };
      };
      var parent = this.getLayoutParent();
      if(parent){

        parent.updateLayoutProperties(props);
      };
      for(var key in props){

        if(props[key] == null){

          delete storage[key];
        } else {

          storage[key] = props[key];
        };
      };
    },
    getLayoutProperties : function(){

      return this.__layoutProperties || this.__emptyProperties;
    },
    clearLayoutProperties : function(){

      delete this.__layoutProperties;
    },
    updateLayoutProperties : function(props){

      var layout = this._getLayout();
      if(layout){

        if(qx.core.Environment.get("qx.debug")){

          if(props){

            for(var key in props){

              if(props[key] !== null){

                layout.verifyLayoutProperty(this, key, props[key]);
              };
            };
          };
        };
        layout.invalidateChildrenCache();
      };
      qx.ui.core.queue.Layout.add(this);
    },
    getApplicationRoot : function(){

      return qx.core.Init.getApplication().getRoot();
    },
    getLayoutParent : function(){

      return this.$$parent || null;
    },
    setLayoutParent : function(parent){

      if(this.$$parent === parent){

        return;
      };
      this.$$parent = parent || null;
      qx.ui.core.queue.Visibility.add(this);
    },
    isRootWidget : function(){

      return false;
    },
    _getRoot : function(){

      var parent = this;
      while(parent){

        if(parent.isRootWidget()){

          return parent;
        };
        parent = parent.$$parent;
      };
      return null;
    },
    clone : function(){

      var clone = this.base(arguments);
      var props = this.__layoutProperties;
      if(props){

        clone.__layoutProperties = qx.lang.Object.clone(props);
      };
      return clone;
    }
  },
  destruct : function(){

    if(qx.core.Environment.get("qx.dyntheme")){

      qx.theme.manager.Appearance.getInstance().removeListener("changeTheme", this._onChangeTheme, this);
      qx.theme.manager.Color.getInstance().removeListener("changeTheme", this._onChangeTheme, this);
    };
    this.$$parent = this.$$subparent = this.__layoutProperties = this.__computedLayout = this.__userBounds = this.__sizeHint = null;
  }
});

qx.Class.define("qx.theme.manager.Appearance", {
  type : "singleton",
  extend : qx.core.Object,
  construct : function(){

    this.base(arguments);
    this.__styleCache = {
    };
    this.__aliasMap = {
    };
  },
  properties : {
    theme : {
      check : "Theme",
      nullable : true,
      event : "changeTheme",
      apply : "_applyTheme"
    }
  },
  members : {
    __defaultStates : {
    },
    __styleCache : null,
    __aliasMap : null,
    _applyTheme : function(){

      this.__aliasMap = {
      };
      this.__styleCache = {
      };
    },
    __resolveId : function(id, theme, defaultId, chain){

      var db = theme.appearances;
      var entry = db[id];
      if(!entry){

        var divider = "/";
        var end = [];
        var splitted = id.split(divider);
        var chainCopy = qx.lang.Array.clone(splitted);
        var alias;
        while(!entry && splitted.length > 0){

          end.unshift(splitted.pop());
          var baseid = splitted.join(divider);
          entry = db[baseid];
          if(entry){

            alias = entry.alias || entry;
            if(typeof alias === "string"){

              var mapped = alias + divider + end.join(divider);
              return this.__resolveId(mapped, theme, defaultId, chainCopy);
            };
          };
        };
        for(var i = 0;i < end.length - 1;i++){

          end.shift();
          var subId = end.join(divider);
          var resolved = this.__resolveId(subId, theme, null, chainCopy);
          if(resolved){

            return resolved;
          };
        };
        if(defaultId != null){

          return this.__resolveId(defaultId, theme, null, chainCopy);
        };
        if(qx.core.Environment.get("qx.debug")){

          if(typeof chain !== "undefined"){

            this.debug("Cannot find a matching appearance for '" + chain.join("/") + "'.");
            if(chain.length > 1){

              this.info("Hint: This may be an issue with nested child controls and a missing alias definition in the appearance theme.");
            };
          };
        };
        return null;
      } else if(typeof entry === "string"){

        return this.__resolveId(entry, theme, defaultId, chainCopy);
      } else if(entry.include && !entry.style){

        return this.__resolveId(entry.include, theme, defaultId, chainCopy);
      };;
      return id;
    },
    styleFrom : function(id, states, theme, defaultId){

      if(!theme){

        theme = this.getTheme();
      };
      var aliasMap = this.__aliasMap;
      var resolved = aliasMap[id];
      if(!resolved){

        resolved = aliasMap[id] = this.__resolveId(id, theme, defaultId);
      };
      var entry = theme.appearances[resolved];
      if(!entry){

        this.warn("Missing appearance: " + id);
        return null;
      };
      if(!entry.style){

        return null;
      };
      var unique = resolved;
      if(states){

        var bits = entry.$$bits;
        if(!bits){

          bits = entry.$$bits = {
          };
          entry.$$length = 0;
        };
        var sum = 0;
        for(var state in states){

          if(!states[state]){

            continue;
          };
          if(bits[state] == null){

            bits[state] = 1 << entry.$$length++;
          };
          sum += bits[state];
        };
        if(sum > 0){

          unique += ":" + sum;
        };
      };
      var cache = this.__styleCache;
      if(cache[unique] !== undefined){

        return cache[unique];
      };
      if(!states){

        states = this.__defaultStates;
      };
      var result;
      if(entry.include || entry.base){

        var incl;
        if(entry.include){

          incl = this.styleFrom(entry.include, states, theme, defaultId);
        };
        var local = entry.style(states, incl);
        result = {
        };
        if(entry.base){

          var base = this.styleFrom(resolved, states, entry.base, defaultId);
          if(entry.include){

            for(var baseIncludeKey in base){

              if(!incl.hasOwnProperty(baseIncludeKey) && !local.hasOwnProperty(baseIncludeKey)){

                result[baseIncludeKey] = base[baseIncludeKey];
              };
            };
          } else {

            for(var baseKey in base){

              if(!local.hasOwnProperty(baseKey)){

                result[baseKey] = base[baseKey];
              };
            };
          };
        };
        if(entry.include){

          for(var includeKey in incl){

            if(!local.hasOwnProperty(includeKey)){

              result[includeKey] = incl[includeKey];
            };
          };
        };
        for(var localKey in local){

          result[localKey] = local[localKey];
        };
      } else {

        result = entry.style(states);
      };
      return cache[unique] = result || null;
    }
  },
  destruct : function(){

    this.__styleCache = this.__aliasMap = null;
  }
});

qx.Class.define("qx.util.ValueManager", {
  type : "abstract",
  extend : qx.core.Object,
  construct : function(){

    this.base(arguments);
    this._dynamic = {
    };
  },
  members : {
    _dynamic : null,
    resolveDynamic : function(value){

      return this._dynamic[value];
    },
    isDynamic : function(value){

      return !!this._dynamic[value];
    },
    resolve : function(value){

      if(value && this._dynamic[value]){

        return this._dynamic[value];
      };
      return value;
    },
    _setDynamic : function(value){

      this._dynamic = value;
    },
    _getDynamic : function(){

      return this._dynamic;
    }
  },
  destruct : function(){

    this._dynamic = null;
  }
});

qx.Class.define("qx.theme.manager.Color", {
  type : "singleton",
  extend : qx.util.ValueManager,
  properties : {
    theme : {
      check : "Theme",
      nullable : true,
      apply : "_applyTheme",
      event : "changeTheme"
    }
  },
  members : {
    _applyTheme : function(value){

      var dest = {
      };
      if(value){

        var colors = value.colors;
        for(var name in colors){

          dest[name] = this.__parseColor(colors, name);
        };
      };
      this._setDynamic(dest);
    },
    __parseColor : function(colors, name){

      var color = colors[name];
      if(typeof color === "string"){

        if(!qx.util.ColorUtil.isCssString(color)){

          if(colors[color] != undefined){

            return this.__parseColor(colors, color);
          };
          throw new Error("Could not parse color: " + color);
        };
        return color;
      } else if(color instanceof Array){

        return qx.util.ColorUtil.rgbToRgbString(color);
      };
      throw new Error("Could not parse color: " + color);
    },
    resolve : function(value){

      var cache = this._dynamic;
      var resolved = cache[value];
      if(resolved){

        return resolved;
      };
      var theme = this.getTheme();
      if(theme !== null && theme.colors[value]){

        return cache[value] = theme.colors[value];
      };
      return value;
    },
    isDynamic : function(value){

      var cache = this._dynamic;
      if(value && (cache[value] !== undefined)){

        return true;
      };
      var theme = this.getTheme();
      if(theme !== null && value && (theme.colors[value] !== undefined)){

        cache[value] = theme.colors[value];
        return true;
      };
      return false;
    }
  }
});

qx.Bootstrap.define("qx.util.ColorUtil", {
  statics : {
    REGEXP : {
      hex3 : /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6 : /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      rgb : /^rgb\(\s*([0-9]{1,3}\.{0,1}[0-9]*)\s*,\s*([0-9]{1,3}\.{0,1}[0-9]*)\s*,\s*([0-9]{1,3}\.{0,1}[0-9]*)\s*\)$/,
      rgba : /^rgba\(\s*([0-9]{1,3}\.{0,1}[0-9]*)\s*,\s*([0-9]{1,3}\.{0,1}[0-9]*)\s*,\s*([0-9]{1,3}\.{0,1}[0-9]*)\s*,\s*([0-9]{1,3}\.{0,1}[0-9]*)\s*\)$/
    },
    SYSTEM : {
      activeborder : true,
      activecaption : true,
      appworkspace : true,
      background : true,
      buttonface : true,
      buttonhighlight : true,
      buttonshadow : true,
      buttontext : true,
      captiontext : true,
      graytext : true,
      highlight : true,
      highlighttext : true,
      inactiveborder : true,
      inactivecaption : true,
      inactivecaptiontext : true,
      infobackground : true,
      infotext : true,
      menu : true,
      menutext : true,
      scrollbar : true,
      threeddarkshadow : true,
      threedface : true,
      threedhighlight : true,
      threedlightshadow : true,
      threedshadow : true,
      window : true,
      windowframe : true,
      windowtext : true
    },
    NAMED : {
      black : [0, 0, 0],
      silver : [192, 192, 192],
      gray : [128, 128, 128],
      white : [255, 255, 255],
      maroon : [128, 0, 0],
      red : [255, 0, 0],
      purple : [128, 0, 128],
      fuchsia : [255, 0, 255],
      green : [0, 128, 0],
      lime : [0, 255, 0],
      olive : [128, 128, 0],
      yellow : [255, 255, 0],
      navy : [0, 0, 128],
      blue : [0, 0, 255],
      teal : [0, 128, 128],
      aqua : [0, 255, 255],
      transparent : [-1, -1, -1],
      magenta : [255, 0, 255],
      orange : [255, 165, 0],
      brown : [165, 42, 42]
    },
    isNamedColor : function(value){

      return this.NAMED[value] !== undefined;
    },
    isSystemColor : function(value){

      return this.SYSTEM[value] !== undefined;
    },
    supportsThemes : function(){

      if(qx.Class){

        return qx.Class.isDefined("qx.theme.manager.Color");
      };
      return false;
    },
    isThemedColor : function(value){

      if(!this.supportsThemes()){

        return false;
      };
      if(qx.theme && qx.theme.manager && qx.theme.manager.Color){

        return qx.theme.manager.Color.getInstance().isDynamic(value);
      };
      return false;
    },
    stringToRgb : function(str){

      if(this.supportsThemes() && this.isThemedColor(str)){

        str = qx.theme.manager.Color.getInstance().resolveDynamic(str);
      };
      if(this.isNamedColor(str)){

        return this.NAMED[str].concat();
      } else if(this.isSystemColor(str)){

        throw new Error("Could not convert system colors to RGB: " + str);
      } else if(this.isRgbaString(str)){

        return this.__rgbaStringToRgb(str);
      } else if(this.isRgbString(str)){

        return this.__rgbStringToRgb();
      } else if(this.isHex3String(str)){

        return this.__hex3StringToRgb();
      } else if(this.isHex6String(str)){

        return this.__hex6StringToRgb();
      };;;;;
      throw new Error("Could not parse color: " + str);
    },
    cssStringToRgb : function(str){

      if(this.isNamedColor(str)){

        return this.NAMED[str];
      } else if(this.isSystemColor(str)){

        throw new Error("Could not convert system colors to RGB: " + str);
      } else if(this.isRgbString(str)){

        return this.__rgbStringToRgb();
      } else if(this.isRgbaString(str)){

        return this.__rgbaStringToRgb();
      } else if(this.isHex3String(str)){

        return this.__hex3StringToRgb();
      } else if(this.isHex6String(str)){

        return this.__hex6StringToRgb();
      };;;;;
      throw new Error("Could not parse color: " + str);
    },
    stringToRgbString : function(str){

      return this.rgbToRgbString(this.stringToRgb(str));
    },
    rgbToRgbString : function(rgb){

      return "rgb" + (rgb[3] !== undefined ? "a" : "") + "(" + rgb.join(",") + ")";
    },
    rgbToHexString : function(rgb){

      return ("#" + qx.lang.String.pad(rgb[0].toString(16).toUpperCase(), 2) + qx.lang.String.pad(rgb[1].toString(16).toUpperCase(), 2) + qx.lang.String.pad(rgb[2].toString(16).toUpperCase(), 2));
    },
    isValidPropertyValue : function(str){

      return (this.isThemedColor(str) || this.isNamedColor(str) || this.isHex3String(str) || this.isHex6String(str) || this.isRgbString(str) || this.isRgbaString(str));
    },
    isCssString : function(str){

      return (this.isSystemColor(str) || this.isNamedColor(str) || this.isHex3String(str) || this.isHex6String(str) || this.isRgbString(str) || this.isRgbaString(str));
    },
    isHex3String : function(str){

      return this.REGEXP.hex3.test(str);
    },
    isHex6String : function(str){

      return this.REGEXP.hex6.test(str);
    },
    isRgbString : function(str){

      return this.REGEXP.rgb.test(str);
    },
    isRgbaString : function(str){

      return this.REGEXP.rgba.test(str);
    },
    __rgbStringToRgb : function(){

      var red = parseInt(RegExp.$1, 10);
      var green = parseInt(RegExp.$2, 10);
      var blue = parseInt(RegExp.$3, 10);
      return [red, green, blue];
    },
    __rgbaStringToRgb : function(){

      var red = parseInt(RegExp.$1, 10);
      var green = parseInt(RegExp.$2, 10);
      var blue = parseInt(RegExp.$3, 10);
      var alpha = parseInt(RegExp.$4, 10);
      if(red === 0 && green === 0 & blue === 0 && alpha === 0){

        return [-1, -1, -1];
      };
      return [red, green, blue];
    },
    __hex3StringToRgb : function(){

      var red = parseInt(RegExp.$1, 16) * 17;
      var green = parseInt(RegExp.$2, 16) * 17;
      var blue = parseInt(RegExp.$3, 16) * 17;
      return [red, green, blue];
    },
    __hex6StringToRgb : function(){

      var red = (parseInt(RegExp.$1, 16) * 16) + parseInt(RegExp.$2, 16);
      var green = (parseInt(RegExp.$3, 16) * 16) + parseInt(RegExp.$4, 16);
      var blue = (parseInt(RegExp.$5, 16) * 16) + parseInt(RegExp.$6, 16);
      return [red, green, blue];
    },
    hex3StringToRgb : function(value){

      if(this.isHex3String(value)){

        return this.__hex3StringToRgb(value);
      };
      throw new Error("Invalid hex3 value: " + value);
    },
    hex3StringToHex6String : function(value){

      if(this.isHex3String(value)){

        return this.rgbToHexString(this.hex3StringToRgb(value));
      };
      return value;
    },
    hex6StringToRgb : function(value){

      if(this.isHex6String(value)){

        return this.__hex6StringToRgb(value);
      };
      throw new Error("Invalid hex6 value: " + value);
    },
    hexStringToRgb : function(value){

      if(this.isHex3String(value)){

        return this.__hex3StringToRgb(value);
      };
      if(this.isHex6String(value)){

        return this.__hex6StringToRgb(value);
      };
      throw new Error("Invalid hex value: " + value);
    },
    rgbToHsb : function(rgb){

      var hue,saturation,brightness;
      var red = rgb[0];
      var green = rgb[1];
      var blue = rgb[2];
      var cmax = (red > green) ? red : green;
      if(blue > cmax){

        cmax = blue;
      };
      var cmin = (red < green) ? red : green;
      if(blue < cmin){

        cmin = blue;
      };
      brightness = cmax / 255.0;
      if(cmax != 0){

        saturation = (cmax - cmin) / cmax;
      } else {

        saturation = 0;
      };
      if(saturation == 0){

        hue = 0;
      } else {

        var redc = (cmax - red) / (cmax - cmin);
        var greenc = (cmax - green) / (cmax - cmin);
        var bluec = (cmax - blue) / (cmax - cmin);
        if(red == cmax){

          hue = bluec - greenc;
        } else if(green == cmax){

          hue = 2.0 + redc - bluec;
        } else {

          hue = 4.0 + greenc - redc;
        };
        hue = hue / 6.0;
        if(hue < 0){

          hue = hue + 1.0;
        };
      };
      return [Math.round(hue * 360), Math.round(saturation * 100), Math.round(brightness * 100)];
    },
    hsbToRgb : function(hsb){

      var i,f,p,r,t;
      var hue = hsb[0] / 360;
      var saturation = hsb[1] / 100;
      var brightness = hsb[2] / 100;
      if(hue >= 1.0){

        hue %= 1.0;
      };
      if(saturation > 1.0){

        saturation = 1.0;
      };
      if(brightness > 1.0){

        brightness = 1.0;
      };
      var tov = Math.floor(255 * brightness);
      var rgb = {
      };
      if(saturation == 0.0){

        rgb.red = rgb.green = rgb.blue = tov;
      } else {

        hue *= 6.0;
        i = Math.floor(hue);
        f = hue - i;
        p = Math.floor(tov * (1.0 - saturation));
        r = Math.floor(tov * (1.0 - (saturation * f)));
        t = Math.floor(tov * (1.0 - (saturation * (1.0 - f))));
        switch(i){case 0:
        rgb.red = tov;
        rgb.green = t;
        rgb.blue = p;
        break;case 1:
        rgb.red = r;
        rgb.green = tov;
        rgb.blue = p;
        break;case 2:
        rgb.red = p;
        rgb.green = tov;
        rgb.blue = t;
        break;case 3:
        rgb.red = p;
        rgb.green = r;
        rgb.blue = tov;
        break;case 4:
        rgb.red = t;
        rgb.green = p;
        rgb.blue = tov;
        break;case 5:
        rgb.red = tov;
        rgb.green = p;
        rgb.blue = r;
        break;};
      };
      return [rgb.red, rgb.green, rgb.blue];
    },
    randomColor : function(){

      var r = Math.round(Math.random() * 255);
      var g = Math.round(Math.random() * 255);
      var b = Math.round(Math.random() * 255);
      return this.rgbToRgbString([r, g, b]);
    }
  }
});

qx.Class.define("qx.util.PropertyUtil", {
  statics : {
    getProperties : function(clazz){

      return clazz.$$properties;
    },
    getAllProperties : function(clazz){

      var properties = {
      };
      var superclass = clazz;
      while(superclass != qx.core.Object){

        var currentProperties = this.getProperties(superclass);
        for(var property in currentProperties){

          properties[property] = currentProperties[property];
        };
        superclass = superclass.superclass;
      };
      return properties;
    },
    getUserValue : function(object, propertyName){

      return object["$$user_" + propertyName];
    },
    setUserValue : function(object, propertyName, value){

      object["$$user_" + propertyName] = value;
    },
    deleteUserValue : function(object, propertyName){

      delete (object["$$user_" + propertyName]);
    },
    getInitValue : function(object, propertyName){

      return object["$$init_" + propertyName];
    },
    setInitValue : function(object, propertyName, value){

      object["$$init_" + propertyName] = value;
    },
    deleteInitValue : function(object, propertyName){

      delete (object["$$init_" + propertyName]);
    },
    getThemeValue : function(object, propertyName){

      return object["$$theme_" + propertyName];
    },
    setThemeValue : function(object, propertyName, value){

      object["$$theme_" + propertyName] = value;
    },
    deleteThemeValue : function(object, propertyName){

      delete (object["$$theme_" + propertyName]);
    },
    setThemed : function(object, propertyName, value){

      var styler = qx.core.Property.$$method.setThemed;
      object[styler[propertyName]](value);
    },
    resetThemed : function(object, propertyName){

      var unstyler = qx.core.Property.$$method.resetThemed;
      object[unstyler[propertyName]]();
    }
  }
});

qx.Class.define("qx.ui.core.queue.Layout", {
  statics : {
    __queue : {
    },
    __nesting : {
    },
    remove : function(widget){

      delete this.__queue[widget.$$hash];
    },
    add : function(widget){

      this.__queue[widget.$$hash] = widget;
      qx.ui.core.queue.Manager.scheduleFlush("layout");
    },
    isScheduled : function(widget){

      return !!this.__queue[widget.$$hash];
    },
    flush : function(){

      var queue = this.__getSortedQueue();
      for(var i = queue.length - 1;i >= 0;i--){

        var widget = queue[i];
        if(widget.hasValidLayout()){

          continue;
        };
        if(widget.isRootWidget() && !widget.hasUserBounds()){

          var hint = widget.getSizeHint();
          widget.renderLayout(0, 0, hint.width, hint.height);
        } else {

          var bounds = widget.getBounds();
          widget.renderLayout(bounds.left, bounds.top, bounds.width, bounds.height);
        };
      };
    },
    getNestingLevel : function(widget){

      var cache = this.__nesting;
      var level = 0;
      var parent = widget;
      while(true){

        if(cache[parent.$$hash] != null){

          level += cache[parent.$$hash];
          break;
        };
        if(!parent.$$parent){

          break;
        };
        parent = parent.$$parent;
        level += 1;
      };
      var leveldown = level;
      while(widget && widget !== parent){

        cache[widget.$$hash] = leveldown--;
        widget = widget.$$parent;
      };
      return level;
    },
    __getLevelGroupedWidgets : function(){

      var VisibilityQueue = qx.ui.core.queue.Visibility;
      this.__nesting = {
      };
      var levels = [];
      var queue = this.__queue;
      var widget,level;
      for(var hash in queue){

        widget = queue[hash];
        if(VisibilityQueue.isVisible(widget)){

          level = this.getNestingLevel(widget);
          if(!levels[level]){

            levels[level] = {
            };
          };
          levels[level][hash] = widget;
          delete queue[hash];
        };
      };
      return levels;
    },
    __getSortedQueue : function(){

      var sortedQueue = [];
      var levels = this.__getLevelGroupedWidgets();
      for(var level = levels.length - 1;level >= 0;level--){

        if(!levels[level]){

          continue;
        };
        for(var hash in levels[level]){

          var widget = levels[level][hash];
          if(level == 0 || widget.isRootWidget() || widget.hasUserBounds()){

            sortedQueue.push(widget);
            widget.invalidateLayoutCache();
            continue;
          };
          var oldSizeHint = widget.getSizeHint(false);
          if(oldSizeHint){

            widget.invalidateLayoutCache();
            var newSizeHint = widget.getSizeHint();
            var hintChanged = (!widget.getBounds() || oldSizeHint.minWidth !== newSizeHint.minWidth || oldSizeHint.width !== newSizeHint.width || oldSizeHint.maxWidth !== newSizeHint.maxWidth || oldSizeHint.minHeight !== newSizeHint.minHeight || oldSizeHint.height !== newSizeHint.height || oldSizeHint.maxHeight !== newSizeHint.maxHeight);
          } else {

            hintChanged = true;
          };
          if(hintChanged){

            var parent = widget.getLayoutParent();
            if(!levels[level - 1]){

              levels[level - 1] = {
              };
            };
            levels[level - 1][parent.$$hash] = parent;
          } else {

            sortedQueue.push(widget);
          };
        };
      };
      return sortedQueue;
    }
  }
});

qx.Bootstrap.define("qx.module.Environment", {
  statics : {
    get : function(key){

      return qx.core.Environment.get(key);
    },
    add : function(key, value){

      qx.core.Environment.add(key, value);
      return this;
    }
  },
  defer : function(statics){

    qx.core.Environment.get("browser.name");
    qx.core.Environment.get("browser.version");
    qx.core.Environment.get("browser.quirksmode");
    qx.core.Environment.get("browser.documentmode");
    qx.core.Environment.get("engine.name");
    qx.core.Environment.get("engine.version");
    qx.core.Environment.get("device.name");
    qx.core.Environment.get("device.type");
    qx.core.Environment.get("event.touch");
    qx.core.Environment.get("event.mspointer");
    qxWeb.$attachStatic({
      "env" : {
        get : statics.get,
        add : statics.add
      }
    });
  }
});

qx.Bootstrap.define("qx.module.Css", {
  statics : {
    setStyle : function(name, value){

      if(/\w-\w/.test(name)){

        name = qx.lang.String.camelCase(name);
      };
      this._forEachElement(function(item){

        qx.bom.element.Style.set(item, name, value);
      });
      return this;
    },
    getStyle : function(name){

      if(this[0] && qx.dom.Node.isElement(this[0])){

        if(/\w-\w/.test(name)){

          name = qx.lang.String.camelCase(name);
        };
        return qx.bom.element.Style.get(this[0], name);
      };
      return null;
    },
    setStyles : function(styles){

      for(var name in styles){

        this.setStyle(name, styles[name]);
      };
      return this;
    },
    getStyles : function(names){

      var styles = {
      };
      for(var i = 0;i < names.length;i++){

        styles[names[i]] = this.getStyle(names[i]);
      };
      return styles;
    },
    addClass : function(name){

      this._forEachElement(function(item){

        qx.bom.element.Class.add(item, name);
      });
      return this;
    },
    addClasses : function(names){

      this._forEachElement(function(item){

        qx.bom.element.Class.addClasses(item, names);
      });
      return this;
    },
    removeClass : function(name){

      this._forEachElement(function(item){

        qx.bom.element.Class.remove(item, name);
      });
      return this;
    },
    removeClasses : function(names){

      this._forEachElement(function(item){

        qx.bom.element.Class.removeClasses(item, names);
      });
      return this;
    },
    hasClass : function(name){

      if(!this[0] || !qx.dom.Node.isElement(this[0])){

        return false;
      };
      return qx.bom.element.Class.has(this[0], name);
    },
    getClass : function(){

      if(!this[0] || !qx.dom.Node.isElement(this[0])){

        return "";
      };
      return qx.bom.element.Class.get(this[0]);
    },
    toggleClass : function(name){

      var bCls = qx.bom.element.Class;
      this._forEachElement(function(item){

        bCls.has(item, name) ? bCls.remove(item, name) : bCls.add(item, name);
      });
      return this;
    },
    toggleClasses : function(names){

      for(var i = 0,l = names.length;i < l;i++){

        this.toggleClass(names[i]);
      };
      return this;
    },
    replaceClass : function(oldName, newName){

      this._forEachElement(function(item){

        qx.bom.element.Class.replace(item, oldName, newName);
      });
      return this;
    },
    getHeight : function(force){

      var elem = this[0];
      if(elem){

        if(qx.dom.Node.isElement(elem)){

          var elementHeight;
          if(force){

            var stylesToSwap = {
              display : "block",
              position : "absolute",
              visibility : "hidden"
            };
            elementHeight = qx.module.Css.__swap(elem, stylesToSwap, qx.module.Css.getHeight, this);
          } else {

            elementHeight = qx.bom.element.Dimension.getHeight(elem);
          };
          return elementHeight;
        } else if(qx.dom.Node.isDocument(elem)){

          return qx.bom.Document.getHeight(qx.dom.Node.getWindow(elem));
        } else if(qx.dom.Node.isWindow(elem)){

          return qx.bom.Viewport.getHeight(elem);
        };;
      };
      return null;
    },
    getWidth : function(force){

      var elem = this[0];
      if(elem){

        if(qx.dom.Node.isElement(elem)){

          var elementWidth;
          if(force){

            var stylesToSwap = {
              display : "block",
              position : "absolute",
              visibility : "hidden"
            };
            elementWidth = qx.module.Css.__swap(elem, stylesToSwap, qx.module.Css.getWidth, this);
          } else {

            elementWidth = qx.bom.element.Dimension.getWidth(elem);
          };
          return elementWidth;
        } else if(qx.dom.Node.isDocument(elem)){

          return qx.bom.Document.getWidth(qx.dom.Node.getWindow(elem));
        } else if(qx.dom.Node.isWindow(elem)){

          return qx.bom.Viewport.getWidth(elem);
        };;
      };
      return null;
    },
    getOffset : function(mode){

      var elem = this[0];
      if(elem && qx.dom.Node.isElement(elem)){

        return qx.bom.element.Location.get(elem, mode);
      };
      return null;
    },
    getContentHeight : function(force){

      var obj = this[0];
      if(qx.dom.Node.isElement(obj)){

        var contentHeight;
        if(force){

          var stylesToSwap = {
            position : "absolute",
            visibility : "hidden",
            display : "block"
          };
          contentHeight = qx.module.Css.__swap(obj, stylesToSwap, qx.module.Css.getContentHeight, this);
        } else {

          contentHeight = qx.bom.element.Dimension.getContentHeight(obj);
        };
        return contentHeight;
      };
      return null;
    },
    getContentWidth : function(force){

      var obj = this[0];
      if(qx.dom.Node.isElement(obj)){

        var contentWidth;
        if(force){

          var stylesToSwap = {
            position : "absolute",
            visibility : "hidden",
            display : "block"
          };
          contentWidth = qx.module.Css.__swap(obj, stylesToSwap, qx.module.Css.getContentWidth, this);
        } else {

          contentWidth = qx.bom.element.Dimension.getContentWidth(obj);
        };
        return contentWidth;
      };
      return null;
    },
    getPosition : function(){

      var obj = this[0];
      if(qx.dom.Node.isElement(obj)){

        return qx.bom.element.Location.getPosition(obj);
      };
      return null;
    },
    includeStylesheet : function(uri, doc){

      qx.bom.Stylesheet.includeFile(uri, doc);
    },
    hide : function(){

      this._forEachElementWrapped(function(item){

        var prevStyle = item.getStyle("display");
        if(prevStyle !== "none"){

          item[0].$$qPrevDisp = prevStyle;
          item.setStyle("display", "none");
        };
      });
      return this;
    },
    show : function(){

      this._forEachElementWrapped(function(item){

        var currentVal = item.getStyle("display");
        var prevVal = item[0].$$qPrevDisp;
        var newVal;
        if(currentVal == "none"){

          if(prevVal && prevVal != "none"){

            newVal = prevVal;
          } else {

            var doc = qxWeb.getDocument(item[0]);
            newVal = qx.module.Css.__getDisplayDefault(item[0].tagName, doc);
          };
          item.setStyle("display", newVal);
          item[0].$$qPrevDisp = "none";
        };
      });
      return this;
    },
    __displayDefaults : {
    },
    __getDisplayDefault : function(tagName, doc){

      var defaults = qx.module.Css.__displayDefaults;
      if(!defaults[tagName]){

        var docu = doc || document;
        var tempEl = qxWeb(docu.createElement(tagName)).appendTo(doc.body);
        defaults[tagName] = tempEl.getStyle("display");
        tempEl.remove();
      };
      return defaults[tagName] || "";
    },
    __swap : function(element, styles, callback, context){

      var currentValues = {
      };
      for(var styleProperty in styles){

        currentValues[styleProperty] = element.style[styleProperty];
        element.style[styleProperty] = styles[styleProperty];
      };
      var value = callback.call(context);
      for(var styleProperty in currentValues){

        element.style[styleProperty] = currentValues[styleProperty];
      };
      return value;
    }
  },
  defer : function(statics){

    qxWeb.$attach({
      "setStyle" : statics.setStyle,
      "getStyle" : statics.getStyle,
      "setStyles" : statics.setStyles,
      "getStyles" : statics.getStyles,
      "addClass" : statics.addClass,
      "addClasses" : statics.addClasses,
      "removeClass" : statics.removeClass,
      "removeClasses" : statics.removeClasses,
      "hasClass" : statics.hasClass,
      "getClass" : statics.getClass,
      "toggleClass" : statics.toggleClass,
      "toggleClasses" : statics.toggleClasses,
      "replaceClass" : statics.replaceClass,
      "getHeight" : statics.getHeight,
      "getWidth" : statics.getWidth,
      "getOffset" : statics.getOffset,
      "getContentHeight" : statics.getContentHeight,
      "getContentWidth" : statics.getContentWidth,
      "getPosition" : statics.getPosition,
      "hide" : statics.hide,
      "show" : statics.show
    });
    qxWeb.$attachStatic({
      "includeStylesheet" : statics.includeStylesheet
    });
  }
});

qx.Bootstrap.define("qx.module.Polyfill", {
});

qx.Bootstrap.define("qx.module.Event", {
  statics : {
    __normalizations : {
    },
    __hooks : {
      on : {
      },
      off : {
      }
    },
    on : function(type, listener, context, useCapture){

      for(var i = 0;i < this.length;i++){

        var el = this[i];
        var ctx = context || qxWeb(el);
        var hooks = qx.module.Event.__hooks.on;
        var typeHooks = hooks["*"] || [];
        if(hooks[type]){

          typeHooks = typeHooks.concat(hooks[type]);
        };
        for(var j = 0,m = typeHooks.length;j < m;j++){

          typeHooks[j](el, type, listener, context);
        };
        var bound = function(event){

          var registry = qx.module.Event.__normalizations;
          var normalizations = registry["*"] || [];
          if(registry[type]){

            normalizations = normalizations.concat(registry[type]);
          };
          for(var x = 0,y = normalizations.length;x < y;x++){

            event = normalizations[x](event, el, type);
          };
          listener.apply(this, [event]);
        }.bind(ctx);
        bound.original = listener;
        if(qx.bom.Event.supportsEvent(el, type)){

          qx.bom.Event.addNativeListener(el, type, bound, useCapture);
        };
        if(!el.$$emitter){

          el.$$emitter = new qx.event.Emitter();
        };
        var id = el.$$emitter.on(type, bound, ctx);
        if(!el.__listener){

          el.__listener = {
          };
        };
        if(!el.__listener[type]){

          el.__listener[type] = {
          };
        };
        el.__listener[type][id] = bound;
        if(!context){

          if(!el.__ctx){

            el.__ctx = {
            };
          };
          el.__ctx[id] = ctx;
        };
      };
      return this;
    },
    off : function(type, listener, context, useCapture){

      var removeAll = (listener === null && context === null);
      for(var j = 0;j < this.length;j++){

        var el = this[j];
        if(!el.__listener){

          continue;
        };
        var types = [];
        if(type !== null){

          types.push(type);
        } else {

          for(var listenerType in el.__listener){

            types.push(listenerType);
          };
        };
        for(var i = 0,l = types.length;i < l;i++){

          for(var id in el.__listener[types[i]]){

            var storedListener = el.__listener[types[i]][id];
            if(removeAll || storedListener == listener || storedListener.original == listener){

              var hasStoredContext = typeof el.__ctx !== "undefined" && el.__ctx[id];
              var storedContext;
              if(!context && hasStoredContext){

                storedContext = el.__ctx[id];
              };
              el.$$emitter.off(types[i], storedListener, storedContext || context);
              if(removeAll || storedListener.original == listener){

                qx.bom.Event.removeNativeListener(el, types[i], storedListener, useCapture);
              };
              delete el.__listener[types[i]][id];
              if(hasStoredContext){

                delete el.__ctx[id];
              };
            };
          };
          var hooks = qx.module.Event.__hooks.off;
          var typeHooks = hooks["*"] || [];
          if(hooks[type]){

            typeHooks = typeHooks.concat(hooks[type]);
          };
          for(var k = 0,m = typeHooks.length;k < m;k++){

            typeHooks[k](el, type, listener, context);
          };
        };
      };
      return this;
    },
    allOff : function(type){

      return this.off(type || null, null, null);
    },
    emit : function(type, data){

      for(var j = 0;j < this.length;j++){

        var el = this[j];
        if(el.$$emitter){

          el.$$emitter.emit(type, data);
        };
      };
      return this;
    },
    once : function(type, listener, context){

      var self = this;
      var wrappedListener = function(data){

        self.off(type, wrappedListener, context);
        listener.call(this, data);
      };
      this.on(type, wrappedListener, context);
      return this;
    },
    hasListener : function(type, listener, context){

      if(!this[0] || !this[0].$$emitter || !this[0].$$emitter.getListeners()[type]){

        return false;
      };
      if(listener){

        var attachedListeners = this[0].$$emitter.getListeners()[type];
        for(var i = 0;i < attachedListeners.length;i++){

          var hasListener = false;
          if(attachedListeners[i].listener == listener){

            hasListener = true;
          };
          if(attachedListeners[i].listener.original && attachedListeners[i].listener.original == listener){

            hasListener = true;
          };
          if(hasListener){

            if(context !== undefined){

              if(attachedListeners[i].ctx === context){

                return true;
              };
            } else {

              return true;
            };
          };
        };
        return false;
      };
      return this[0].$$emitter.getListeners()[type].length > 0;
    },
    copyEventsTo : function(target){

      var source = this.concat();
      var targetCopy = target.concat();
      for(var i = source.length - 1;i >= 0;i--){

        var descendants = source[i].getElementsByTagName("*");
        for(var j = 0;j < descendants.length;j++){

          source.push(descendants[j]);
        };
      };
      for(var i = targetCopy.length - 1;i >= 0;i--){

        var descendants = targetCopy[i].getElementsByTagName("*");
        for(var j = 0;j < descendants.length;j++){

          targetCopy.push(descendants[j]);
        };
      };
      targetCopy.forEach(function(el){

        el.$$emitter = null;
      });
      for(var i = 0;i < source.length;i++){

        var el = source[i];
        if(!el.$$emitter){

          continue;
        };
        var storage = el.$$emitter.getListeners();
        for(var name in storage){

          for(var j = storage[name].length - 1;j >= 0;j--){

            var listener = storage[name][j].listener;
            if(listener.original){

              listener = listener.original;
            };
            qxWeb(targetCopy[i]).on(name, listener, storage[name][j].ctx);
          };
        };
      };
    },
    __isReady : false,
    ready : function(callback){

      if(document.readyState === "complete"){

        window.setTimeout(callback, 1);
        return;
      };
      var onWindowLoad = function(){

        qx.module.Event.__isReady = true;
        callback();
      };
      qxWeb(window).on("load", onWindowLoad);
      var wrappedCallback = function(){

        qxWeb(window).off("load", onWindowLoad);
        callback();
      };
      if(qxWeb.env.get("engine.name") !== "mshtml" || qxWeb.env.get("browser.documentmode") > 8){

        qx.bom.Event.addNativeListener(document, "DOMContentLoaded", wrappedCallback);
      } else {

        var timer = function(){

          if(qx.module.Event.__isReady){

            return;
          };
          try{

            document.documentElement.doScroll("left");
            if(document.body){

              wrappedCallback();
            };
          } catch(error) {

            window.setTimeout(timer, 100);
          };
        };
        timer();
      };
    },
    hover : function(callbackIn, callbackOut){

      this.on("pointerover", callbackIn, this);
      if(qx.lang.Type.isFunction(callbackOut)){

        this.on("pointerout", callbackOut, this);
      };
      return this;
    },
    $registerNormalization : function(types, normalizer){

      if(!qx.lang.Type.isArray(types)){

        types = [types];
      };
      var registry = qx.module.Event.__normalizations;
      for(var i = 0,l = types.length;i < l;i++){

        var type = types[i];
        if(qx.lang.Type.isFunction(normalizer)){

          if(!registry[type]){

            registry[type] = [];
          };
          registry[type].push(normalizer);
        };
      };
    },
    $unregisterNormalization : function(types, normalizer){

      if(!qx.lang.Type.isArray(types)){

        types = [types];
      };
      var registry = qx.module.Event.__normalizations;
      for(var i = 0,l = types.length;i < l;i++){

        var type = types[i];
        if(registry[type]){

          qx.lang.Array.remove(registry[type], normalizer);
        };
      };
    },
    $getRegistry : function(){

      return qx.module.Event.__normalizations;
    },
    $registerEventHook : function(types, registerHook, unregisterHook){

      if(!qx.lang.Type.isArray(types)){

        types = [types];
      };
      var onHooks = qx.module.Event.__hooks.on;
      for(var i = 0,l = types.length;i < l;i++){

        var type = types[i];
        if(qx.lang.Type.isFunction(registerHook)){

          if(!onHooks[type]){

            onHooks[type] = [];
          };
          onHooks[type].push(registerHook);
        };
      };
      if(!unregisterHook){

        return;
      };
      var offHooks = qx.module.Event.__hooks.off;
      for(var i = 0,l = types.length;i < l;i++){

        var type = types[i];
        if(qx.lang.Type.isFunction(unregisterHook)){

          if(!offHooks[type]){

            offHooks[type] = [];
          };
          offHooks[type].push(unregisterHook);
        };
      };
    },
    $unregisterEventHook : function(types, registerHook, unregisterHook){

      if(!qx.lang.Type.isArray(types)){

        types = [types];
      };
      var onHooks = qx.module.Event.__hooks.on;
      for(var i = 0,l = types.length;i < l;i++){

        var type = types[i];
        if(onHooks[type]){

          qx.lang.Array.remove(onHooks[type], registerHook);
        };
      };
      if(!unregisterHook){

        return;
      };
      var offHooks = qx.module.Event.__hooks.off;
      for(var i = 0,l = types.length;i < l;i++){

        var type = types[i];
        if(offHooks[type]){

          qx.lang.Array.remove(offHooks[type], unregisterHook);
        };
      };
    },
    $getHookRegistry : function(){

      return qx.module.Event.__hooks;
    }
  },
  defer : function(statics){

    qxWeb.$attach({
      "on" : statics.on,
      "off" : statics.off,
      "allOff" : statics.allOff,
      "once" : statics.once,
      "emit" : statics.emit,
      "hasListener" : statics.hasListener,
      "copyEventsTo" : statics.copyEventsTo,
      "hover" : statics.hover
    });
    qxWeb.$attachStatic({
      "ready" : statics.ready,
      "$registerEventNormalization" : statics.$registerNormalization,
      "$unregisterEventNormalization" : statics.$unregisterNormalization,
      "$getEventNormalizationRegistry" : statics.$getRegistry,
      "$registerEventHook" : statics.$registerEventHook,
      "$unregisterEventHook" : statics.$unregisterEventHook,
      "$getEventHookRegistry" : statics.$getHookRegistry
    });
  }
});

qx.Bootstrap.define("qx.module.event.PointerHandler", {
  statics : {
    TYPES : ["pointermove", "pointerover", "pointerout", "pointerdown", "pointerup", "pointercancel", "gesturebegin", "gesturemove", "gesturefinish", "gesturecancel"],
    register : function(element, type){

      if(!element["on" + type]){

        element["on" + type] = true;
      };
      if(!element.__pointerListeners){

        element.__pointerListeners = 0;
      };
      if(!element.$$pointerHandler){

        if(!qx.core.Environment.get("event.dispatchevent")){

          if(!element.$$emitter){

            element.$$emitter = new qx.event.Emitter();
          };
        };
        element.$$pointerHandler = new qx.event.handler.PointerCore(element, element.$$emitter);
      };
      element.__pointerListeners++;
    },
    unregister : function(element){

      if(element.$$pointerHandler){

        element.__pointerListeners--;
        if(element.__pointerListeners === 0){

          element.$$pointerHandler.dispose();
          element.$$pointerHandler = null;
        };
      };
    }
  },
  defer : function(statics){

    qxWeb.$registerEventHook(statics.TYPES, statics.register, statics.unregister);
  }
});

qx.Bootstrap.define("qx.module.Animation", {
  events : {
    "animationStart" : undefined,
    "animationIteration" : undefined,
    "animationEnd" : undefined
  },
  statics : {
    getAnimationHandles : function(){

      var animationHandles = [];
      for(var i = 0;i < this.length;i++){

        animationHandles[i] = this[i].$$animation;
      };
      return animationHandles;
    },
    _fadeOut : {
      duration : 700,
      timing : "ease-out",
      keep : 100,
      keyFrames : {
        '0' : {
          opacity : 1
        },
        '100' : {
          opacity : 0,
          display : "none"
        }
      }
    },
    _fadeIn : {
      duration : 700,
      timing : "ease-in",
      keep : 100,
      keyFrames : {
        '0' : {
          opacity : 0
        },
        '100' : {
          opacity : 1
        }
      }
    },
    animate : function(desc, duration){

      qx.module.Animation._animate.bind(this)(desc, duration, false);
      return this;
    },
    animateReverse : function(desc, duration){

      qx.module.Animation._animate.bind(this)(desc, duration, true);
      return this;
    },
    _animate : function(desc, duration, reverse){

      this._forEachElement(function(el, i){

        if(el.$$animation){

          el.$$animation.stop();
        };
        var handle;
        if(reverse){

          handle = qx.bom.element.Animation.animateReverse(el, desc, duration);
        } else {

          handle = qx.bom.element.Animation.animate(el, desc, duration);
        };
        var self = this;
        if(i == 0){

          handle.on("start", function(){

            self.emit("animationStart");
          }, handle);
          handle.on("iteration", function(){

            self.emit("animationIteration");
          }, handle);
        };
        handle.on("end", function(){

          for(var i = 0;i < self.length;i++){

            if(self[i].$$animation){

              return;
            };
          };
          self.emit("animationEnd");
        }, el);
      });
    },
    play : function(){

      for(var i = 0;i < this.length;i++){

        var handle = this[i].$$animation;
        if(handle){

          handle.play();
        };
      };
      return this;
    },
    pause : function(){

      for(var i = 0;i < this.length;i++){

        var handle = this[i].$$animation;
        if(handle){

          handle.pause();
        };
      };
      return this;
    },
    stop : function(){

      for(var i = 0;i < this.length;i++){

        var handle = this[i].$$animation;
        if(handle){

          handle.stop();
        };
      };
      return this;
    },
    isPlaying : function(){

      for(var i = 0;i < this.length;i++){

        var handle = this[i].$$animation;
        if(handle && handle.isPlaying()){

          return true;
        };
      };
      return false;
    },
    isEnded : function(){

      for(var i = 0;i < this.length;i++){

        var handle = this[i].$$animation;
        if(handle && !handle.isEnded()){

          return false;
        };
      };
      return true;
    },
    fadeIn : function(duration){

      this.setStyle("display", "");
      return this.animate(qx.module.Animation._fadeIn, duration);
    },
    fadeOut : function(duration){

      return this.animate(qx.module.Animation._fadeOut, duration);
    }
  },
  defer : function(statics){

    qxWeb.$attach({
      "animate" : statics.animate,
      "animateReverse" : statics.animateReverse,
      "fadeIn" : statics.fadeIn,
      "fadeOut" : statics.fadeOut,
      "play" : statics.play,
      "pause" : statics.pause,
      "stop" : statics.stop,
      "isEnded" : statics.isEnded,
      "isPlaying" : statics.isPlaying,
      "getAnimationHandles" : statics.getAnimationHandles
    });
    if(qxWeb.env.get("browser.name") === "ie" && qxWeb.env.get("browser.version") <= 9){

      statics._fadeIn.keyFrames[100].opacity = 0.99;
    };
  }
});

qx.Bootstrap.define("qx.bom.element.Animation", {
  statics : {
    animate : function(el, desc, duration){

      var onlyCssKeys = qx.bom.element.Animation.__hasOnlyCssKeys(el, desc.keyFrames);
      if(qx.core.Environment.get("css.animation") && onlyCssKeys){

        return qx.bom.element.AnimationCss.animate(el, desc, duration);
      } else {

        return qx.bom.element.AnimationJs.animate(el, desc, duration);
      };
    },
    animateReverse : function(el, desc, duration){

      var onlyCssKeys = qx.bom.element.Animation.__hasOnlyCssKeys(el, desc.keyFrames);
      if(qx.core.Environment.get("css.animation") && onlyCssKeys){

        return qx.bom.element.AnimationCss.animateReverse(el, desc, duration);
      } else {

        return qx.bom.element.AnimationJs.animateReverse(el, desc, duration);
      };
    },
    __hasOnlyCssKeys : function(el, keyFrames){

      var keys = [];
      for(var nr in keyFrames){

        var frame = keyFrames[nr];
        for(var key in frame){

          if(keys.indexOf(key) == -1){

            keys.push(key);
          };
        };
      };
      var transformKeys = ["scale", "rotate", "skew", "translate"];
      for(var i = 0;i < keys.length;i++){

        var key = qx.lang.String.camelCase(keys[i]);
        if(!(key in el.style)){

          if(transformKeys.indexOf(keys[i]) != -1){

            continue;
          };
          if(qx.bom.Style.getPropertyName(key)){

            continue;
          };
          return false;
        };
      };
      return true;
    }
  }
});

qx.Bootstrap.define("qx.bom.element.AnimationCss", {
  statics : {
    __sheet : null,
    __rulePrefix : "Anni",
    __id : 0,
    __rules : {
    },
    __transitionKeys : {
      "scale" : true,
      "rotate" : true,
      "skew" : true,
      "translate" : true
    },
    __cssAnimationKeys : qx.core.Environment.get("css.animation"),
    animateReverse : function(el, desc, duration){

      return this._animate(el, desc, duration, true);
    },
    animate : function(el, desc, duration){

      return this._animate(el, desc, duration, false);
    },
    _animate : function(el, desc, duration, reverse){

      this.__normalizeDesc(desc);
      if(qx.core.Environment.get("qx.debug")){

        this.__validateDesc(desc);
      };
      var keep = desc.keep;
      if(keep != null && (reverse || (desc.alternate && desc.repeat % 2 == 0))){

        keep = 100 - keep;
      };
      if(!this.__sheet){

        this.__sheet = qx.bom.Stylesheet.createElement();
      };
      var keyFrames = desc.keyFrames;
      if(duration == undefined){

        duration = desc.duration;
      };
      if(this.__cssAnimationKeys != null){

        var name = this.__addKeyFrames(keyFrames, reverse);
        var style = name + " " + duration + "ms " + desc.timing + " " + (desc.delay ? desc.delay + "ms " : "") + desc.repeat + " " + (desc.alternate ? "alternate" : "");
        qx.bom.Event.addNativeListener(el, this.__cssAnimationKeys["start-event"], this.__onAnimationStart);
        qx.bom.Event.addNativeListener(el, this.__cssAnimationKeys["iteration-event"], this.__onAnimationIteration);
        qx.bom.Event.addNativeListener(el, this.__cssAnimationKeys["end-event"], this.__onAnimationEnd);
        if(qx.core.Environment.get("qx.debug")){

          if(qx.bom.element.Style.get(el, "display") == "none"){

            qx.log.Logger.warn("Some browsers will not animate elements with display==none", el);
          };
        };
        el.style[qx.lang.String.camelCase(this.__cssAnimationKeys["name"])] = style;
        if(keep && keep == 100 && this.__cssAnimationKeys["fill-mode"]){

          el.style[this.__cssAnimationKeys["fill-mode"]] = "forwards";
        };
      };
      var animation = new qx.bom.element.AnimationHandle();
      animation.desc = desc;
      animation.el = el;
      animation.keep = keep;
      el.$$animation = animation;
      if(desc.origin != null){

        qx.bom.element.Transform.setOrigin(el, desc.origin);
      };
      if(this.__cssAnimationKeys == null){

        window.setTimeout(function(){

          qx.bom.element.AnimationCss.__onAnimationEnd({
            target : el
          });
        }, 0);
      };
      return animation;
    },
    __onAnimationStart : function(e){

      e.target.$$animation.emit("start", e.target);
    },
    __onAnimationIteration : function(e){

      if(e.target != null && e.target.$$animation != null){

        e.target.$$animation.emit("iteration", e.target);
      };
    },
    __onAnimationEnd : function(e){

      var el = e.target;
      var animation = el.$$animation;
      if(!animation){

        return;
      };
      var desc = animation.desc;
      if(qx.bom.element.AnimationCss.__cssAnimationKeys != null){

        var key = qx.lang.String.camelCase(qx.bom.element.AnimationCss.__cssAnimationKeys["name"]);
        el.style[key] = "";
        qx.bom.Event.removeNativeListener(el, qx.bom.element.AnimationCss.__cssAnimationKeys["name"], qx.bom.element.AnimationCss.__onAnimationEnd);
      };
      if(desc.origin != null){

        qx.bom.element.Transform.setOrigin(el, "");
      };
      qx.bom.element.AnimationCss.__keepFrame(el, desc.keyFrames[animation.keep]);
      el.$$animation = null;
      animation.el = null;
      animation.ended = true;
      animation.emit("end", el);
    },
    __keepFrame : function(el, endFrame){

      var transforms;
      for(var style in endFrame){

        if(style in qx.bom.element.AnimationCss.__transitionKeys){

          if(!transforms){

            transforms = {
            };
          };
          transforms[style] = endFrame[style];
        } else {

          el.style[qx.lang.String.camelCase(style)] = endFrame[style];
        };
      };
      if(transforms){

        qx.bom.element.Transform.transform(el, transforms);
      };
    },
    __normalizeDesc : function(desc){

      if(!desc.hasOwnProperty("alternate")){

        desc.alternate = false;
      };
      if(!desc.hasOwnProperty("keep")){

        desc.keep = null;
      };
      if(!desc.hasOwnProperty("repeat")){

        desc.repeat = 1;
      };
      if(!desc.hasOwnProperty("timing")){

        desc.timing = "linear";
      };
      if(!desc.hasOwnProperty("origin")){

        desc.origin = null;
      };
    },
    __validateDesc : qx.core.Environment.select("qx.debug", {
      "true" : function(desc){

        var possibleKeys = ["origin", "duration", "keep", "keyFrames", "delay", "repeat", "timing", "alternate"];
        for(var name in desc){

          if(!(possibleKeys.indexOf(name) != -1)){

            qx.Bootstrap.warn("Unknown key '" + name + "' in the animation description.");
          };
        };
        if(desc.keyFrames == null){

          qx.Bootstrap.warn("No 'keyFrames' given > 0");
        } else {

          for(var pos in desc.keyFrames){

            if(pos < 0 || pos > 100){

              qx.Bootstrap.warn("Keyframe position needs to be between 0 and 100");
            };
          };
        };
      },
      "default" : null
    }),
    __addKeyFrames : function(frames, reverse){

      var rule = "";
      for(var position in frames){

        rule += (reverse ? -(position - 100) : position) + "% {";
        var frame = frames[position];
        var transforms;
        for(var style in frame){

          if(style in this.__transitionKeys){

            if(!transforms){

              transforms = {
              };
            };
            transforms[style] = frame[style];
          } else {

            var propName = qx.bom.Style.getPropertyName(style);
            var prefixed = (propName !== null) ? qx.bom.Style.getCssName(propName) : "";
            rule += (prefixed || style) + ":" + frame[style] + ";";
          };
        };
        if(transforms){

          rule += qx.bom.element.Transform.getCss(transforms);
        };
        rule += "} ";
      };
      if(this.__rules[rule]){

        return this.__rules[rule];
      };
      var name = this.__rulePrefix + this.__id++;
      var selector = this.__cssAnimationKeys["keyframes"] + " " + name;
      qx.bom.Stylesheet.addRule(this.__sheet, selector, rule);
      this.__rules[rule] = name;
      return name;
    }
  }
});

qx.Bootstrap.define("qx.bom.element.AnimationHandle", {
  extend : qx.event.Emitter,
  construct : function(){

    var css = qx.core.Environment.get("css.animation");
    this.__playState = css && css["play-state"];
    this.__playing = true;
  },
  events : {
    "start" : "Element",
    "end" : "Element",
    "iteration" : "Element"
  },
  members : {
    __playState : null,
    __playing : false,
    __ended : false,
    isPlaying : function(){

      return this.__playing;
    },
    isEnded : function(){

      return this.__ended;
    },
    isPaused : function(){

      return this.el.style[this.__playState] == "paused";
    },
    pause : function(){

      if(this.el){

        this.el.style[this.__playState] = "paused";
        this.el.$$animation.__playing = false;
        if(this.animationId && qx.bom.element.AnimationJs){

          qx.bom.element.AnimationJs.pause(this);
        };
      };
    },
    play : function(){

      if(this.el){

        this.el.style[this.__playState] = "running";
        this.el.$$animation.__playing = true;
        if(this.i != undefined && qx.bom.element.AnimationJs){

          qx.bom.element.AnimationJs.play(this);
        };
      };
    },
    stop : function(){

      if(this.el && qx.core.Environment.get("css.animation") && !this.jsAnimation){

        this.el.style[this.__playState] = "";
        this.el.style[qx.core.Environment.get("css.animation").name] = "";
        this.el.$$animation.__playing = false;
        this.el.$$animation.__ended = true;
      } else if(this.jsAnimation){

        this.stopped = true;
        qx.bom.element.AnimationJs.stop(this);
      };
    }
  }
});

qx.Bootstrap.define("qx.bom.element.AnimationJs", {
  statics : {
    __maxStepTime : 30,
    __units : ["%", "in", "cm", "mm", "em", "ex", "pt", "pc", "px"],
    __transitionKeys : {
      "scale" : true,
      "rotate" : true,
      "skew" : true,
      "translate" : true
    },
    animate : function(el, desc, duration){

      return this._animate(el, desc, duration, false);
    },
    animateReverse : function(el, desc, duration){

      return this._animate(el, desc, duration, true);
    },
    _animate : function(el, desc, duration, reverse){

      if(el.$$animation){

        return el.$$animation;
      };
      desc = qx.lang.Object.clone(desc, true);
      if(duration == undefined){

        duration = desc.duration;
      };
      var keyFrames = desc.keyFrames;
      var keys = this.__getOrderedKeys(keyFrames);
      var stepTime = this.__getStepTime(duration, keys);
      var steps = parseInt(duration / stepTime, 10);
      this.__normalizeKeyFrames(keyFrames, el);
      var delta = this.__calculateDelta(steps, stepTime, keys, keyFrames, duration, desc.timing);
      var handle = new qx.bom.element.AnimationHandle();
      handle.jsAnimation = true;
      if(reverse){

        delta.reverse();
        handle.reverse = true;
      };
      handle.desc = desc;
      handle.el = el;
      handle.delta = delta;
      handle.stepTime = stepTime;
      handle.steps = steps;
      el.$$animation = handle;
      handle.i = 0;
      handle.initValues = {
      };
      handle.repeatSteps = this.__applyRepeat(steps, desc.repeat);
      var delay = desc.delay || 0;
      var self = this;
      handle.delayId = window.setTimeout(function(){

        handle.delayId = null;
        self.play(handle);
      }, delay);
      return handle;
    },
    __normalizeKeyFrames : function(keyFrames, el){

      var units = {
      };
      for(var percent in keyFrames){

        for(var name in keyFrames[percent]){

          var prefixed = qx.bom.Style.getPropertyName(name);
          if(prefixed && prefixed != name){

            var prefixedName = qx.bom.Style.getCssName(prefixed);
            keyFrames[percent][prefixedName] = keyFrames[percent][name];
            delete keyFrames[percent][name];
            name = prefixedName;
          };
          if(units[name] == undefined){

            var item = keyFrames[percent][name];
            if(typeof item == "string"){

              units[name] = this.__getUnit(item);
            } else {

              units[name] = "";
            };
          };
        };
      };
      for(var percent in keyFrames){

        var frame = keyFrames[percent];
        for(var name in units){

          if(frame[name] == undefined){

            if(name in el.style){

              if(window.getComputedStyle){

                frame[name] = getComputedStyle(el, null)[name];
              } else {

                frame[name] = el.style[name];
              };
            } else {

              frame[name] = el[name];
            };
            if(frame[name] === "" && this.__units.indexOf(units[name]) != -1){

              frame[name] = "0" + units[name];
            };
          };
        };
      };
    },
    __normalizeKeyFrameTransforms : function(frame){

      frame = qx.lang.Object.clone(frame);
      var transforms;
      for(var name in frame){

        if(name in this.__transitionKeys){

          if(!transforms){

            transforms = {
            };
          };
          transforms[name] = frame[name];
          delete frame[name];
        };
      };
      if(transforms){

        var transformStyle = qx.bom.element.Transform.getCss(transforms).split(":");
        if(transformStyle.length > 1){

          frame[transformStyle[0]] = transformStyle[1].replace(";", "");
        };
      };
      return frame;
    },
    __calculateDelta : function(steps, stepTime, keys, keyFrames, duration, timing){

      var delta = new Array(steps);
      var keyIndex = 1;
      delta[0] = this.__normalizeKeyFrameTransforms(keyFrames[0]);
      var last = keyFrames[0];
      var next = keyFrames[keys[keyIndex]];
      var stepsToNext = Math.floor(keys[keyIndex] / (stepTime / duration * 100));
      var calculationIndex = 1;
      for(var i = 1;i < delta.length;i++){

        if(i * stepTime / duration * 100 > keys[keyIndex]){

          last = next;
          keyIndex++;
          next = keyFrames[keys[keyIndex]];
          stepsToNext = Math.floor(keys[keyIndex] / (stepTime / duration * 100)) - stepsToNext;
          calculationIndex = 1;
        };
        delta[i] = {
        };
        var transforms;
        for(var name in next){

          var nItem = next[name] + "";
          if(name in this.__transitionKeys){

            if(!transforms){

              transforms = {
              };
            };
            if(qx.Bootstrap.isArray(last[name])){

              if(!qx.Bootstrap.isArray(next[name])){

                next[name] = [next[name]];
              };
              transforms[name] = [];
              for(var j = 0;j < next[name].length;j++){

                var item = next[name][j] + "";
                var x = calculationIndex / stepsToNext;
                transforms[name][j] = this.__getNextValue(item, last[name], timing, x);
              };
            } else {

              var x = calculationIndex / stepsToNext;
              transforms[name] = this.__getNextValue(nItem, last[name], timing, x);
            };
          } else if(nItem.charAt(0) == "#"){

            var value0 = qx.util.ColorUtil.cssStringToRgb(last[name]);
            var value1 = qx.util.ColorUtil.cssStringToRgb(nItem);
            var stepValue = [];
            for(var j = 0;j < value0.length;j++){

              var range = value0[j] - value1[j];
              var x = calculationIndex / stepsToNext;
              var timingX = qx.bom.AnimationFrame.calculateTiming(timing, x);
              stepValue[j] = parseInt(value0[j] - range * timingX, 10);
            };
            delta[i][name] = qx.util.ColorUtil.rgbToHexString(stepValue);
          } else if(!isNaN(parseFloat(nItem))){

            var x = calculationIndex / stepsToNext;
            delta[i][name] = this.__getNextValue(nItem, last[name], timing, x);
          } else {

            delta[i][name] = last[name] + "";
          };;
        };
        if(transforms){

          var transformStyle = qx.bom.element.Transform.getCss(transforms).split(":");
          if(transformStyle.length > 1){

            delta[i][transformStyle[0]] = transformStyle[1].replace(";", "");
          };
        };
        calculationIndex++;
      };
      delta[delta.length - 1] = this.__normalizeKeyFrameTransforms(keyFrames[100]);
      return delta;
    },
    __getUnit : function(item){

      return item.substring((parseFloat(item) + "").length, item.length);
    },
    __getNextValue : function(nextItem, lastItem, timing, x){

      var range = parseFloat(nextItem) - parseFloat(lastItem);
      return (parseFloat(lastItem) + range * qx.bom.AnimationFrame.calculateTiming(timing, x)) + this.__getUnit(nextItem);
    },
    play : function(handle){

      handle.emit("start", handle.el);
      var id = window.setInterval(function(){

        handle.repeatSteps--;
        var values = handle.delta[handle.i % handle.steps];
        if(handle.i === 0){

          for(var name in values){

            if(handle.initValues[name] === undefined){

              if(handle.el[name] !== undefined){

                handle.initValues[name] = handle.el[name];
              } else if(qx.bom.element.Style){

                handle.initValues[name] = qx.bom.element.Style.get(handle.el, qx.lang.String.camelCase(name));
              } else {

                handle.initValues[name] = handle.el.style[qx.lang.String.camelCase(name)];
              };
            };
          };
        };
        qx.bom.element.AnimationJs.__applyStyles(handle.el, values);
        handle.i++;
        if(handle.i % handle.steps == 0){

          handle.emit("iteration", handle.el);
          if(handle.desc.alternate){

            handle.delta.reverse();
          };
        };
        if(handle.repeatSteps < 0){

          qx.bom.element.AnimationJs.stop(handle);
        };
      }, handle.stepTime);
      handle.animationId = id;
      return handle;
    },
    pause : function(handle){

      window.clearInterval(handle.animationId);
      handle.animationId = null;
      return handle;
    },
    stop : function(handle){

      var desc = handle.desc;
      var el = handle.el;
      var initValues = handle.initValues;
      if(handle.animationId){

        window.clearInterval(handle.animationId);
      };
      if(handle.delayId){

        window.clearTimeout(handle.delayId);
      };
      if(el == undefined){

        return handle;
      };
      var keep = desc.keep;
      if(keep != undefined && !handle.stopped){

        if(handle.reverse || (desc.alternate && desc.repeat && desc.repeat % 2 == 0)){

          keep = 100 - keep;
        };
        this.__applyStyles(el, desc.keyFrames[keep]);
      } else {

        this.__applyStyles(el, initValues);
      };
      el.$$animation = null;
      handle.el = null;
      handle.ended = true;
      handle.animationId = null;
      handle.emit("end", el);
      return handle;
    },
    __applyRepeat : function(steps, repeat){

      if(repeat == undefined){

        return steps;
      };
      if(repeat == "infinite"){

        return Number.MAX_VALUE;
      };
      return steps * repeat;
    },
    __applyStyles : function(el, styles){

      for(var key in styles){

        if(styles[key] === undefined){

          continue;
        };
        if(typeof el.style[key] === "undefined" && key in el){

          el[key] = styles[key];
          continue;
        };
        var name = qx.bom.Style.getPropertyName(key) || key;
        if(qx.bom.element.Style){

          qx.bom.element.Style.set(el, name, styles[key]);
        } else {

          el.style[name] = styles[key];
        };
      };
    },
    __getStepTime : function(duration, keys){

      var minDiff = 100;
      for(var i = 0;i < keys.length - 1;i++){

        minDiff = Math.min(minDiff, keys[i + 1] - keys[i]);
      };
      var stepTime = duration * minDiff / 100;
      while(stepTime > this.__maxStepTime){

        stepTime = stepTime / 2;
      };
      return Math.round(stepTime);
    },
    __getOrderedKeys : function(keyFrames){

      var keys = Object.keys(keyFrames);
      for(var i = 0;i < keys.length;i++){

        keys[i] = parseInt(keys[i], 10);
      };
      keys.sort(function(a, b){

        return a - b;
      });
      return keys;
    }
  }
});

qx.Bootstrap.define("qx.bom.element.Transform", {
  statics : {
    __dimensions : ["X", "Y", "Z"],
    __cssKeys : qx.core.Environment.get("css.transform"),
    transform : function(el, transforms){

      var transformCss = this.__mapToCss(transforms);
      if(this.__cssKeys != null){

        var style = this.__cssKeys["name"];
        el.style[style] = transformCss;
      };
    },
    translate : function(el, value){

      this.transform(el, {
        translate : value
      });
    },
    scale : function(el, value){

      this.transform(el, {
        scale : value
      });
    },
    rotate : function(el, value){

      this.transform(el, {
        rotate : value
      });
    },
    skew : function(el, value){

      this.transform(el, {
        skew : value
      });
    },
    getCss : function(transforms){

      var transformCss = this.__mapToCss(transforms);
      if(this.__cssKeys != null){

        var style = this.__cssKeys["name"];
        return qx.bom.Style.getCssName(style) + ":" + transformCss + ";";
      };
      return "";
    },
    setOrigin : function(el, value){

      if(this.__cssKeys != null){

        el.style[this.__cssKeys["origin"]] = value;
      };
    },
    getOrigin : function(el){

      if(this.__cssKeys != null){

        return el.style[this.__cssKeys["origin"]];
      };
      return "";
    },
    setStyle : function(el, value){

      if(this.__cssKeys != null){

        el.style[this.__cssKeys["style"]] = value;
      };
    },
    getStyle : function(el){

      if(this.__cssKeys != null){

        return el.style[this.__cssKeys["style"]];
      };
      return "";
    },
    setPerspective : function(el, value){

      if(this.__cssKeys != null){

        el.style[this.__cssKeys["perspective"]] = value + "px";
      };
    },
    getPerspective : function(el){

      if(this.__cssKeys != null){

        return el.style[this.__cssKeys["perspective"]];
      };
      return "";
    },
    setPerspectiveOrigin : function(el, value){

      if(this.__cssKeys != null){

        el.style[this.__cssKeys["perspective-origin"]] = value;
      };
    },
    getPerspectiveOrigin : function(el){

      if(this.__cssKeys != null){

        var value = el.style[this.__cssKeys["perspective-origin"]];
        if(value != ""){

          return value;
        } else {

          var valueX = el.style[this.__cssKeys["perspective-origin"] + "X"];
          var valueY = el.style[this.__cssKeys["perspective-origin"] + "Y"];
          if(valueX != ""){

            return valueX + " " + valueY;
          };
        };
      };
      return "";
    },
    setBackfaceVisibility : function(el, value){

      if(this.__cssKeys != null){

        el.style[this.__cssKeys["backface-visibility"]] = value ? "visible" : "hidden";
      };
    },
    getBackfaceVisibility : function(el){

      if(this.__cssKeys != null){

        return el.style[this.__cssKeys["backface-visibility"]] == "visible";
      };
      return true;
    },
    __mapToCss : function(transforms){

      var value = "";
      for(var func in transforms){

        var params = transforms[func];
        if(qx.Bootstrap.isArray(params)){

          for(var i = 0;i < params.length;i++){

            if(params[i] == undefined || (i == 2 && !qx.core.Environment.get("css.transform.3d"))){

              continue;
            };
            value += func + this.__dimensions[i] + "(";
            value += params[i];
            value += ") ";
          };
        } else {

          value += func + "(" + transforms[func] + ") ";
        };
      };
      return value;
    }
  }
});

qx.Class.define("qx.util.DeferredCallManager", {
  extend : qx.core.Object,
  type : "singleton",
  construct : function(){

    this.__calls = {
    };
    this.__timeoutWrapper = qx.lang.Function.bind(this.__timeout, this);
    this.__hasCalls = false;
  },
  members : {
    __timeoutId : null,
    __currentQueue : null,
    __calls : null,
    __hasCalls : null,
    __timeoutWrapper : null,
    schedule : function(deferredCall){

      if(this.__timeoutId == null){

        this.__timeoutId = window.setTimeout(this.__timeoutWrapper, 0);
      };
      var callKey = deferredCall.toHashCode();
      if(this.__currentQueue && this.__currentQueue[callKey]){

        return;
      };
      this.__calls[callKey] = deferredCall;
      this.__hasCalls = true;
    },
    cancel : function(deferredCall){

      var callKey = deferredCall.toHashCode();
      if(this.__currentQueue && this.__currentQueue[callKey]){

        this.__currentQueue[callKey] = null;
        return;
      };
      delete this.__calls[callKey];
      if(qx.lang.Object.isEmpty(this.__calls) && this.__timeoutId != null){

        window.clearTimeout(this.__timeoutId);
        this.__timeoutId = null;
      };
    },
    __timeout : qx.event.GlobalError.observeMethod(function(){

      this.__timeoutId = null;
      while(this.__hasCalls){

        this.__currentQueue = qx.lang.Object.clone(this.__calls);
        this.__calls = {
        };
        this.__hasCalls = false;
        for(var key in this.__currentQueue){

          var call = this.__currentQueue[key];
          if(call){

            this.__currentQueue[key] = null;
            call.call();
          };
        };
      };
      this.__currentQueue = null;
    })
  },
  destruct : function(){

    if(this.__timeoutId != null){

      window.clearTimeout(this.__timeoutId);
    };
    this.__timeoutWrapper = this.__calls = null;
  }
});

qx.Class.define("qx.util.DeferredCall", {
  extend : qx.core.Object,
  construct : function(callback, context){

    this.base(arguments);
    this.__callback = callback;
    this.__context = context || null;
    this.__manager = qx.util.DeferredCallManager.getInstance();
  },
  members : {
    __callback : null,
    __context : null,
    __manager : null,
    cancel : function(){

      this.__manager.cancel(this);
    },
    schedule : function(){

      this.__manager.schedule(this);
    },
    call : function(){

      if(qx.core.Environment.get("qx.debug")){

        var context = this.__context;
        if(context && context.isDisposed && context.isDisposed()){

          this.warn("The context object '" + context + "' of the defered call '" + this + "'is already disposed.");
        };
      };
      this.__context ? this.__callback.apply(this.__context) : this.__callback();
    }
  },
  destruct : function(){

    this.cancel();
    this.__context = this.__callback = this.__manager = null;
  }
});

qx.Class.define("qx.html.Element", {
  extend : qx.core.Object,
  construct : function(tagName, styles, attributes){

    this.base(arguments);
    this.__nodeName = tagName || "div";
    this.__styleValues = styles || null;
    this.__attribValues = attributes || null;
  },
  statics : {
    DEBUG : false,
    _modified : {
    },
    _visibility : {
    },
    _scroll : {
    },
    _actions : [],
    __selection : {
    },
    __focusHandler : null,
    __mouseCapture : null,
    _scheduleFlush : function(job){

      qx.html.Element.__deferredCall.schedule();
    },
    flush : function(){

      var obj;
      if(qx.core.Environment.get("qx.debug")){

        if(this.DEBUG){

          qx.log.Logger.debug(this, "Flushing elements...");
        };
      };
      var focusHandler = this.__getFocusHandler();
      var focusedDomElement = focusHandler.getFocus();
      if(focusedDomElement && this.__willBecomeInvisible(focusedDomElement)){

        focusHandler.blur(focusedDomElement);
      };
      var activeDomElement = focusHandler.getActive();
      if(activeDomElement && this.__willBecomeInvisible(activeDomElement)){

        qx.bom.Element.deactivate(activeDomElement);
      };
      var captureDomElement = this.__getCaptureElement();
      if(captureDomElement && this.__willBecomeInvisible(captureDomElement)){

        qx.bom.Element.releaseCapture(captureDomElement);
      };
      var later = [];
      var modified = this._modified;
      for(var hc in modified){

        obj = modified[hc];
        if(obj.__willBeSeeable() || obj.classname == "qx.html.Iframe"){

          if(obj.__element && qx.dom.Hierarchy.isRendered(obj.__element)){

            later.push(obj);
          } else {

            if(qx.core.Environment.get("qx.debug")){

              if(this.DEBUG){

                obj.debug("Flush invisible element");
              };
            };
            obj.__flush();
          };
          delete modified[hc];
        };
      };
      for(var i = 0,l = later.length;i < l;i++){

        obj = later[i];
        if(qx.core.Environment.get("qx.debug")){

          if(this.DEBUG){

            obj.debug("Flush rendered element");
          };
        };
        obj.__flush();
      };
      var visibility = this._visibility;
      for(var hc in visibility){

        obj = visibility[hc];
        var element = obj.__element;
        if(!element){

          delete visibility[hc];
          continue;
        };
        if(qx.core.Environment.get("qx.debug")){

          if(this.DEBUG){

            qx.log.Logger.debug(this, "Switching visibility to: " + obj.__visible);
          };
        };
        if(!obj.$$disposed){

          element.style.display = obj.__visible ? "" : "none";
          if((qx.core.Environment.get("engine.name") == "mshtml")){

            if(!(document.documentMode >= 8)){

              element.style.visibility = obj.__visible ? "visible" : "hidden";
            };
          };
        };
        delete visibility[hc];
      };
      var scroll = this._scroll;
      for(var hc in scroll){

        obj = scroll[hc];
        var elem = obj.__element;
        if(elem && elem.offsetWidth){

          var done = true;
          if(obj.__lazyScrollX != null){

            obj.__element.scrollLeft = obj.__lazyScrollX;
            delete obj.__lazyScrollX;
          };
          if(obj.__lazyScrollY != null){

            obj.__element.scrollTop = obj.__lazyScrollY;
            delete obj.__lazyScrollY;
          };
          var intoViewX = obj.__lazyScrollIntoViewX;
          if(intoViewX != null){

            var child = intoViewX.element.getDomElement();
            if(child && child.offsetWidth){

              qx.bom.element.Scroll.intoViewX(child, elem, intoViewX.align);
              delete obj.__lazyScrollIntoViewX;
            } else {

              done = false;
            };
          };
          var intoViewY = obj.__lazyScrollIntoViewY;
          if(intoViewY != null){

            var child = intoViewY.element.getDomElement();
            if(child && child.offsetWidth){

              qx.bom.element.Scroll.intoViewY(child, elem, intoViewY.align);
              delete obj.__lazyScrollIntoViewY;
            } else {

              done = false;
            };
          };
          if(done){

            delete scroll[hc];
          };
        };
      };
      var activityEndActions = {
        "releaseCapture" : 1,
        "blur" : 1,
        "deactivate" : 1
      };
      for(var i = 0;i < this._actions.length;i++){

        var action = this._actions[i];
        var element = action.element.__element;
        if(!element || !activityEndActions[action.type] && !action.element.__willBeSeeable()){

          continue;
        };
        var args = action.args;
        args.unshift(element);
        qx.bom.Element[action.type].apply(qx.bom.Element, args);
      };
      this._actions = [];
      for(var hc in this.__selection){

        var selection = this.__selection[hc];
        var elem = selection.element.__element;
        if(elem){

          qx.bom.Selection.set(elem, selection.start, selection.end);
          delete this.__selection[hc];
        };
      };
      qx.event.handler.Appear.refresh();
    },
    __getFocusHandler : function(){

      if(!this.__focusHandler){

        var eventManager = qx.event.Registration.getManager(window);
        this.__focusHandler = eventManager.getHandler(qx.event.handler.Focus);
      };
      return this.__focusHandler;
    },
    __getCaptureElement : function(){

      if(!this.__mouseCapture){

        var eventManager = qx.event.Registration.getManager(window);
        this.__mouseCapture = eventManager.getDispatcher(qx.event.dispatch.MouseCapture);
      };
      return this.__mouseCapture.getCaptureElement();
    },
    __willBecomeInvisible : function(domElement){

      var element = qx.core.ObjectRegistry.fromHashCode(domElement.$$element);
      return element && !element.__willBeSeeable();
    }
  },
  members : {
    __nodeName : null,
    __element : null,
    __root : false,
    __included : true,
    __visible : true,
    __lazyScrollIntoViewX : null,
    __lazyScrollIntoViewY : null,
    __lazyScrollX : null,
    __lazyScrollY : null,
    __styleJobs : null,
    __attribJobs : null,
    __propertyJobs : null,
    __styleValues : null,
    __attribValues : null,
    __propertyValues : null,
    __eventValues : null,
    __children : null,
    __modifiedChildren : null,
    __parent : null,
    _scheduleChildrenUpdate : function(){

      if(this.__modifiedChildren){

        return;
      };
      this.__modifiedChildren = true;
      qx.html.Element._modified[this.$$hash] = this;
      qx.html.Element._scheduleFlush("element");
    },
    _createDomElement : function(){

      return qx.dom.Element.create(this.__nodeName);
    },
    __flush : function(){

      if(qx.core.Environment.get("qx.debug")){

        if(this.DEBUG){

          this.debug("Flush: " + this.getAttribute("id"));
        };
      };
      var length;
      var children = this.__children;
      if(children){

        length = children.length;
        var child;
        for(var i = 0;i < length;i++){

          child = children[i];
          if(child.__visible && child.__included && !child.__element){

            child.__flush();
          };
        };
      };
      if(!this.__element){

        this.__element = this._createDomElement();
        this.__element.$$element = this.$$hash;
        this._copyData(false);
        if(children && length > 0){

          this._insertChildren();
        };
      } else {

        this._syncData();
        if(this.__modifiedChildren){

          this._syncChildren();
        };
      };
      delete this.__modifiedChildren;
    },
    _insertChildren : function(){

      var children = this.__children;
      var length = children.length;
      var child;
      if(length > 2){

        var domElement = document.createDocumentFragment();
        for(var i = 0;i < length;i++){

          child = children[i];
          if(child.__element && child.__included){

            domElement.appendChild(child.__element);
          };
        };
        this.__element.appendChild(domElement);
      } else {

        var domElement = this.__element;
        for(var i = 0;i < length;i++){

          child = children[i];
          if(child.__element && child.__included){

            domElement.appendChild(child.__element);
          };
        };
      };
    },
    _syncChildren : function(){

      var ObjectRegistry = qx.core.ObjectRegistry;
      var dataChildren = this.__children;
      var dataLength = dataChildren.length;
      var dataChild;
      var dataEl;
      var domParent = this.__element;
      var domChildren = domParent.childNodes;
      var domPos = 0;
      var domEl;
      if(qx.core.Environment.get("qx.debug")){

        var domOperations = 0;
      };
      for(var i = domChildren.length - 1;i >= 0;i--){

        domEl = domChildren[i];
        dataEl = ObjectRegistry.fromHashCode(domEl.$$element);
        if(!dataEl || !dataEl.__included || dataEl.__parent !== this){

          domParent.removeChild(domEl);
          if(qx.core.Environment.get("qx.debug")){

            domOperations++;
          };
        };
      };
      for(var i = 0;i < dataLength;i++){

        dataChild = dataChildren[i];
        if(dataChild.__included){

          dataEl = dataChild.__element;
          domEl = domChildren[domPos];
          if(!dataEl){

            continue;
          };
          if(dataEl != domEl){

            if(domEl){

              domParent.insertBefore(dataEl, domEl);
            } else {

              domParent.appendChild(dataEl);
            };
            if(qx.core.Environment.get("qx.debug")){

              domOperations++;
            };
          };
          domPos++;
        };
      };
      if(qx.core.Environment.get("qx.debug")){

        if(qx.html.Element.DEBUG){

          this.debug("Synced DOM with " + domOperations + " operations");
        };
      };
    },
    _copyData : function(fromMarkup){

      var elem = this.__element;
      var data = this.__attribValues;
      if(data){

        var Attribute = qx.bom.element.Attribute;
        for(var key in data){

          Attribute.set(elem, key, data[key]);
        };
      };
      var data = this.__styleValues;
      if(data){

        var Style = qx.bom.element.Style;
        if(fromMarkup){

          Style.setStyles(elem, data);
        } else {

          Style.setCss(elem, Style.compile(data));
        };
      };
      var data = this.__propertyValues;
      if(data){

        for(var key in data){

          this._applyProperty(key, data[key]);
        };
      };
      var data = this.__eventValues;
      if(data){

        qx.event.Registration.getManager(elem).importListeners(elem, data);
        delete this.__eventValues;
      };
    },
    _syncData : function(){

      var elem = this.__element;
      var Attribute = qx.bom.element.Attribute;
      var Style = qx.bom.element.Style;
      var jobs = this.__attribJobs;
      if(jobs){

        var data = this.__attribValues;
        if(data){

          var value;
          for(var key in jobs){

            value = data[key];
            if(value !== undefined){

              Attribute.set(elem, key, value);
            } else {

              Attribute.reset(elem, key);
            };
          };
        };
        this.__attribJobs = null;
      };
      var jobs = this.__styleJobs;
      if(jobs){

        var data = this.__styleValues;
        if(data){

          var styles = {
          };
          for(var key in jobs){

            styles[key] = data[key];
          };
          Style.setStyles(elem, styles);
        };
        this.__styleJobs = null;
      };
      var jobs = this.__propertyJobs;
      if(jobs){

        var data = this.__propertyValues;
        if(data){

          var value;
          for(var key in jobs){

            this._applyProperty(key, data[key]);
          };
        };
        this.__propertyJobs = null;
      };
    },
    __willBeSeeable : function(){

      var pa = this;
      while(pa){

        if(pa.__root){

          return true;
        };
        if(!pa.__included || !pa.__visible){

          return false;
        };
        pa = pa.__parent;
      };
      return false;
    },
    __addChildHelper : function(child){

      if(child.__parent === this){

        throw new Error("Child is already in: " + child);
      };
      if(child.__root){

        throw new Error("Root elements could not be inserted into other ones.");
      };
      if(child.__parent){

        child.__parent.remove(child);
      };
      child.__parent = this;
      if(!this.__children){

        this.__children = [];
      };
      if(this.__element){

        this._scheduleChildrenUpdate();
      };
    },
    __removeChildHelper : function(child){

      if(child.__parent !== this){

        throw new Error("Has no child: " + child);
      };
      if(this.__element){

        this._scheduleChildrenUpdate();
      };
      delete child.__parent;
    },
    __moveChildHelper : function(child){

      if(child.__parent !== this){

        throw new Error("Has no child: " + child);
      };
      if(this.__element){

        this._scheduleChildrenUpdate();
      };
    },
    getChildren : function(){

      return this.__children || null;
    },
    getChild : function(index){

      var children = this.__children;
      return children && children[index] || null;
    },
    hasChildren : function(){

      var children = this.__children;
      return children && children[0] !== undefined;
    },
    indexOf : function(child){

      var children = this.__children;
      return children ? children.indexOf(child) : -1;
    },
    hasChild : function(child){

      var children = this.__children;
      return children && children.indexOf(child) !== -1;
    },
    add : function(varargs){

      if(arguments[1]){

        for(var i = 0,l = arguments.length;i < l;i++){

          this.__addChildHelper(arguments[i]);
        };
        this.__children.push.apply(this.__children, arguments);
      } else {

        this.__addChildHelper(varargs);
        this.__children.push(varargs);
      };
      return this;
    },
    addAt : function(child, index){

      this.__addChildHelper(child);
      qx.lang.Array.insertAt(this.__children, child, index);
      return this;
    },
    remove : function(childs){

      var children = this.__children;
      if(!children){

        return this;
      };
      if(arguments[1]){

        var child;
        for(var i = 0,l = arguments.length;i < l;i++){

          child = arguments[i];
          this.__removeChildHelper(child);
          qx.lang.Array.remove(children, child);
        };
      } else {

        this.__removeChildHelper(childs);
        qx.lang.Array.remove(children, childs);
      };
      return this;
    },
    removeAt : function(index){

      var children = this.__children;
      if(!children){

        throw new Error("Has no children!");
      };
      var child = children[index];
      if(!child){

        throw new Error("Has no child at this position!");
      };
      this.__removeChildHelper(child);
      qx.lang.Array.removeAt(this.__children, index);
      return this;
    },
    removeAll : function(){

      var children = this.__children;
      if(children){

        for(var i = 0,l = children.length;i < l;i++){

          this.__removeChildHelper(children[i]);
        };
        children.length = 0;
      };
      return this;
    },
    getParent : function(){

      return this.__parent || null;
    },
    insertInto : function(parent, index){

      parent.__addChildHelper(this);
      if(index == null){

        parent.__children.push(this);
      } else {

        qx.lang.Array.insertAt(this.__children, this, index);
      };
      return this;
    },
    insertBefore : function(rel){

      var parent = rel.__parent;
      parent.__addChildHelper(this);
      qx.lang.Array.insertBefore(parent.__children, this, rel);
      return this;
    },
    insertAfter : function(rel){

      var parent = rel.__parent;
      parent.__addChildHelper(this);
      qx.lang.Array.insertAfter(parent.__children, this, rel);
      return this;
    },
    moveTo : function(index){

      var parent = this.__parent;
      parent.__moveChildHelper(this);
      var oldIndex = parent.__children.indexOf(this);
      if(oldIndex === index){

        throw new Error("Could not move to same index!");
      } else if(oldIndex < index){

        index--;
      };
      qx.lang.Array.removeAt(parent.__children, oldIndex);
      qx.lang.Array.insertAt(parent.__children, this, index);
      return this;
    },
    moveBefore : function(rel){

      var parent = this.__parent;
      return this.moveTo(parent.__children.indexOf(rel));
    },
    moveAfter : function(rel){

      var parent = this.__parent;
      return this.moveTo(parent.__children.indexOf(rel) + 1);
    },
    free : function(){

      var parent = this.__parent;
      if(!parent){

        throw new Error("Has no parent to remove from.");
      };
      if(!parent.__children){

        return this;
      };
      parent.__removeChildHelper(this);
      qx.lang.Array.remove(parent.__children, this);
      return this;
    },
    getDomElement : function(){

      return this.__element || null;
    },
    getNodeName : function(){

      return this.__nodeName;
    },
    setNodeName : function(name){

      this.__nodeName = name;
    },
    setRoot : function(root){

      this.__root = root;
    },
    useMarkup : function(html){

      if(this.__element){

        throw new Error("Could not overwrite existing element!");
      };
      if(qx.core.Environment.get("engine.name") == "mshtml"){

        var helper = document.createElement("div");
      } else {

        var helper = qx.dom.Element.getHelperElement();
      };
      helper.innerHTML = html;
      this.useElement(helper.firstChild);
      return this.__element;
    },
    useElement : function(elem){

      if(this.__element){

        throw new Error("Could not overwrite existing element!");
      };
      this.__element = elem;
      this.__element.$$element = this.$$hash;
      this._copyData(true);
    },
    isFocusable : function(){

      var tabIndex = this.getAttribute("tabIndex");
      if(tabIndex >= 1){

        return true;
      };
      var focusable = qx.event.handler.Focus.FOCUSABLE_ELEMENTS;
      if(tabIndex >= 0 && focusable[this.__nodeName]){

        return true;
      };
      return false;
    },
    setSelectable : function(value){

      this.setAttribute("qxSelectable", value ? "on" : "off");
      var userSelect = qx.core.Environment.get("css.userselect");
      if(userSelect){

        this.setStyle(userSelect, value ? "text" : qx.core.Environment.get("css.userselect.none"));
      };
    },
    isNativelyFocusable : function(){

      return !!qx.event.handler.Focus.FOCUSABLE_ELEMENTS[this.__nodeName];
    },
    include : function(){

      if(this.__included){

        return this;
      };
      delete this.__included;
      if(this.__parent){

        this.__parent._scheduleChildrenUpdate();
      };
      return this;
    },
    exclude : function(){

      if(!this.__included){

        return this;
      };
      this.__included = false;
      if(this.__parent){

        this.__parent._scheduleChildrenUpdate();
      };
      return this;
    },
    isIncluded : function(){

      return this.__included === true;
    },
    fadeIn : function(duration){

      var col = qxWeb(this.__element);
      if(col.isPlaying()){

        col.stop();
      };
      if(!this.__element){

        this.__flush();
        col.push(this.__element);
      };
      if(this.__element){

        col.fadeIn(duration);
        return col.getAnimationHandles()[0];
      };
    },
    fadeOut : function(duration){

      var col = qxWeb(this.__element);
      if(col.isPlaying()){

        col.stop();
      };
      if(this.__element){

        col.fadeOut(duration).once("animationEnd", function(){

          this.hide();
          qx.html.Element.flush();
        }, this);
        return col.getAnimationHandles()[0];
      };
    },
    show : function(){

      if(this.__visible){

        return this;
      };
      if(this.__element){

        qx.html.Element._visibility[this.$$hash] = this;
        qx.html.Element._scheduleFlush("element");
      };
      if(this.__parent){

        this.__parent._scheduleChildrenUpdate();
      };
      delete this.__visible;
      return this;
    },
    hide : function(){

      if(!this.__visible){

        return this;
      };
      if(this.__element){

        qx.html.Element._visibility[this.$$hash] = this;
        qx.html.Element._scheduleFlush("element");
      };
      this.__visible = false;
      return this;
    },
    isVisible : function(){

      return this.__visible === true;
    },
    scrollChildIntoViewX : function(elem, align, direct){

      var thisEl = this.__element;
      var childEl = elem.getDomElement();
      if(direct !== false && thisEl && thisEl.offsetWidth && childEl && childEl.offsetWidth){

        qx.bom.element.Scroll.intoViewX(childEl, thisEl, align);
      } else {

        this.__lazyScrollIntoViewX = {
          element : elem,
          align : align
        };
        qx.html.Element._scroll[this.$$hash] = this;
        qx.html.Element._scheduleFlush("element");
      };
      delete this.__lazyScrollX;
    },
    scrollChildIntoViewY : function(elem, align, direct){

      var thisEl = this.__element;
      var childEl = elem.getDomElement();
      if(direct !== false && thisEl && thisEl.offsetWidth && childEl && childEl.offsetWidth){

        qx.bom.element.Scroll.intoViewY(childEl, thisEl, align);
      } else {

        this.__lazyScrollIntoViewY = {
          element : elem,
          align : align
        };
        qx.html.Element._scroll[this.$$hash] = this;
        qx.html.Element._scheduleFlush("element");
      };
      delete this.__lazyScrollY;
    },
    scrollToX : function(x, lazy){

      var thisEl = this.__element;
      if(lazy !== true && thisEl && thisEl.offsetWidth){

        thisEl.scrollLeft = x;
        delete this.__lazyScrollX;
      } else {

        this.__lazyScrollX = x;
        qx.html.Element._scroll[this.$$hash] = this;
        qx.html.Element._scheduleFlush("element");
      };
      delete this.__lazyScrollIntoViewX;
    },
    getScrollX : function(){

      var thisEl = this.__element;
      if(thisEl){

        return thisEl.scrollLeft;
      };
      return this.__lazyScrollX || 0;
    },
    scrollToY : function(y, lazy){

      var thisEl = this.__element;
      if(lazy !== true && thisEl && thisEl.offsetWidth){

        thisEl.scrollTop = y;
        delete this.__lazyScrollY;
      } else {

        this.__lazyScrollY = y;
        qx.html.Element._scroll[this.$$hash] = this;
        qx.html.Element._scheduleFlush("element");
      };
      delete this.__lazyScrollIntoViewY;
    },
    getScrollY : function(){

      var thisEl = this.__element;
      if(thisEl){

        return thisEl.scrollTop;
      };
      return this.__lazyScrollY || 0;
    },
    disableScrolling : function(){

      this.enableScrolling();
      this.scrollToX(0);
      this.scrollToY(0);
      this.addListener("scroll", this.__onScroll, this);
    },
    enableScrolling : function(){

      this.removeListener("scroll", this.__onScroll, this);
    },
    __inScroll : null,
    __onScroll : function(e){

      if(!this.__inScroll){

        this.__inScroll = true;
        this.__element.scrollTop = 0;
        this.__element.scrollLeft = 0;
        delete this.__inScroll;
      };
    },
    getTextSelection : function(){

      var el = this.__element;
      if(el){

        return qx.bom.Selection.get(el);
      };
      return null;
    },
    getTextSelectionLength : function(){

      var el = this.__element;
      if(el){

        return qx.bom.Selection.getLength(el);
      };
      return null;
    },
    getTextSelectionStart : function(){

      var el = this.__element;
      if(el){

        return qx.bom.Selection.getStart(el);
      };
      return null;
    },
    getTextSelectionEnd : function(){

      var el = this.__element;
      if(el){

        return qx.bom.Selection.getEnd(el);
      };
      return null;
    },
    setTextSelection : function(start, end){

      var el = this.__element;
      if(el){

        qx.bom.Selection.set(el, start, end);
        return;
      };
      qx.html.Element.__selection[this.toHashCode()] = {
        element : this,
        start : start,
        end : end
      };
      qx.html.Element._scheduleFlush("element");
    },
    clearTextSelection : function(){

      var el = this.__element;
      if(el){

        qx.bom.Selection.clear(el);
      };
      delete qx.html.Element.__selection[this.toHashCode()];
    },
    __performAction : function(action, args){

      var actions = qx.html.Element._actions;
      actions.push({
        type : action,
        element : this,
        args : args || []
      });
      qx.html.Element._scheduleFlush("element");
    },
    focus : function(){

      this.__performAction("focus");
    },
    blur : function(){

      this.__performAction("blur");
    },
    activate : function(){

      this.__performAction("activate");
    },
    deactivate : function(){

      this.__performAction("deactivate");
    },
    capture : function(containerCapture){

      this.__performAction("capture", [containerCapture !== false]);
    },
    releaseCapture : function(){

      this.__performAction("releaseCapture");
    },
    setStyle : function(key, value, direct){

      if(!this.__styleValues){

        this.__styleValues = {
        };
      };
      if(this.__styleValues[key] == value){

        return this;
      };
      if(value == null){

        delete this.__styleValues[key];
      } else {

        this.__styleValues[key] = value;
      };
      if(this.__element){

        if(direct){

          qx.bom.element.Style.set(this.__element, key, value);
          return this;
        };
        if(!this.__styleJobs){

          this.__styleJobs = {
          };
        };
        this.__styleJobs[key] = true;
        qx.html.Element._modified[this.$$hash] = this;
        qx.html.Element._scheduleFlush("element");
      };
      return this;
    },
    setStyles : function(map, direct){

      var Style = qx.bom.element.Style;
      if(!this.__styleValues){

        this.__styleValues = {
        };
      };
      if(this.__element){

        if(!this.__styleJobs){

          this.__styleJobs = {
          };
        };
        for(var key in map){

          var value = map[key];
          if(this.__styleValues[key] == value){

            continue;
          };
          if(value == null){

            delete this.__styleValues[key];
          } else {

            this.__styleValues[key] = value;
          };
          if(direct){

            Style.set(this.__element, key, value);
            continue;
          };
          this.__styleJobs[key] = true;
        };
        qx.html.Element._modified[this.$$hash] = this;
        qx.html.Element._scheduleFlush("element");
      } else {

        for(var key in map){

          var value = map[key];
          if(this.__styleValues[key] == value){

            continue;
          };
          if(value == null){

            delete this.__styleValues[key];
          } else {

            this.__styleValues[key] = value;
          };
        };
      };
      return this;
    },
    removeStyle : function(key, direct){

      this.setStyle(key, null, direct);
      return this;
    },
    getStyle : function(key){

      return this.__styleValues ? this.__styleValues[key] : null;
    },
    getAllStyles : function(){

      return this.__styleValues || null;
    },
    setAttribute : function(key, value, direct){

      if(!this.__attribValues){

        this.__attribValues = {
        };
      };
      if(this.__attribValues[key] == value){

        return this;
      };
      if(value == null){

        delete this.__attribValues[key];
      } else {

        this.__attribValues[key] = value;
      };
      if(this.__element){

        if(direct){

          qx.bom.element.Attribute.set(this.__element, key, value);
          return this;
        };
        if(!this.__attribJobs){

          this.__attribJobs = {
          };
        };
        this.__attribJobs[key] = true;
        qx.html.Element._modified[this.$$hash] = this;
        qx.html.Element._scheduleFlush("element");
      };
      return this;
    },
    setAttributes : function(map, direct){

      for(var key in map){

        this.setAttribute(key, map[key], direct);
      };
      return this;
    },
    removeAttribute : function(key, direct){

      return this.setAttribute(key, null, direct);
    },
    getAttribute : function(key){

      return this.__attribValues ? this.__attribValues[key] : null;
    },
    addClass : function(name){

      var value = ((this.getAttribute("class") || "") + " " + name).trim();
      this.setAttribute("class", value);
    },
    removeClass : function(name){

      var currentClass = this.getAttribute("class");
      if(currentClass){

        this.setAttribute("class", (currentClass.replace(name, "")).trim());
      };
    },
    _applyProperty : function(name, value){
    },
    _setProperty : function(key, value, direct){

      if(!this.__propertyValues){

        this.__propertyValues = {
        };
      };
      if(this.__propertyValues[key] == value){

        return this;
      };
      if(value == null){

        delete this.__propertyValues[key];
      } else {

        this.__propertyValues[key] = value;
      };
      if(this.__element){

        if(direct){

          this._applyProperty(key, value);
          return this;
        };
        if(!this.__propertyJobs){

          this.__propertyJobs = {
          };
        };
        this.__propertyJobs[key] = true;
        qx.html.Element._modified[this.$$hash] = this;
        qx.html.Element._scheduleFlush("element");
      };
      return this;
    },
    _removeProperty : function(key, direct){

      return this._setProperty(key, null, direct);
    },
    _getProperty : function(key){

      var db = this.__propertyValues;
      if(!db){

        return null;
      };
      var value = db[key];
      return value == null ? null : value;
    },
    addListener : function(type, listener, self, capture){

      if(this.$$disposed){

        return null;
      };
      if(qx.core.Environment.get("qx.debug")){

        var msg = "Failed to add event listener for type '" + type + "'" + " to the target '" + this + "': ";
        this.assertString(type, msg + "Invalid event type.");
        this.assertFunction(listener, msg + "Invalid callback function");
        if(self !== undefined){

          this.assertObject(self, "Invalid context for callback.");
        };
        if(capture !== undefined){

          this.assertBoolean(capture, "Invalid capture flag.");
        };
      };
      if(this.__element){

        return qx.event.Registration.addListener(this.__element, type, listener, self, capture);
      };
      if(!this.__eventValues){

        this.__eventValues = {
        };
      };
      if(capture == null){

        capture = false;
      };
      var unique = qx.event.Manager.getNextUniqueId();
      var id = type + (capture ? "|capture|" : "|bubble|") + unique;
      this.__eventValues[id] = {
        type : type,
        listener : listener,
        self : self,
        capture : capture,
        unique : unique
      };
      return id;
    },
    removeListener : function(type, listener, self, capture){

      if(this.$$disposed){

        return null;
      };
      if(qx.core.Environment.get("qx.debug")){

        var msg = "Failed to remove event listener for type '" + type + "'" + " from the target '" + this + "': ";
        this.assertString(type, msg + "Invalid event type.");
        this.assertFunction(listener, msg + "Invalid callback function");
        if(self !== undefined){

          this.assertObject(self, "Invalid context for callback.");
        };
        if(capture !== undefined){

          this.assertBoolean(capture, "Invalid capture flag.");
        };
      };
      if(this.__element){

        qx.event.Registration.removeListener(this.__element, type, listener, self, capture);
      } else {

        var values = this.__eventValues;
        var entry;
        if(capture == null){

          capture = false;
        };
        for(var key in values){

          entry = values[key];
          if(entry.listener === listener && entry.self === self && entry.capture === capture && entry.type === type){

            delete values[key];
            break;
          };
        };
      };
      return this;
    },
    removeListenerById : function(id){

      if(this.$$disposed){

        return null;
      };
      if(this.__element){

        qx.event.Registration.removeListenerById(this.__element, id);
      } else {

        delete this.__eventValues[id];
      };
      return this;
    },
    hasListener : function(type, capture){

      if(this.$$disposed){

        return false;
      };
      if(this.__element){

        return qx.event.Registration.hasListener(this.__element, type, capture);
      };
      var values = this.__eventValues;
      var entry;
      if(capture == null){

        capture = false;
      };
      for(var key in values){

        entry = values[key];
        if(entry.capture === capture && entry.type === type){

          return true;
        };
      };
      return false;
    },
    getListeners : function(){

      if(this.$$disposed){

        return null;
      };
      if(this.__element){

        return qx.event.Registration.getManager(this.__element).serializeListeners(this.__element);
      };
      var listeners = [];
      for(var id in this.__eventValues){

        var listenerData = this.__eventValues[id];
        listeners.push({
          type : listenerData.type,
          handler : listenerData.listener,
          self : listenerData.self,
          capture : listenerData.capture
        });
      };
      return listeners;
    }
  },
  defer : function(statics){

    statics.__deferredCall = new qx.util.DeferredCall(statics.flush, statics);
  },
  destruct : function(){

    var el = this.__element;
    if(el){

      qx.event.Registration.getManager(el).removeAllListeners(el);
      el.$$element = "";
    };
    if(!qx.core.ObjectRegistry.inShutDown){

      var parent = this.__parent;
      if(parent && !parent.$$disposed){

        parent.remove(this);
      };
    };
    this._disposeArray("__children");
    this.__attribValues = this.__styleValues = this.__eventValues = this.__propertyValues = this.__attribJobs = this.__styleJobs = this.__propertyJobs = this.__element = this.__parent = this.__lazyScrollIntoViewX = this.__lazyScrollIntoViewY = null;
  }
});

qx.Class.define("qx.event.handler.Offline", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  construct : function(manager){

    this.base(arguments);
    this.__manager = manager;
    this.__window = manager.getWindow();
    this._initObserver();
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      online : true,
      offline : true
    },
    TARGET_CHECK : qx.event.IEventHandler.TARGET_WINDOW,
    IGNORE_CAN_HANDLE : true
  },
  members : {
    __manager : null,
    __window : null,
    __onNativeWrapper : null,
    canHandleEvent : function(target, type){
    },
    registerEvent : function(target, type, capture){
    },
    unregisterEvent : function(target, type, capture){
    },
    _initObserver : function(){

      this.__onNativeWrapper = qx.lang.Function.listener(this._onNative, this);
      qx.bom.Event.addNativeListener(this.__window, "offline", this.__onNativeWrapper);
      qx.bom.Event.addNativeListener(this.__window, "online", this.__onNativeWrapper);
    },
    _stopObserver : function(){

      qx.bom.Event.removeNativeListener(this.__window, "offline", this.__onNativeWrapper);
      qx.bom.Event.removeNativeListener(this.__window, "online", this.__onNativeWrapper);
    },
    _onNative : qx.event.GlobalError.observeMethod(function(domEvent){

      qx.event.Registration.fireEvent(this.__window, domEvent.type, qx.event.type.Event, []);
    }),
    isOnline : function(){

      return !!this.__window.navigator.onLine;
    }
  },
  destruct : function(){

    this.__manager = null;
    this._stopObserver();
    delete qx.event.handler.Appear.__instances[this.$$hash];
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
  }
});

qx.Class.define("qx.bom.Element", {
  statics : {
    addListener : function(element, type, listener, self, capture){

      return qx.event.Registration.addListener(element, type, listener, self, capture);
    },
    removeListener : function(element, type, listener, self, capture){

      return qx.event.Registration.removeListener(element, type, listener, self, capture);
    },
    removeListenerById : function(target, id){

      return qx.event.Registration.removeListenerById(target, id);
    },
    hasListener : function(element, type, capture){

      return qx.event.Registration.hasListener(element, type, capture);
    },
    focus : function(element){

      qx.event.Registration.getManager(element).getHandler(qx.event.handler.Focus).focus(element);
    },
    blur : function(element){

      qx.event.Registration.getManager(element).getHandler(qx.event.handler.Focus).blur(element);
    },
    activate : function(element){

      qx.event.Registration.getManager(element).getHandler(qx.event.handler.Focus).activate(element);
    },
    deactivate : function(element){

      qx.event.Registration.getManager(element).getHandler(qx.event.handler.Focus).deactivate(element);
    },
    capture : function(element, containerCapture){

      qx.event.Registration.getManager(element).getDispatcher(qx.event.dispatch.MouseCapture).activateCapture(element, containerCapture);
    },
    releaseCapture : function(element){

      qx.event.Registration.getManager(element).getDispatcher(qx.event.dispatch.MouseCapture).releaseCapture(element);
    },
    clone : function(element, events){

      var clone;
      if(events || ((qx.core.Environment.get("engine.name") == "mshtml") && !qx.xml.Document.isXmlDocument(element))){

        var mgr = qx.event.Registration.getManager(element);
        var all = qx.dom.Hierarchy.getDescendants(element);
        all.push(element);
      };
      if((qx.core.Environment.get("engine.name") == "mshtml")){

        for(var i = 0,l = all.length;i < l;i++){

          mgr.toggleAttachedEvents(all[i], false);
        };
      };
      var clone = element.cloneNode(true);
      if((qx.core.Environment.get("engine.name") == "mshtml")){

        for(var i = 0,l = all.length;i < l;i++){

          mgr.toggleAttachedEvents(all[i], true);
        };
      };
      if(events === true){

        var cloneAll = qx.dom.Hierarchy.getDescendants(clone);
        cloneAll.push(clone);
        var eventList,cloneElem,origElem,eventEntry;
        for(var i = 0,il = all.length;i < il;i++){

          origElem = all[i];
          eventList = mgr.serializeListeners(origElem);
          if(eventList.length > 0){

            cloneElem = cloneAll[i];
            for(var j = 0,jl = eventList.length;j < jl;j++){

              eventEntry = eventList[j];
              mgr.addListener(cloneElem, eventEntry.type, eventEntry.handler, eventEntry.self, eventEntry.capture);
            };
          };
        };
      };
      return clone;
    }
  }
});

qx.Class.define("qx.event.dispatch.MouseCapture", {
  extend : qx.event.dispatch.AbstractBubbling,
  construct : function(manager, registration){

    this.base(arguments, manager);
    this.__window = manager.getWindow();
    this.__registration = registration;
    manager.addListener(this.__window, "blur", this.releaseCapture, this);
    manager.addListener(this.__window, "focus", this.releaseCapture, this);
    manager.addListener(this.__window, "scroll", this.releaseCapture, this);
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_FIRST
  },
  members : {
    __registration : null,
    __captureElement : null,
    __containerCapture : true,
    __window : null,
    _getParent : function(target){

      return target.parentNode;
    },
    canDispatchEvent : function(target, event, type){

      return !!(this.__captureElement && this.__captureEvents[type]);
    },
    dispatchEvent : function(target, event, type){

      if(type == "click"){

        event.stopPropagation();
        this.releaseCapture();
        return;
      };
      if(this.__containerCapture || !qx.dom.Hierarchy.contains(this.__captureElement, target)){

        target = this.__captureElement;
      };
      this.base(arguments, target, event, type);
    },
    __captureEvents : {
      "mouseup" : 1,
      "mousedown" : 1,
      "click" : 1,
      "dblclick" : 1,
      "mousemove" : 1,
      "mouseout" : 1,
      "mouseover" : 1,
      "pointerdown" : 1,
      "pointerup" : 1,
      "pointermove" : 1,
      "pointerover" : 1,
      "pointerout" : 1,
      "tap" : 1,
      "dbltap" : 1
    },
    activateCapture : function(element, containerCapture){

      var containerCapture = containerCapture !== false;
      if(this.__captureElement === element && this.__containerCapture == containerCapture){

        return;
      };
      if(this.__captureElement){

        this.releaseCapture();
      };
      if(this.hasNativeCapture){

        this.nativeSetCapture(element, containerCapture);
        var self = this;
        qx.bom.Event.addNativeListener(element, "losecapture", function(){

          qx.bom.Event.removeNativeListener(element, "losecapture", arguments.callee);
          self.releaseCapture();
        });
      };
      this.__containerCapture = containerCapture;
      this.__captureElement = element;
      this.__registration.fireEvent(element, "capture", qx.event.type.Event, [true, false]);
    },
    getCaptureElement : function(){

      return this.__captureElement;
    },
    releaseCapture : function(){

      var element = this.__captureElement;
      if(!element){

        return;
      };
      this.__captureElement = null;
      this.__registration.fireEvent(element, "losecapture", qx.event.type.Event, [true, false]);
      this.nativeReleaseCapture(element);
    },
    hasNativeCapture : (qx.core.Environment.get("engine.name") == "mshtml" && (qx.core.Environment.get("os.version") !== "7" || qx.core.Environment.get("browser.documentmode") < 9)),
    nativeSetCapture : qx.core.Environment.select("engine.name", {
      "mshtml" : function(element, containerCapture){

        element.setCapture(containerCapture !== false);
      },
      "default" : (function(){
      })
    }),
    nativeReleaseCapture : qx.core.Environment.select("engine.name", {
      "mshtml" : function(element){

        element.releaseCapture();
      },
      "default" : (function(){
      })
    })
  },
  destruct : function(){

    this.__captureElement = this.__window = this.__registration = null;
  },
  defer : function(statics){

    qx.event.Registration.addDispatcher(statics);
  }
});

qx.Bootstrap.define("qx.bom.client.Plugin", {
  statics : {
    getGears : function(){

      return !!(window.google && window.google.gears);
    },
    getActiveX : function(){

      if(typeof window.ActiveXObject === "function"){

        return true;
      };
      try{

        return (typeof (new window.ActiveXObject("Microsoft.XMLHTTP")) === "object" || typeof (new window.ActiveXObject("MSXML2.DOMDocument.6.0")) === "object");
      } catch(ex) {

        return false;
      };
    },
    getSkype : function(){

      if(qx.bom.client.Plugin.getActiveX()){

        try{

          new ActiveXObject("Skype.Detection");
          return true;
        } catch(e) {
        };
      };
      var mimeTypes = navigator.mimeTypes;
      if(mimeTypes){

        if("application/x-skype" in mimeTypes){

          return true;
        };
        for(var i = 0;i < mimeTypes.length;i++){

          var desc = mimeTypes[i];
          if(desc.type.indexOf("skype.click2call") != -1){

            return true;
          };
        };
      };
      return false;
    },
    __db : {
      quicktime : {
        plugin : ["QuickTime"],
        control : "QuickTimeCheckObject.QuickTimeCheck.1"
      },
      wmv : {
        plugin : ["Windows Media"],
        control : "WMPlayer.OCX.7"
      },
      divx : {
        plugin : ["DivX Web Player"],
        control : "npdivx.DivXBrowserPlugin.1"
      },
      silverlight : {
        plugin : ["Silverlight"],
        control : "AgControl.AgControl"
      },
      pdf : {
        plugin : ["Chrome PDF Viewer", "Adobe Acrobat"],
        control : "AcroPDF.PDF"
      }
    },
    getQuicktimeVersion : function(){

      var entry = qx.bom.client.Plugin.__db["quicktime"];
      return qx.bom.client.Plugin.__getVersion(entry.control, entry.plugin);
    },
    getWindowsMediaVersion : function(){

      var entry = qx.bom.client.Plugin.__db["wmv"];
      return qx.bom.client.Plugin.__getVersion(entry.control, entry.plugin);
    },
    getDivXVersion : function(){

      var entry = qx.bom.client.Plugin.__db["divx"];
      return qx.bom.client.Plugin.__getVersion(entry.control, entry.plugin);
    },
    getSilverlightVersion : function(){

      var entry = qx.bom.client.Plugin.__db["silverlight"];
      return qx.bom.client.Plugin.__getVersion(entry.control, entry.plugin);
    },
    getPdfVersion : function(){

      var entry = qx.bom.client.Plugin.__db["pdf"];
      return qx.bom.client.Plugin.__getVersion(entry.control, entry.plugin);
    },
    getQuicktime : function(){

      var entry = qx.bom.client.Plugin.__db["quicktime"];
      return qx.bom.client.Plugin.__isAvailable(entry.control, entry.plugin);
    },
    getWindowsMedia : function(){

      var entry = qx.bom.client.Plugin.__db["wmv"];
      return qx.bom.client.Plugin.__isAvailable(entry.control, entry.plugin);
    },
    getDivX : function(){

      var entry = qx.bom.client.Plugin.__db["divx"];
      return qx.bom.client.Plugin.__isAvailable(entry.control, entry.plugin);
    },
    getSilverlight : function(){

      var entry = qx.bom.client.Plugin.__db["silverlight"];
      return qx.bom.client.Plugin.__isAvailable(entry.control, entry.plugin);
    },
    getPdf : function(){

      var entry = qx.bom.client.Plugin.__db["pdf"];
      return qx.bom.client.Plugin.__isAvailable(entry.control, entry.plugin);
    },
    __getVersion : function(activeXName, pluginNames){

      var available = qx.bom.client.Plugin.__isAvailable(activeXName, pluginNames);
      if(!available){

        return "";
      };
      if(qx.bom.client.Engine.getName() == "mshtml"){

        var obj = new ActiveXObject(activeXName);
        try{

          var version = obj.versionInfo;
          if(version != undefined){

            return version;
          };
          version = obj.version;
          if(version != undefined){

            return version;
          };
          version = obj.settings.version;
          if(version != undefined){

            return version;
          };
        } catch(ex) {

          return "";
        };
        return "";
      } else {

        var plugins = navigator.plugins;
        var verreg = /([0-9]\.[0-9])/g;
        for(var i = 0;i < plugins.length;i++){

          var plugin = plugins[i];
          for(var j = 0;j < pluginNames.length;j++){

            if(plugin.name.indexOf(pluginNames[j]) !== -1){

              if(verreg.test(plugin.name) || verreg.test(plugin.description)){

                return RegExp.$1;
              };
            };
          };
        };
        return "";
      };
    },
    __isAvailable : function(activeXName, pluginNames){

      if(qx.bom.client.Engine.getName() == "mshtml"){

        var control = window.ActiveXObject;
        if(!control){

          return false;
        };
        try{

          new ActiveXObject(activeXName);
        } catch(ex) {

          return false;
        };
        return true;
      } else {

        var plugins = navigator.plugins;
        if(!plugins){

          return false;
        };
        var name;
        for(var i = 0;i < plugins.length;i++){

          name = plugins[i].name;
          for(var j = 0;j < pluginNames.length;j++){

            if(name.indexOf(pluginNames[j]) !== -1){

              return true;
            };
          };
        };
        return false;
      };
    }
  },
  defer : function(statics){

    qx.core.Environment.add("plugin.gears", statics.getGears);
    qx.core.Environment.add("plugin.quicktime", statics.getQuicktime);
    qx.core.Environment.add("plugin.quicktime.version", statics.getQuicktimeVersion);
    qx.core.Environment.add("plugin.windowsmedia", statics.getWindowsMedia);
    qx.core.Environment.add("plugin.windowsmedia.version", statics.getWindowsMediaVersion);
    qx.core.Environment.add("plugin.divx", statics.getDivX);
    qx.core.Environment.add("plugin.divx.version", statics.getDivXVersion);
    qx.core.Environment.add("plugin.silverlight", statics.getSilverlight);
    qx.core.Environment.add("plugin.silverlight.version", statics.getSilverlightVersion);
    qx.core.Environment.add("plugin.pdf", statics.getPdf);
    qx.core.Environment.add("plugin.pdf.version", statics.getPdfVersion);
    qx.core.Environment.add("plugin.activex", statics.getActiveX);
    qx.core.Environment.add("plugin.skype", statics.getSkype);
  }
});

qx.Bootstrap.define("qx.xml.Document", {
  statics : {
    DOMDOC : null,
    XMLHTTP : null,
    isXmlDocument : function(elem){

      if(elem.nodeType === 9){

        return elem.documentElement.nodeName !== "HTML";
      } else if(elem.ownerDocument){

        return this.isXmlDocument(elem.ownerDocument);
      } else {

        return false;
      };
    },
    create : function(namespaceUri, qualifiedName){

      if(qx.core.Environment.get("plugin.activex")){

        var obj = new ActiveXObject(this.DOMDOC);
        if(this.DOMDOC == "MSXML2.DOMDocument.3.0"){

          obj.setProperty("SelectionLanguage", "XPath");
        };
        if(qualifiedName){

          var str = '<\?xml version="1.0" encoding="utf-8"?>\n<';
          str += qualifiedName;
          if(namespaceUri){

            str += " xmlns='" + namespaceUri + "'";
          };
          str += " />";
          obj.loadXML(str);
        };
        return obj;
      };
      if(qx.core.Environment.get("xml.implementation")){

        return document.implementation.createDocument(namespaceUri || "", qualifiedName || "", null);
      };
      throw new Error("No XML implementation available!");
    },
    fromString : function(str){

      if(qx.core.Environment.get("plugin.activex")){

        var dom = qx.xml.Document.create();
        dom.loadXML(str);
        return dom;
      };
      if(qx.core.Environment.get("xml.domparser")){

        var parser = new DOMParser();
        return parser.parseFromString(str, "text/xml");
      };
      throw new Error("No XML implementation available!");
    }
  },
  defer : function(statics){

    if(qx.core.Environment.get("plugin.activex")){

      var domDoc = ["MSXML2.DOMDocument.6.0", "MSXML2.DOMDocument.3.0"];
      var httpReq = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0"];
      for(var i = 0,l = domDoc.length;i < l;i++){

        try{

          new ActiveXObject(domDoc[i]);
          new ActiveXObject(httpReq[i]);
        } catch(ex) {

          continue;
        };
        statics.DOMDOC = domDoc[i];
        statics.XMLHTTP = httpReq[i];
        break;
      };
    };
  }
});

qx.Bootstrap.define("qx.bom.client.Xml", {
  statics : {
    getImplementation : function(){

      return document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("XML", "1.0");
    },
    getDomParser : function(){

      return typeof window.DOMParser !== "undefined";
    },
    getSelectSingleNode : function(){

      return typeof qx.xml.Document.create().selectSingleNode !== "undefined";
    },
    getSelectNodes : function(){

      return typeof qx.xml.Document.create().selectNodes !== "undefined";
    },
    getElementsByTagNameNS : function(){

      return typeof qx.xml.Document.create().getElementsByTagNameNS !== "undefined";
    },
    getDomProperties : function(){

      var doc = qx.xml.Document.create();
      return ("getProperty" in doc && typeof doc.getProperty("SelectionLanguage") === "string");
    },
    getAttributeNS : function(){

      var docElem = qx.xml.Document.fromString("<a></a>").documentElement;
      return typeof docElem.getAttributeNS === "function" && typeof docElem.setAttributeNS === "function";
    },
    getCreateElementNS : function(){

      return typeof qx.xml.Document.create().createElementNS === "function";
    },
    getCreateNode : function(){

      return typeof qx.xml.Document.create().createNode !== "undefined";
    },
    getQualifiedItem : function(){

      var docElem = qx.xml.Document.fromString("<a></a>").documentElement;
      return typeof docElem.attributes.getQualifiedItem !== "undefined";
    }
  },
  defer : function(statics){

    qx.core.Environment.add("xml.implementation", statics.getImplementation);
    qx.core.Environment.add("xml.domparser", statics.getDomParser);
    qx.core.Environment.add("xml.selectsinglenode", statics.getSelectSingleNode);
    qx.core.Environment.add("xml.selectnodes", statics.getSelectNodes);
    qx.core.Environment.add("xml.getelementsbytagnamens", statics.getElementsByTagNameNS);
    qx.core.Environment.add("xml.domproperties", statics.getDomProperties);
    qx.core.Environment.add("xml.attributens", statics.getAttributeNS);
    qx.core.Environment.add("xml.createelementns", statics.getCreateElementNS);
    qx.core.Environment.add("xml.createnode", statics.getCreateNode);
    qx.core.Environment.add("xml.getqualifieditem", statics.getQualifiedItem);
  }
});

qx.Class.define("qx.ui.core.queue.Manager", {
  statics : {
    __scheduled : false,
    __canceled : false,
    __jobs : {
    },
    __retries : 0,
    MAX_RETRIES : 10,
    scheduleFlush : function(job){

      var self = qx.ui.core.queue.Manager;
      self.__jobs[job] = true;
      if(!self.__scheduled){

        self.__canceled = false;
        qx.bom.AnimationFrame.request(function(){

          if(self.__canceled){

            self.__canceled = false;
            return;
          };
          self.flush();
        }, self);
        self.__scheduled = true;
      };
    },
    flush : function(){

      var self = qx.ui.core.queue.Manager;
      if(self.__inFlush){

        return;
      };
      self.__inFlush = true;
      self.__canceled = true;
      var jobs = self.__jobs;
      self.__executeAndRescheduleOnError(function(){

        while(jobs.visibility || jobs.widget || jobs.appearance || jobs.layout || jobs.element){

          if(jobs.widget){

            delete jobs.widget;
            if(qx.core.Environment.get("qx.debug.ui.queue")){

              try{

                qx.ui.core.queue.Widget.flush();
              } catch(e) {

                qx.log.Logger.error(qx.ui.core.queue.Widget, "Error in the 'Widget' queue:" + e, e);
              };
            } else {

              qx.ui.core.queue.Widget.flush();
            };
          };
          if(jobs.visibility){

            delete jobs.visibility;
            if(qx.core.Environment.get("qx.debug.ui.queue")){

              try{

                qx.ui.core.queue.Visibility.flush();
              } catch(e) {

                qx.log.Logger.error(qx.ui.core.queue.Visibility, "Error in the 'Visibility' queue:" + e, e);
              };
            } else {

              qx.ui.core.queue.Visibility.flush();
            };
          };
          if(jobs.appearance){

            delete jobs.appearance;
            if(qx.core.Environment.get("qx.debug.ui.queue")){

              try{

                qx.ui.core.queue.Appearance.flush();
              } catch(e) {

                qx.log.Logger.error(qx.ui.core.queue.Appearance, "Error in the 'Appearance' queue:" + e, e);
              };
            } else {

              qx.ui.core.queue.Appearance.flush();
            };
          };
          if(jobs.widget || jobs.visibility || jobs.appearance){

            continue;
          };
          if(jobs.layout){

            delete jobs.layout;
            if(qx.core.Environment.get("qx.debug.ui.queue")){

              try{

                qx.ui.core.queue.Layout.flush();
              } catch(e) {

                qx.log.Logger.error(qx.ui.core.queue.Layout, "Error in the 'Layout' queue:" + e, e);
              };
            } else {

              qx.ui.core.queue.Layout.flush();
            };
          };
          if(jobs.widget || jobs.visibility || jobs.appearance || jobs.layout){

            continue;
          };
          if(jobs.element){

            delete jobs.element;
            qx.html.Element.flush();
          };
        };
      }, function(){

        self.__scheduled = false;
      });
      self.__executeAndRescheduleOnError(function(){

        if(jobs.dispose){

          delete jobs.dispose;
          if(qx.core.Environment.get("qx.debug.ui.queue")){

            try{

              qx.ui.core.queue.Dispose.flush();
            } catch(e) {

              qx.log.Logger.error("Error in the 'Dispose' queue:" + e);
            };
          } else {

            qx.ui.core.queue.Dispose.flush();
          };
        };
      }, function(){

        self.__inFlush = false;
      });
      self.__retries = 0;
    },
    __executeAndRescheduleOnError : qx.core.Environment.select("qx.debug", {
      "true" : function(callback, finallyCode){

        callback();
        finallyCode();
      },
      "false" : function(callback, finallyCode){

        var self = qx.ui.core.queue.Manager;
        try{

          callback();
        } catch(e) {

          if(qx.core.Environment.get("qx.debug")){

            qx.log.Logger.error("Error while layout flush: " + e + "\n" + "Stack trace: \n" + qx.dev.StackTrace.getStackTraceFromError(e));
          };
          self.__scheduled = false;
          self.__inFlush = false;
          self.__retries += 1;
          if(self.__retries <= self.MAX_RETRIES){

            self.scheduleFlush();
          } else {

            throw new Error("Fatal Error: Flush terminated " + (self.__retries - 1) + " times in a row" + " due to exceptions in user code. The application has to be reloaded!");
          };
          throw e;
        }finally{

          finallyCode();
        };
      }
    }),
    __onUserAction : function(e){

      qx.ui.core.queue.Manager.flush();
    }
  },
  defer : function(statics){

    qx.html.Element._scheduleFlush = statics.scheduleFlush;
    qx.event.Registration.addListener(window, "useraction", qx.core.Environment.get("event.touch") ? statics.__onUserAction : statics.flush);
  }
});

qx.Class.define("qx.ui.core.queue.Widget", {
  statics : {
    __queue : [],
    __jobs : {
    },
    remove : function(widget, job){

      var queue = this.__queue;
      if(!qx.lang.Array.contains(queue, widget)){

        return;
      };
      var hash = widget.$$hash;
      if(job == null){

        qx.lang.Array.remove(queue, widget);
        delete this.__jobs[hash];
        return;
      };
      if(this.__jobs[hash]){

        delete this.__jobs[hash][job];
        if(qx.lang.Object.getLength(this.__jobs[hash]) == 0){

          qx.lang.Array.remove(queue, widget);
        };
      };
    },
    add : function(widget, job){

      var queue = this.__queue;
      if(!qx.lang.Array.contains(queue, widget)){

        queue.unshift(widget);
      };
      if(job == null){

        job = "$$default";
      };
      var hash = widget.$$hash;
      if(!this.__jobs[hash]){

        this.__jobs[hash] = {
        };
      };
      this.__jobs[hash][job] = true;
      qx.ui.core.queue.Manager.scheduleFlush("widget");
    },
    flush : function(){

      var queue = this.__queue;
      var obj,jobs;
      for(var i = queue.length - 1;i >= 0;i--){

        obj = queue[i];
        jobs = this.__jobs[obj.$$hash];
        queue.splice(i, 1);
        obj.syncWidget(jobs);
      };
      if(queue.length != 0){

        return;
      };
      this.__queue = [];
      this.__jobs = {
      };
    }
  }
});

qx.Class.define("qx.ui.core.queue.Visibility", {
  statics : {
    __queue : [],
    __data : {
    },
    remove : function(widget){

      delete this.__data[widget.$$hash];
      qx.lang.Array.remove(this.__queue, widget);
    },
    isVisible : function(widget){

      return this.__data[widget.$$hash] || false;
    },
    __computeVisible : function(widget){

      var data = this.__data;
      var hash = widget.$$hash;
      var visible;
      if(widget.isExcluded()){

        visible = false;
      } else {

        var parent = widget.$$parent;
        if(parent){

          visible = this.__computeVisible(parent);
        } else {

          visible = widget.isRootWidget();
        };
      };
      return data[hash] = visible;
    },
    add : function(widget){

      var queue = this.__queue;
      if(qx.lang.Array.contains(queue, widget)){

        return;
      };
      queue.unshift(widget);
      qx.ui.core.queue.Manager.scheduleFlush("visibility");
    },
    flush : function(){

      var queue = this.__queue;
      var data = this.__data;
      for(var i = queue.length - 1;i >= 0;i--){

        var hash = queue[i].$$hash;
        if(data[hash] != null){

          queue[i].addChildrenToQueue(queue);
        };
      };
      var oldData = {
      };
      for(var i = queue.length - 1;i >= 0;i--){

        var hash = queue[i].$$hash;
        oldData[hash] = data[hash];
        data[hash] = null;
      };
      for(var i = queue.length - 1;i >= 0;i--){

        var widget = queue[i];
        var hash = widget.$$hash;
        queue.splice(i, 1);
        if(data[hash] == null){

          this.__computeVisible(widget);
        };
        if(data[hash] && data[hash] != oldData[hash]){

          widget.checkAppearanceNeeds();
        };
      };
      this.__queue = [];
    }
  }
});

qx.Class.define("qx.ui.core.queue.Appearance", {
  statics : {
    __queue : [],
    remove : function(widget){

      qx.lang.Array.remove(this.__queue, widget);
    },
    add : function(widget){

      var queue = this.__queue;
      if(qx.lang.Array.contains(queue, widget)){

        return;
      };
      queue.unshift(widget);
      qx.ui.core.queue.Manager.scheduleFlush("appearance");
    },
    has : function(widget){

      return qx.lang.Array.contains(this.__queue, widget);
    },
    flush : function(){

      var Visibility = qx.ui.core.queue.Visibility;
      var queue = this.__queue;
      var obj;
      for(var i = queue.length - 1;i >= 0;i--){

        obj = queue[i];
        queue.splice(i, 1);
        if(Visibility.isVisible(obj)){

          obj.syncAppearance();
        } else {

          obj.$$stateChanges = true;
        };
      };
    }
  }
});

qx.Class.define("qx.ui.core.queue.Dispose", {
  statics : {
    __queue : [],
    add : function(widget){

      var queue = this.__queue;
      if(qx.lang.Array.contains(queue, widget)){

        return;
      };
      queue.unshift(widget);
      qx.ui.core.queue.Manager.scheduleFlush("dispose");
    },
    isEmpty : function(){

      return this.__queue.length == 0;
    },
    flush : function(){

      var queue = this.__queue;
      for(var i = queue.length - 1;i >= 0;i--){

        var widget = queue[i];
        queue.splice(i, 1);
        widget.dispose();
      };
      if(queue.length != 0){

        return;
      };
      this.__queue = [];
    }
  }
});

qx.Class.define("qx.ui.core.Widget", {
  extend : qx.ui.core.LayoutItem,
  include : [qx.locale.MTranslation],
  construct : function(){

    this.base(arguments);
    this.__contentElement = this.__createContentElement();
    this.initFocusable();
    this.initSelectable();
    this.initNativeContextMenu();
  },
  events : {
    appear : "qx.event.type.Event",
    disappear : "qx.event.type.Event",
    createChildControl : "qx.event.type.Data",
    resize : "qx.event.type.Data",
    move : "qx.event.type.Data",
    syncAppearance : "qx.event.type.Data",
    mousemove : "qx.event.type.Mouse",
    mouseover : "qx.event.type.Mouse",
    mouseout : "qx.event.type.Mouse",
    mousedown : "qx.event.type.Mouse",
    mouseup : "qx.event.type.Mouse",
    click : "qx.event.type.Mouse",
    dblclick : "qx.event.type.Mouse",
    contextmenu : "qx.event.type.Mouse",
    beforeContextmenuOpen : "qx.event.type.Data",
    mousewheel : "qx.event.type.MouseWheel",
    touchstart : "qx.event.type.Touch",
    touchend : "qx.event.type.Touch",
    touchmove : "qx.event.type.Touch",
    touchcancel : "qx.event.type.Touch",
    tap : "qx.event.type.Tap",
    longtap : "qx.event.type.Tap",
    dbltap : "qx.event.type.Tap",
    swipe : "qx.event.type.Touch",
    rotate : "qx.event.type.Rotate",
    pinch : "qx.event.type.Pinch",
    track : "qx.event.type.Track",
    roll : "qx.event.type.Roll",
    pointermove : "qx.event.type.Pointer",
    pointerover : "qx.event.type.Pointer",
    pointerout : "qx.event.type.Pointer",
    pointerdown : "qx.event.type.Pointer",
    pointerup : "qx.event.type.Pointer",
    pointercancel : "qx.event.type.Pointer",
    keyup : "qx.event.type.KeySequence",
    keydown : "qx.event.type.KeySequence",
    keypress : "qx.event.type.KeySequence",
    keyinput : "qx.event.type.KeyInput",
    focus : "qx.event.type.Focus",
    blur : "qx.event.type.Focus",
    focusin : "qx.event.type.Focus",
    focusout : "qx.event.type.Focus",
    activate : "qx.event.type.Focus",
    deactivate : "qx.event.type.Focus",
    capture : "qx.event.type.Event",
    losecapture : "qx.event.type.Event",
    drop : "qx.event.type.Drag",
    dragleave : "qx.event.type.Drag",
    dragover : "qx.event.type.Drag",
    drag : "qx.event.type.Drag",
    dragstart : "qx.event.type.Drag",
    dragend : "qx.event.type.Drag",
    dragchange : "qx.event.type.Drag",
    droprequest : "qx.event.type.Drag"
  },
  properties : {
    paddingTop : {
      check : "Integer",
      init : 0,
      apply : "_applyPadding",
      themeable : true
    },
    paddingRight : {
      check : "Integer",
      init : 0,
      apply : "_applyPadding",
      themeable : true
    },
    paddingBottom : {
      check : "Integer",
      init : 0,
      apply : "_applyPadding",
      themeable : true
    },
    paddingLeft : {
      check : "Integer",
      init : 0,
      apply : "_applyPadding",
      themeable : true
    },
    padding : {
      group : ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
      mode : "shorthand",
      themeable : true
    },
    zIndex : {
      nullable : true,
      init : 10,
      apply : "_applyZIndex",
      event : "changeZIndex",
      check : "Integer",
      themeable : true
    },
    decorator : {
      nullable : true,
      init : null,
      apply : "_applyDecorator",
      event : "changeDecorator",
      check : "Decorator",
      themeable : true
    },
    backgroundColor : {
      nullable : true,
      check : "Color",
      apply : "_applyBackgroundColor",
      event : "changeBackgroundColor",
      themeable : true
    },
    textColor : {
      nullable : true,
      check : "Color",
      apply : "_applyTextColor",
      event : "changeTextColor",
      themeable : true,
      inheritable : true
    },
    font : {
      nullable : true,
      apply : "_applyFont",
      check : "Font",
      event : "changeFont",
      themeable : true,
      inheritable : true,
      dereference : true
    },
    opacity : {
      check : "Number",
      apply : "_applyOpacity",
      themeable : true,
      nullable : true,
      init : null
    },
    cursor : {
      check : "String",
      apply : "_applyCursor",
      themeable : true,
      inheritable : true,
      nullable : true,
      init : null
    },
    toolTip : {
      check : "qx.ui.tooltip.ToolTip",
      nullable : true
    },
    toolTipText : {
      check : "String",
      nullable : true,
      event : "changeToolTipText",
      apply : "_applyToolTipText"
    },
    toolTipIcon : {
      check : "String",
      nullable : true,
      event : "changeToolTipText"
    },
    blockToolTip : {
      check : "Boolean",
      init : false
    },
    visibility : {
      check : ["visible", "hidden", "excluded"],
      init : "visible",
      apply : "_applyVisibility",
      event : "changeVisibility"
    },
    enabled : {
      init : true,
      check : "Boolean",
      inheritable : true,
      apply : "_applyEnabled",
      event : "changeEnabled"
    },
    anonymous : {
      init : false,
      check : "Boolean"
    },
    tabIndex : {
      check : "Integer",
      nullable : true,
      apply : "_applyTabIndex"
    },
    focusable : {
      check : "Boolean",
      init : false,
      apply : "_applyFocusable"
    },
    keepFocus : {
      check : "Boolean",
      init : false,
      apply : "_applyKeepFocus"
    },
    keepActive : {
      check : "Boolean",
      init : false,
      apply : "_applyKeepActive"
    },
    draggable : {
      check : "Boolean",
      init : false,
      apply : "_applyDraggable"
    },
    droppable : {
      check : "Boolean",
      init : false,
      apply : "_applyDroppable"
    },
    selectable : {
      check : "Boolean",
      init : false,
      event : "changeSelectable",
      apply : "_applySelectable"
    },
    contextMenu : {
      check : "qx.ui.menu.Menu",
      apply : "_applyContextMenu",
      nullable : true,
      event : "changeContextMenu"
    },
    nativeContextMenu : {
      check : "Boolean",
      init : false,
      themeable : true,
      event : "changeNativeContextMenu",
      apply : "_applyNativeContextMenu"
    },
    appearance : {
      check : "String",
      init : "widget",
      apply : "_applyAppearance",
      event : "changeAppearance"
    }
  },
  statics : {
    DEBUG : false,
    getWidgetByElement : function(element, considerAnonymousState){

      while(element){

        var widgetKey = element.$$widget;
        if(widgetKey != null){

          var widget = qx.core.ObjectRegistry.fromHashCode(widgetKey);
          if(!considerAnonymousState || !widget.getAnonymous()){

            return widget;
          };
        };
        try{

          element = element.parentNode;
        } catch(e) {

          return null;
        };
      };
      return null;
    },
    contains : function(parent, child){

      while(child){

        if(parent == child){

          return true;
        };
        child = child.getLayoutParent();
      };
      return false;
    },
    __separatorPool : new qx.util.ObjectPool()
  },
  members : {
    __contentElement : null,
    __initialAppearanceApplied : null,
    __toolTipTextListenerId : null,
    __layoutManager : null,
    _getLayout : function(){

      return this.__layoutManager;
    },
    _setLayout : function(layout){

      if(qx.core.Environment.get("qx.debug")){

        if(layout){

          this.assertInstance(layout, qx.ui.layout.Abstract);
        };
      };
      if(this.__layoutManager){

        this.__layoutManager.connectToWidget(null);
      };
      if(layout){

        layout.connectToWidget(this);
      };
      this.__layoutManager = layout;
      qx.ui.core.queue.Layout.add(this);
    },
    setLayoutParent : function(parent){

      if(this.$$parent === parent){

        return;
      };
      var content = this.getContentElement();
      if(this.$$parent && !this.$$parent.$$disposed){

        this.$$parent.getContentElement().remove(content);
      };
      this.$$parent = parent || null;
      if(parent && !parent.$$disposed){

        this.$$parent.getContentElement().add(content);
      };
      this.$$refreshInheritables();
      qx.ui.core.queue.Visibility.add(this);
    },
    _updateInsets : null,
    renderLayout : function(left, top, width, height){

      var changes = this.base(arguments, left, top, width, height);
      if(!changes){

        return null;
      };
      if(qx.lang.Object.isEmpty(changes) && !this._updateInsets){

        return null;
      };
      var content = this.getContentElement();
      var inner = changes.size || this._updateInsets;
      var pixel = "px";
      var contentStyles = {
      };
      if(changes.position){

        contentStyles.left = left + pixel;
        contentStyles.top = top + pixel;
      };
      if(inner || changes.margin){

        contentStyles.width = width + pixel;
        contentStyles.height = height + pixel;
      };
      if(Object.keys(contentStyles).length > 0){

        content.setStyles(contentStyles);
      };
      if(inner || changes.local || changes.margin){

        if(this.__layoutManager && this.hasLayoutChildren()){

          var inset = this.getInsets();
          var innerWidth = width - inset.left - inset.right;
          var innerHeight = height - inset.top - inset.bottom;
          var decorator = this.getDecorator();
          var decoratorPadding = {
            left : 0,
            right : 0,
            top : 0,
            bottom : 0
          };
          if(decorator){

            decorator = qx.theme.manager.Decoration.getInstance().resolve(decorator);
            decoratorPadding = decorator.getPadding();
          };
          var padding = {
            top : this.getPaddingTop() + decoratorPadding.top,
            right : this.getPaddingRight() + decoratorPadding.right,
            bottom : this.getPaddingBottom() + decoratorPadding.bottom,
            left : this.getPaddingLeft() + decoratorPadding.left
          };
          this.__layoutManager.renderLayout(innerWidth, innerHeight, padding);
        } else if(this.hasLayoutChildren()){

          throw new Error("At least one child in control " + this._findTopControl() + " requires a layout, but no one was defined!");
        };
      };
      if(changes.position && this.hasListener("move")){

        this.fireDataEvent("move", this.getBounds());
      };
      if(changes.size && this.hasListener("resize")){

        this.fireDataEvent("resize", this.getBounds());
      };
      delete this._updateInsets;
      return changes;
    },
    __separators : null,
    clearSeparators : function(){

      var reg = this.__separators;
      if(!reg){

        return;
      };
      var pool = qx.ui.core.Widget.__separatorPool;
      var content = this.getContentElement();
      var widget;
      for(var i = 0,l = reg.length;i < l;i++){

        widget = reg[i];
        pool.poolObject(widget);
        content.remove(widget.getContentElement());
      };
      reg.length = 0;
    },
    renderSeparator : function(separator, bounds){

      var widget = qx.ui.core.Widget.__separatorPool.getObject(qx.ui.core.Widget);
      widget.set({
        decorator : separator
      });
      var elem = widget.getContentElement();
      this.getContentElement().add(elem);
      var domEl = elem.getDomElement();
      if(domEl){

        domEl.style.top = bounds.top + "px";
        domEl.style.left = bounds.left + "px";
        domEl.style.width = bounds.width + "px";
        domEl.style.height = bounds.height + "px";
      } else {

        elem.setStyles({
          left : bounds.left + "px",
          top : bounds.top + "px",
          width : bounds.width + "px",
          height : bounds.height + "px"
        });
      };
      if(!this.__separators){

        this.__separators = [];
      };
      this.__separators.push(widget);
    },
    _computeSizeHint : function(){

      var width = this.getWidth();
      var minWidth = this.getMinWidth();
      var maxWidth = this.getMaxWidth();
      var height = this.getHeight();
      var minHeight = this.getMinHeight();
      var maxHeight = this.getMaxHeight();
      if(qx.core.Environment.get("qx.debug")){

        if(minWidth !== null && maxWidth !== null){

          this.assert(minWidth <= maxWidth, "minWidth is larger than maxWidth!");
        };
        if(minHeight !== null && maxHeight !== null){

          this.assert(minHeight <= maxHeight, "minHeight is larger than maxHeight!");
        };
      };
      var contentHint = this._getContentHint();
      var insets = this.getInsets();
      var insetX = insets.left + insets.right;
      var insetY = insets.top + insets.bottom;
      if(width == null){

        width = contentHint.width + insetX;
      };
      if(height == null){

        height = contentHint.height + insetY;
      };
      if(minWidth == null){

        minWidth = insetX;
        if(contentHint.minWidth != null){

          minWidth += contentHint.minWidth;
          if(minWidth > maxWidth && maxWidth != null){

            minWidth = maxWidth;
          };
        };
      };
      if(minHeight == null){

        minHeight = insetY;
        if(contentHint.minHeight != null){

          minHeight += contentHint.minHeight;
          if(minHeight > maxHeight && maxHeight != null){

            minHeight = maxHeight;
          };
        };
      };
      if(maxWidth == null){

        if(contentHint.maxWidth == null){

          maxWidth = Infinity;
        } else {

          maxWidth = contentHint.maxWidth + insetX;
          if(maxWidth < minWidth && minWidth != null){

            maxWidth = minWidth;
          };
        };
      };
      if(maxHeight == null){

        if(contentHint.maxHeight == null){

          maxHeight = Infinity;
        } else {

          maxHeight = contentHint.maxHeight + insetY;
          if(maxHeight < minHeight && minHeight != null){

            maxHeight = minHeight;
          };
        };
      };
      return {
        width : width,
        minWidth : minWidth,
        maxWidth : maxWidth,
        height : height,
        minHeight : minHeight,
        maxHeight : maxHeight
      };
    },
    invalidateLayoutCache : function(){

      this.base(arguments);
      if(this.__layoutManager){

        this.__layoutManager.invalidateLayoutCache();
      };
    },
    _getContentHint : function(){

      var layout = this.__layoutManager;
      if(layout){

        if(this.hasLayoutChildren()){

          var hint = layout.getSizeHint();
          if(qx.core.Environment.get("qx.debug")){

            var msg = "The layout of the widget" + this.toString() + " returned an invalid size hint!";
            this.assertInteger(hint.width, "Wrong 'left' argument. " + msg);
            this.assertInteger(hint.height, "Wrong 'top' argument. " + msg);
          };
          return hint;
        } else {

          return {
            width : 0,
            height : 0
          };
        };
      } else {

        return {
          width : 100,
          height : 50
        };
      };
    },
    _getHeightForWidth : function(width){

      var insets = this.getInsets();
      var insetX = insets.left + insets.right;
      var insetY = insets.top + insets.bottom;
      var contentWidth = width - insetX;
      var layout = this._getLayout();
      if(layout && layout.hasHeightForWidth()){

        var contentHeight = layout.getHeightForWidth(width);
      } else {

        contentHeight = this._getContentHeightForWidth(contentWidth);
      };
      var height = contentHeight + insetY;
      return height;
    },
    _getContentHeightForWidth : function(width){

      throw new Error("Abstract method call: _getContentHeightForWidth()!");
    },
    getInsets : function(){

      var top = this.getPaddingTop();
      var right = this.getPaddingRight();
      var bottom = this.getPaddingBottom();
      var left = this.getPaddingLeft();
      if(this.getDecorator()){

        var decorator = qx.theme.manager.Decoration.getInstance().resolve(this.getDecorator());
        var inset = decorator.getInsets();
        if(qx.core.Environment.get("qx.debug")){

          this.assertNumber(inset.top, "Invalid top decorator inset detected: " + inset.top);
          this.assertNumber(inset.right, "Invalid right decorator inset detected: " + inset.right);
          this.assertNumber(inset.bottom, "Invalid bottom decorator inset detected: " + inset.bottom);
          this.assertNumber(inset.left, "Invalid left decorator inset detected: " + inset.left);
        };
        top += inset.top;
        right += inset.right;
        bottom += inset.bottom;
        left += inset.left;
      };
      return {
        "top" : top,
        "right" : right,
        "bottom" : bottom,
        "left" : left
      };
    },
    getInnerSize : function(){

      var computed = this.getBounds();
      if(!computed){

        return null;
      };
      var insets = this.getInsets();
      return {
        width : computed.width - insets.left - insets.right,
        height : computed.height - insets.top - insets.bottom
      };
    },
    fadeOut : function(duration){

      return this.getContentElement().fadeOut(duration);
    },
    fadeIn : function(duration){

      return this.getContentElement().fadeIn(duration);
    },
    show : function(){

      this.setVisibility("visible");
    },
    hide : function(){

      this.setVisibility("hidden");
    },
    exclude : function(){

      this.setVisibility("excluded");
    },
    isVisible : function(){

      return this.getVisibility() === "visible";
    },
    isHidden : function(){

      return this.getVisibility() !== "visible";
    },
    isExcluded : function(){

      return this.getVisibility() === "excluded";
    },
    isSeeable : function(){

      qx.ui.core.queue.Manager.flush();
      var element = this.getContentElement().getDomElement();
      if(element){

        return element.offsetWidth > 0;
      };
      return false;
    },
    __createContentElement : function(){

      var el = this._createContentElement();
      el.setAttribute("$$widget", this.toHashCode());
      el.setStyles({
        "touch-action" : "none",
        "-ms-touch-action" : "none"
      });
      if(qx.core.Environment.get("qx.debug")){

        el.setAttribute("qxClass", this.classname);
      };
      var styles = {
        "zIndex" : 10,
        "boxSizing" : "border-box"
      };
      if(!qx.ui.root.Inline || !(this instanceof qx.ui.root.Inline)){

        styles.position = "absolute";
      };
      el.setStyles(styles);
      return el;
    },
    _createContentElement : function(){

      return new qx.html.Element("div", {
        overflowX : "hidden",
        overflowY : "hidden"
      });
    },
    getContentElement : function(){

      return this.__contentElement;
    },
    __widgetChildren : null,
    getLayoutChildren : function(){

      var children = this.__widgetChildren;
      if(!children){

        return this.__emptyChildren;
      };
      var layoutChildren;
      for(var i = 0,l = children.length;i < l;i++){

        var child = children[i];
        if(child.hasUserBounds() || child.isExcluded()){

          if(layoutChildren == null){

            layoutChildren = children.concat();
          };
          qx.lang.Array.remove(layoutChildren, child);
        };
      };
      return layoutChildren || children;
    },
    scheduleLayoutUpdate : function(){

      qx.ui.core.queue.Layout.add(this);
    },
    invalidateLayoutChildren : function(){

      var layout = this.__layoutManager;
      if(layout){

        layout.invalidateChildrenCache();
      };
      qx.ui.core.queue.Layout.add(this);
    },
    hasLayoutChildren : function(){

      var children = this.__widgetChildren;
      if(!children){

        return false;
      };
      var child;
      for(var i = 0,l = children.length;i < l;i++){

        child = children[i];
        if(!child.hasUserBounds() && !child.isExcluded()){

          return true;
        };
      };
      return false;
    },
    getChildrenContainer : function(){

      return this;
    },
    __emptyChildren : [],
    _getChildren : function(){

      return this.__widgetChildren || this.__emptyChildren;
    },
    _indexOf : function(child){

      var children = this.__widgetChildren;
      if(!children){

        return -1;
      };
      return children.indexOf(child);
    },
    _hasChildren : function(){

      var children = this.__widgetChildren;
      return children != null && (!!children[0]);
    },
    addChildrenToQueue : function(queue){

      var children = this.__widgetChildren;
      if(!children){

        return;
      };
      var child;
      for(var i = 0,l = children.length;i < l;i++){

        child = children[i];
        queue.push(child);
        child.addChildrenToQueue(queue);
      };
    },
    _add : function(child, options){

      if(qx.core.Environment.get("qx.debug")){

        this.assertInstance(child, qx.ui.core.LayoutItem.constructor, "'Child' must be an instance of qx.ui.core.LayoutItem!");
      };
      if(child.getLayoutParent() == this){

        qx.lang.Array.remove(this.__widgetChildren, child);
      };
      if(this.__widgetChildren){

        this.__widgetChildren.push(child);
      } else {

        this.__widgetChildren = [child];
      };
      this.__addHelper(child, options);
    },
    _addAt : function(child, index, options){

      if(!this.__widgetChildren){

        this.__widgetChildren = [];
      };
      if(child.getLayoutParent() == this){

        qx.lang.Array.remove(this.__widgetChildren, child);
      };
      var ref = this.__widgetChildren[index];
      if(ref === child){

        child.setLayoutProperties(options);
      };
      if(ref){

        qx.lang.Array.insertBefore(this.__widgetChildren, child, ref);
      } else {

        this.__widgetChildren.push(child);
      };
      this.__addHelper(child, options);
    },
    _addBefore : function(child, before, options){

      if(qx.core.Environment.get("qx.debug")){

        this.assertInArray(before, this._getChildren(), "The 'before' widget is not a child of this widget!");
      };
      if(child == before){

        return;
      };
      if(!this.__widgetChildren){

        this.__widgetChildren = [];
      };
      if(child.getLayoutParent() == this){

        qx.lang.Array.remove(this.__widgetChildren, child);
      };
      qx.lang.Array.insertBefore(this.__widgetChildren, child, before);
      this.__addHelper(child, options);
    },
    _addAfter : function(child, after, options){

      if(qx.core.Environment.get("qx.debug")){

        this.assertInArray(after, this._getChildren(), "The 'after' widget is not a child of this widget!");
      };
      if(child == after){

        return;
      };
      if(!this.__widgetChildren){

        this.__widgetChildren = [];
      };
      if(child.getLayoutParent() == this){

        qx.lang.Array.remove(this.__widgetChildren, child);
      };
      qx.lang.Array.insertAfter(this.__widgetChildren, child, after);
      this.__addHelper(child, options);
    },
    _remove : function(child){

      if(!this.__widgetChildren){

        throw new Error("This widget has no children!");
      };
      qx.lang.Array.remove(this.__widgetChildren, child);
      this.__removeHelper(child);
    },
    _removeAt : function(index){

      if(!this.__widgetChildren){

        throw new Error("This widget has no children!");
      };
      var child = this.__widgetChildren[index];
      qx.lang.Array.removeAt(this.__widgetChildren, index);
      this.__removeHelper(child);
      return child;
    },
    _removeAll : function(){

      if(!this.__widgetChildren){

        return [];
      };
      var children = this.__widgetChildren.concat();
      this.__widgetChildren.length = 0;
      for(var i = children.length - 1;i >= 0;i--){

        this.__removeHelper(children[i]);
      };
      qx.ui.core.queue.Layout.add(this);
      return children;
    },
    _afterAddChild : null,
    _afterRemoveChild : null,
    __addHelper : function(child, options){

      if(qx.core.Environment.get("qx.debug")){

        this.assertInstance(child, qx.ui.core.LayoutItem, "Invalid widget to add: " + child);
        this.assertNotIdentical(child, this, "Could not add widget to itself: " + child);
        if(options != null){

          this.assertType(options, "object", "Invalid layout data: " + options);
        };
      };
      var parent = child.getLayoutParent();
      if(parent && parent != this){

        parent._remove(child);
      };
      child.setLayoutParent(this);
      if(options){

        child.setLayoutProperties(options);
      } else {

        this.updateLayoutProperties();
      };
      if(this._afterAddChild){

        this._afterAddChild(child);
      };
    },
    __removeHelper : function(child){

      if(qx.core.Environment.get("qx.debug")){

        this.assertNotUndefined(child);
      };
      if(child.getLayoutParent() !== this){

        throw new Error("Remove Error: " + child + " is not a child of this widget!");
      };
      child.setLayoutParent(null);
      if(this.__layoutManager){

        this.__layoutManager.invalidateChildrenCache();
      };
      qx.ui.core.queue.Layout.add(this);
      if(this._afterRemoveChild){

        this._afterRemoveChild(child);
      };
    },
    capture : function(capture){

      this.getContentElement().capture(capture);
    },
    releaseCapture : function(){

      this.getContentElement().releaseCapture();
    },
    isCapturing : function(){

      var el = this.getContentElement().getDomElement();
      if(!el){

        return false;
      };
      var manager = qx.event.Registration.getManager(el);
      var dispatcher = manager.getDispatcher(qx.event.dispatch.MouseCapture);
      return el == dispatcher.getCaptureElement();
    },
    _applyPadding : function(value, old, name){

      this._updateInsets = true;
      qx.ui.core.queue.Layout.add(this);
      this.__updateContentPadding(name, value);
    },
    __updateContentPadding : function(style, value){

      var content = this.getContentElement();
      var decorator = this.getDecorator();
      decorator = qx.theme.manager.Decoration.getInstance().resolve(decorator);
      if(decorator){

        var direction = qx.Bootstrap.firstLow(style.replace("padding", ""));
        value += decorator.getPadding()[direction] || 0;
      };
      content.setStyle(style, value + "px");
    },
    _applyDecorator : function(value, old){

      var content = this.getContentElement();
      if(old){

        old = qx.theme.manager.Decoration.getInstance().getCssClassName(old);
        content.removeClass(old);
      };
      if(value){

        value = qx.theme.manager.Decoration.getInstance().addCssClass(value);
        content.addClass(value);
      };
    },
    _applyToolTipText : function(value, old){

      if(qx.core.Environment.get("qx.dynlocale")){

        if(this.__toolTipTextListenerId){

          return;
        };
        var manager = qx.locale.Manager.getInstance();
        this.__toolTipTextListenerId = manager.addListener("changeLocale", function(){

          var toolTipText = this.getToolTipText();
          if(toolTipText && toolTipText.translate){

            this.setToolTipText(toolTipText.translate());
          };
        }, this);
      };
    },
    _applyTextColor : function(value, old){
    },
    _applyZIndex : function(value, old){

      this.getContentElement().setStyle("zIndex", value == null ? 0 : value);
    },
    _applyVisibility : function(value, old){

      var content = this.getContentElement();
      if(value === "visible"){

        content.show();
      } else {

        content.hide();
      };
      var parent = this.$$parent;
      if(parent && (old == null || value == null || old === "excluded" || value === "excluded")){

        parent.invalidateLayoutChildren();
      };
      qx.ui.core.queue.Visibility.add(this);
    },
    _applyOpacity : function(value, old){

      this.getContentElement().setStyle("opacity", value == 1 ? null : value);
    },
    _applyCursor : function(value, old){

      if(value == null && !this.isSelectable()){

        value = "default";
      };
      this.getContentElement().setStyle("cursor", value, qx.core.Environment.get("engine.name") == "opera");
    },
    _applyBackgroundColor : function(value, old){

      var color = this.getBackgroundColor();
      var content = this.getContentElement();
      var resolved = qx.theme.manager.Color.getInstance().resolve(color);
      content.setStyle("backgroundColor", resolved);
    },
    _applyFont : function(value, old){
    },
    _onChangeTheme : function(){

      this.base(arguments);
      this.updateAppearance();
      var value = this.getDecorator();
      this._applyDecorator(null, value);
      this._applyDecorator(value);
      value = this.getFont();
      if(qx.lang.Type.isString(value)){

        this._applyFont(value, value);
      };
      value = this.getTextColor();
      if(qx.lang.Type.isString(value)){

        this._applyTextColor(value, value);
      };
      value = this.getBackgroundColor();
      if(qx.lang.Type.isString(value)){

        this._applyBackgroundColor(value, value);
      };
    },
    __states : null,
    $$stateChanges : null,
    _forwardStates : null,
    hasState : function(state){

      var states = this.__states;
      return !!states && !!states[state];
    },
    addState : function(state){

      var states = this.__states;
      if(!states){

        states = this.__states = {
        };
      };
      if(states[state]){

        return;
      };
      this.__states[state] = true;
      if(state === "hovered"){

        this.syncAppearance();
      } else if(!qx.ui.core.queue.Visibility.isVisible(this)){

        this.$$stateChanges = true;
      } else {

        qx.ui.core.queue.Appearance.add(this);
      };
      var forward = this._forwardStates;
      var controls = this.__childControls;
      if(forward && forward[state] && controls){

        var control;
        for(var id in controls){

          control = controls[id];
          if(control instanceof qx.ui.core.Widget){

            controls[id].addState(state);
          };
        };
      };
    },
    removeState : function(state){

      var states = this.__states;
      if(!states || !states[state]){

        return;
      };
      delete this.__states[state];
      if(state === "hovered"){

        this.syncAppearance();
      } else if(!qx.ui.core.queue.Visibility.isVisible(this)){

        this.$$stateChanges = true;
      } else {

        qx.ui.core.queue.Appearance.add(this);
      };
      var forward = this._forwardStates;
      var controls = this.__childControls;
      if(forward && forward[state] && controls){

        for(var id in controls){

          var control = controls[id];
          if(control instanceof qx.ui.core.Widget){

            control.removeState(state);
          };
        };
      };
    },
    replaceState : function(old, value){

      var states = this.__states;
      if(!states){

        states = this.__states = {
        };
      };
      if(!states[value]){

        states[value] = true;
      };
      if(states[old]){

        delete states[old];
      };
      if(!qx.ui.core.queue.Visibility.isVisible(this)){

        this.$$stateChanges = true;
      } else {

        qx.ui.core.queue.Appearance.add(this);
      };
      var forward = this._forwardStates;
      var controls = this.__childControls;
      if(forward && forward[value] && controls){

        for(var id in controls){

          var control = controls[id];
          if(control instanceof qx.ui.core.Widget){

            control.replaceState(old, value);
          };
        };
      };
    },
    __appearanceSelector : null,
    __updateSelector : null,
    syncAppearance : function(){

      var states = this.__states;
      var selector = this.__appearanceSelector;
      var manager = qx.theme.manager.Appearance.getInstance();
      var styler = qx.core.Property.$$method.setThemed;
      var unstyler = qx.core.Property.$$method.resetThemed;
      if(this.__updateSelector){

        delete this.__updateSelector;
        if(selector){

          var oldData = manager.styleFrom(selector, states, null, this.getAppearance());
          selector = null;
        };
      };
      if(!selector){

        var obj = this;
        var id = [];
        do {

          id.push(obj.$$subcontrol || obj.getAppearance());
        }while((obj = obj.$$subparent));
        selector = id.reverse().join("/").replace(/#[0-9]+/g, "");
        this.__appearanceSelector = selector;
      };
      var newData = manager.styleFrom(selector, states, null, this.getAppearance());
      if(newData){

        if(oldData){

          for(var prop in oldData){

            if(newData[prop] === undefined){

              this[unstyler[prop]]();
            };
          };
        };
        if(qx.core.Environment.get("qx.debug")){

          for(var prop in newData){

            if(!this[styler[prop]]){

              throw new Error(this.classname + ' has no themeable property "' + prop + '" while styling ' + selector);
            };
          };
        };
        for(var prop in newData){

          newData[prop] === undefined ? this[unstyler[prop]]() : this[styler[prop]](newData[prop]);
        };
      } else if(oldData){

        for(var prop in oldData){

          this[unstyler[prop]]();
        };
      };
      this.fireDataEvent("syncAppearance", this.__states);
    },
    _applyAppearance : function(value, old){

      this.updateAppearance();
    },
    checkAppearanceNeeds : function(){

      if(!this.__initialAppearanceApplied){

        qx.ui.core.queue.Appearance.add(this);
        this.__initialAppearanceApplied = true;
      } else if(this.$$stateChanges){

        qx.ui.core.queue.Appearance.add(this);
        delete this.$$stateChanges;
      };
    },
    updateAppearance : function(){

      this.__updateSelector = true;
      qx.ui.core.queue.Appearance.add(this);
      var controls = this.__childControls;
      if(controls){

        var obj;
        for(var id in controls){

          obj = controls[id];
          if(obj instanceof qx.ui.core.Widget){

            obj.updateAppearance();
          };
        };
      };
    },
    syncWidget : function(jobs){
    },
    getEventTarget : function(){

      var target = this;
      while(target.getAnonymous()){

        target = target.getLayoutParent();
        if(!target){

          return null;
        };
      };
      return target;
    },
    getFocusTarget : function(){

      var target = this;
      if(!target.getEnabled()){

        return null;
      };
      while(target.getAnonymous() || !target.getFocusable()){

        target = target.getLayoutParent();
        if(!target || !target.getEnabled()){

          return null;
        };
      };
      return target;
    },
    getFocusElement : function(){

      return this.getContentElement();
    },
    isTabable : function(){

      return (!!this.getContentElement().getDomElement()) && this.isFocusable();
    },
    _applyFocusable : function(value, old){

      var target = this.getFocusElement();
      if(value){

        var tabIndex = this.getTabIndex();
        if(tabIndex == null){

          tabIndex = 1;
        };
        target.setAttribute("tabIndex", tabIndex);
        target.setStyle("outline", "none");
      } else {

        if(target.isNativelyFocusable()){

          target.setAttribute("tabIndex", -1);
        } else if(old){

          target.setAttribute("tabIndex", null);
        };
      };
    },
    _applyKeepFocus : function(value){

      var target = this.getFocusElement();
      target.setAttribute("qxKeepFocus", value ? "on" : null);
    },
    _applyKeepActive : function(value){

      var target = this.getContentElement();
      target.setAttribute("qxKeepActive", value ? "on" : null);
    },
    _applyTabIndex : function(value){

      if(value == null){

        value = 1;
      } else if(value < 1 || value > 32000){

        throw new Error("TabIndex property must be between 1 and 32000");
      };
      if(this.getFocusable() && value != null){

        this.getFocusElement().setAttribute("tabIndex", value);
      };
    },
    _applySelectable : function(value, old){

      if(old !== null){

        this._applyCursor(this.getCursor());
      };
      this.getContentElement().setSelectable(value);
    },
    _applyEnabled : function(value, old){

      if(value === false){

        this.addState("disabled");
        this.removeState("hovered");
        if(this.isFocusable()){

          this.removeState("focused");
          this._applyFocusable(false, true);
        };
        if(this.isDraggable()){

          this._applyDraggable(false, true);
        };
        if(this.isDroppable()){

          this._applyDroppable(false, true);
        };
      } else {

        this.removeState("disabled");
        if(this.isFocusable()){

          this._applyFocusable(true, false);
        };
        if(this.isDraggable()){

          this._applyDraggable(true, false);
        };
        if(this.isDroppable()){

          this._applyDroppable(true, false);
        };
      };
    },
    _applyNativeContextMenu : function(value, old, name){
    },
    _applyContextMenu : function(value, old){

      if(old){

        old.removeState("contextmenu");
        if(old.getOpener() == this){

          old.resetOpener();
        };
        if(!value){

          this.removeListener("contextmenu", this._onContextMenuOpen);
          this.removeListener("longtap", this._onContextMenuOpen);
          old.removeListener("changeVisibility", this._onBeforeContextMenuOpen, this);
        };
      };
      if(value){

        value.setOpener(this);
        value.addState("contextmenu");
        if(!old){

          this.addListener("contextmenu", this._onContextMenuOpen);
          this.addListener("longtap", this._onContextMenuOpen);
          value.addListener("changeVisibility", this._onBeforeContextMenuOpen, this);
        };
      };
    },
    _onContextMenuOpen : function(e){

      if(e.getType() == "longtap"){

        if(e.getPointerType() !== "touch"){

          return;
        };
      };
      this.getContextMenu().openAtPointer(e);
      e.stop();
    },
    _onBeforeContextMenuOpen : function(e){

      if(e.getData() == "visible" && this.hasListener("beforeContextmenuOpen")){

        this.fireDataEvent("beforeContextmenuOpen", e);
      };
    },
    _onStopEvent : function(e){

      e.stopPropagation();
    },
    _getDragDropCursor : function(){

      return qx.ui.core.DragDropCursor.getInstance();
    },
    _applyDraggable : function(value, old){

      if(!this.isEnabled() && value === true){

        value = false;
      };
      this._getDragDropCursor();
      if(value){

        this.addListener("dragstart", this._onDragStart);
        this.addListener("drag", this._onDrag);
        this.addListener("dragend", this._onDragEnd);
        this.addListener("dragchange", this._onDragChange);
      } else {

        this.removeListener("dragstart", this._onDragStart);
        this.removeListener("drag", this._onDrag);
        this.removeListener("dragend", this._onDragEnd);
        this.removeListener("dragchange", this._onDragChange);
      };
      this.getContentElement().setAttribute("qxDraggable", value ? "on" : null);
    },
    _applyDroppable : function(value, old){

      if(!this.isEnabled() && value === true){

        value = false;
      };
      this.getContentElement().setAttribute("qxDroppable", value ? "on" : null);
    },
    _onDragStart : function(e){

      this._getDragDropCursor().placeToPointer(e);
      this.getApplicationRoot().setGlobalCursor("default");
    },
    _onDrag : function(e){

      this._getDragDropCursor().placeToPointer(e);
    },
    _onDragEnd : function(e){

      this._getDragDropCursor().moveTo(-1000, -1000);
      this.getApplicationRoot().resetGlobalCursor();
    },
    _onDragChange : function(e){

      var cursor = this._getDragDropCursor();
      var action = e.getCurrentAction();
      action ? cursor.setAction(action) : cursor.resetAction();
    },
    visualizeFocus : function(){

      this.addState("focused");
    },
    visualizeBlur : function(){

      this.removeState("focused");
    },
    scrollChildIntoView : function(child, alignX, alignY, direct){

      direct = typeof direct == "undefined" ? true : direct;
      var Layout = qx.ui.core.queue.Layout;
      var parent;
      if(direct){

        direct = !Layout.isScheduled(child);
        parent = child.getLayoutParent();
        if(direct && parent){

          direct = !Layout.isScheduled(parent);
          if(direct){

            parent.getChildren().forEach(function(sibling){

              direct = direct && !Layout.isScheduled(sibling);
            });
          };
        };
      };
      this.scrollChildIntoViewX(child, alignX, direct);
      this.scrollChildIntoViewY(child, alignY, direct);
    },
    scrollChildIntoViewX : function(child, align, direct){

      this.getContentElement().scrollChildIntoViewX(child.getContentElement(), align, direct);
    },
    scrollChildIntoViewY : function(child, align, direct){

      this.getContentElement().scrollChildIntoViewY(child.getContentElement(), align, direct);
    },
    focus : function(){

      if(this.isFocusable()){

        this.getFocusElement().focus();
      } else {

        throw new Error("Widget is not focusable!");
      };
    },
    blur : function(){

      if(this.isFocusable()){

        this.getFocusElement().blur();
      } else {

        throw new Error("Widget is not focusable!");
      };
    },
    activate : function(){

      this.getContentElement().activate();
    },
    deactivate : function(){

      this.getContentElement().deactivate();
    },
    tabFocus : function(){

      this.getFocusElement().focus();
    },
    hasChildControl : function(id){

      if(!this.__childControls){

        return false;
      };
      return !!this.__childControls[id];
    },
    __childControls : null,
    _getCreatedChildControls : function(){

      return this.__childControls;
    },
    getChildControl : function(id, notcreate){

      if(!this.__childControls){

        if(notcreate){

          return null;
        };
        this.__childControls = {
        };
      };
      var control = this.__childControls[id];
      if(control){

        return control;
      };
      if(notcreate === true){

        return null;
      };
      return this._createChildControl(id);
    },
    _showChildControl : function(id){

      var control = this.getChildControl(id);
      control.show();
      return control;
    },
    _excludeChildControl : function(id){

      var control = this.getChildControl(id, true);
      if(control){

        control.exclude();
      };
    },
    _isChildControlVisible : function(id){

      var control = this.getChildControl(id, true);
      if(control){

        return control.isVisible();
      };
      return false;
    },
    _releaseChildControl : function(id){

      var control = this.getChildControl(id, false);
      if(!control){

        throw new Error("Unsupported control: " + id);
      };
      delete control.$$subcontrol;
      delete control.$$subparent;
      var states = this.__states;
      var forward = this._forwardStates;
      if(states && forward && control instanceof qx.ui.core.Widget){

        for(var state in states){

          if(forward[state]){

            control.removeState(state);
          };
        };
      };
      delete this.__childControls[id];
      return control;
    },
    _createChildControl : function(id){

      if(!this.__childControls){

        this.__childControls = {
        };
      } else if(this.__childControls[id]){

        throw new Error("Child control '" + id + "' already created!");
      };
      var pos = id.indexOf("#");
      try{

        if(pos == -1){

          var control = this._createChildControlImpl(id);
        } else {

          var control = this._createChildControlImpl(id.substring(0, pos), id.substring(pos + 1, id.length));
        };
      } catch(exc) {

        exc.message = "Exception while creating child control '" + id + "' of widget " + this.toString() + ": " + exc.message;
        throw exc;
      };
      if(!control){

        throw new Error("Unsupported control: " + id);
      };
      control.$$subcontrol = id;
      control.$$subparent = this;
      var states = this.__states;
      var forward = this._forwardStates;
      if(states && forward && control instanceof qx.ui.core.Widget){

        for(var state in states){

          if(forward[state]){

            control.addState(state);
          };
        };
      };
      this.fireDataEvent("createChildControl", control);
      return this.__childControls[id] = control;
    },
    _createChildControlImpl : function(id, hash){

      return null;
    },
    _disposeChildControls : function(){

      var controls = this.__childControls;
      if(!controls){

        return;
      };
      var Widget = qx.ui.core.Widget;
      for(var id in controls){

        var control = controls[id];
        if(!Widget.contains(this, control)){

          control.destroy();
        } else {

          control.dispose();
        };
      };
      delete this.__childControls;
    },
    _findTopControl : function(){

      var obj = this;
      while(obj){

        if(!obj.$$subparent){

          return obj;
        };
        obj = obj.$$subparent;
      };
      return null;
    },
    getContentLocation : function(mode){

      var domEl = this.getContentElement().getDomElement();
      return domEl ? qx.bom.element.Location.get(domEl, mode) : null;
    },
    setDomLeft : function(value){

      var domEl = this.getContentElement().getDomElement();
      if(domEl){

        domEl.style.left = value + "px";
      } else {

        throw new Error("DOM element is not yet created!");
      };
    },
    setDomTop : function(value){

      var domEl = this.getContentElement().getDomElement();
      if(domEl){

        domEl.style.top = value + "px";
      } else {

        throw new Error("DOM element is not yet created!");
      };
    },
    setDomPosition : function(left, top){

      var domEl = this.getContentElement().getDomElement();
      if(domEl){

        domEl.style.left = left + "px";
        domEl.style.top = top + "px";
      } else {

        throw new Error("DOM element is not yet created!");
      };
    },
    destroy : function(){

      if(this.$$disposed){

        return;
      };
      var parent = this.$$parent;
      if(parent){

        parent._remove(this);
      };
      qx.ui.core.queue.Dispose.add(this);
    },
    clone : function(){

      var clone = this.base(arguments);
      if(this.getChildren){

        var children = this.getChildren();
        for(var i = 0,l = children.length;i < l;i++){

          clone.add(children[i].clone());
        };
      };
      return clone;
    }
  },
  destruct : function(){

    if(!qx.core.ObjectRegistry.inShutDown){

      if(qx.core.Environment.get("qx.dynlocale")){

        if(this.__toolTipTextListenerId){

          qx.locale.Manager.getInstance().removeListenerById(this.__toolTipTextListenerId);
        };
      };
      var contentEl = this.getContentElement();
      if(contentEl){

        contentEl.setAttribute("$$widget", null, true);
      };
      this._disposeChildControls();
      qx.ui.core.queue.Appearance.remove(this);
      qx.ui.core.queue.Layout.remove(this);
      qx.ui.core.queue.Visibility.remove(this);
      qx.ui.core.queue.Widget.remove(this);
    };
    if(this.getContextMenu()){

      this.setContextMenu(null);
    };
    if(!qx.core.ObjectRegistry.inShutDown){

      this.clearSeparators();
      this.__separators = null;
    } else {

      this._disposeArray("__separators");
    };
    this._disposeArray("__widgetChildren");
    this.__states = this.__childControls = null;
    this._disposeObjects("__layoutManager", "__contentElement");
  }
});

qx.Class.define("qx.ui.core.EventHandler", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  construct : function(){

    this.base(arguments);
    this.__manager = qx.event.Registration.getManager(window);
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_FIRST,
    SUPPORTED_TYPES : {
      mousemove : 1,
      mouseover : 1,
      mouseout : 1,
      mousedown : 1,
      mouseup : 1,
      click : 1,
      dblclick : 1,
      contextmenu : 1,
      mousewheel : 1,
      keyup : 1,
      keydown : 1,
      keypress : 1,
      keyinput : 1,
      capture : 1,
      losecapture : 1,
      focusin : 1,
      focusout : 1,
      focus : 1,
      blur : 1,
      activate : 1,
      deactivate : 1,
      appear : 1,
      disappear : 1,
      dragstart : 1,
      dragend : 1,
      dragover : 1,
      dragleave : 1,
      drop : 1,
      drag : 1,
      dragchange : 1,
      droprequest : 1,
      touchstart : 1,
      touchend : 1,
      touchmove : 1,
      touchcancel : 1,
      tap : 1,
      longtap : 1,
      swipe : 1,
      dbltap : 1,
      track : 1,
      trackend : 1,
      trackstart : 1,
      pinch : 1,
      rotate : 1,
      roll : 1,
      pointermove : 1,
      pointerover : 1,
      pointerout : 1,
      pointerdown : 1,
      pointerup : 1,
      pointercancel : 1
    },
    IGNORE_CAN_HANDLE : false
  },
  members : {
    __manager : null,
    __focusEvents : {
      focusin : 1,
      focusout : 1,
      focus : 1,
      blur : 1
    },
    __ignoreDisabled : {
      mouseover : 1,
      mouseout : 1,
      appear : 1,
      disappear : 1
    },
    canHandleEvent : function(target, type){

      return target instanceof qx.ui.core.Widget;
    },
    _dispatchEvent : function(domEvent){

      var domTarget = domEvent.getTarget();
      var widgetTarget = qx.ui.core.Widget.getWidgetByElement(domTarget);
      var targetChanged = false;
      while(widgetTarget && widgetTarget.isAnonymous()){

        var targetChanged = true;
        widgetTarget = widgetTarget.getLayoutParent();
      };
      if(widgetTarget && targetChanged && domEvent.getType() == "activate"){

        widgetTarget.getContentElement().activate();
      };
      if(this.__focusEvents[domEvent.getType()]){

        widgetTarget = widgetTarget && widgetTarget.getFocusTarget();
        if(!widgetTarget){

          return;
        };
      };
      if(domEvent.getRelatedTarget){

        var domRelatedTarget = domEvent.getRelatedTarget();
        var widgetRelatedTarget = qx.ui.core.Widget.getWidgetByElement(domRelatedTarget);
        while(widgetRelatedTarget && widgetRelatedTarget.isAnonymous()){

          widgetRelatedTarget = widgetRelatedTarget.getLayoutParent();
        };
        if(widgetRelatedTarget){

          if(this.__focusEvents[domEvent.getType()]){

            widgetRelatedTarget = widgetRelatedTarget.getFocusTarget();
          };
          if(widgetRelatedTarget === widgetTarget){

            return;
          };
        };
      };
      var currentTarget = domEvent.getCurrentTarget();
      var currentWidget = qx.ui.core.Widget.getWidgetByElement(currentTarget);
      if(!currentWidget || currentWidget.isAnonymous()){

        return;
      };
      if(this.__focusEvents[domEvent.getType()]){

        currentWidget = currentWidget.getFocusTarget();
      };
      var type = domEvent.getType();
      if(!currentWidget || !(currentWidget.isEnabled() || this.__ignoreDisabled[type])){

        return;
      };
      var capture = domEvent.getEventPhase() == qx.event.type.Event.CAPTURING_PHASE;
      var listeners = this.__manager.getListeners(currentWidget, type, capture);
      if(!listeners || listeners.length === 0){

        return;
      };
      var widgetEvent = qx.event.Pool.getInstance().getObject(domEvent.constructor);
      domEvent.clone(widgetEvent);
      widgetEvent.setTarget(widgetTarget);
      widgetEvent.setRelatedTarget(widgetRelatedTarget || null);
      widgetEvent.setCurrentTarget(currentWidget);
      var orig = domEvent.getOriginalTarget();
      if(orig){

        var widgetOriginalTarget = qx.ui.core.Widget.getWidgetByElement(orig);
        while(widgetOriginalTarget && widgetOriginalTarget.isAnonymous()){

          widgetOriginalTarget = widgetOriginalTarget.getLayoutParent();
        };
        widgetEvent.setOriginalTarget(widgetOriginalTarget);
      } else {

        widgetEvent.setOriginalTarget(domTarget);
      };
      for(var i = 0,l = listeners.length;i < l;i++){

        var context = listeners[i].context || currentWidget;
        listeners[i].handler.call(context, widgetEvent);
      };
      if(widgetEvent.getPropagationStopped()){

        domEvent.stopPropagation();
      };
      if(widgetEvent.getDefaultPrevented()){

        domEvent.preventDefault();
      };
      qx.event.Pool.getInstance().poolObject(widgetEvent);
    },
    registerEvent : function(target, type, capture){

      var elem;
      if(type === "focus" || type === "blur"){

        elem = target.getFocusElement();
      } else {

        elem = target.getContentElement();
      };
      if(elem){

        elem.addListener(type, this._dispatchEvent, this, capture);
      };
    },
    unregisterEvent : function(target, type, capture){

      var elem;
      if(type === "focus" || type === "blur"){

        elem = target.getFocusElement();
      } else {

        elem = target.getContentElement();
      };
      if(elem){

        elem.removeListener(type, this._dispatchEvent, this, capture);
      };
    }
  },
  destruct : function(){

    this.__manager = null;
  },
  defer : function(statics){

    qx.event.Registration.addHandler(statics);
  }
});

qx.Class.define("qx.ui.layout.Abstract", {
  type : "abstract",
  extend : qx.core.Object,
  members : {
    __sizeHint : null,
    _invalidChildrenCache : null,
    __widget : null,
    invalidateLayoutCache : function(){

      this.__sizeHint = null;
    },
    renderLayout : function(availWidth, availHeight, padding){

      this.warn("Missing renderLayout() implementation!");
    },
    getSizeHint : function(){

      if(this.__sizeHint){

        return this.__sizeHint;
      };
      return this.__sizeHint = this._computeSizeHint();
    },
    hasHeightForWidth : function(){

      return false;
    },
    getHeightForWidth : function(width){

      this.warn("Missing getHeightForWidth() implementation!");
      return null;
    },
    _computeSizeHint : function(){

      return null;
    },
    invalidateChildrenCache : function(){

      this._invalidChildrenCache = true;
    },
    verifyLayoutProperty : qx.core.Environment.select("qx.debug", {
      "true" : function(item, name, value){
      },
      "false" : null
    }),
    _clearSeparators : function(){

      var widget = this.__widget;
      if(widget instanceof qx.ui.core.LayoutItem){

        widget.clearSeparators();
      };
    },
    _renderSeparator : function(separator, bounds){

      this.__widget.renderSeparator(separator, bounds);
    },
    connectToWidget : function(widget){

      if(widget && this.__widget){

        throw new Error("It is not possible to manually set the connected widget.");
      };
      this.__widget = widget;
      this.invalidateChildrenCache();
    },
    _getWidget : function(){

      return this.__widget;
    },
    _applyLayoutChange : function(){

      if(this.__widget){

        this.__widget.scheduleLayoutUpdate();
      };
    },
    _getLayoutChildren : function(){

      return this.__widget.getLayoutChildren();
    }
  },
  destruct : function(){

    this.__widget = this.__sizeHint = null;
  }
});

qx.Class.define("qx.theme.manager.Decoration", {
  type : "singleton",
  extend : qx.core.Object,
  construct : function(){

    this.base(arguments);
    this.__rules = [];
    this.__legacyIe = (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 9);
  },
  properties : {
    theme : {
      check : "Theme",
      nullable : true,
      apply : "_applyTheme",
      event : "changeTheme"
    }
  },
  members : {
    __dynamic : null,
    __rules : null,
    __legacyIe : false,
    getCssClassName : function(value){

      if(qx.lang.Type.isString(value)){

        return "qx-" + value;
      } else {

        return "qx-" + value.toHashCode();
      };
    },
    addCssClass : function(value){

      var sheet = qx.ui.style.Stylesheet.getInstance();
      var instance = value;
      value = this.getCssClassName(value);
      var selector = "." + value;
      if(sheet.hasRule(selector)){

        return value;
      };
      if(qx.lang.Type.isString(instance)){

        instance = this.resolve(instance);
      };
      if(!instance){

        throw new Error("Unable to resolve decorator '" + value + "'.");
      };
      var css = "";
      var styles = instance.getStyles(true);
      for(var key in styles){

        if(qx.Bootstrap.isObject(styles[key])){

          var innerCss = "";
          var innerStyles = styles[key];
          var inner = false;
          for(var innerKey in innerStyles){

            inner = true;
            innerCss += innerKey + ":" + innerStyles[innerKey] + ";";
          };
          var innerSelector = this.__legacyIe ? selector : selector + (inner ? ":" : "");
          this.__rules.push(innerSelector + key);
          sheet.addRule(innerSelector + key, innerCss);
          continue;
        };
        css += key + ":" + styles[key] + ";";
      };
      if(css){

        sheet.addRule(selector, css);
        this.__rules.push(selector);
      };
      return value;
    },
    resolve : function(value){

      if(!value){

        return null;
      };
      if(typeof value === "object"){

        return value;
      };
      var theme = this.getTheme();
      if(!theme){

        return null;
      };
      var cache = this.__dynamic;
      if(!cache){

        cache = this.__dynamic = {
        };
      };
      var resolved = cache[value];
      if(resolved){

        return resolved;
      };
      var entry = qx.lang.Object.clone(theme.decorations[value], true);
      if(!entry){

        return null;
      };
      if(!entry.style){

        entry.style = {
        };
      };
      var currentEntry = entry;
      while(currentEntry.include){

        currentEntry = theme.decorations[currentEntry.include];
        if(!entry.decorator && currentEntry.decorator){

          entry.decorator = qx.lang.Object.clone(currentEntry.decorator);
        };
        if(currentEntry.style){

          for(var key in currentEntry.style){

            if(entry.style[key] === undefined){

              entry.style[key] = qx.lang.Object.clone(currentEntry.style[key], true);
            };
          };
        };
      };
      return cache[value] = (new qx.ui.decoration.Decorator()).set(entry.style);
    },
    isValidPropertyValue : function(value){

      if(typeof value === "string"){

        return this.isDynamic(value);
      } else if(typeof value === "object"){

        var clazz = value.constructor;
        return qx.Class.hasInterface(clazz, qx.ui.decoration.IDecorator);
      };
      return false;
    },
    isDynamic : function(value){

      if(!value){

        return false;
      };
      var theme = this.getTheme();
      if(!theme){

        return false;
      };
      return !!theme.decorations[value];
    },
    isCached : function(decorator){

      return !this.__dynamic ? false : qx.lang.Object.contains(this.__dynamic, decorator);
    },
    _applyTheme : function(value, old){

      var aliasManager = qx.util.AliasManager.getInstance();
      for(var i = 0;i < this.__rules.length;i++){

        var selector = this.__rules[i];
        qx.ui.style.Stylesheet.getInstance().removeRule(selector);
      };
      this.__rules = [];
      if(old){

        for(var alias in old.aliases){

          aliasManager.remove(alias);
        };
      };
      if(value){

        for(var alias in value.aliases){

          aliasManager.add(alias, value.aliases[alias]);
        };
      };
      this._disposeMap("__dynamic");
      this.__dynamic = {
      };
    }
  },
  destruct : function(){

    this._disposeMap("__dynamic");
  }
});

qx.Class.define("qx.ui.style.Stylesheet", {
  type : "singleton",
  extend : qx.core.Object,
  construct : function(){

    this.base(arguments);
    this.__sheet = qx.bom.Stylesheet.createElement();
    this.__rules = [];
  },
  members : {
    __rules : null,
    __sheet : null,
    addRule : function(selector, css){

      if(this.hasRule(selector)){

        return;
      };
      qx.bom.Stylesheet.addRule(this.__sheet, selector, css);
      this.__rules.push(selector);
    },
    hasRule : function(selector){

      return this.__rules.indexOf(selector) != -1;
    },
    removeRule : function(selector){

      delete this.__rules[this.__rules.indexOf(selector)];
      qx.bom.Stylesheet.removeRule(this.__sheet, selector);
    }
  }
});

qx.Mixin.define("qx.ui.decoration.MBackgroundColor", {
  properties : {
    backgroundColor : {
      check : "Color",
      nullable : true,
      apply : "_applyBackgroundColor"
    }
  },
  members : {
    _styleBackgroundColor : function(styles){

      var bgcolor = this.getBackgroundColor();
      if(bgcolor && qx.core.Environment.get("qx.theme")){

        bgcolor = qx.theme.manager.Color.getInstance().resolve(bgcolor);
      };
      if(bgcolor){

        styles["background-color"] = bgcolor;
      };
    },
    _applyBackgroundColor : function(){

      if(qx.core.Environment.get("qx.debug")){

        if(this._isInitialized()){

          throw new Error("This decorator is already in-use. Modification is not possible anymore!");
        };
      };
    }
  }
});

qx.Interface.define("qx.ui.decoration.IDecorator", {
  members : {
    getStyles : function(){
    },
    getPadding : function(){
    },
    getInsets : function(){
    }
  }
});

qx.Class.define("qx.ui.decoration.Abstract", {
  extend : qx.core.Object,
  implement : [qx.ui.decoration.IDecorator],
  type : "abstract",
  members : {
    __insets : null,
    _getDefaultInsets : function(){

      throw new Error("Abstract method called.");
    },
    _isInitialized : function(){

      throw new Error("Abstract method called.");
    },
    _resetInsets : function(){

      this.__insets = null;
    },
    getInsets : function(){

      if(this.__insets){

        return this.__insets;
      };
      return this._getDefaultInsets();
    }
  },
  destruct : function(){

    this.__insets = null;
  }
});

qx.Mixin.define("qx.ui.decoration.MBackgroundImage", {
  properties : {
    backgroundImage : {
      check : "String",
      nullable : true,
      apply : "_applyBackgroundImage"
    },
    backgroundRepeat : {
      check : ["repeat", "repeat-x", "repeat-y", "no-repeat", "scale"],
      init : "repeat",
      apply : "_applyBackgroundImage"
    },
    backgroundPositionX : {
      nullable : true,
      apply : "_applyBackgroundPosition"
    },
    backgroundPositionY : {
      nullable : true,
      apply : "_applyBackgroundPosition"
    },
    backgroundPosition : {
      group : ["backgroundPositionY", "backgroundPositionX"]
    }
  },
  members : {
    _styleBackgroundImage : function(styles){

      var image = this.getBackgroundImage();
      if(!image){

        return;
      };
      var id = qx.util.AliasManager.getInstance().resolve(image);
      var source = qx.util.ResourceManager.getInstance().toUri(id);
      if(styles["background-image"]){

        styles["background-image"] += ', url(' + source + ')';
      } else {

        styles["background-image"] = 'url(' + source + ')';
      };
      var repeat = this.getBackgroundRepeat();
      if(repeat === "scale"){

        styles["background-size"] = "100% 100%";
      } else {

        styles["background-repeat"] = repeat;
      };
      var top = this.getBackgroundPositionY() || 0;
      var left = this.getBackgroundPositionX() || 0;
      if(!isNaN(top)){

        top += "px";
      };
      if(!isNaN(left)){

        left += "px";
      };
      styles["background-position"] = left + " " + top;
      if(qx.core.Environment.get("qx.debug") && source && qx.lang.String.endsWith(source, ".png") && (repeat == "scale" || repeat == "no-repeat") && qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 9){

        this.warn("Background PNGs with repeat == 'scale' or repeat == 'no-repeat'" + " are not supported in this client! The image's resource id is '" + id + "'");
      };
    },
    _applyBackgroundImage : function(){

      if(qx.core.Environment.get("qx.debug")){

        if(this._isInitialized()){

          throw new Error("This decorator is already in-use. Modification is not possible anymore!");
        };
      };
    },
    _applyBackgroundPosition : function(){

      if(qx.core.Environment.get("qx.debug")){

        if(this._isInitialized()){

          throw new Error("This decorator is already in-use. Modification is not possible anymore!");
        };
        if(qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 9){

          this.warn("The backgroundPosition property is not supported by this client!");
        };
      };
    }
  }
});

qx.Class.define("qx.util.AliasManager", {
  type : "singleton",
  extend : qx.util.ValueManager,
  construct : function(){

    this.base(arguments);
    this.__aliases = {
    };
    this.add("static", "qx/static");
  },
  members : {
    __aliases : null,
    _preprocess : function(value){

      var dynamics = this._getDynamic();
      if(dynamics[value] === false){

        return value;
      } else if(dynamics[value] === undefined){

        if(value.charAt(0) === "/" || value.charAt(0) === "." || value.indexOf("http://") === 0 || value.indexOf("https://") === "0" || value.indexOf("file://") === 0){

          dynamics[value] = false;
          return value;
        };
        if(this.__aliases[value]){

          return this.__aliases[value];
        };
        var alias = value.substring(0, value.indexOf("/"));
        var resolved = this.__aliases[alias];
        if(resolved !== undefined){

          dynamics[value] = resolved + value.substring(alias.length);
        };
      };
      return value;
    },
    add : function(alias, base){

      this.__aliases[alias] = base;
      var dynamics = this._getDynamic();
      for(var path in dynamics){

        if(path.substring(0, path.indexOf("/")) === alias){

          dynamics[path] = base + path.substring(alias.length);
        };
      };
    },
    remove : function(alias){

      delete this.__aliases[alias];
    },
    resolve : function(path){

      var dynamic = this._getDynamic();
      if(path != null){

        path = this._preprocess(path);
      };
      return dynamic[path] || path;
    },
    getAliases : function(){

      var res = {
      };
      for(var key in this.__aliases){

        res[key] = this.__aliases[key];
      };
      return res;
    }
  },
  destruct : function(){

    this.__aliases = null;
  }
});

qx.Mixin.define("qx.ui.decoration.MSingleBorder", {
  properties : {
    widthTop : {
      check : "Number",
      init : 0,
      apply : "_applyWidth"
    },
    widthRight : {
      check : "Number",
      init : 0,
      apply : "_applyWidth"
    },
    widthBottom : {
      check : "Number",
      init : 0,
      apply : "_applyWidth"
    },
    widthLeft : {
      check : "Number",
      init : 0,
      apply : "_applyWidth"
    },
    styleTop : {
      nullable : true,
      check : ["solid", "dotted", "dashed", "double", "inset", "outset", "ridge", "groove"],
      init : "solid",
      apply : "_applyStyle"
    },
    styleRight : {
      nullable : true,
      check : ["solid", "dotted", "dashed", "double", "inset", "outset", "ridge", "groove"],
      init : "solid",
      apply : "_applyStyle"
    },
    styleBottom : {
      nullable : true,
      check : ["solid", "dotted", "dashed", "double", "inset", "outset", "ridge", "groove"],
      init : "solid",
      apply : "_applyStyle"
    },
    styleLeft : {
      nullable : true,
      check : ["solid", "dotted", "dashed", "double", "inset", "outset", "ridge", "groove"],
      init : "solid",
      apply : "_applyStyle"
    },
    colorTop : {
      nullable : true,
      check : "Color",
      apply : "_applyStyle"
    },
    colorRight : {
      nullable : true,
      check : "Color",
      apply : "_applyStyle"
    },
    colorBottom : {
      nullable : true,
      check : "Color",
      apply : "_applyStyle"
    },
    colorLeft : {
      nullable : true,
      check : "Color",
      apply : "_applyStyle"
    },
    left : {
      group : ["widthLeft", "styleLeft", "colorLeft"]
    },
    right : {
      group : ["widthRight", "styleRight", "colorRight"]
    },
    top : {
      group : ["widthTop", "styleTop", "colorTop"]
    },
    bottom : {
      group : ["widthBottom", "styleBottom", "colorBottom"]
    },
    width : {
      group : ["widthTop", "widthRight", "widthBottom", "widthLeft"],
      mode : "shorthand"
    },
    style : {
      group : ["styleTop", "styleRight", "styleBottom", "styleLeft"],
      mode : "shorthand"
    },
    color : {
      group : ["colorTop", "colorRight", "colorBottom", "colorLeft"],
      mode : "shorthand"
    }
  },
  members : {
    _styleBorder : function(styles){

      if(qx.core.Environment.get("qx.theme")){

        var Color = qx.theme.manager.Color.getInstance();
        var colorTop = Color.resolve(this.getColorTop());
        var colorRight = Color.resolve(this.getColorRight());
        var colorBottom = Color.resolve(this.getColorBottom());
        var colorLeft = Color.resolve(this.getColorLeft());
      } else {

        var colorTop = this.getColorTop();
        var colorRight = this.getColorRight();
        var colorBottom = this.getColorBottom();
        var colorLeft = this.getColorLeft();
      };
      var width = this.getWidthTop();
      if(width > 0){

        styles["border-top"] = width + "px " + this.getStyleTop() + " " + (colorTop || "");
      };
      var width = this.getWidthRight();
      if(width > 0){

        styles["border-right"] = width + "px " + this.getStyleRight() + " " + (colorRight || "");
      };
      var width = this.getWidthBottom();
      if(width > 0){

        styles["border-bottom"] = width + "px " + this.getStyleBottom() + " " + (colorBottom || "");
      };
      var width = this.getWidthLeft();
      if(width > 0){

        styles["border-left"] = width + "px " + this.getStyleLeft() + " " + (colorLeft || "");
      };
      if(qx.core.Environment.get("qx.debug")){

        if(styles.length === 0){

          throw new Error("Invalid Single decorator (zero border width). Use qx.ui.decorator.Background instead!");
        };
      };
      styles.position = "absolute";
    },
    _getDefaultInsetsForBorder : function(){

      return {
        top : this.getWidthTop(),
        right : this.getWidthRight(),
        bottom : this.getWidthBottom(),
        left : this.getWidthLeft()
      };
    },
    _applyWidth : function(){

      this._applyStyle();
      this._resetInsets();
    },
    _applyStyle : function(){

      if(qx.core.Environment.get("qx.debug")){

        if(this._isInitialized()){

          throw new Error("This decorator is already in-use. Modification is not possible anymore!");
        };
      };
    }
  }
});

qx.Mixin.define("qx.ui.decoration.MDoubleBorder", {
  include : [qx.ui.decoration.MSingleBorder, qx.ui.decoration.MBackgroundImage],
  construct : function(){

    this._getDefaultInsetsForBorder = this.__getDefaultInsetsForDoubleBorder;
    this._styleBorder = this.__styleDoubleBorder;
  },
  properties : {
    innerWidthTop : {
      check : "Number",
      init : 0,
      apply : "_applyDoubleBorder"
    },
    innerWidthRight : {
      check : "Number",
      init : 0,
      apply : "_applyDoubleBorder"
    },
    innerWidthBottom : {
      check : "Number",
      init : 0,
      apply : "_applyDoubleBorder"
    },
    innerWidthLeft : {
      check : "Number",
      init : 0,
      apply : "_applyDoubleBorder"
    },
    innerWidth : {
      group : ["innerWidthTop", "innerWidthRight", "innerWidthBottom", "innerWidthLeft"],
      mode : "shorthand"
    },
    innerColorTop : {
      nullable : true,
      check : "Color",
      apply : "_applyDoubleBorder"
    },
    innerColorRight : {
      nullable : true,
      check : "Color",
      apply : "_applyDoubleBorder"
    },
    innerColorBottom : {
      nullable : true,
      check : "Color",
      apply : "_applyDoubleBorder"
    },
    innerColorLeft : {
      nullable : true,
      check : "Color",
      apply : "_applyDoubleBorder"
    },
    innerColor : {
      group : ["innerColorTop", "innerColorRight", "innerColorBottom", "innerColorLeft"],
      mode : "shorthand"
    },
    innerOpacity : {
      check : "Number",
      init : 1,
      apply : "_applyDoubleBorder"
    }
  },
  members : {
    __styleDoubleBorder : function(styles){

      var propName = qx.core.Environment.get("css.boxshadow");
      var color,innerColor,innerWidth;
      if(qx.core.Environment.get("qx.theme")){

        var Color = qx.theme.manager.Color.getInstance();
        color = {
          top : Color.resolve(this.getColorTop()),
          right : Color.resolve(this.getColorRight()),
          bottom : Color.resolve(this.getColorBottom()),
          left : Color.resolve(this.getColorLeft())
        };
        innerColor = {
          top : Color.resolve(this.getInnerColorTop()),
          right : Color.resolve(this.getInnerColorRight()),
          bottom : Color.resolve(this.getInnerColorBottom()),
          left : Color.resolve(this.getInnerColorLeft())
        };
      } else {

        color = {
          top : this.getColorTop(),
          right : this.getColorRight(),
          bottom : this.getColorBottom(),
          left : this.getColorLeft()
        };
        innerColor = {
          top : this.getInnerColorTop(),
          right : this.getInnerColorRight(),
          bottom : this.getInnerColorBottom(),
          left : this.getInnerColorLeft()
        };
      };
      innerWidth = {
        top : this.getInnerWidthTop(),
        right : this.getInnerWidthRight(),
        bottom : this.getInnerWidthBottom(),
        left : this.getInnerWidthLeft()
      };
      var width = this.getWidthTop();
      if(width > 0){

        styles["border-top"] = width + "px " + this.getStyleTop() + " " + color.top;
      };
      width = this.getWidthRight();
      if(width > 0){

        styles["border-right"] = width + "px " + this.getStyleRight() + " " + color.right;
      };
      width = this.getWidthBottom();
      if(width > 0){

        styles["border-bottom"] = width + "px " + this.getStyleBottom() + " " + color.bottom;
      };
      width = this.getWidthLeft();
      if(width > 0){

        styles["border-left"] = width + "px " + this.getStyleLeft() + " " + color.left;
      };
      var innerOpacity = this.getInnerOpacity();
      if(innerOpacity < 1){

        this.__processInnerOpacity(innerColor, innerOpacity);
      };
      if(innerWidth.top > 0 || innerWidth.right > 0 || innerWidth.bottom > 0 || innerWidth.left > 0){

        var borderTop = (innerWidth.top || 0) + "px solid " + innerColor.top;
        var borderRight = (innerWidth.right || 0) + "px solid " + innerColor.right;
        var borderBottom = (innerWidth.bottom || 0) + "px solid " + innerColor.bottom;
        var borderLeft = (innerWidth.left || 0) + "px solid " + innerColor.left;
        styles[":before"] = {
          "width" : "100%",
          "height" : "100%",
          "position" : "absolute",
          "content" : '""',
          "border-top" : borderTop,
          "border-right" : borderRight,
          "border-bottom" : borderBottom,
          "border-left" : borderLeft,
          "left" : 0,
          "top" : 0
        };
        var boxSizingKey = qx.bom.Style.getCssName(qx.core.Environment.get("css.boxsizing"));
        styles[":before"][boxSizingKey] = "border-box";
        var borderRadiusKey = qx.core.Environment.get("css.borderradius");
        if(borderRadiusKey){

          borderRadiusKey = qx.bom.Style.getCssName(borderRadiusKey);
          styles[":before"][borderRadiusKey] = "inherit";
        };
        var shadowStyle = [];
        if(innerColor.top && innerWidth.top && innerColor.top == innerColor.bottom && innerColor.top == innerColor.right && innerColor.top == innerColor.left && innerWidth.top == innerWidth.bottom && innerWidth.top == innerWidth.right && innerWidth.top == innerWidth.left){

          shadowStyle.push("inset 0 0 0 " + innerWidth.top + "px " + innerColor.top);
        } else {

          if(innerColor.top){

            shadowStyle.push("inset 0 " + (innerWidth.top || 0) + "px " + innerColor.top);
          };
          if(innerColor.right){

            shadowStyle.push("inset -" + (innerWidth.right || 0) + "px 0 " + innerColor.right);
          };
          if(innerColor.bottom){

            shadowStyle.push("inset 0 -" + (innerWidth.bottom || 0) + "px " + innerColor.bottom);
          };
          if(innerColor.left){

            shadowStyle.push("inset " + (innerWidth.left || 0) + "px 0 " + innerColor.left);
          };
        };
        if(shadowStyle.length > 0 && propName){

          propName = qx.bom.Style.getCssName(propName);
          if(!styles[propName]){

            styles[propName] = shadowStyle.join(",");
          } else {

            styles[propName] += "," + shadowStyle.join(",");
          };
        };
      } else {

        styles[":before"] = {
          border : 0
        };
      };
    },
    __processInnerOpacity : function(innerColor, innerOpacity){

      if(!qx.core.Environment.get("css.rgba")){

        if(qx.core.Environment.get("qx.debug")){

          qx.log.Logger.warn("innerOpacity is configured but the browser doesn't support RGBA colors.");
        };
        return;
      };
      for(var edge in innerColor){

        var rgb = qx.util.ColorUtil.stringToRgb(innerColor[edge]);
        rgb.push(innerOpacity);
        var rgbString = qx.util.ColorUtil.rgbToRgbString(rgb);
        innerColor[edge] = rgbString;
      };
    },
    _applyDoubleBorder : function(){

      if(qx.core.Environment.get("qx.debug")){

        if(this._isInitialized()){

          throw new Error("This decorator is already in-use. Modification is not possible anymore!");
        };
      };
    },
    __getDefaultInsetsForDoubleBorder : function(){

      return {
        top : this.getWidthTop() + this.getInnerWidthTop(),
        right : this.getWidthRight() + this.getInnerWidthRight(),
        bottom : this.getWidthBottom() + this.getInnerWidthBottom(),
        left : this.getWidthLeft() + this.getInnerWidthLeft()
      };
    }
  }
});

qx.Mixin.define("qx.ui.decoration.MBorderRadius", {
  properties : {
    radiusTopLeft : {
      nullable : true,
      check : "Integer",
      apply : "_applyBorderRadius"
    },
    radiusTopRight : {
      nullable : true,
      check : "Integer",
      apply : "_applyBorderRadius"
    },
    radiusBottomLeft : {
      nullable : true,
      check : "Integer",
      apply : "_applyBorderRadius"
    },
    radiusBottomRight : {
      nullable : true,
      check : "Integer",
      apply : "_applyBorderRadius"
    },
    radius : {
      group : ["radiusTopLeft", "radiusTopRight", "radiusBottomRight", "radiusBottomLeft"],
      mode : "shorthand"
    }
  },
  members : {
    _styleBorderRadius : function(styles){

      styles["-webkit-background-clip"] = "padding-box";
      styles["background-clip"] = "padding-box";
      var hasRadius = false;
      var radius = this.getRadiusTopLeft();
      if(radius > 0){

        hasRadius = true;
        styles["-moz-border-radius-topleft"] = radius + "px";
        styles["-webkit-border-top-left-radius"] = radius + "px";
        styles["border-top-left-radius"] = radius + "px";
      };
      radius = this.getRadiusTopRight();
      if(radius > 0){

        hasRadius = true;
        styles["-moz-border-radius-topright"] = radius + "px";
        styles["-webkit-border-top-right-radius"] = radius + "px";
        styles["border-top-right-radius"] = radius + "px";
      };
      radius = this.getRadiusBottomLeft();
      if(radius > 0){

        hasRadius = true;
        styles["-moz-border-radius-bottomleft"] = radius + "px";
        styles["-webkit-border-bottom-left-radius"] = radius + "px";
        styles["border-bottom-left-radius"] = radius + "px";
      };
      radius = this.getRadiusBottomRight();
      if(radius > 0){

        hasRadius = true;
        styles["-moz-border-radius-bottomright"] = radius + "px";
        styles["-webkit-border-bottom-right-radius"] = radius + "px";
        styles["border-bottom-right-radius"] = radius + "px";
      };
      if(hasRadius && qx.core.Environment.get("engine.name") == "webkit"){

        styles["-webkit-background-clip"] = "padding-box";
      } else {

        styles["background-clip"] = "padding-box";
      };
    },
    _applyBorderRadius : function(){

      if(qx.core.Environment.get("qx.debug")){

        if(this._isInitialized()){

          throw new Error("This decorator is already in-use. Modification is not possible anymore!");
        };
      };
    }
  }
});

qx.Mixin.define("qx.ui.decoration.MBorderImage", {
  properties : {
    borderImage : {
      check : "String",
      nullable : true,
      apply : "_applyBorderImage"
    },
    sliceTop : {
      check : "Integer",
      nullable : true,
      init : null,
      apply : "_applyBorderImage"
    },
    sliceRight : {
      check : "Integer",
      nullable : true,
      init : null,
      apply : "_applyBorderImage"
    },
    sliceBottom : {
      check : "Integer",
      nullable : true,
      init : null,
      apply : "_applyBorderImage"
    },
    sliceLeft : {
      check : "Integer",
      nullable : true,
      init : null,
      apply : "_applyBorderImage"
    },
    slice : {
      group : ["sliceTop", "sliceRight", "sliceBottom", "sliceLeft"],
      mode : "shorthand"
    },
    repeatX : {
      check : ["stretch", "repeat", "round"],
      init : "stretch",
      apply : "_applyBorderImage"
    },
    repeatY : {
      check : ["stretch", "repeat", "round"],
      init : "stretch",
      apply : "_applyBorderImage"
    },
    repeat : {
      group : ["repeatX", "repeatY"],
      mode : "shorthand"
    },
    fill : {
      check : "Boolean",
      init : true,
      apply : "_applyBorderImage"
    },
    borderImageMode : {
      check : ["horizontal", "vertical", "grid"],
      init : "grid"
    }
  },
  members : {
    _styleBorderImage : function(styles){

      if(!this.getBorderImage()){

        return;
      };
      var resolvedImage = qx.util.AliasManager.getInstance().resolve(this.getBorderImage());
      var source = qx.util.ResourceManager.getInstance().toUri(resolvedImage);
      var computedSlices = this._getDefaultInsetsForBorderImage();
      var slice = [computedSlices.top, computedSlices.right, computedSlices.bottom, computedSlices.left];
      var repeat = [this.getRepeatX(), this.getRepeatY()].join(" ");
      var fill = this.getFill() && qx.core.Environment.get("css.borderimage.standardsyntax") ? " fill" : "";
      var styleName = qx.bom.Style.getPropertyName("borderImage");
      if(styleName){

        var cssName = qx.bom.Style.getCssName(styleName);
        styles[cssName] = 'url("' + source + '") ' + slice.join(" ") + fill + " " + repeat;
      };
      styles["border-style"] = "solid";
      styles["border-color"] = "transparent";
      styles["border-width"] = slice.join("px ") + "px";
    },
    _getDefaultInsetsForBorderImage : function(){

      if(!this.getBorderImage()){

        return {
          top : 0,
          right : 0,
          bottom : 0,
          left : 0
        };
      };
      var resolvedImage = qx.util.AliasManager.getInstance().resolve(this.getBorderImage());
      var computedSlices = this.__getSlices(resolvedImage);
      return {
        top : this.getSliceTop() || computedSlices[0],
        right : this.getSliceRight() || computedSlices[1],
        bottom : this.getSliceBottom() || computedSlices[2],
        left : this.getSliceLeft() || computedSlices[3]
      };
    },
    _applyBorderImage : function(){

      if(qx.core.Environment.get("qx.debug")){

        if(this._isInitialized()){

          throw new Error("This decorator is already in-use. Modification is not possible anymore!");
        };
      };
    },
    __getSlices : function(baseImage){

      var mode = this.getBorderImageMode();
      var topSlice = 0;
      var rightSlice = 0;
      var bottomSlice = 0;
      var leftSlice = 0;
      var split = /(.*)(\.[a-z]+)$/.exec(baseImage);
      var prefix = split[1];
      var ext = split[2];
      var ResourceManager = qx.util.ResourceManager.getInstance();
      if(mode == "grid" || mode == "vertical"){

        topSlice = ResourceManager.getImageHeight(prefix + "-t" + ext);
        bottomSlice = ResourceManager.getImageHeight(prefix + "-b" + ext);
      };
      if(mode == "grid" || mode == "horizontal"){

        rightSlice = ResourceManager.getImageWidth(prefix + "-r" + ext);
        leftSlice = ResourceManager.getImageWidth(prefix + "-l" + ext);
      };
      return [topSlice, rightSlice, bottomSlice, leftSlice];
    }
  }
});

qx.Mixin.define("qx.ui.decoration.MLinearBackgroundGradient", {
  properties : {
    startColor : {
      check : "Color",
      nullable : true,
      apply : "_applyLinearBackgroundGradient"
    },
    endColor : {
      check : "Color",
      nullable : true,
      apply : "_applyLinearBackgroundGradient"
    },
    orientation : {
      check : ["horizontal", "vertical"],
      init : "vertical",
      apply : "_applyLinearBackgroundGradient"
    },
    startColorPosition : {
      check : "Number",
      init : 0,
      apply : "_applyLinearBackgroundGradient"
    },
    endColorPosition : {
      check : "Number",
      init : 100,
      apply : "_applyLinearBackgroundGradient"
    },
    colorPositionUnit : {
      check : ["px", "%"],
      init : "%",
      apply : "_applyLinearBackgroundGradient"
    },
    gradientStart : {
      group : ["startColor", "startColorPosition"],
      mode : "shorthand"
    },
    gradientEnd : {
      group : ["endColor", "endColorPosition"],
      mode : "shorthand"
    }
  },
  members : {
    __canvas : null,
    _styleLinearBackgroundGradient : function(styles){

      var colors = this.__getColors();
      var startColor = colors.start;
      var endColor = colors.end;
      var value;
      if(!startColor || !endColor){

        return;
      };
      var unit = this.getColorPositionUnit();
      if(qx.core.Environment.get("css.gradient.legacywebkit")){

        unit = unit === "px" ? "" : unit;
        if(this.getOrientation() == "horizontal"){

          var startPos = this.getStartColorPosition() + unit + " 0" + unit;
          var endPos = this.getEndColorPosition() + unit + " 0" + unit;
        } else {

          var startPos = "0" + unit + " " + this.getStartColorPosition() + unit;
          var endPos = "0" + unit + " " + this.getEndColorPosition() + unit;
        };
        var color = "from(" + startColor + "),to(" + endColor + ")";
        value = "-webkit-gradient(linear," + startPos + "," + endPos + "," + color + ")";
        styles["background"] = value;
      } else if(qx.core.Environment.get("css.gradient.filter") && !qx.core.Environment.get("css.gradient.linear") && qx.core.Environment.get("css.borderradius")){

        if(!this.__canvas){

          this.__canvas = document.createElement("canvas");
        };
        var isVertical = this.getOrientation() == "vertical";
        var colors = this.__getColors();
        var height = isVertical ? 200 : 1;
        var width = isVertical ? 1 : 200;
        var range = Math.max(100, this.getEndColorPosition() - this.getStartColorPosition());
        if(unit === "px"){

          if(isVertical){

            height = Math.max(height, this.getEndColorPosition() - this.getStartColorPosition());
          } else {

            width = Math.max(width, this.getEndColorPosition() - this.getStartColorPosition());
          };
        } else {

          if(isVertical){

            height = Math.max(height, (this.getEndColorPosition() - this.getStartColorPosition()) * 2);
          } else {

            width = Math.max(width, (this.getEndColorPosition() - this.getStartColorPosition()) * 2);
          };
        };
        this.__canvas.width = width;
        this.__canvas.height = height;
        var ctx = this.__canvas.getContext('2d');
        if(isVertical){

          var lingrad = ctx.createLinearGradient(0, 0, 0, height);
        } else {

          var lingrad = ctx.createLinearGradient(0, 0, width, 0);
        };
        if(unit === "%"){

          lingrad.addColorStop(Math.max(0, this.getStartColorPosition()) / range, colors.start);
          lingrad.addColorStop(this.getEndColorPosition() / range, colors.end);
        } else {

          var comp = isVertical ? height : width;
          lingrad.addColorStop(Math.max(0, this.getStartColorPosition()) / comp, colors.start);
          lingrad.addColorStop(this.getEndColorPosition() / comp, colors.end);
        };
        ctx.fillStyle = lingrad;
        ctx.fillRect(0, 0, width, height);
        var value = "url(" + this.__canvas.toDataURL() + ")";
        styles["background-image"] = value;
        if(unit === "%"){

          if(isVertical){

            styles["background-size"] = "100% " + range + "%";
          } else {

            styles["background-size"] = range + "% 100%";
          };
        } else {

          styles["background-size"] = isVertical ? height + "px 100%" : "100% " + width + "px";
        };
      } else if(qx.core.Environment.get("css.gradient.filter") && !qx.core.Environment.get("css.gradient.linear")){

        var colors = this.__getColors();
        var type = this.getOrientation() == "horizontal" ? 1 : 0;
        var startColor = colors.start;
        var endColor = colors.end;
        if(!qx.util.ColorUtil.isHex6String(startColor)){

          startColor = qx.util.ColorUtil.stringToRgb(startColor);
          startColor = qx.util.ColorUtil.rgbToHexString(startColor);
        };
        if(!qx.util.ColorUtil.isHex6String(endColor)){

          endColor = qx.util.ColorUtil.stringToRgb(endColor);
          endColor = qx.util.ColorUtil.rgbToHexString(endColor);
        };
        startColor = startColor.substring(1, startColor.length);
        endColor = endColor.substring(1, endColor.length);
        value = "progid:DXImageTransform.Microsoft.Gradient" + "(GradientType=" + type + ", " + "StartColorStr='#FF" + startColor + "', " + "EndColorStr='#FF" + endColor + "';)";
        if(styles["filter"]){

          styles["filter"] += ", " + value;
        } else {

          styles["filter"] = value;
        };
        if(!styles["background-color"] || styles["background-color"] == "transparent"){

          styles["background-color"] = "white";
        };
      } else {

        var deg = this.getOrientation() == "horizontal" ? 0 : 270;
        var start = startColor + " " + this.getStartColorPosition() + unit;
        var end = endColor + " " + this.getEndColorPosition() + unit;
        var prefixedName = qx.core.Environment.get("css.gradient.linear");
        if(prefixedName === "linear-gradient"){

          deg = this.getOrientation() == "horizontal" ? deg + 90 : deg - 90;
        };
        value = prefixedName + "(" + deg + "deg, " + start + "," + end + ")";
        if(styles["background-image"]){

          styles["background-image"] += ", " + value;
        } else {

          styles["background-image"] = value;
        };
      };;
    },
    __getColors : function(){

      if(qx.core.Environment.get("qx.theme")){

        var Color = qx.theme.manager.Color.getInstance();
        var startColor = Color.resolve(this.getStartColor());
        var endColor = Color.resolve(this.getEndColor());
      } else {

        var startColor = this.getStartColor();
        var endColor = this.getEndColor();
      };
      return {
        start : startColor,
        end : endColor
      };
    },
    _getContent : function(){

      if(qx.core.Environment.get("css.gradient.filter") && !qx.core.Environment.get("css.gradient.linear")){

        var colors = this.__getColors();
        var type = this.getOrientation() == "horizontal" ? 1 : 0;
        var startColor = qx.util.ColorUtil.hex3StringToHex6String(colors.start);
        var endColor = qx.util.ColorUtil.hex3StringToHex6String(colors.end);
        startColor = startColor.substring(1, startColor.length);
        endColor = endColor.substring(1, endColor.length);
        var shadow = "";
        if(this.classname.indexOf("MBoxShadow") != -1){

          var styles = {
          };
          this._styleBoxShadow(styles);
          shadow = "<div style='width: 100%; height: 100%; position: absolute;" + qx.bom.element.Style.compile(styles) + "'></div>";
        };
        return "<div style=\"position: absolute; width: 100%; height: 100%; " + "filter:progid:DXImageTransform.Microsoft.Gradient" + "(GradientType=" + type + ", " + "StartColorStr='#FF" + startColor + "', " + "EndColorStr='#FF" + endColor + "';)\">" + shadow + "</div>";
      };
      return "";
    },
    _applyLinearBackgroundGradient : function(){

      if(qx.core.Environment.get("qx.debug")){

        if(this._isInitialized()){

          throw new Error("This decorator is already in-use. Modification is not possible anymore!");
        };
      };
    }
  }
});

qx.Mixin.define("qx.ui.decoration.MBoxShadow", {
  properties : {
    shadowHorizontalLength : {
      nullable : true,
      check : "Integer",
      apply : "_applyBoxShadow"
    },
    shadowVerticalLength : {
      nullable : true,
      check : "Integer",
      apply : "_applyBoxShadow"
    },
    shadowBlurRadius : {
      nullable : true,
      check : "Integer",
      apply : "_applyBoxShadow"
    },
    shadowSpreadRadius : {
      nullable : true,
      check : "Integer",
      apply : "_applyBoxShadow"
    },
    shadowColor : {
      nullable : true,
      check : "Color",
      apply : "_applyBoxShadow"
    },
    inset : {
      init : false,
      check : "Boolean",
      apply : "_applyBoxShadow"
    },
    shadowLength : {
      group : ["shadowHorizontalLength", "shadowVerticalLength"],
      mode : "shorthand"
    }
  },
  members : {
    _styleBoxShadow : function(styles){

      var propName = qx.core.Environment.get("css.boxshadow");
      if(!propName || this.getShadowVerticalLength() == null && this.getShadowHorizontalLength() == null){

        return;
      };
      if(qx.core.Environment.get("qx.theme")){

        var Color = qx.theme.manager.Color.getInstance();
        var color = Color.resolve(this.getShadowColor());
      } else {

        var color = this.getShadowColor();
      };
      if(color != null){

        var vLength = this.getShadowVerticalLength() || 0;
        var hLength = this.getShadowHorizontalLength() || 0;
        var blur = this.getShadowBlurRadius() || 0;
        var spread = this.getShadowSpreadRadius() || 0;
        var inset = this.getInset() ? "inset " : "";
        var value = inset + hLength + "px " + vLength + "px " + blur + "px " + spread + "px " + color;
        propName = qx.bom.Style.getCssName(propName);
        if(!styles[propName]){

          styles[propName] = value;
        } else {

          styles[propName] += "," + value;
        };
      };
    },
    _applyBoxShadow : function(){

      if(qx.core.Environment.get("qx.debug")){

        if(this._isInitialized()){

          throw new Error("This decorator is already in-use. Modification is not possible anymore!");
        };
      };
    }
  }
});

qx.Class.define("qx.ui.decoration.Decorator", {
  extend : qx.ui.decoration.Abstract,
  implement : [qx.ui.decoration.IDecorator],
  include : [qx.ui.decoration.MBackgroundColor, qx.ui.decoration.MBorderRadius, qx.ui.decoration.MBoxShadow, qx.ui.decoration.MDoubleBorder, qx.ui.decoration.MLinearBackgroundGradient, qx.ui.decoration.MBorderImage],
  members : {
    __initialized : false,
    getPadding : function(){

      var insets = this.getInset();
      var slices = this._getDefaultInsetsForBorderImage();
      var borderTop = insets.top - (slices.top ? slices.top : this.getWidthTop());
      var borderRight = insets.right - (slices.right ? slices.right : this.getWidthRight());
      var borderBottom = insets.bottom - (slices.bottom ? slices.bottom : this.getWidthBottom());
      var borderLeft = insets.left - (slices.left ? slices.left : this.getWidthLeft());
      return {
        top : insets.top ? borderTop : this.getInnerWidthTop(),
        right : insets.right ? borderRight : this.getInnerWidthRight(),
        bottom : insets.bottom ? borderBottom : this.getInnerWidthBottom(),
        left : insets.left ? borderLeft : this.getInnerWidthLeft()
      };
    },
    getStyles : function(css){

      if(css){

        return this._getStyles();
      };
      var jsStyles = {
      };
      var cssStyles = this._getStyles();
      for(var property in cssStyles){

        jsStyles[qx.lang.String.camelCase(property)] = cssStyles[property];
      };
      return jsStyles;
    },
    _getStyles : function(){

      var styles = {
      };
      for(var name in this){

        if(name.indexOf("_style") == 0 && this[name] instanceof Function){

          this[name](styles);
        };
      };
      this.__initialized = true;
      return styles;
    },
    _getDefaultInsets : function(){

      var directions = ["top", "right", "bottom", "left"];
      var defaultInsets = {
      };
      for(var name in this){

        if(name.indexOf("_getDefaultInsetsFor") == 0 && this[name] instanceof Function){

          var currentInsets = this[name]();
          for(var i = 0;i < directions.length;i++){

            var direction = directions[i];
            if(defaultInsets[direction] == undefined){

              defaultInsets[direction] = currentInsets[direction];
            };
            if(currentInsets[direction] > defaultInsets[direction]){

              defaultInsets[direction] = currentInsets[direction];
            };
          };
        };
      };
      if(defaultInsets["top"] != undefined){

        return defaultInsets;
      };
      return {
        top : 0,
        right : 0,
        bottom : 0,
        left : 0
      };
    },
    _isInitialized : function(){

      return this.__initialized;
    }
  }
});

qx.Class.define("qx.type.BaseString", {
  extend : Object,
  construct : function(txt){

    var txt = txt || "";
    this.__txt = txt;
    this.length = txt.length;
  },
  members : {
    $$isString : true,
    length : 0,
    __txt : null,
    toString : function(){

      return this.__txt;
    },
    charAt : null,
    valueOf : null,
    charCodeAt : null,
    concat : null,
    indexOf : null,
    lastIndexOf : null,
    match : null,
    replace : null,
    search : null,
    slice : null,
    split : null,
    substr : null,
    substring : null,
    toLowerCase : null,
    toUpperCase : null,
    toHashCode : function(){

      return qx.core.ObjectRegistry.toHashCode(this);
    },
    toLocaleLowerCase : null,
    toLocaleUpperCase : null,
    base : function(args, varags){

      return qx.core.Object.prototype.base.apply(this, arguments);
    }
  },
  defer : function(statics, members){

    if(qx.core.Environment.get("qx.debug")){

      qx.Class.include(statics, qx.core.MAssert);
    };
    var mappedFunctions = ['charAt', 'charCodeAt', 'concat', 'indexOf', 'lastIndexOf', 'match', 'replace', 'search', 'slice', 'split', 'substr', 'substring', 'toLowerCase', 'toUpperCase', 'toLocaleLowerCase', 'toLocaleUpperCase', 'trim'];
    members.valueOf = members.toString;
    if(new statics("").valueOf() == null){

      delete members.valueOf;
    };
    for(var i = 0,l = mappedFunctions.length;i < l;i++){

      members[mappedFunctions[i]] = String.prototype[mappedFunctions[i]];
    };
  }
});

qx.Class.define("qx.locale.LocalizedString", {
  extend : qx.type.BaseString,
  construct : function(translation, messageId, args){

    this.base(arguments, translation);
    this.__messageId = messageId;
    this.__args = args;
  },
  members : {
    __messageId : null,
    __args : null,
    translate : function(){

      return qx.locale.Manager.getInstance().translate(this.__messageId, this.__args);
    },
    getMessageId : function(){

      return this.__messageId;
    }
  }
});

qx.Class.define("qx.locale.Manager", {
  type : "singleton",
  extend : qx.core.Object,
  construct : function(){

    this.base(arguments);
    this.__translations = qx.$$translations || {
    };
    this.__locales = qx.$$locales || {
    };
    var locale = qx.core.Environment.get("locale");
    var variant = qx.core.Environment.get("locale.variant");
    if(variant !== ""){

      locale += "_" + variant;
    };
    this.__clientLocale = locale;
    this.setLocale(locale || this.__defaultLocale);
  },
  statics : {
    tr : function(messageId, varargs){

      var args = qx.lang.Array.fromArguments(arguments);
      args.splice(0, 1);
      return qx.locale.Manager.getInstance().translate(messageId, args);
    },
    trn : function(singularMessageId, pluralMessageId, count, varargs){

      var args = qx.lang.Array.fromArguments(arguments);
      args.splice(0, 3);
      if(count != 1){

        return qx.locale.Manager.getInstance().translate(pluralMessageId, args);
      } else {

        return qx.locale.Manager.getInstance().translate(singularMessageId, args);
      };
    },
    trc : function(hint, messageId, varargs){

      var args = qx.lang.Array.fromArguments(arguments);
      args.splice(0, 2);
      return qx.locale.Manager.getInstance().translate(messageId, args);
    },
    trnc : function(hint, singularMessageId, pluralMessageId, count, varargs){

      var args = qx.lang.Array.fromArguments(arguments);
      args.splice(0, 4);
      if(count != 1){

        return qx.locale.Manager.getInstance().translate(pluralMessageId, args);
      } else {

        return qx.locale.Manager.getInstance().translate(singularMessageId, args);
      };
    },
    marktr : function(messageId){

      return messageId;
    }
  },
  properties : {
    locale : {
      check : "String",
      nullable : true,
      apply : "_applyLocale",
      event : "changeLocale"
    }
  },
  members : {
    __defaultLocale : "C",
    __locale : null,
    __language : null,
    __translations : null,
    __locales : null,
    __clientLocale : null,
    getLanguage : function(){

      return this.__language;
    },
    getTerritory : function(){

      return this.getLocale().split("_")[1] || "";
    },
    getAvailableLocales : function(includeNonloaded){

      var locales = [];
      for(var locale in this.__locales){

        if(locale != this.__defaultLocale){

          if(this.__locales[locale] === null && !includeNonloaded){

            continue;
          };
          locales.push(locale);
        };
      };
      return locales;
    },
    __extractLanguage : function(locale){

      var language;
      if(locale == null){

        return null;
      };
      var pos = locale.indexOf("_");
      if(pos == -1){

        language = locale;
      } else {

        language = locale.substring(0, pos);
      };
      return language;
    },
    _applyLocale : function(value, old){

      if(qx.core.Environment.get("qx.debug")){

        if(!(value in this.__locales || value == this.__clientLocale)){

          qx.log.Logger.warn("Locale: " + value + " not available.");
        };
      };
      this.__locale = value;
      this.__language = this.__extractLanguage(value);
    },
    addTranslation : function(languageCode, translationMap){

      var catalog = this.__translations;
      if(catalog[languageCode]){

        for(var key in translationMap){

          catalog[languageCode][key] = translationMap[key];
        };
      } else {

        catalog[languageCode] = translationMap;
      };
    },
    addLocale : function(localeCode, localeMap){

      var catalog = this.__locales;
      if(catalog[localeCode]){

        for(var key in localeMap){

          catalog[localeCode][key] = localeMap[key];
        };
      } else {

        catalog[localeCode] = localeMap;
      };
    },
    translate : function(messageId, args, locale){

      var catalog = this.__translations;
      return this.__lookupAndExpand(catalog, messageId, args, locale);
    },
    localize : function(messageId, args, locale){

      var catalog = this.__locales;
      return this.__lookupAndExpand(catalog, messageId, args, locale);
    },
    __lookupAndExpand : function(catalog, messageId, args, locale){

      if(qx.core.Environment.get("qx.debug")){

        this.assertObject(catalog);
        this.assertString(messageId);
        this.assertArray(args);
      };
      var txt;
      if(!catalog){

        return messageId;
      };
      if(locale){

        var language = this.__extractLanguage(locale);
      } else {

        locale = this.__locale;
        language = this.__language;
      };
      if(!txt && catalog[locale]){

        txt = catalog[locale][messageId];
      };
      if(!txt && catalog[language]){

        txt = catalog[language][messageId];
      };
      if(!txt && catalog[this.__defaultLocale]){

        txt = catalog[this.__defaultLocale][messageId];
      };
      if(!txt){

        txt = messageId;
      };
      if(args.length > 0){

        var translatedArgs = [];
        for(var i = 0;i < args.length;i++){

          var arg = args[i];
          if(arg && arg.translate){

            translatedArgs[i] = arg.translate();
          } else {

            translatedArgs[i] = arg;
          };
        };
        txt = qx.lang.String.format(txt, translatedArgs);
      };
      if(qx.core.Environment.get("qx.dynlocale")){

        txt = new qx.locale.LocalizedString(txt, messageId, args);
      };
      return txt;
    }
  },
  destruct : function(){

    this.__translations = this.__locales = null;
  }
});

qx.Bootstrap.define("qx.bom.client.Locale", {
  statics : {
    getLocale : function(){

      var locale = qx.bom.client.Locale.__getNavigatorLocale();
      var index = locale.indexOf("-");
      if(index != -1){

        locale = locale.substr(0, index);
      };
      return locale;
    },
    getVariant : function(){

      var locale = qx.bom.client.Locale.__getNavigatorLocale();
      var variant = "";
      var index = locale.indexOf("-");
      if(index != -1){

        variant = locale.substr(index + 1);
      };
      return variant;
    },
    __getNavigatorLocale : function(){

      var locale = (navigator.userLanguage || navigator.language || "");
      if(qx.bom.client.OperatingSystem.getName() == "android"){

        var match = /(\w{2})-(\w{2})/i.exec(navigator.userAgent);
        if(match){

          locale = match[0];
        };
      };
      return locale.toLowerCase();
    }
  },
  defer : function(statics){

    qx.core.Environment.add("locale", statics.getLocale);
    qx.core.Environment.add("locale.variant", statics.getVariant);
  }
});

qx.Mixin.define("qx.ui.core.MPlacement", {
  statics : {
    __visible : null,
    __direction : "left",
    setVisibleElement : function(elem){

      this.__visible = elem;
    },
    getVisibleElement : function(){

      return this.__visible;
    },
    setMoveDirection : function(direction){

      if(direction === "top" || direction === "left"){

        this.__direction = direction;
      } else {

        throw new Error("Invalid value for the parameter 'direction' " + "[qx.ui.core.MPlacement.setMoveDirection()], the value was '" + direction + "' " + "but 'top' or 'left' are allowed.");
      };
    },
    getMoveDirection : function(){

      return this.__direction;
    }
  },
  properties : {
    position : {
      check : ["top-left", "top-center", "top-right", "bottom-left", "bottom-center", "bottom-right", "left-top", "left-middle", "left-bottom", "right-top", "right-middle", "right-bottom"],
      init : "bottom-left",
      themeable : true
    },
    placeMethod : {
      check : ["widget", "pointer"],
      init : "pointer",
      themeable : true
    },
    domMove : {
      check : "Boolean",
      init : false
    },
    placementModeX : {
      check : ["direct", "keep-align", "best-fit"],
      init : "keep-align",
      themeable : true
    },
    placementModeY : {
      check : ["direct", "keep-align", "best-fit"],
      init : "keep-align",
      themeable : true
    },
    offsetLeft : {
      check : "Integer",
      init : 0,
      themeable : true
    },
    offsetTop : {
      check : "Integer",
      init : 0,
      themeable : true
    },
    offsetRight : {
      check : "Integer",
      init : 0,
      themeable : true
    },
    offsetBottom : {
      check : "Integer",
      init : 0,
      themeable : true
    },
    offset : {
      group : ["offsetTop", "offsetRight", "offsetBottom", "offsetLeft"],
      mode : "shorthand",
      themeable : true
    }
  },
  members : {
    __ptwLiveUpdater : null,
    __ptwLiveDisappearListener : null,
    __ptwLiveUpdateDisappearListener : null,
    getLayoutLocation : function(widget){

      var insets,bounds,left,top;
      bounds = widget.getBounds();
      if(!bounds){

        return null;
      };
      left = bounds.left;
      top = bounds.top;
      var size = bounds;
      widget = widget.getLayoutParent();
      while(widget && !widget.isRootWidget()){

        bounds = widget.getBounds();
        left += bounds.left;
        top += bounds.top;
        insets = widget.getInsets();
        left += insets.left;
        top += insets.top;
        widget = widget.getLayoutParent();
      };
      if(widget.isRootWidget()){

        var rootCoords = widget.getContentLocation();
        if(rootCoords){

          left += rootCoords.left;
          top += rootCoords.top;
        };
      };
      return {
        left : left,
        top : top,
        right : left + size.width,
        bottom : top + size.height
      };
    },
    moveTo : function(left, top){

      var visible = qx.ui.core.MPlacement.getVisibleElement();
      if(visible){

        var bounds = this.getBounds();
        var elemLocation = visible.getContentLocation();
        if(bounds && elemLocation){

          var bottom = top + bounds.height;
          var right = left + bounds.width;
          if((right > elemLocation.left && left < elemLocation.right) && (bottom > elemLocation.top && top < elemLocation.bottom)){

            var direction = qx.ui.core.MPlacement.getMoveDirection();
            if(direction === "left"){

              left = Math.max(elemLocation.left - bounds.width, 0);
            } else {

              top = Math.max(elemLocation.top - bounds.height, 0);
            };
          };
        };
      };
      if(this.getDomMove()){

        this.setDomPosition(left, top);
      } else {

        this.setLayoutProperties({
          left : left,
          top : top
        });
      };
    },
    placeToWidget : function(target, liveupdate){

      if(liveupdate){

        this.__cleanupFromLastPlaceToWidgetLiveUpdate();
        this.__ptwLiveUpdater = qx.lang.Function.bind(this.placeToWidget, this, target, false);
        qx.event.Idle.getInstance().addListener("interval", this.__ptwLiveUpdater);
        this.__ptwLiveUpdateDisappearListener = function(){

          this.__cleanupFromLastPlaceToWidgetLiveUpdate();
        };
        this.addListener("disappear", this.__ptwLiveUpdateDisappearListener, this);
      };
      var coords = target.getContentLocation() || this.getLayoutLocation(target);
      if(coords != null){

        this._place(coords);
        return true;
      } else {

        return false;
      };
    },
    __cleanupFromLastPlaceToWidgetLiveUpdate : function(){

      if(this.__ptwLiveUpdater){

        qx.event.Idle.getInstance().removeListener("interval", this.__ptwLiveUpdater);
        this.__ptwLiveUpdater = null;
      };
      if(this.__ptwLiveUpdateDisappearListener){

        this.removeListener("disappear", this.__ptwLiveUpdateDisappearListener, this);
        this.__ptwLiveUpdateDisappearListener = null;
      };
    },
    placeToPointer : function(event){

      var left = Math.round(event.getDocumentLeft());
      var top = Math.round(event.getDocumentTop());
      var coords = {
        left : left,
        top : top,
        right : left,
        bottom : top
      };
      this._place(coords);
    },
    placeToElement : function(elem, liveupdate){

      var location = qx.bom.element.Location.get(elem);
      var coords = {
        left : location.left,
        top : location.top,
        right : location.left + elem.offsetWidth,
        bottom : location.top + elem.offsetHeight
      };
      if(liveupdate){

        this.__ptwLiveUpdater = qx.lang.Function.bind(this.placeToElement, this, elem, false);
        qx.event.Idle.getInstance().addListener("interval", this.__ptwLiveUpdater);
        this.addListener("disappear", function(){

          if(this.__ptwLiveUpdater){

            qx.event.Idle.getInstance().removeListener("interval", this.__ptwLiveUpdater);
            this.__ptwLiveUpdater = null;
          };
        }, this);
      };
      this._place(coords);
    },
    placeToPoint : function(point){

      var coords = {
        left : point.left,
        top : point.top,
        right : point.left,
        bottom : point.top
      };
      this._place(coords);
    },
    _getPlacementOffsets : function(){

      return {
        left : this.getOffsetLeft(),
        top : this.getOffsetTop(),
        right : this.getOffsetRight(),
        bottom : this.getOffsetBottom()
      };
    },
    __getPlacementSize : function(callback){

      var size = null;
      if(this._computePlacementSize){

        var size = this._computePlacementSize();
      } else if(this.isVisible()){

        var size = this.getBounds();
      };
      if(size == null){

        this.addListenerOnce("appear", function(){

          this.__getPlacementSize(callback);
        }, this);
      } else {

        callback.call(this, size);
      };
    },
    _place : function(coords){

      this.__getPlacementSize(function(size){

        var result = qx.util.placement.Placement.compute(size, this.getLayoutParent().getBounds(), coords, this._getPlacementOffsets(), this.getPosition(), this.getPlacementModeX(), this.getPlacementModeY());
        this.removeState("placementLeft");
        this.removeState("placementRight");
        this.addState(coords.left < result.left ? "placementRight" : "placementLeft");
        this.moveTo(result.left, result.top);
      });
    }
  },
  destruct : function(){

    this.__cleanupFromLastPlaceToWidgetLiveUpdate();
  }
});

qx.Class.define("qx.util.placement.Placement", {
  extend : qx.core.Object,
  construct : function(){

    this.base(arguments);
    this.__defaultAxis = qx.util.placement.DirectAxis;
  },
  properties : {
    axisX : {
      check : "Class"
    },
    axisY : {
      check : "Class"
    },
    edge : {
      check : ["top", "right", "bottom", "left"],
      init : "top"
    },
    align : {
      check : ["top", "right", "bottom", "left", "center", "middle"],
      init : "right"
    }
  },
  statics : {
    __instance : null,
    compute : function(size, area, target, offsets, position, modeX, modeY){

      this.__instance = this.__instance || new qx.util.placement.Placement();
      var splitted = position.split("-");
      var edge = splitted[0];
      var align = splitted[1];
      if(qx.core.Environment.get("qx.debug")){

        if(align === "center" || align === "middle"){

          var expected = "middle";
          if(edge === "top" || edge === "bottom"){

            expected = "center";
          };
          qx.core.Assert.assertEquals(expected, align, "Please use '" + edge + "-" + expected + "' instead!");
        };
      };
      this.__instance.set({
        axisX : this.__getAxis(modeX),
        axisY : this.__getAxis(modeY),
        edge : edge,
        align : align
      });
      return this.__instance.compute(size, area, target, offsets);
    },
    __direct : null,
    __keepAlign : null,
    __bestFit : null,
    __getAxis : function(mode){

      switch(mode){case "direct":
      this.__direct = this.__direct || qx.util.placement.DirectAxis;
      return this.__direct;case "keep-align":
      this.__keepAlign = this.__keepAlign || qx.util.placement.KeepAlignAxis;
      return this.__keepAlign;case "best-fit":
      this.__bestFit = this.__bestFit || qx.util.placement.BestFitAxis;
      return this.__bestFit;default:
      throw new Error("Invalid 'mode' argument!'");};
    }
  },
  members : {
    __defaultAxis : null,
    compute : function(size, area, target, offsets){

      if(qx.core.Environment.get("qx.debug")){

        this.assertObject(size, "size");
        this.assertNumber(size.width, "size.width");
        this.assertNumber(size.height, "size.height");
        this.assertObject(area, "area");
        this.assertNumber(area.width, "area.width");
        this.assertNumber(area.height, "area.height");
        this.assertObject(target, "target");
        this.assertNumber(target.top, "target.top");
        this.assertNumber(target.right, "target.right");
        this.assertNumber(target.bottom, "target.bottom");
        this.assertNumber(target.left, "target.left");
        this.assertObject(offsets, "offsets");
        this.assertNumber(offsets.top, "offsets.top");
        this.assertNumber(offsets.right, "offsets.right");
        this.assertNumber(offsets.bottom, "offsets.bottom");
        this.assertNumber(offsets.left, "offsets.left");
      };
      var axisX = this.getAxisX() || this.__defaultAxis;
      var left = axisX.computeStart(size.width, {
        start : target.left,
        end : target.right
      }, {
        start : offsets.left,
        end : offsets.right
      }, area.width, this.__getPositionX());
      var axisY = this.getAxisY() || this.__defaultAxis;
      var top = axisY.computeStart(size.height, {
        start : target.top,
        end : target.bottom
      }, {
        start : offsets.top,
        end : offsets.bottom
      }, area.height, this.__getPositionY());
      return {
        left : left,
        top : top
      };
    },
    __getPositionX : function(){

      var edge = this.getEdge();
      var align = this.getAlign();
      if(edge == "left"){

        return "edge-start";
      } else if(edge == "right"){

        return "edge-end";
      } else if(align == "left"){

        return "align-start";
      } else if(align == "center"){

        return "align-center";
      } else if(align == "right"){

        return "align-end";
      };;;;
    },
    __getPositionY : function(){

      var edge = this.getEdge();
      var align = this.getAlign();
      if(edge == "top"){

        return "edge-start";
      } else if(edge == "bottom"){

        return "edge-end";
      } else if(align == "top"){

        return "align-start";
      } else if(align == "middle"){

        return "align-center";
      } else if(align == "bottom"){

        return "align-end";
      };;;;
    }
  },
  destruct : function(){

    this._disposeObjects('__defaultAxis');
  }
});

qx.Bootstrap.define("qx.util.placement.AbstractAxis", {
  extend : Object,
  statics : {
    computeStart : function(size, target, offsets, areaSize, position){

      throw new Error("abstract method call!");
    },
    _moveToEdgeAndAlign : function(size, target, offsets, position){

      switch(position){case "edge-start":
      return target.start - offsets.end - size;case "edge-end":
      return target.end + offsets.start;case "align-start":
      return target.start + offsets.start;case "align-center":
      return target.start + parseInt((target.end - target.start - size) / 2, 10) + offsets.start;case "align-end":
      return target.end - offsets.end - size;};
    },
    _isInRange : function(start, size, areaSize){

      return start >= 0 && start + size <= areaSize;
    }
  }
});

qx.Bootstrap.define("qx.util.placement.DirectAxis", {
  statics : {
    _moveToEdgeAndAlign : qx.util.placement.AbstractAxis._moveToEdgeAndAlign,
    computeStart : function(size, target, offsets, areaSize, position){

      return this._moveToEdgeAndAlign(size, target, offsets, position);
    }
  }
});

qx.Bootstrap.define("qx.util.placement.KeepAlignAxis", {
  statics : {
    _moveToEdgeAndAlign : qx.util.placement.AbstractAxis._moveToEdgeAndAlign,
    _isInRange : qx.util.placement.AbstractAxis._isInRange,
    computeStart : function(size, target, offsets, areaSize, position){

      var start = this._moveToEdgeAndAlign(size, target, offsets, position);
      var range1End,range2Start;
      if(this._isInRange(start, size, areaSize)){

        return start;
      };
      if(position == "edge-start" || position == "edge-end"){

        range1End = target.start - offsets.end;
        range2Start = target.end + offsets.start;
      } else {

        range1End = target.end - offsets.end;
        range2Start = target.start + offsets.start;
      };
      if(range1End > areaSize - range2Start){

        start = range1End - size;
      } else {

        start = range2Start;
      };
      return start;
    }
  }
});

qx.Bootstrap.define("qx.util.placement.BestFitAxis", {
  statics : {
    _isInRange : qx.util.placement.AbstractAxis._isInRange,
    _moveToEdgeAndAlign : qx.util.placement.AbstractAxis._moveToEdgeAndAlign,
    computeStart : function(size, target, offsets, areaSize, position){

      var start = this._moveToEdgeAndAlign(size, target, offsets, position);
      if(this._isInRange(start, size, areaSize)){

        return start;
      };
      if(start < 0){

        start = Math.min(0, areaSize - size);
      };
      if(start + size > areaSize){

        start = Math.max(0, areaSize - size);
      };
      return start;
    }
  }
});

qx.Class.define("qx.ui.basic.Image", {
  extend : qx.ui.core.Widget,
  construct : function(source){

    this.__contentElements = {
    };
    this.base(arguments);
    if(source){

      this.setSource(source);
    };
  },
  properties : {
    source : {
      check : "String",
      init : null,
      nullable : true,
      event : "changeSource",
      apply : "_applySource",
      themeable : true
    },
    scale : {
      check : "Boolean",
      init : false,
      themeable : true,
      apply : "_applyScale"
    },
    appearance : {
      refine : true,
      init : "image"
    },
    allowShrinkX : {
      refine : true,
      init : false
    },
    allowShrinkY : {
      refine : true,
      init : false
    },
    allowGrowX : {
      refine : true,
      init : false
    },
    allowGrowY : {
      refine : true,
      init : false
    }
  },
  events : {
    loadingFailed : "qx.event.type.Event",
    loaded : "qx.event.type.Event",
    aborted : "qx.event.type.Event"
  },
  members : {
    __width : null,
    __height : null,
    __mode : null,
    __contentElements : null,
    __currentContentElement : null,
    __wrapper : null,
    __requestId : 0,
    _onChangeTheme : function(){

      this.base(arguments);
      this._styleSource();
    },
    getContentElement : function(){

      return this.__getSuitableContentElement();
    },
    _createContentElement : function(){

      return this.__getSuitableContentElement();
    },
    _getContentHint : function(){

      return {
        width : this.__width || 0,
        height : this.__height || 0
      };
    },
    _applyDecorator : function(value, old){

      this.base(arguments, value, old);
      var source = this.getSource();
      source = qx.util.AliasManager.getInstance().resolve(source);
      var el = this.getContentElement();
      if(this.__wrapper){

        el = el.getChild(0);
      };
      this.__setSource(el, source);
    },
    _applyPadding : function(value, old, name){

      this.base(arguments, value, old, name);
      var element = this.getContentElement();
      if(this.__wrapper){

        element.getChild(0).setStyles({
          top : this.getPaddingTop() || 0,
          left : this.getPaddingLeft() || 0
        });
      } else {

        element.setPadding(this.getPaddingLeft() || 0, this.getPaddingTop() || 0);
      };
    },
    renderLayout : function(left, top, width, height){

      this.base(arguments, left, top, width, height);
      var element = this.getContentElement();
      if(this.__wrapper){

        element.getChild(0).setStyles({
          width : width - (this.getPaddingLeft() || 0) - (this.getPaddingRight() || 0),
          height : height - (this.getPaddingTop() || 0) - (this.getPaddingBottom() || 0),
          top : this.getPaddingTop() || 0,
          left : this.getPaddingLeft() || 0
        });
      };
    },
    _applyEnabled : function(value, old){

      this.base(arguments, value, old);
      if(this.getSource()){

        this._styleSource();
      };
    },
    _applySource : function(value, old){

      if(old){

        if(qx.io.ImageLoader.isLoading(old)){

          qx.io.ImageLoader.abort(old);
        };
      };
      this._styleSource();
    },
    _applyScale : function(value){

      this._styleSource();
    },
    __setMode : function(mode){

      this.__mode = mode;
    },
    __getMode : function(){

      if(this.__mode == null){

        var source = this.getSource();
        var isPng = false;
        if(source != null){

          isPng = qx.lang.String.endsWith(source, ".png");
        };
        if(this.getScale() && isPng && qx.core.Environment.get("css.alphaimageloaderneeded")){

          this.__mode = "alphaScaled";
        } else if(this.getScale()){

          this.__mode = "scaled";
        } else {

          this.__mode = "nonScaled";
        };
      };
      return this.__mode;
    },
    __createSuitableContentElement : function(mode){

      var scale;
      var tagName;
      if(mode == "alphaScaled"){

        scale = true;
        tagName = "div";
      } else if(mode == "nonScaled"){

        scale = false;
        tagName = "div";
      } else {

        scale = true;
        tagName = "img";
      };
      var element = new qx.html.Image(tagName);
      element.setAttribute("$$widget", this.toHashCode());
      element.setScale(scale);
      element.setStyles({
        "overflowX" : "hidden",
        "overflowY" : "hidden",
        "boxSizing" : "border-box"
      });
      if(qx.core.Environment.get("css.alphaimageloaderneeded")){

        var wrapper = this.__wrapper = new qx.html.Element("div");
        wrapper.setAttribute("$$widget", this.toHashCode());
        wrapper.setStyle("position", "absolute");
        wrapper.add(element);
        return wrapper;
      };
      return element;
    },
    __getSuitableContentElement : function(){

      if(this.$$disposed){

        return null;
      };
      var mode = this.__getMode();
      if(this.__contentElements[mode] == null){

        this.__contentElements[mode] = this.__createSuitableContentElement(mode);
      };
      var element = this.__contentElements[mode];
      if(!this.__currentContentElement){

        this.__currentContentElement = element;
      };
      return element;
    },
    _styleSource : function(){

      var source = qx.util.AliasManager.getInstance().resolve(this.getSource());
      var element = this.getContentElement();
      if(this.__wrapper){

        element = element.getChild(0);
      };
      if(!source){

        element.resetSource();
        return;
      };
      this.__checkForContentElementSwitch(source);
      if((qx.core.Environment.get("engine.name") == "mshtml") && (parseInt(qx.core.Environment.get("engine.version"), 10) < 9 || qx.core.Environment.get("browser.documentmode") < 9)){

        var repeat = this.getScale() ? "scale" : "no-repeat";
        element.tagNameHint = qx.bom.element.Decoration.getTagName(repeat, source);
      };
      var contentEl = this.__getContentElement();
      if(qx.util.ResourceManager.getInstance().has(source)){

        this.__setManagedImage(contentEl, source);
        this.__fireLoadEvent();
      } else if(qx.io.ImageLoader.isLoaded(source)){

        this.__setUnmanagedImage(contentEl, source);
        this.__fireLoadEvent();
      } else {

        this.__loadUnmanagedImage(contentEl, source);
      };
    },
    __fireLoadEvent : function(){

      this.__requestId++;
      qx.bom.AnimationFrame.request(function(rId){

        if(rId === this.__requestId){

          this.fireEvent("loaded");
        } else {

          this.fireEvent("aborted");
        };
      }.bind(this, this.__requestId));
    },
    __getContentElement : function(){

      var contentEl = this.__currentContentElement;
      if(this.__wrapper){

        contentEl = contentEl.getChild(0);
      };
      return contentEl;
    },
    __checkForContentElementSwitch : qx.core.Environment.select("engine.name", {
      "mshtml" : function(source){

        var alphaImageLoader = qx.core.Environment.get("css.alphaimageloaderneeded");
        var isPng = qx.lang.String.endsWith(source, ".png");
        if(alphaImageLoader && isPng){

          if(this.getScale() && this.__getMode() != "alphaScaled"){

            this.__setMode("alphaScaled");
          } else if(!this.getScale() && this.__getMode() != "nonScaled"){

            this.__setMode("nonScaled");
          };
        } else {

          if(this.getScale() && this.__getMode() != "scaled"){

            this.__setMode("scaled");
          } else if(!this.getScale() && this.__getMode() != "nonScaled"){

            this.__setMode("nonScaled");
          };
        };
        this.__checkForContentElementReplacement(this.__getSuitableContentElement());
      },
      "default" : function(source){

        if(this.getScale() && this.__getMode() != "scaled"){

          this.__setMode("scaled");
        } else if(!this.getScale() && this.__getMode("nonScaled")){

          this.__setMode("nonScaled");
        };
        this.__checkForContentElementReplacement(this.__getSuitableContentElement());
      }
    }),
    __checkForContentElementReplacement : function(elementToAdd){

      var currentContentElement = this.__currentContentElement;
      if(currentContentElement != elementToAdd){

        if(currentContentElement != null){

          var pixel = "px";
          var styles = {
          };
          var bounds = this.getBounds();
          if(bounds != null){

            styles.width = bounds.width + pixel;
            styles.height = bounds.height + pixel;
          };
          var insets = this.getInsets();
          styles.left = parseInt(currentContentElement.getStyle("left") || insets.left) + pixel;
          styles.top = parseInt(currentContentElement.getStyle("top") || insets.top) + pixel;
          styles.zIndex = 10;
          var newEl = this.__wrapper ? elementToAdd.getChild(0) : elementToAdd;
          newEl.setStyles(styles, true);
          newEl.setSelectable(this.getSelectable());
          if(!currentContentElement.isVisible()){

            elementToAdd.hide();
          };
          if(!currentContentElement.isIncluded()){

            elementToAdd.exclude();
          };
          var container = currentContentElement.getParent();
          if(container){

            var index = container.getChildren().indexOf(currentContentElement);
            container.removeAt(index);
            container.addAt(elementToAdd, index);
          };
          var hint = newEl.getNodeName();
          newEl.setSource(null);
          var currentEl = this.__getContentElement();
          newEl.tagNameHint = hint;
          newEl.setAttribute("class", currentEl.getAttribute("class"));
          qx.html.Element.flush();
          var currentDomEl = currentEl.getDomElement();
          var newDomEl = elementToAdd.getDomElement();
          var listeners = currentContentElement.getListeners() || [];
          listeners.forEach(function(listenerData){

            elementToAdd.addListener(listenerData.type, listenerData.handler, listenerData.self, listenerData.capture);
          });
          if(currentDomEl && newDomEl){

            var currentHash = currentDomEl.$$hash;
            currentDomEl.$$hash = newDomEl.$$hash;
            newDomEl.$$hash = currentHash;
          };
          this.__currentContentElement = elementToAdd;
        };
      };
    },
    __setManagedImage : function(el, source){

      var ResourceManager = qx.util.ResourceManager.getInstance();
      if(!this.getEnabled()){

        var disabled = source.replace(/\.([a-z]+)$/, "-disabled.$1");
        if(ResourceManager.has(disabled)){

          source = disabled;
          this.addState("replacement");
        } else {

          this.removeState("replacement");
        };
      };
      if(el.getSource() === source){

        return;
      };
      this.__setSource(el, source);
      this.__updateContentHint(ResourceManager.getImageWidth(source), ResourceManager.getImageHeight(source));
    },
    __setUnmanagedImage : function(el, source){

      var ImageLoader = qx.io.ImageLoader;
      this.__setSource(el, source);
      var width = ImageLoader.getWidth(source);
      var height = ImageLoader.getHeight(source);
      this.__updateContentHint(width, height);
    },
    __loadUnmanagedImage : function(el, source){

      var ImageLoader = qx.io.ImageLoader;
      if(qx.core.Environment.get("qx.debug")){

        var sourceLC = source.toLowerCase();
        var startsWith = qx.lang.String.startsWith;
        if(!startsWith(sourceLC, "http") && !startsWith(sourceLC, "data:image/")){

          var self = this.self(arguments);
          if(!self.__warned){

            self.__warned = {
            };
          };
          if(!self.__warned[source]){

            this.debug("try to load an unmanaged relative image: " + source);
            self.__warned[source] = true;
          };
        };
      };
      if(!ImageLoader.isFailed(source)){

        ImageLoader.load(source, this.__loaderCallback, this);
      } else {

        if(el != null){

          el.resetSource();
        };
      };
    },
    __setSource : function(el, source){

      if(el.getNodeName() == "div"){

        var dec = qx.theme.manager.Decoration.getInstance().resolve(this.getDecorator());
        if(dec){

          var hasGradient = (dec.getStartColor() && dec.getEndColor());
          var hasBackground = dec.getBackgroundImage();
          if(hasGradient || hasBackground){

            var repeat = this.getScale() ? "scale" : "no-repeat";
            var attr = qx.bom.element.Decoration.getAttributes(source, repeat);
            var decStyle = dec.getStyles(true);
            var combinedStyles = {
              "backgroundImage" : attr.style.backgroundImage,
              "backgroundPosition" : (attr.style.backgroundPosition || "0 0"),
              "backgroundRepeat" : (attr.style.backgroundRepeat || "no-repeat")
            };
            if(hasBackground){

              combinedStyles["backgroundPosition"] += "," + decStyle["background-position"] || "0 0";
              combinedStyles["backgroundRepeat"] += ", " + dec.getBackgroundRepeat();
            };
            if(hasGradient){

              combinedStyles["backgroundPosition"] += ", 0 0";
              combinedStyles["backgroundRepeat"] += ", no-repeat";
            };
            combinedStyles["backgroundImage"] += "," + decStyle["background-image"];
            el.setStyles(combinedStyles);
            return;
          };
        } else {

          el.setSource(null);
        };
      };
      el.setSource(source);
    },
    __loaderCallback : function(source, imageInfo){

      if(this.$$disposed === true){

        return;
      };
      if(source !== qx.util.AliasManager.getInstance().resolve(this.getSource())){

        this.fireEvent("aborted");
        return;
      };
      if(imageInfo.failed){

        this.warn("Image could not be loaded: " + source);
        this.fireEvent("loadingFailed");
      } else if(imageInfo.aborted){

        this.fireEvent("aborted");
        return;
      } else {

        this.fireEvent("loaded");
      };
      this.__setUnmanagedImage(this.__getContentElement(), source);
    },
    __updateContentHint : function(width, height){

      if(width !== this.__width || height !== this.__height){

        this.__width = width;
        this.__height = height;
        qx.ui.core.queue.Layout.add(this);
      };
    }
  },
  destruct : function(){

    delete this.__currentContentElement;
    if(this.__wrapper){

      delete this.__wrapper;
    };
    this._disposeMap("__contentElements");
  }
});

qx.Bootstrap.define("qx.io.ImageLoader", {
  statics : {
    __data : {
    },
    __defaultSize : {
      width : null,
      height : null
    },
    __knownImageTypesRegExp : /\.(png|gif|jpg|jpeg|bmp)\b/i,
    __dataUrlRegExp : /^data:image\/(png|gif|jpg|jpeg|bmp)\b/i,
    isLoaded : function(source){

      var entry = this.__data[source];
      return !!(entry && entry.loaded);
    },
    isFailed : function(source){

      var entry = this.__data[source];
      return !!(entry && entry.failed);
    },
    isLoading : function(source){

      var entry = this.__data[source];
      return !!(entry && entry.loading);
    },
    getFormat : function(source){

      var entry = this.__data[source];
      if(!entry || !entry.format){

        var result = this.__dataUrlRegExp.exec(source);
        if(result != null){

          var width = (entry && qx.lang.Type.isNumber(entry.width) ? entry.width : this.__defaultSize.width);
          var height = (entry && qx.lang.Type.isNumber(entry.height) ? entry.height : this.__defaultSize.height);
          entry = {
            loaded : true,
            format : result[1],
            width : width,
            height : height
          };
        };
      };
      return entry ? entry.format : null;
    },
    getSize : function(source){

      var entry = this.__data[source];
      return entry ? {
        width : entry.width,
        height : entry.height
      } : this.__defaultSize;
    },
    getWidth : function(source){

      var entry = this.__data[source];
      return entry ? entry.width : null;
    },
    getHeight : function(source){

      var entry = this.__data[source];
      return entry ? entry.height : null;
    },
    load : function(source, callback, context){

      var entry = this.__data[source];
      if(!entry){

        entry = this.__data[source] = {
        };
      };
      if(callback && !context){

        context = window;
      };
      if(entry.loaded || entry.loading || entry.failed){

        if(callback){

          if(entry.loading){

            entry.callbacks.push(callback, context);
          } else {

            callback.call(context, source, entry);
          };
        };
      } else {

        entry.loading = true;
        entry.callbacks = [];
        if(callback){

          entry.callbacks.push(callback, context);
        };
        var el = new Image();
        var boundCallback = qx.lang.Function.listener(this.__onload, this, el, source);
        el.onload = boundCallback;
        el.onerror = boundCallback;
        el.src = source;
        entry.element = el;
      };
    },
    abort : function(source){

      var entry = this.__data[source];
      if(entry && !entry.loaded){

        entry.aborted = true;
        var callbacks = entry.callbacks;
        var element = entry.element;
        element.onload = element.onerror = null;
        element.src = "";
        delete entry.callbacks;
        delete entry.element;
        delete entry.loading;
        for(var i = 0,l = callbacks.length;i < l;i += 2){

          callbacks[i].call(callbacks[i + 1], source, entry);
        };
      };
      this.__data[source] = null;
    },
    __onload : qx.event.GlobalError.observeMethod(function(event, element, source){

      var entry = this.__data[source];
      var isImageAvailable = function(imgElem){

        return (imgElem && imgElem.height !== 0);
      };
      if(event.type === "load" && isImageAvailable(element)){

        entry.loaded = true;
        entry.width = this.__getWidth(element);
        entry.height = this.__getHeight(element);
        var result = this.__knownImageTypesRegExp.exec(source);
        if(result != null){

          entry.format = result[1];
        };
      } else {

        entry.failed = true;
      };
      element.onload = element.onerror = null;
      var callbacks = entry.callbacks;
      delete entry.loading;
      delete entry.callbacks;
      delete entry.element;
      for(var i = 0,l = callbacks.length;i < l;i += 2){

        callbacks[i].call(callbacks[i + 1], source, entry);
      };
    }),
    __getWidth : function(element){

      return qx.core.Environment.get("html.image.naturaldimensions") ? element.naturalWidth : element.width;
    },
    __getHeight : function(element){

      return qx.core.Environment.get("html.image.naturaldimensions") ? element.naturalHeight : element.height;
    },
    dispose : function(){

      this.__data = {
      };
    }
  }
});

qx.Class.define("qx.html.Image", {
  extend : qx.html.Element,
  members : {
    __paddingTop : null,
    __paddingLeft : null,
    tagNameHint : null,
    setPadding : function(paddingLeft, paddingTop){

      this.__paddingLeft = paddingLeft;
      this.__paddingTop = paddingTop;
      if(this.getNodeName() == "div"){

        this.setStyle("backgroundPosition", paddingLeft + "px " + paddingTop + "px");
      };
    },
    _applyProperty : function(name, value){

      this.base(arguments, name, value);
      if(name === "source"){

        var elem = this.getDomElement();
        var styles = this.getAllStyles();
        if(this.getNodeName() == "div" && this.getStyle("backgroundImage")){

          styles.backgroundRepeat = null;
        };
        var source = this._getProperty("source");
        var scale = this._getProperty("scale");
        var repeat = scale ? "scale" : "no-repeat";
        if(source != null){

          source = source || null;
          styles.paddingTop = this.__paddingTop;
          styles.paddingLeft = this.__paddingLeft;
          qx.bom.element.Decoration.update(elem, source, repeat, styles);
        };
      };
    },
    _removeProperty : function(key, direct){

      if(key == "source"){

        this._setProperty(key, "", direct);
      } else {

        this._setProperty(key, null, direct);
      };
    },
    _createDomElement : function(){

      var scale = this._getProperty("scale");
      var repeat = scale ? "scale" : "no-repeat";
      if((qx.core.Environment.get("engine.name") == "mshtml")){

        var source = this._getProperty("source");
        if(this.tagNameHint != null){

          this.setNodeName(this.tagNameHint);
        } else {

          this.setNodeName(qx.bom.element.Decoration.getTagName(repeat, source));
        };
      } else {

        this.setNodeName(qx.bom.element.Decoration.getTagName(repeat));
      };
      return this.base(arguments);
    },
    _copyData : function(fromMarkup){

      return this.base(arguments, true);
    },
    setSource : function(value){

      this._setProperty("source", value);
      return this;
    },
    getSource : function(){

      return this._getProperty("source");
    },
    resetSource : function(){

      if((qx.core.Environment.get("engine.name") == "webkit")){

        this._setProperty("source", "qx/static/blank.gif");
      } else {

        this._removeProperty("source", true);
      };
      return this;
    },
    setScale : function(value){

      this._setProperty("scale", value);
      return this;
    },
    getScale : function(){

      return this._getProperty("scale");
    }
  }
});

qx.Class.define("qx.bom.element.Decoration", {
  statics : {
    DEBUG : false,
    __warnings : {
    },
    __alphaFixRepeats : qx.core.Environment.select("engine.name", {
      "mshtml" : {
        "scale-x" : true,
        "scale-y" : true,
        "scale" : true,
        "no-repeat" : true
      },
      "default" : null
    }),
    __repeatToTagname : {
      "scale-x" : "img",
      "scale-y" : "img",
      "scale" : "img",
      "repeat" : "div",
      "no-repeat" : "div",
      "repeat-x" : "div",
      "repeat-y" : "div"
    },
    update : function(element, source, repeat, style){

      var tag = this.getTagName(repeat, source);
      if(tag != element.tagName.toLowerCase()){

        throw new Error("Image modification not possible because elements could not be replaced at runtime anymore!");
      };
      var ret = this.getAttributes(source, repeat, style);
      if(tag === "img"){

        element.src = ret.src || qx.util.ResourceManager.getInstance().toUri("qx/static/blank.gif");
      };
      if(element.style.backgroundPosition != "" && ret.style.backgroundPosition === undefined){

        ret.style.backgroundPosition = null;
      };
      if(element.style.clip != "" && ret.style.clip === undefined){

        ret.style.clip = null;
      };
      qx.bom.element.Style.setStyles(element, ret.style);
      if(qx.core.Environment.get("css.alphaimageloaderneeded")){

        try{

          element.filters["DXImageTransform.Microsoft.AlphaImageLoader"].apply();
        } catch(e) {
        };
      };
    },
    create : function(source, repeat, style){

      var tag = this.getTagName(repeat, source);
      var ret = this.getAttributes(source, repeat, style);
      var css = qx.bom.element.Style.compile(ret.style);
      if(tag === "img"){

        return '<img src="' + ret.src + '" style="' + css + '"/>';
      } else {

        return '<div style="' + css + '"></div>';
      };
    },
    getTagName : function(repeat, source){

      if(source && qx.core.Environment.get("css.alphaimageloaderneeded") && this.__alphaFixRepeats[repeat] && qx.lang.String.endsWith(source, ".png")){

        return "div";
      };
      return this.__repeatToTagname[repeat];
    },
    getAttributes : function(source, repeat, style){

      if(!style){

        style = {
        };
      };
      if(!style.position){

        style.position = "absolute";
      };
      if((qx.core.Environment.get("engine.name") == "mshtml")){

        style.fontSize = 0;
        style.lineHeight = 0;
      } else if((qx.core.Environment.get("engine.name") == "webkit")){

        style.WebkitUserDrag = "none";
      };
      var format = qx.util.ResourceManager.getInstance().getImageFormat(source) || qx.io.ImageLoader.getFormat(source);
      if(qx.core.Environment.get("qx.debug")){

        if(source != null && format == null){

          qx.log.Logger.warn("ImageLoader: Not recognized format of external image '" + source + "'!");
        };
      };
      var result;
      if(qx.core.Environment.get("css.alphaimageloaderneeded") && this.__alphaFixRepeats[repeat] && format === "png"){

        var dimension = this.__getDimension(source);
        this.__normalizeWidthHeight(style, dimension.width, dimension.height);
        result = this.processAlphaFix(style, repeat, source);
      } else {

        delete style.clip;
        if(repeat === "scale"){

          result = this.__processScale(style, repeat, source);
        } else if(repeat === "scale-x" || repeat === "scale-y"){

          result = this.__processScaleXScaleY(style, repeat, source);
        } else {

          result = this.__processRepeats(style, repeat, source);
        };
      };
      return result;
    },
    __normalizeWidthHeight : function(style, width, height){

      if(style.width == null && width != null){

        style.width = width + "px";
      };
      if(style.height == null && height != null){

        style.height = height + "px";
      };
    },
    __getDimension : function(source){

      var width = qx.util.ResourceManager.getInstance().getImageWidth(source) || qx.io.ImageLoader.getWidth(source);
      var height = qx.util.ResourceManager.getInstance().getImageHeight(source) || qx.io.ImageLoader.getHeight(source);
      return {
        width : width,
        height : height
      };
    },
    processAlphaFix : function(style, repeat, source){

      if(repeat == "repeat" || repeat == "repeat-x" || repeat == "repeat-y"){

        return style;
      };
      var sizingMethod = repeat == "no-repeat" ? "crop" : "scale";
      var filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + qx.util.ResourceManager.getInstance().toUri(source) + "', sizingMethod='" + sizingMethod + "')";
      style.filter = filter;
      style.backgroundImage = style.backgroundRepeat = "";
      delete style["background-image"];
      delete style["background-repeat"];
      return {
        style : style
      };
    },
    __processScale : function(style, repeat, source){

      var uri = qx.util.ResourceManager.getInstance().toUri(source);
      var dimension = this.__getDimension(source);
      this.__normalizeWidthHeight(style, dimension.width, dimension.height);
      return {
        src : uri,
        style : style
      };
    },
    __processScaleXScaleY : function(style, repeat, sourceid){

      var ResourceManager = qx.util.ResourceManager.getInstance();
      var clipped = ResourceManager.getCombinedFormat(sourceid);
      var dimension = this.__getDimension(sourceid);
      var uri;
      if(clipped){

        var data = ResourceManager.getData(sourceid);
        var combinedid = data[4];
        if(clipped == "b64"){

          uri = ResourceManager.toDataUri(sourceid);
        } else {

          uri = ResourceManager.toUri(combinedid);
        };
        if(repeat === "scale-x"){

          style = this.__getStylesForClippedScaleX(style, data, dimension.height);
        } else {

          style = this.__getStylesForClippedScaleY(style, data, dimension.width);
        };
        return {
          src : uri,
          style : style
        };
      } else {

        if(qx.core.Environment.get("qx.debug")){

          this.__checkForPotentialClippedImage(sourceid);
        };
        if(repeat == "scale-x"){

          style.height = dimension.height == null ? null : dimension.height + "px";
        } else if(repeat == "scale-y"){

          style.width = dimension.width == null ? null : dimension.width + "px";
        };
        uri = ResourceManager.toUri(sourceid);
        return {
          src : uri,
          style : style
        };
      };
    },
    __getStylesForClippedScaleX : function(style, data, height){

      var imageHeight = qx.util.ResourceManager.getInstance().getImageHeight(data[4]);
      style.clip = {
        top : -data[6],
        height : height
      };
      style.height = imageHeight + "px";
      if(style.top != null){

        style.top = (parseInt(style.top, 10) + data[6]) + "px";
      } else if(style.bottom != null){

        style.bottom = (parseInt(style.bottom, 10) + height - imageHeight - data[6]) + "px";
      };
      return style;
    },
    __getStylesForClippedScaleY : function(style, data, width){

      var imageWidth = qx.util.ResourceManager.getInstance().getImageWidth(data[4]);
      style.clip = {
        left : -data[5],
        width : width
      };
      style.width = imageWidth + "px";
      if(style.left != null){

        style.left = (parseInt(style.left, 10) + data[5]) + "px";
      } else if(style.right != null){

        style.right = (parseInt(style.right, 10) + width - imageWidth - data[5]) + "px";
      };
      return style;
    },
    __processRepeats : function(style, repeat, sourceid){

      var ResourceManager = qx.util.ResourceManager.getInstance();
      var clipped = ResourceManager.getCombinedFormat(sourceid);
      var dimension = this.__getDimension(sourceid);
      if(clipped && repeat !== "repeat"){

        var data = ResourceManager.getData(sourceid);
        var combinedid = data[4];
        if(clipped == "b64"){

          var uri = ResourceManager.toDataUri(sourceid);
          var offx = 0;
          var offy = 0;
        } else {

          var uri = ResourceManager.toUri(combinedid);
          var offx = data[5];
          var offy = data[6];
          if(style.paddingTop || style.paddingLeft || style.paddingRight || style.paddingBottom){

            var top = style.paddingTop || 0;
            var left = style.paddingLeft || 0;
            offx += style.paddingLeft || 0;
            offy += style.paddingTop || 0;
            style.clip = {
              left : left,
              top : top,
              width : dimension.width,
              height : dimension.height
            };
          };
        };
        var bg = qx.bom.element.Background.getStyles(uri, repeat, offx, offy);
        for(var key in bg){

          style[key] = bg[key];
        };
        if(dimension.width != null && style.width == null && (repeat == "repeat-y" || repeat === "no-repeat")){

          style.width = dimension.width + "px";
        };
        if(dimension.height != null && style.height == null && (repeat == "repeat-x" || repeat === "no-repeat")){

          style.height = dimension.height + "px";
        };
        return {
          style : style
        };
      } else {

        var top = style.paddingTop || 0;
        var left = style.paddingLeft || 0;
        style.backgroundPosition = left + "px " + top + "px";
        if(qx.core.Environment.get("qx.debug")){

          if(repeat !== "repeat"){

            this.__checkForPotentialClippedImage(sourceid);
          };
        };
        this.__normalizeWidthHeight(style, dimension.width, dimension.height);
        this.__getStylesForSingleRepeat(style, sourceid, repeat);
        return {
          style : style
        };
      };
    },
    __getStylesForSingleRepeat : function(style, source, repeat){

      var top = null;
      var left = null;
      if(style.backgroundPosition){

        var backgroundPosition = style.backgroundPosition.split(" ");
        left = parseInt(backgroundPosition[0], 10);
        if(isNaN(left)){

          left = backgroundPosition[0];
        };
        top = parseInt(backgroundPosition[1], 10);
        if(isNaN(top)){

          top = backgroundPosition[1];
        };
      };
      var bg = qx.bom.element.Background.getStyles(source, repeat, left, top);
      for(var key in bg){

        style[key] = bg[key];
      };
      if(style.filter){

        style.filter = "";
      };
    },
    __checkForPotentialClippedImage : function(source){

      if(this.DEBUG && qx.util.ResourceManager.getInstance().has(source) && source.indexOf("qx/icon") == -1){

        if(!this.__warnings[source]){

          qx.log.Logger.debug("Potential clipped image candidate: " + source);
          this.__warnings[source] = true;
        };
      };
    }
  }
});

qx.Class.define("qx.bom.element.Background", {
  statics : {
    __tmpl : ["background-image:url(", null, ");", "background-position:", null, ";", "background-repeat:", null, ";"],
    __emptyStyles : {
      backgroundImage : null,
      backgroundPosition : null,
      backgroundRepeat : null
    },
    __computePosition : function(left, top){

      var engine = qx.core.Environment.get("engine.name");
      var version = qx.core.Environment.get("engine.version");
      if(engine == "gecko" && version < 1.9 && left == top && typeof left == "number"){

        top += 0.01;
      };
      if(left){

        var leftCss = (typeof left == "number") ? left + "px" : left;
      } else {

        leftCss = "0";
      };
      if(top){

        var topCss = (typeof top == "number") ? top + "px" : top;
      } else {

        topCss = "0";
      };
      return leftCss + " " + topCss;
    },
    __isBase64EncodedImage : function(url){

      var String = qx.lang.String;
      var firstPartOfUrl = url.substr(0, 50);
      return String.startsWith(firstPartOfUrl, "data:") && String.contains(firstPartOfUrl, "base64");
    },
    compile : function(source, repeat, left, top){

      var position = this.__computePosition(left, top);
      var backgroundImageUrl = qx.util.ResourceManager.getInstance().toUri(source);
      if(this.__isBase64EncodedImage(backgroundImageUrl)){

        backgroundImageUrl = "'" + backgroundImageUrl + "'";
      };
      var tmpl = this.__tmpl;
      tmpl[1] = backgroundImageUrl;
      tmpl[4] = position;
      tmpl[7] = repeat;
      return tmpl.join("");
    },
    getStyles : function(source, repeat, left, top){

      if(!source){

        return this.__emptyStyles;
      };
      var position = this.__computePosition(left, top);
      var backgroundImageUrl = qx.util.ResourceManager.getInstance().toUri(source);
      var backgroundImageCssString;
      if(this.__isBase64EncodedImage(backgroundImageUrl)){

        backgroundImageCssString = "url('" + backgroundImageUrl + "')";
      } else {

        backgroundImageCssString = "url(" + backgroundImageUrl + ")";
      };
      var map = {
        backgroundPosition : position,
        backgroundImage : backgroundImageCssString
      };
      if(repeat != null){

        map.backgroundRepeat = repeat;
      };
      return map;
    },
    set : function(element, source, repeat, left, top){

      var styles = this.getStyles(source, repeat, left, top);
      for(var prop in styles){

        element.style[prop] = styles[prop];
      };
    }
  }
});

qx.Class.define("qx.ui.core.DragDropCursor", {
  extend : qx.ui.basic.Image,
  include : qx.ui.core.MPlacement,
  type : "singleton",
  construct : function(){

    this.base(arguments);
    this.setZIndex(1e8);
    this.setDomMove(true);
    var root = this.getApplicationRoot();
    root.add(this, {
      left : -1000,
      top : -1000
    });
  },
  properties : {
    appearance : {
      refine : true,
      init : "dragdrop-cursor"
    },
    action : {
      check : ["alias", "copy", "move"],
      apply : "_applyAction",
      nullable : true
    }
  },
  members : {
    _applyAction : function(value, old){

      if(old){

        this.removeState(old);
      };
      if(value){

        this.addState(value);
      };
    }
  }
});

qx.Class.define("qx.ui.mobile.layout.HBox", {
  extend : qx.ui.mobile.layout.AbstractBox,
  members : {
    _getCssClasses : function(){

      return ["hbox"];
    }
  }
});

qx.Class.define("qx.ui.mobile.basic.Atom", {
  extend : qx.ui.mobile.core.Widget,
  construct : function(label, icon){

    this.base(arguments);
    this.__createChildren(label, icon);
    this.addCssClass("gap");
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "atom"
    },
    label : {
      apply : "_applyLabel",
      nullable : true,
      check : "String",
      event : "changeLabel"
    },
    icon : {
      check : "String",
      apply : "_applyIcon",
      nullable : true,
      event : "changeIcon"
    },
    gap : {
      check : "Integer",
      nullable : false,
      apply : "_applyGap",
      init : 4
    },
    show : {
      init : "both",
      check : ["both", "label", "icon"],
      inheritable : true,
      apply : "_applyShow"
    },
    iconPosition : {
      init : "left",
      check : ["top", "right", "bottom", "left"],
      apply : "_applyIconPosition"
    }
  },
  members : {
    __label : null,
    __icon : null,
    __childrenContainer : null,
    _applyIconPosition : function(value, old){

      var targetLayout;
      var verticalLayout = ["top", "bottom"].indexOf(value) != -1;
      if(verticalLayout){

        targetLayout = new qx.ui.mobile.layout.VBox();
      } else {

        targetLayout = new qx.ui.mobile.layout.HBox();
      };
      var isReverse = ["right", "bottom"].indexOf(value) != -1;
      targetLayout.setReversed(isReverse);
      this.__childrenContainer.setLayout(targetLayout);
      this._domUpdated();
    },
    _applyShow : function(value, old){

      if(this.__label){

        if(value === 'both' || value === 'label'){

          this.__label.show();
        } else if(value === 'icon'){

          this.__label.exclude();
        };
      };
      if(this.__icon){

        if(value === 'both' || value === 'icon'){

          this.__icon.show();
        } else if(value === 'label'){

          this.__icon.exclude();
        };
      };
    },
    _applyGap : function(value, old){

      if(qx.core.Environment.get("qx.debug")){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, "The property 'gap' is deprecated. Please use SCSS variable $application-gap-size instead.");
      };
    },
    _applyLabel : function(value, old){

      if(this.__label){

        this.__label.setValue(value);
      } else {

        this.__label = this._createLabelWidget(value);
      };
    },
    _applyIcon : function(value, old){

      if(this.__icon){

        this.__icon.setSource(value);
      } else {

        this.__icon = this._createIconWidget(value);
      };
    },
    getIconWidget : function(){

      return this.__icon;
    },
    getLabelWidget : function(){

      return this.__label;
    },
    _createIconWidget : function(iconUrl){

      var iconWidget = new qx.ui.mobile.basic.Image(iconUrl);
      qx.bom.element.Style.set(iconWidget.getContentElement(), "display", "block");
      iconWidget.setAnonymous(true);
      iconWidget.addCssClass("gap");
      return iconWidget;
    },
    _createLabelWidget : function(label){

      var labelWidget = new qx.ui.mobile.basic.Label(label);
      labelWidget.setAnonymous(true);
      labelWidget.setWrap(false);
      labelWidget.addCssClass("gap");
      return labelWidget;
    },
    __createChildren : function(label, icon){

      this.__label = this._createLabelWidget(label);
      if(label){

        this.setLabel(label);
      };
      this.__icon = this._createIconWidget(icon);
      if(icon){

        this.setIcon(icon);
      } else {

        this.__icon.exclude();
      };
      var layout;
      var verticalLayout = ["top", "bottom"].indexOf(this.getIconPosition()) != -1;
      var hasNoLabel = !this.__label;
      if(verticalLayout || hasNoLabel){

        layout = new qx.ui.mobile.layout.VBox();
      } else {

        layout = new qx.ui.mobile.layout.HBox();
      };
      this.__childrenContainer = new qx.ui.mobile.container.Composite(layout);
      this.__childrenContainer.addCssClass("flex-center");
      this.__childrenContainer.setAnonymous(true);
      if(this.__icon){

        this.__childrenContainer.add(this.__icon);
      };
      if(this.__label){

        this.__label.addCssClass("flex-center");
        this.__childrenContainer.add(this.__label);
      };
      if(this.getShow() === 'icon' && this.__label){

        this.__label.exclude();
      };
      if(this.getShow() === 'label' && this.__icon){

        this.__icon.exclude();
      };
      this._add(this.__childrenContainer);
    }
  },
  destruct : function(){

    this._disposeObjects("__label", "__icon", "__childrenContainer");
  }
});

qx.Class.define("qx.ui.mobile.basic.Image", {
  extend : qx.ui.mobile.core.Widget,
  construct : function(source){

    this.base(arguments);
    if(qx.ui.mobile.basic.Image.ROOT === null){

      qx.ui.mobile.basic.Image.ROOT = qx.core.Init.getApplication().getRoot();
    };
    if(source){

      this.setSource(source);
    } else {

      this.initSource();
    };
    qx.ui.mobile.basic.Image.ROOT.addListener("changeAppScale", this._onChangeAppScale, this);
  },
  events : {
    loadingFailed : "qx.event.type.Event",
    loaded : "qx.event.type.Event"
  },
  statics : {
    PIXEL_RATIOS : null,
    ROOT : null,
    PLACEHOLDER_IMAGE : null
  },
  properties : {
    source : {
      check : "String",
      nullable : true,
      init : null,
      apply : "_applySource"
    }
  },
  members : {
    _getTagName : function(){

      return "img";
    },
    _applySource : function(value, old){

      var source = value;
      var resourceManager = qx.util.ResourceManager.getInstance();
      var uri = resourceManager.toUri(source);
      if(source && source.indexOf('data:') != 0){

        if(resourceManager.has(source) && this._findHighResolutionSource(source)){

          return;
        };
        var ImageLoader = qx.io.ImageLoader;
        if(!ImageLoader.isFailed(uri) && !ImageLoader.isLoaded(uri)){

          ImageLoader.load(uri, this.__loaderCallback, this);
        };
      };
      this._setSource(uri);
    },
    _onChangeAppScale : function(){

      this._applySource(this.getSource());
    },
    _findHighResolutionSource : function(lowResImgSrc){

      var pixelRatioCandidates = qx.ui.mobile.basic.Image.PIXEL_RATIOS;
      var factor = qx.ui.mobile.basic.Image.ROOT.getAppScale();
      if(factor <= 1){

        return false;
      };
      var i = pixelRatioCandidates.length;
      while(i > 0 && factor > pixelRatioCandidates[--i]){
      };
      var hiResImgSrc;
      for(var k = i;k >= 0;k--){

        hiResImgSrc = this._getHighResolutionSource(lowResImgSrc, pixelRatioCandidates[k]);
        if(hiResImgSrc){

          this._createHighResolutionOverlay(hiResImgSrc, lowResImgSrc);
          return true;
        };
      };
      for(var k = i + 1;k < pixelRatioCandidates.length;k++){

        hiResImgSrc = this._getHighResolutionSource(lowResImgSrc, pixelRatioCandidates[k]);
        if(hiResImgSrc){

          this._createHighResolutionOverlay(hiResImgSrc, lowResImgSrc);
          return true;
        };
      };
      return false;
    },
    _getHighResolutionSource : function(source, pixelRatio){

      var fileExtIndex = source.lastIndexOf('.');
      if(fileExtIndex > -1){

        var pixelRatioIdentifier = "@" + pixelRatio + "x";
        var candidate = source.slice(0, fileExtIndex) + pixelRatioIdentifier + source.slice(fileExtIndex);
        if(qx.util.ResourceManager.getInstance().has(candidate)){

          return candidate;
        };
      };
      return null;
    },
    _createHighResolutionOverlay : function(highResSource, lowResSource){

      this._setSource(qx.ui.mobile.basic.Image.PLACEHOLDER_IMAGE);
      var resourceManager = qx.util.ResourceManager.getInstance();
      this._setStyle("backgroundImage", "url(" + resourceManager.toUri(highResSource) + ")");
      this._setStyle("backgroundSize", "100%");
      this._setStyle("backgroundRepeat", "no-repeat");
      this._setStyle("backgroundPosition", "50% 50%");
      this._setStyle("width", resourceManager.getImageWidth(lowResSource) / 16 + "rem");
      this._setStyle("height", resourceManager.getImageHeight(lowResSource) / 16 + "rem");
    },
    __loaderCallback : function(source, imageInfo){

      if(this.$$disposed === true){

        return;
      };
      if(imageInfo.failed){

        this.warn("Image could not be loaded: " + source);
        this.fireEvent("loadingFailed");
      } else if(imageInfo.aborted){

        return;
      } else {

        this.fireEvent("loaded");
      };
      this._domUpdated();
    },
    _setSource : function(source){

      this._setAttribute("src", source);
    },
    setDraggable : function(isDraggable){

      if(isDraggable){

        this._setAttribute("draggable", "true");
      } else {

        this._setAttribute("draggable", "false");
      };
    }
  },
  defer : function(statics){

    statics.PIXEL_RATIOS = ["3", "2", "1.5"];
    statics.PLACEHOLDER_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
  },
  destruct : function(){

    qx.ui.mobile.basic.Image.ROOT.removeListener("changeAppScale", this._onChangeAppScale, this);
  }
});

qx.Class.define("qx.ui.mobile.basic.Label", {
  extend : qx.ui.mobile.core.Widget,
  construct : function(value){

    this.base(arguments);
    if(value){

      this.setValue(value);
    };
    this.initWrap();
    if(qx.core.Environment.get("qx.dynlocale")){

      qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
    };
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "label"
    },
    value : {
      nullable : true,
      init : null,
      check : "String",
      apply : "_applyValue",
      event : "changeValue"
    },
    anonymous : {
      refine : true,
      init : true
    },
    wrap : {
      check : "Boolean",
      init : true,
      apply : "_applyWrap"
    }
  },
  members : {
    _applyValue : function(value, old){

      this._setHtml(value);
    },
    _applyWrap : function(value, old){

      if(value){

        this.removeCssClass("no-wrap");
      } else {

        this.addCssClass("no-wrap");
      };
    },
    _onChangeLocale : qx.core.Environment.select("qx.dynlocale", {
      "true" : function(e){

        var content = this.getValue();
        if(content && content.translate){

          this.setValue(content.translate());
        };
      },
      "false" : null
    })
  },
  destruct : function(){

    if(qx.core.Environment.get("qx.dynlocale")){

      qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
    };
  }
});

qx.Class.define("qx.ui.mobile.form.Button", {
  extend : qx.ui.mobile.basic.Atom,
  properties : {
    defaultCssClass : {
      refine : true,
      init : "button"
    },
    activatable : {
      refine : true,
      init : true
    }
  },
  members : {
    setValue : function(value){

      this.setLabel(value);
    },
    getValue : function(){

      return this.getLabel();
    }
  }
});

qx.Class.define("qx.ui.mobile.navigationbar.Button", {
  extend : qx.ui.mobile.form.Button,
  properties : {
    defaultCssClass : {
      refine : true,
      init : "navigationbar-button"
    }
  }
});

qx.Class.define("qx.ui.mobile.container.Navigation", {
  extend : qx.ui.mobile.container.Composite,
  construct : function(){

    this.base(arguments, new qx.ui.mobile.layout.VBox());
    this.__navigationBar = this._createNavigationBar();
    if(this.__navigationBar){

      this._add(this.__navigationBar);
    };
    this.__content = this._createContent();
    this._add(this.__content, {
      flex : 1
    });
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "navigation"
    }
  },
  events : {
    "update" : "qx.event.type.Data"
  },
  members : {
    __navigationBar : null,
    __content : null,
    __layout : null,
    add : function(widget){

      if(qx.core.Environment.get("qx.debug")){

        this.assertInterface(widget, qx.ui.mobile.container.INavigation);
      };
      this.getContent().add(widget);
    },
    remove : function(widget){

      if(qx.core.Environment.get("qx.debug")){

        this.assertInterface(widget, qx.ui.mobile.container.INavigation);
      };
      this.getContent().remove(widget);
    },
    getContent : function(){

      return this.__content;
    },
    getLayout : function(){

      return this.__layout;
    },
    getNavigationBar : function(){

      return this.__navigationBar;
    },
    _createContent : function(){

      this.__layout = new qx.ui.mobile.layout.Card();
      this.__layout.addListener("updateLayout", this._onUpdateLayout, this);
      this.__layout.addListener("animationStart", this._onAnimationStart, this);
      this.__layout.addListener("animationEnd", this._onAnimationEnd, this);
      return new qx.ui.mobile.container.Composite(this.__layout);
    },
    _onAnimationStart : function(){

      this.addCssClass("blocked");
    },
    _onAnimationEnd : function(){

      this.removeCssClass("blocked");
    },
    _onUpdateLayout : function(evt){

      var data = evt.getData();
      var widget = data.widget;
      var action = data.action;
      if(action == "visible"){

        this._update(widget);
      };
    },
    _update : function(widget){

      var navigationBar = this.getNavigationBar();
      this._setStyle("transitionDuration", widget.getNavigationBarToggleDuration() + "s");
      if(widget.isNavigationBarHidden()){

        this.addCssClass("hidden");
      } else {

        navigationBar.show();
        this.removeCssClass("hidden");
      };
      navigationBar.removeAll();
      if(widget.basename){

        this._setAttribute("data-target-page", widget.basename.toLowerCase());
      };
      var leftContainer = widget.getLeftContainer();
      if(leftContainer){

        navigationBar.add(leftContainer);
      };
      var title = widget.getTitleWidget();
      if(title){

        navigationBar.add(title, {
          flex : 1
        });
      };
      var rightContainer = widget.getRightContainer();
      if(rightContainer){

        navigationBar.add(rightContainer);
      };
      this.fireDataEvent("update", widget);
    },
    _createNavigationBar : function(){

      return new qx.ui.mobile.navigationbar.NavigationBar();
    }
  },
  destruct : function(){

    this.getLayout().removeListener("animationStart", this._onAnimationStart, this);
    this.getLayout().removeListener("animationEnd", this._onAnimationEnd, this);
    this._disposeObjects("__navigationBar", "__content", "__layout");
    this.__navigationBar = this.__content = this.__layout = null;
  }
});

qx.Interface.define("qx.ui.mobile.container.INavigation", {
  members : {
    getTitleWidget : function(){
    },
    getLeftContainer : function(){
    },
    getRightContainer : function(){
    }
  }
});

qx.Class.define("qx.ui.mobile.layout.Card", {
  extend : qx.ui.mobile.layout.Abstract,
  construct : function(){

    this.base(arguments);
    this.__cardAnimation = new qx.ui.mobile.layout.CardAnimation();
  },
  events : {
    animationStart : "qx.event.type.Data",
    animationEnd : "qx.event.type.Data"
  },
  properties : {
    defaultAnimation : {
      check : "String",
      init : "slide"
    },
    showAnimation : {
      check : "Boolean",
      init : true
    },
    animationDuration : {
      check : "Integer",
      init : 350
    }
  },
  members : {
    __nextWidget : null,
    __currentWidget : null,
    __inAnimation : null,
    __animation : null,
    __reverse : null,
    __cardAnimation : null,
    _getCssClasses : function(){

      return ["layout-card", "vbox"];
    },
    connectToChildWidget : function(widget){

      this.base(arguments);
      if(widget){

        widget.addCssClass("layout-card-item");
        widget.addCssClass("flex1");
        widget.exclude();
      };
    },
    disconnectFromChildWidget : function(widget){

      this.base(arguments);
      widget.removeCssClass("layout-card-item");
    },
    updateLayout : function(widget, action, properties){

      if(action == "visible"){

        this._showWidget(widget, properties);
      };
      this.base(arguments, widget, action, properties);
    },
    setCardAnimation : function(value){

      this.__cardAnimation = value;
    },
    getCardAnimation : function(){

      return this.__cardAnimation;
    },
    _showWidget : function(widget, properties){

      if(this.__nextWidget == widget){

        return;
      };
      if(this.__inAnimation){

        this.__stopAnimation();
      };
      this.__nextWidget = widget;
      if(this.__currentWidget && this.getShowAnimation() && qx.core.Environment.get("css.transform.3d")){

        properties = properties || {
        };
        this.__animation = properties.animation || this.getDefaultAnimation();
        if(properties.action && properties.action === "back"){

          this.__reverse = true;
        } else {

          properties.reverse = properties.reverse === null ? false : properties.reverse;
          this.__reverse = properties.reverse;
        };
        qx.bom.AnimationFrame.request(function(){

          this.__startAnimation(widget);
        }, this);
      } else {

        this._swapWidget();
      };
    },
    _swapWidget : function(){

      if(this.__currentWidget){

        this.__currentWidget.removeCssClass("active");
        this.__currentWidget.exclude();
      };
      this.__currentWidget = this.__nextWidget;
      this.__currentWidget.addCssClass("active");
    },
    _fixWidgetSize : function(widget){

      if(widget){

        var hasResizeMixin = qx.Class.hasMixin(widget.constructor, qx.ui.mobile.core.MResize);
        if(hasResizeMixin){

          widget.fixSize();
        };
      };
    },
    _releaseWidgetSize : function(widget){

      if(widget){

        var hasResizeMixin = qx.Class.hasMixin(widget.constructor, qx.ui.mobile.core.MResize);
        if(hasResizeMixin){

          widget.releaseFixedSize();
        };
      };
    },
    __startAnimation : function(widget){

      if(widget.isDisposed()){

        return;
      };
      this.__inAnimation = true;
      this.fireDataEvent("animationStart", [this.__currentWidget, widget]);
      var fromElement = this.__currentWidget.getContainerElement();
      var toElement = widget.getContainerElement();
      var onAnimationEnd = qx.lang.Function.bind(this._onAnimationEnd, this);
      if(qx.core.Environment.get("browser.name") == "iemobile" || qx.core.Environment.get("browser.name") == "ie"){

        qx.bom.Event.addNativeListener(fromElement, "MSAnimationEnd", onAnimationEnd, false);
        qx.bom.Event.addNativeListener(toElement, "MSAnimationEnd", onAnimationEnd, false);
      } else {

        qx.event.Registration.addListener(fromElement, "animationEnd", this._onAnimationEnd, this);
        qx.event.Registration.addListener(toElement, "animationEnd", this._onAnimationEnd, this);
      };
      var fromCssClasses = this.__getAnimationClasses("out");
      var toCssClasses = this.__getAnimationClasses("in");
      this._widget.addCssClass("animationParent");
      var toElementAnimation = this.__cardAnimation.getAnimation(this.__animation, "in", this.__reverse);
      var fromElementAnimation = this.__cardAnimation.getAnimation(this.__animation, "out", this.__reverse);
      qx.bom.element.Class.addClasses(toElement, toCssClasses);
      qx.bom.element.Class.addClasses(fromElement, fromCssClasses);
      qx.bom.element.Animation.animate(toElement, toElementAnimation);
      qx.bom.element.Animation.animate(fromElement, fromElementAnimation);
    },
    _onAnimationEnd : function(evt){

      this.__stopAnimation();
      this.fireDataEvent("animationEnd", [this.__currentWidget, this.__nextWidget]);
    },
    __stopAnimation : function(){

      if(this.__inAnimation){

        var fromElement = this.__currentWidget.getContainerElement();
        var toElement = this.__nextWidget.getContainerElement();
        if(qx.core.Environment.get("browser.name") == "iemobile" || qx.core.Environment.get("browser.name") == "ie"){

          qx.bom.Event.removeNativeListener(fromElement, "MSAnimationEnd", this._onAnimationEnd, false);
          qx.bom.Event.removeNativeListener(toElement, "MSAnimationEnd", this._onAnimationEnd, false);
        } else {

          qx.event.Registration.removeListener(fromElement, "animationEnd", this._onAnimationEnd, this);
          qx.event.Registration.removeListener(toElement, "animationEnd", this._onAnimationEnd, this);
        };
        qx.bom.element.Class.removeClasses(fromElement, this.__getAnimationClasses("out"));
        qx.bom.element.Class.removeClasses(toElement, this.__getAnimationClasses("in"));
        this._swapWidget();
        this._widget.removeCssClass("animationParent");
        this.__inAnimation = false;
      };
    },
    __getAnimationClasses : function(direction){

      var classes = ["animationChild", this.__animation, direction];
      if(this.__reverse){

        classes.push("reverse");
      };
      return classes;
    }
  },
  destruct : function(){

    this._disposeObjects("__cardAnimation");
  }
});

qx.Class.define("qx.event.handler.Transition", {
  extend : qx.core.Object,
  implement : qx.event.IEventHandler,
  construct : function(manager){

    this.base(arguments);
    this.__registeredEvents = {
    };
    this.__onEventWrapper = qx.lang.Function.listener(this._onNative, this);
  },
  statics : {
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
    SUPPORTED_TYPES : {
      transitionEnd : 1,
      animationEnd : 1,
      animationStart : 1,
      animationIteration : 1
    },
    TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE,
    IGNORE_CAN_HANDLE : true,
    TYPE_TO_NATIVE : null,
    NATIVE_TO_TYPE : null
  },
  members : {
    __onEventWrapper : null,
    __registeredEvents : null,
    canHandleEvent : function(target, type){
    },
    registerEvent : qx.core.Environment.select("engine.name", {
      "webkit|gecko|mshtml" : function(target, type, capture){

        var hash = qx.core.ObjectRegistry.toHashCode(target) + type;
        var nativeType = qx.event.handler.Transition.TYPE_TO_NATIVE[type];
        this.__registeredEvents[hash] = {
          target : target,
          type : nativeType
        };
        qx.bom.Event.addNativeListener(target, nativeType, this.__onEventWrapper);
      },
      "default" : function(){
      }
    }),
    unregisterEvent : qx.core.Environment.select("engine.name", {
      "webkit|gecko|mshtml" : function(target, type, capture){

        var events = this.__registeredEvents;
        if(!events){

          return;
        };
        var hash = qx.core.ObjectRegistry.toHashCode(target) + type;
        if(events[hash]){

          delete events[hash];
        };
        qx.bom.Event.removeNativeListener(target, qx.event.handler.Transition.TYPE_TO_NATIVE[type], this.__onEventWrapper);
      },
      "default" : function(){
      }
    }),
    _onNative : qx.event.GlobalError.observeMethod(function(nativeEvent){

      qx.event.Registration.fireEvent(nativeEvent.target, qx.event.handler.Transition.NATIVE_TO_TYPE[nativeEvent.type], qx.event.type.Event);
    })
  },
  destruct : function(){

    var event;
    var events = this.__registeredEvents;
    for(var id in events){

      event = events[id];
      if(event.target){

        qx.bom.Event.removeNativeListener(event.target, event.type, this.__onEventWrapper);
      };
    };
    this.__registeredEvents = this.__onEventWrapper = null;
  },
  defer : function(statics){

    var aniEnv = qx.core.Environment.get("css.animation") || {
    };
    var transEnv = qx.core.Environment.get("css.transition") || {
    };
    var n2t = qx.event.handler.Transition.NATIVE_TO_TYPE = {
    };
    var t2n = qx.event.handler.Transition.TYPE_TO_NATIVE = {
      transitionEnd : transEnv["end-event"] || null,
      animationStart : aniEnv["start-event"] || null,
      animationEnd : aniEnv["end-event"] || null,
      animationIteration : aniEnv["iteration-event"] || null
    };
    for(var type in t2n){

      var nate = t2n[type];
      n2t[nate] = type;
    };
    qx.event.Registration.addHandler(statics);
  }
});

qx.Class.define("qx.ui.mobile.layout.CardAnimation", {
  extend : qx.core.Object,
  construct : function(){

    this.base(arguments);
    this._cardAnimationsMap = {
      "slide" : {
        "in" : qx.util.Animation.SLIDE_LEFT_IN,
        "out" : qx.util.Animation.SLIDE_LEFT_OUT,
        "reverse" : {
          "in" : qx.util.Animation.SLIDE_RIGHT_IN,
          "out" : qx.util.Animation.SLIDE_RIGHT_OUT
        }
      },
      "fade" : {
        "in" : qx.util.Animation.FADE_IN,
        "out" : qx.util.Animation.FADE_OUT,
        "reverse" : {
          "in" : qx.util.Animation.FADE_IN,
          "out" : qx.util.Animation.FADE_OUT
        }
      },
      "pop" : {
        "in" : qx.util.Animation.POP_IN,
        "out" : qx.util.Animation.POP_OUT,
        "reverse" : {
          "in" : qx.util.Animation.POP_IN,
          "out" : qx.util.Animation.POP_OUT
        }
      },
      "slideup" : {
        "in" : qx.util.Animation.SLIDE_UP_IN,
        "out" : qx.util.Animation.SLIDE_UP_OUT,
        "reverse" : {
          "in" : qx.util.Animation.SLIDE_DOWN_IN,
          "out" : qx.util.Animation.SLIDE_DOWN_OUT
        }
      },
      "flip" : {
        "in" : qx.util.Animation.FLIP_LEFT_IN,
        "out" : qx.util.Animation.FLIP_LEFT_OUT,
        "reverse" : {
          "in" : qx.util.Animation.FLIP_RIGHT_IN,
          "out" : qx.util.Animation.FLIP_RIGHT_OUT
        }
      },
      "swap" : {
        "in" : qx.util.Animation.SWAP_LEFT_IN,
        "out" : qx.util.Animation.SWAP_LEFT_OUT,
        "reverse" : {
          "in" : qx.util.Animation.SWAP_RIGHT_IN,
          "out" : qx.util.Animation.SWAP_RIGHT_OUT
        }
      },
      "cube" : {
        "in" : qx.util.Animation.CUBE_LEFT_IN,
        "out" : qx.util.Animation.CUBE_LEFT_OUT,
        "reverse" : {
          "in" : qx.util.Animation.CUBE_RIGHT_IN,
          "out" : qx.util.Animation.CUBE_RIGHT_OUT
        }
      }
    };
  },
  members : {
    _cardAnimationsMap : null,
    getAnimation : function(animationName, direction, reverse){

      if(qx.core.Environment.get("qx.debug")){

        if(!reverse){

          this.assertNotUndefined(this._cardAnimationsMap[animationName], "Animation '" + animationName + "' is not defined.");
          this.assertNotUndefined(this._cardAnimationsMap[animationName][direction], "Animation '" + animationName + " " + direction + "' is not defined.");
        } else {

          this.assertNotUndefined(this._cardAnimationsMap[animationName], "Animation Reverse'" + animationName + "' is not defined.");
          this.assertNotUndefined(this._cardAnimationsMap[animationName]["reverse"], "Animation Reverse'" + animationName + "' is not defined.");
          this.assertNotUndefined(this._cardAnimationsMap[animationName]["reverse"][direction], "Animation Reverse'" + animationName + " " + direction + "' is not defined.");
        };
      };
      var animation = this._cardAnimationsMap[animationName];
      var animationObject = {
      };
      if(!reverse){

        animationObject = animation[direction];
      } else {

        animationObject = animation["reverse"][direction];
      };
      return animationObject;
    },
    getMap : function(){

      return this._cardAnimationsMap;
    }
  },
  destruct : function(){

    this._cardAnimationsMap = null;
  }
});

qx.Bootstrap.define("qx.util.Animation", {
  statics : {
    SLIDE_LEFT_IN : {
      duration : 350,
      timing : "linear",
      origin : "bottom center",
      keyFrames : {
        '0' : {
          translate : ["100%"]
        },
        '100' : {
          translate : ["0%"]
        }
      }
    },
    SLIDE_LEFT_OUT : {
      duration : 350,
      timing : "linear",
      origin : "bottom center",
      keyFrames : {
        '0' : {
          translate : ["0px"]
        },
        '100' : {
          translate : ["-100%"]
        }
      }
    },
    SLIDE_RIGHT_IN : {
      duration : 350,
      timing : "linear",
      origin : "bottom center",
      keyFrames : {
        '0' : {
          translate : ["-100%"]
        },
        '100' : {
          translate : ["0%"]
        }
      }
    },
    SLIDE_RIGHT_OUT : {
      duration : 350,
      timing : "linear",
      origin : "bottom center",
      keyFrames : {
        '0' : {
          translate : ["0px"]
        },
        '100' : {
          translate : ["100%"]
        }
      }
    },
    FADE_IN : {
      duration : 350,
      timing : "linear",
      origin : "bottom center",
      keyFrames : {
        '0' : {
          opacity : ["0"]
        },
        '100' : {
          opacity : ["1"]
        }
      }
    },
    FADE_OUT : {
      duration : 350,
      timing : "linear",
      origin : "bottom center",
      keyFrames : {
        '0' : {
          opacity : ["1"]
        },
        '100' : {
          opacity : ["0"]
        }
      }
    },
    POP_IN : {
      duration : 350,
      timing : "linear",
      origin : "center",
      keyFrames : {
        '0' : {
          scale : [".2", ".2"]
        },
        '100' : {
          scale : ["1", "1"]
        }
      }
    },
    POP_OUT : {
      duration : 350,
      timing : "linear",
      origin : "center",
      keyFrames : {
        '0' : {
          scale : ["1", "1"]
        },
        '100' : {
          scale : [".2", ".2"]
        }
      }
    },
    SHRINK_HEIGHT : {
      duration : 400,
      timing : "linear",
      origin : "top center",
      keep : 100,
      keyFrames : {
        '0' : {
          scale : ["1", "1"],
          opacity : 1
        },
        '100' : {
          scale : ["1", "0"],
          opacity : 0
        }
      }
    },
    GROW_HEIGHT : {
      duration : 400,
      timing : "linear",
      origin : "top center",
      keep : 100,
      keyFrames : {
        '0' : {
          scale : ["1", "0"],
          opacity : 0
        },
        '100' : {
          scale : ["1", "1"],
          opacity : 1
        }
      }
    },
    SHRINK_WIDTH : {
      duration : 400,
      timing : "linear",
      origin : "left center",
      keep : 100,
      keyFrames : {
        '0' : {
          scale : ["1", "1"],
          opacity : 1
        },
        '100' : {
          scale : ["0", "1"],
          opacity : 0
        }
      }
    },
    GROW_WIDTH : {
      duration : 400,
      timing : "linear",
      origin : "left center",
      keep : 100,
      keyFrames : {
        '0' : {
          scale : ["0", "1"],
          opacity : 0
        },
        '100' : {
          scale : ["1", "1"],
          opacity : 1
        }
      }
    },
    SHRINK : {
      duration : 400,
      timing : "linear",
      origin : "left top",
      keep : 100,
      keyFrames : {
        '0' : {
          scale : ["1", "1"],
          opacity : 1
        },
        '100' : {
          scale : ["0", "0"],
          opacity : 0
        }
      }
    },
    GROW : {
      duration : 400,
      timing : "linear",
      origin : "left top",
      keep : 100,
      keyFrames : {
        '0' : {
          scale : ["0", "0"],
          opacity : 0
        },
        '100' : {
          scale : ["1", "1"],
          opacity : 1
        }
      }
    },
    SLIDE_UP_IN : {
      duration : 350,
      timing : "linear",
      origin : "center",
      keyFrames : {
        '0' : {
          translate : ["0px", "100%"]
        },
        '100' : {
          translate : ["0px", "0px"]
        }
      }
    },
    SLIDE_UP_OUT : {
      duration : 350,
      timing : "linear",
      origin : "center",
      keyFrames : {
        '0' : {
          translate : ["0px", "0px"]
        },
        '100' : {
          translate : ["0px", "0px"]
        }
      }
    },
    SLIDE_DOWN_IN : {
      duration : 350,
      timing : "linear",
      origin : "center",
      keyFrames : {
        '0' : {
          translate : ["0px", "0px"]
        },
        '100' : {
          translate : ["0px", "0px"]
        }
      }
    },
    SLIDE_DOWN_OUT : {
      duration : 350,
      timing : "linear",
      origin : "center",
      keyFrames : {
        '0' : {
          translate : ["0px", "0px"]
        },
        '100' : {
          translate : ["0px", "100%"]
        }
      }
    },
    FLIP_LEFT_IN : {
      duration : 350,
      timing : "linear",
      origin : "center",
      keyFrames : {
        '0' : {
          opacity : 0
        },
        '49' : {
          opacity : 0
        },
        '50' : {
          rotate : ["0deg", "90deg"],
          scale : [".8", "1"],
          opacity : 1
        },
        '100' : {
          rotate : ["0deg", "0deg"],
          scale : ["1", "1"],
          opacity : 1
        }
      }
    },
    FLIP_LEFT_OUT : {
      duration : 350,
      timing : "linear",
      origin : "center center",
      keyFrames : {
        '0' : {
          rotate : ["0deg", "0deg"],
          scale : ["1", "1"]
        },
        '100' : {
          rotate : ["0deg", "-180deg"],
          scale : [".8", "1"]
        }
      }
    },
    FLIP_RIGHT_IN : {
      duration : 350,
      timing : "linear",
      origin : "center center",
      keyFrames : {
        '0' : {
          opacity : 0
        },
        '49' : {
          opacity : 0
        },
        '50' : {
          rotate : ["0deg", "-90deg"],
          scale : [".8", "1"],
          opacity : 1
        },
        '100' : {
          rotate : ["0deg", "0deg"],
          scale : ["1", "1"],
          opacity : 1
        }
      }
    },
    FLIP_RIGHT_OUT : {
      duration : 350,
      timing : "linear",
      origin : "center center",
      keyFrames : {
        '0' : {
          rotate : ["0deg", "0deg"],
          scale : ["1", "1"]
        },
        '100' : {
          rotate : ["0deg", "180deg"],
          scale : [".8", "1"]
        }
      }
    },
    SWAP_LEFT_IN : {
      duration : 700,
      timing : "ease-out",
      origin : "center center",
      keyFrames : {
        '0' : {
          rotate : ["0deg", "-70deg"],
          translate : ["0px", "0px", "-800px"],
          opacity : "0"
        },
        '35' : {
          rotate : ["0deg", "-20deg"],
          translate : ["-180px", "0px", "-400px"],
          opacity : "1"
        },
        '100' : {
          rotate : ["0deg", "0deg"],
          translate : ["0px", "0px", "0px"],
          opacity : "1"
        }
      }
    },
    SWAP_LEFT_OUT : {
      duration : 700,
      timing : "ease-out",
      origin : "center center",
      keyFrames : {
        '0' : {
          rotate : ["0deg", "0deg"],
          translate : ["0px", "0px", "0px"],
          opacity : "1"
        },
        '35' : {
          rotate : ["0deg", "20deg"],
          translate : ["-180px", "0px", "-400px"],
          opacity : ".5"
        },
        '100' : {
          rotate : ["0deg", "70deg"],
          translate : ["0px", "0px", "-800px"],
          opacity : "0"
        }
      }
    },
    SWAP_RIGHT_IN : {
      duration : 700,
      timing : "ease-out",
      origin : "center center",
      keyFrames : {
        '0' : {
          rotate : ["0deg", "70deg"],
          translate : ["0px", "0px", "-800px"],
          opacity : "0"
        },
        '35' : {
          rotate : ["0deg", "20deg"],
          translate : ["-180px", "0px", "-400px"],
          opacity : "1"
        },
        '100' : {
          rotate : ["0deg", "0deg"],
          translate : ["0px", "0px", "0px"],
          opacity : "1"
        }
      }
    },
    SWAP_RIGHT_OUT : {
      duration : 700,
      timing : "ease-out",
      origin : "center center",
      keyFrames : {
        '0' : {
          rotate : ["0deg", "0deg"],
          translate : ["0px", "0px", "0px"],
          opacity : "1"
        },
        '35' : {
          rotate : ["0deg", "-20deg"],
          translate : ["180px", "0px", "-400px"],
          opacity : ".5"
        },
        '100' : {
          rotate : ["0deg", "-70deg"],
          translate : ["0px", "0px", "-800px"],
          opacity : "0"
        }
      }
    },
    CUBE_LEFT_IN : {
      duration : 550,
      timing : "linear",
      origin : "100% 50%",
      keyFrames : {
        '0' : {
          rotate : ["0deg", "90deg"],
          scale : ".5",
          translate : ["0", "0", "0px"],
          opacity : [".5"]
        },
        '100' : {
          rotate : ["0deg", "0deg"],
          scale : "1",
          translate : ["0", "0", "0"],
          opacity : ["1"]
        }
      }
    },
    CUBE_LEFT_OUT : {
      duration : 550,
      timing : "linear",
      origin : "0% 50%",
      keyFrames : {
        '0' : {
          rotate : ["0deg", "0deg"],
          scale : "1",
          translate : ["0", "0", "0px"],
          opacity : ["1"]
        },
        '100' : {
          rotate : ["0deg", "-90deg"],
          scale : ".5",
          translate : ["0", "0", "0"],
          opacity : [".5"]
        }
      }
    },
    CUBE_RIGHT_IN : {
      duration : 550,
      timing : "linear",
      origin : "0% 50%",
      keyFrames : {
        '0' : {
          rotate : ["0deg", "-90deg"],
          scale : ".5",
          translate : ["0", "0", "0px"],
          opacity : [".5"]
        },
        '100' : {
          rotate : ["0deg", "0deg"],
          scale : "1",
          translate : ["0", "0", "0"],
          opacity : ["1"]
        }
      }
    },
    CUBE_RIGHT_OUT : {
      duration : 550,
      timing : "linear",
      origin : "100% 50%",
      keyFrames : {
        '0' : {
          rotate : ["0deg", "0deg"],
          scale : "1",
          translate : ["0", "0", "0px"],
          opacity : ["1"]
        },
        '100' : {
          rotate : ["0deg", "90deg"],
          scale : ".5",
          translate : ["0", "0", "0"],
          opacity : [".5"]
        }
      }
    }
  }
});

qx.Mixin.define("qx.ui.mobile.core.MResize", {
  properties : {
    fireDomUpdatedOnResize : {
      check : "Boolean",
      init : false
    }
  },
  members : {
    __lastHeight : null,
    __lastWidth : null,
    releaseFixedSize : function(){

      var parent = this.getLayoutParent();
      if(parent && parent.getContainerElement()){

        var element = this.getContainerElement();
        qx.bom.element.Style.set(element, "height", "auto");
        qx.bom.element.Style.set(element, "width", "auto");
      };
    },
    fixSize : function(){

      var parent = this.getLayoutParent();
      if(parent && parent.getContainerElement()){

        var height = parent.getContainerElement().offsetHeight;
        var width = parent.getContainerElement().offsetWidth;
        if(height === 0 || width === 0){

          return;
        };
        if(!this.getFireDomUpdatedOnResize()){

          this._setHeight(height);
          this._setWidth(width);
        } else if(this.__lastHeight != height && this.__lastWidth != width){

          this._setHeight(height);
          this._setWidth(width);
          this.__lastWidth = width;
          this.__lastHeight = height;
          this._domUpdated();
        };
      };
    },
    _setHeight : function(height){

      var element = this.getContainerElement();
      if(qx.core.Environment.get("qx.mobile.nativescroll")){

        qx.bom.element.Style.set(element, "minHeight", height + "px");
      } else {

        qx.bom.element.Style.set(element, "height", height + "px");
      };
    },
    _setWidth : function(width){

      var element = this.getContainerElement();
      if(qx.core.Environment.get("qx.mobile.nativescroll")){

        qx.bom.element.Style.set(element, "minWidth", width + "px");
      } else {

        qx.bom.element.Style.set(element, "width", width + "px");
      };
    }
  }
});

qx.Class.define("qx.ui.mobile.navigationbar.NavigationBar", {
  extend : qx.ui.mobile.container.Composite,
  construct : function(layout){

    this.base(arguments, layout);
    if(!layout){

      this.setLayout(new qx.ui.mobile.layout.HBox().set({
        alignY : "middle"
      }));
    };
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "navigationbar"
    }
  }
});

qx.Bootstrap.define("qx.bom.client.PhoneGap", {
  statics : {
    getPhoneGap : function(){

      return ("cordova" in window || "Cordova" in window || "PhoneGap" in window);
    },
    getNotification : function(){

      return "notification" in navigator;
    }
  },
  defer : function(statics){

    qx.core.Environment.add("phonegap", statics.getPhoneGap);
    qx.core.Environment.add("phonegap.notification", statics.getNotification);
  }
});

qx.Class.define("qx.ui.mobile.page.Page", {
  extend : qx.ui.mobile.container.Composite,
  include : qx.ui.mobile.core.MResize,
  construct : function(layout){

    this.base(arguments, layout || new qx.ui.mobile.layout.VBox());
  },
  statics : {
    _currentPage : null,
    _onDeviceReady : function(){

      qx.bom.Event.addNativeListener(document, "backbutton", qx.ui.mobile.page.Page._onBackButton);
      qx.bom.Event.addNativeListener(document, "menubutton", qx.ui.mobile.page.Page._onMenuButton);
    },
    _onBackButton : function(){

      if(qx.core.Environment.get("phonegap") && qx.core.Environment.get("os.name") == "android"){

        var exit = true;
        if(qx.ui.mobile.page.Page._currentPage){

          exit = qx.ui.mobile.page.Page._currentPage.back(true);
        };
        if(exit){

          navigator.app.exitApp();
        };
      };
    },
    _onMenuButton : function(){

      if(qx.core.Environment.get("phonegap") && qx.core.Environment.get("os.name") == "android"){

        if(qx.ui.mobile.page.Page._currentPage){

          qx.ui.mobile.page.Page._currentPage.menu();
        };
      };
    }
  },
  events : {
    "initialize" : "qx.event.type.Event",
    "start" : "qx.event.type.Event",
    "stop" : "qx.event.type.Event",
    "pause" : "qx.event.type.Event",
    "resume" : "qx.event.type.Event",
    "back" : "qx.event.type.Data",
    "menu" : "qx.event.type.Event",
    "wait" : "qx.event.type.Event"
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "page"
    },
    lifeCycleState : {
      init : null,
      check : ["initialize", "start", "stop", "resume", "wait", "pause"],
      apply : "_applyLifeCycleState"
    }
  },
  members : {
    __initialized : false,
    show : function(properties){

      if(qx.ui.mobile.page.Page._currentPage){

        qx.ui.mobile.page.Page._currentPage.stop();
      };
      qx.ui.mobile.page.Page._currentPage = this;
      this.initialize();
      this.start();
      this.base(arguments, properties);
    },
    exclude : function(properties){

      this.stop();
      this.base(arguments, properties);
    },
    back : function(triggeredByKeyEvent){

      qx.core.Init.getApplication().fireDataEvent("back", triggeredByKeyEvent);
      this.fireDataEvent("back", triggeredByKeyEvent);
      var value = this._back(triggeredByKeyEvent);
      return value || false;
    },
    _back : function(triggeredByKeyEvent){
    },
    menu : function(){

      this.fireEvent("menu");
    },
    initialize : function(){

      if(!this.isInitialized()){

        this._initialize();
        this.__initialized = true;
        this.setLifeCycleState("initialize");
      };
    },
    _initialize : function(){
    },
    isInitialized : function(){

      return this.__initialized;
    },
    start : function(){

      this._start();
      this.setLifeCycleState("start");
    },
    _start : function(){
    },
    stop : function(){

      if(!this.isInitialized()){

        return;
      };
      this._stop();
      this.setLifeCycleState("stop");
    },
    _stop : function(){
    },
    pause : function(){

      this._pause();
      this.setLifeCycleState("pause");
    },
    _pause : function(){
    },
    resume : function(){

      this._resume();
      this.setLifeCycleState("resume");
    },
    _resume : function(){
    },
    wait : function(){

      this._wait();
      this.setLifeCycleState("wait");
    },
    _wait : function(){
    },
    _applyLifeCycleState : function(value, old){

      if(value == "start" || value == "stop"){

        qx.core.Init.getApplication().fireEvent(value);
      };
      this.fireEvent(value);
    }
  },
  defer : function(statics){

    if(qx.core.Environment.get("phonegap") && qx.core.Environment.get("os.name") == "android"){

      qx.bom.Event.addNativeListener(document, "deviceready", statics._onDeviceReady);
    };
  }
});

qx.Class.define("qx.ui.mobile.page.NavigationPage", {
  extend : qx.ui.mobile.page.Page,
  implement : qx.ui.mobile.container.INavigation,
  construct : function(wrapContentByGroup, layout){

    this.base(arguments);
    if(wrapContentByGroup != null){

      this._wrapContentByGroup = wrapContentByGroup;
    };
  },
  events : {
    action : "qx.event.type.Event"
  },
  properties : {
    title : {
      check : "String",
      init : "",
      event : "changeTitle",
      apply : "_applyTitle"
    },
    backButtonText : {
      check : "String",
      init : "",
      apply : "_applyBackButtonText"
    },
    buttonText : {
      check : "String",
      init : "",
      apply : "_applyActionButtonText"
    },
    buttonIcon : {
      check : "String",
      init : null,
      nullable : true,
      apply : "_applyActionButtonIcon"
    },
    showBackButton : {
      check : "Boolean",
      init : false,
      apply : "_applyShowBackButton"
    },
    showBackButtonOnTablet : {
      check : "Boolean",
      init : false
    },
    showButton : {
      check : "Boolean",
      init : false,
      apply : "_applyShowButton"
    },
    navigationBarHidden : {
      check : "Boolean",
      init : false
    },
    navigationBarToggleDuration : {
      check : "Number",
      init : 0.8
    },
    contentCssClass : {
      check : "String",
      init : "content",
      nullable : true,
      apply : "_applyContentCssClass"
    }
  },
  members : {
    _isTablet : false,
    _wrapContentByGroup : true,
    __backButton : null,
    __actionButton : null,
    __content : null,
    __scrollContainer : null,
    __title : null,
    __leftContainer : null,
    __rightContainer : null,
    getTitleWidget : function(){

      if(!this.__title){

        this.__title = this._createTitleWidget();
      };
      return this.__title;
    },
    _createTitleWidget : function(){

      return new qx.ui.mobile.navigationbar.Title(this.getTitle());
    },
    _applyTitle : function(value, old){

      if(this.__title){

        this.__title.setValue(value);
      };
    },
    getLeftContainer : function(){

      if(!this.__leftContainer){

        this.__leftContainer = this._createLeftContainer();
      };
      return this.__leftContainer;
    },
    getRightContainer : function(){

      if(!this.__rightContainer){

        this.__rightContainer = this._createRightContainer();
      };
      return this.__rightContainer;
    },
    _createLeftContainer : function(){

      var layout = new qx.ui.mobile.layout.HBox();
      var container = new qx.ui.mobile.container.Composite(layout);
      container.addCssClass("left-container");
      this.__backButton = this._createBackButton();
      this.__backButton.addListener("tap", this._onBackButtonTap, this);
      this._showBackButton();
      container.add(this.__backButton);
      return container;
    },
    _createRightContainer : function(){

      var layout = new qx.ui.mobile.layout.HBox();
      var container = new qx.ui.mobile.container.Composite(layout);
      container.addCssClass("right-container");
      this.__actionButton = this._createButton();
      this.__actionButton.addListener("tap", this._onButtonTap, this);
      this._showButton();
      container.add(this.__actionButton);
      return container;
    },
    _createBackButton : function(){

      return new qx.ui.mobile.navigationbar.BackButton(this.getBackButtonText());
    },
    _createButton : function(){

      return new qx.ui.mobile.navigationbar.Button(this.getButtonText(), this.getButtonIcon());
    },
    scrollTo : function(x, y, time){

      if(qx.core.Environment.get("qx.debug")){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, "The method 'scrollTo()' was moved to 'qx.ui.mobile.container.Scroll'.");
      };
      this.__scrollContainer.scrollTo(x, y, time);
    },
    scrollToWidget : function(widget, time){

      if(qx.core.Environment.get("qx.debug")){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, "The method 'scrollToWidget()' was moved to 'qx.ui.mobile.container.Scroll'.");
      };
      if(widget){

        this.__scrollContainer.scrollToElement(widget.getId(), time);
      };
    },
    getContent : function(){

      return this.__content;
    },
    _getBackButton : function(){

      return this.__backButton;
    },
    _getButton : function(){

      return this.__actionButton;
    },
    setIsTablet : function(isTablet){

      this._isTablet = isTablet;
    },
    isTablet : function(){

      return this._isTablet;
    },
    _getScrollContainer : function(){

      return this.__scrollContainer;
    },
    addAfterNavigationBar : function(widget){

      if(widget && this.__scrollContainer){

        this.addBefore(widget, this.__scrollContainer);
      };
    },
    _applyBackButtonText : function(value, old){

      if(this.__backButton){

        this.__backButton.setValue(value);
      };
    },
    _applyActionButtonText : function(value, old){

      if(this.__actionButton){

        this.__actionButton.setValue(value);
      };
    },
    _applyActionButtonIcon : function(value, old){

      if(this.__actionButton){

        this.__actionButton.setIcon(value);
      };
    },
    _applyShowBackButton : function(value, old){

      this._showBackButton();
    },
    _applyShowButton : function(value, old){

      this._showButton();
    },
    _applyContentCssClass : function(value, old){

      if(this.__content){

        this.__content.setDefaultCssClass(value);
      };
    },
    _showBackButton : function(){

      if(this.__backButton){

        if(this.getShowBackButton()){

          this.__backButton.show();
        } else {

          this.__backButton.exclude();
        };
      };
    },
    _showButton : function(){

      if(this.__actionButton){

        if(this.getShowButton()){

          this.__actionButton.show();
        } else {

          this.__actionButton.exclude();
        };
      };
    },
    _initialize : function(){

      this.base(arguments);
      this.__scrollContainer = this._createScrollContainer();
      this.__content = this._createContent();
      if(this.__content){

        this.__scrollContainer.add(this.__content, {
          flex : 1
        });
      };
      if(this.__scrollContainer){

        this.add(this.__scrollContainer, {
          flex : 1
        });
      };
    },
    _createScrollContainer : function(){

      return new qx.ui.mobile.container.Scroll();
    },
    _createContent : function(){

      var content = new qx.ui.mobile.container.Composite();
      content.setDefaultCssClass(this.getContentCssClass());
      if(this._wrapContentByGroup == true){

        content.addCssClass("group");
      };
      return content;
    },
    _onBackButtonTap : function(evt){

      this.back();
    },
    _onButtonTap : function(evt){

      this.fireEvent("action");
    }
  },
  destruct : function(){

    this._disposeObjects("__leftContainer", "__rightContainer", "__backButton", "__actionButton", "__title");
    this.__leftContainer = this.__rightContainer = this.__backButton = this.__actionButton = null;
    this.__title = this.__content = this.__scrollContainer = null;
    this._isTablet = null;
  }
});

qx.Class.define("qx.ui.mobile.navigationbar.Title", {
  extend : qx.ui.mobile.basic.Label,
  properties : {
    wrap : {
      refine : true,
      init : false
    },
    defaultCssClass : {
      refine : true,
      init : "title"
    }
  },
  members : {
    _getTagName : function(){

      return "h1";
    }
  }
});

qx.Class.define("qx.ui.mobile.navigationbar.BackButton", {
  extend : qx.ui.mobile.navigationbar.Button,
  properties : {
    defaultCssClass : {
      refine : true,
      init : "navigationbar-backbutton"
    }
  }
});

qx.Mixin.define("qx.ui.mobile.container.MIScroll", {
  construct : function(){

    this.__initScroll();
    this.__registerEventListeners();
    this.__currentX = this.__currentY = 0;
  },
  members : {
    __scroll : null,
    __currentX : null,
    __currentY : null,
    _createScrollElement : function(){

      var scroll = qx.dom.Element.create("div");
      qx.bom.element.Class.add(scroll, "iscroll");
      return scroll;
    },
    _getScrollContentElement : function(){

      return this.getContainerElement().childNodes[0];
    },
    _getPosition : function(){

      return [this.__currentX, this.__currentY];
    },
    _scrollTo : function(x, y, time){

      if(this.__scroll && this._isScrollable()){

        var lowerLimitY = qx.bom.element.Dimension.getHeight(this._getScrollContentElement()) - this.getContainerElement().offsetHeight;
        if(y > lowerLimitY){

          y = lowerLimitY;
        };
        var lowerLimitX = qx.bom.element.Dimension.getWidth(this._getScrollContentElement()) - this.getContainerElement().offsetWidth;
        if(x > lowerLimitX){

          x = lowerLimitX;
        };
        this.__scroll.scrollTo(-x, -y, time);
      };
    },
    __initScroll : function(){

      if(!window.iScroll){

        if(qx.core.Environment.get("qx.debug")){

          var resource = "qx/mobile/js/iscroll.js";
        } else {

          var resource = "qx/mobile/js/iscroll.min.js";
        };
        var path = qx.util.ResourceManager.getInstance().toUri(resource);
        if(qx.core.Environment.get("qx.debug")){

          path += "?" + new Date().getTime();
        };
        var loader = new qx.bom.request.Script();
        loader.on("load", this.__onScrollLoaded, this);
        loader.open("GET", path);
        loader.send();
      } else {

        this.addListenerOnce("appear", function(){

          this._setScroll(this.__createScrollInstance());
        }, this);
      };
    },
    __createScrollInstance : function(){

      var defaultScrollProperties = this._getDefaultScrollProperties();
      var customScrollProperties = {
      };
      if(this._scrollProperties != null){

        customScrollProperties = this._scrollProperties;
      };
      var iScrollProperties = qx.lang.Object.mergeWith(defaultScrollProperties, customScrollProperties, true);
      return new iScroll(this.getContainerElement(), iScrollProperties);
    },
    _getDefaultScrollProperties : function(){

      var container = this;
      return {
        hideScrollbar : true,
        fadeScrollbar : true,
        hScrollbar : false,
        scrollbarClass : "scrollbar",
        useTransform : true,
        onScrollEnd : function(){

          if(qx.core.Environment.get("qx.mobile.nativescroll") == false){

            container.__currentX = -this.x;
            container.__currentY = -this.y;
            if(this.y == this.maxScrollY){

              container.fireEvent("pageEnd");
            };
          };
        },
        onScrollMove : function(){

          if(qx.core.Environment.get("qx.mobile.nativescroll") == false){

            if(this.y == this.maxScrollY){

              container.fireEvent("pageEnd");
            };
          };
        },
        onBeforeScrollStart : function(e){

          var target = e.target;
          while(target.nodeType != 1){

            target = target.parentNode;
          };
          if(target.tagName != 'SELECT' && target.tagName != 'INPUT' && target.tagName != 'TEXTAREA' && target.tagName != 'LABEL'){

            var elements = [];
            var inputElements = qx.lang.Array.cast(document.getElementsByTagName("input"), Array);
            var textAreaElements = qx.lang.Array.cast(document.getElementsByTagName("textarea"), Array);
            elements = elements.concat(inputElements);
            elements = elements.concat(textAreaElements);
            for(var i = 0,length = elements.length;i < length;i++){

              elements[i].blur();
            };
            e.preventDefault();
          };
          if(qx.core.Environment.get("qx.mobile.nativescroll") == false){

            var iScrollStartEvent = new qx.event.message.Message('iscrollstart');
            qx.event.message.Bus.getInstance().dispatch(iScrollStartEvent);
          };
        }
      };
    },
    __registerEventListeners : function(){

      qx.event.Registration.addListener(window, "orientationchange", this._refresh, this);
      qx.event.Registration.addListener(window, "resize", this._refresh, this);
      this.addListener("touchmove", qx.bom.Event.stopPropagation);
      this.addListener("domupdated", this._refresh, this);
    },
    __unregisterEventListeners : function(){

      qx.event.Registration.removeListener(window, "orientationchange", this._refresh, this);
      qx.event.Registration.removeListener(window, "resize", this._refresh, this);
      this.removeListener("touchmove", qx.bom.Event.stopPropagation);
      this.removeListener("domupdated", this._refresh, this);
    },
    __onScrollLoaded : function(request){

      if(request.status < 400){

        if(!this.isDisposed()){

          this._setScroll(this.__createScrollInstance());
        };
      } else {

        if(qx.core.Environment.get("qx.debug")){

          this.error("Could not load iScroll");
        };
      };
    },
    _setScroll : function(scroll){

      this.__scroll = scroll;
    },
    disable : function(){

      if(this.__scroll){

        this.__scroll.disable();
      };
    },
    enable : function(){

      if(this.__scroll){

        this.__scroll.enable();
      };
    },
    _refresh : function(){

      if(this.__scroll){

        this.__scroll.refresh();
      };
    }
  },
  destruct : function(){

    this.__unregisterEventListeners();
    if(this.__scroll){

      this.__scroll.destroy();
    };
    this.__scroll = null;
  }
});

qx.Bootstrap.define("qx.bom.request.Script", {
  construct : function(){

    this.__initXhrProperties();
    this.__onNativeLoadBound = qx.Bootstrap.bind(this._onNativeLoad, this);
    this.__onNativeErrorBound = qx.Bootstrap.bind(this._onNativeError, this);
    this.__onTimeoutBound = qx.Bootstrap.bind(this._onTimeout, this);
    this.__headElement = document.head || document.getElementsByTagName("head")[0] || document.documentElement;
    this._emitter = new qx.event.Emitter();
    this.timeout = this.__supportsErrorHandler() ? 0 : 15000;
  },
  events : {
    "readystatechange" : "qx.bom.request.Script",
    "error" : "qx.bom.request.Script",
    "loadend" : "qx.bom.request.Script",
    "timeout" : "qx.bom.request.Script",
    "abort" : "qx.bom.request.Script",
    "load" : "qx.bom.request.Script"
  },
  members : {
    readyState : null,
    status : null,
    statusText : null,
    timeout : null,
    __determineSuccess : null,
    on : function(name, listener, ctx){

      this._emitter.on(name, listener, ctx);
      return this;
    },
    open : function(method, url){

      if(this.__disposed){

        return;
      };
      this.__initXhrProperties();
      this.__abort = null;
      this.__url = url;
      if(this.__environmentGet("qx.debug.io")){

        qx.Bootstrap.debug(qx.bom.request.Script, "Open native request with " + "url: " + url);
      };
      this._readyStateChange(1);
    },
    setRequestHeader : function(key, value){

      if(this.__disposed){

        return null;
      };
      var param = {
      };
      if(this.readyState !== 1){

        throw new Error("Invalid state");
      };
      param[key] = value;
      this.__url = qx.util.Uri.appendParamsToUrl(this.__url, param);
      return this;
    },
    send : function(){

      if(this.__disposed){

        return null;
      };
      var script = this.__createScriptElement(),head = this.__headElement,that = this;
      if(this.timeout > 0){

        this.__timeoutId = window.setTimeout(this.__onTimeoutBound, this.timeout);
      };
      if(this.__environmentGet("qx.debug.io")){

        qx.Bootstrap.debug(qx.bom.request.Script, "Send native request");
      };
      head.insertBefore(script, head.firstChild);
      window.setTimeout(function(){

        that._readyStateChange(2);
        that._readyStateChange(3);
      });
      return this;
    },
    abort : function(){

      if(this.__disposed){

        return null;
      };
      this.__abort = true;
      this.__disposeScriptElement();
      this._emit("abort");
      return this;
    },
    _emit : function(event){

      this["on" + event]();
      this._emitter.emit(event, this);
    },
    onreadystatechange : function(){
    },
    onload : function(){
    },
    onloadend : function(){
    },
    onerror : function(){
    },
    onabort : function(){
    },
    ontimeout : function(){
    },
    getResponseHeader : function(key){

      if(this.__disposed){

        return null;
      };
      if(this.__environmentGet("qx.debug")){

        qx.Bootstrap.debug("Response header cannot be determined for " + "requests made with script transport.");
      };
      return "unknown";
    },
    getAllResponseHeaders : function(){

      if(this.__disposed){

        return null;
      };
      if(this.__environmentGet("qx.debug")){

        qx.Bootstrap.debug("Response headers cannot be determined for" + "requests made with script transport.");
      };
      return "Unknown response headers";
    },
    setDetermineSuccess : function(check){

      this.__determineSuccess = check;
    },
    dispose : function(){

      var script = this.__scriptElement;
      if(!this.__disposed){

        if(script){

          script.onload = script.onreadystatechange = null;
          this.__disposeScriptElement();
        };
        if(this.__timeoutId){

          window.clearTimeout(this.__timeoutId);
        };
        this.__disposed = true;
      };
    },
    isDisposed : function(){

      return !!this.__disposed;
    },
    _getUrl : function(){

      return this.__url;
    },
    _getScriptElement : function(){

      return this.__scriptElement;
    },
    _onTimeout : function(){

      this.__failure();
      if(!this.__supportsErrorHandler()){

        this._emit("error");
      };
      this._emit("timeout");
      if(!this.__supportsErrorHandler()){

        this._emit("loadend");
      };
    },
    _onNativeLoad : function(){

      var script = this.__scriptElement,determineSuccess = this.__determineSuccess,that = this;
      if(this.__abort){

        return;
      };
      if(this.__environmentGet("engine.name") === "mshtml" && this.__environmentGet("browser.documentmode") < 9){

        if(!(/loaded|complete/).test(script.readyState)){

          return;
        } else {

          if(this.__environmentGet("qx.debug.io")){

            qx.Bootstrap.debug(qx.bom.request.Script, "Received native readyState: loaded");
          };
        };
      };
      if(this.__environmentGet("qx.debug.io")){

        qx.Bootstrap.debug(qx.bom.request.Script, "Received native load");
      };
      if(determineSuccess){

        if(!this.status){

          this.status = determineSuccess() ? 200 : 500;
        };
      };
      if(this.status === 500){

        if(this.__environmentGet("qx.debug.io")){

          qx.Bootstrap.debug(qx.bom.request.Script, "Detected error");
        };
      };
      if(this.__timeoutId){

        window.clearTimeout(this.__timeoutId);
      };
      window.setTimeout(function(){

        that._success();
        that._readyStateChange(4);
        that._emit("load");
        that._emit("loadend");
      });
    },
    _onNativeError : function(){

      this.__failure();
      this._emit("error");
      this._emit("loadend");
    },
    __scriptElement : null,
    __headElement : null,
    __url : "",
    __onNativeLoadBound : null,
    __onNativeErrorBound : null,
    __onTimeoutBound : null,
    __timeoutId : null,
    __abort : null,
    __disposed : null,
    __initXhrProperties : function(){

      this.readyState = 0;
      this.status = 0;
      this.statusText = "";
    },
    _readyStateChange : function(readyState){

      this.readyState = readyState;
      this._emit("readystatechange");
    },
    _success : function(){

      this.__disposeScriptElement();
      this.readyState = 4;
      if(!this.status){

        this.status = 200;
      };
      this.statusText = "" + this.status;
    },
    __failure : function(){

      this.__disposeScriptElement();
      this.readyState = 4;
      this.status = 0;
      this.statusText = null;
    },
    __supportsErrorHandler : function(){

      var isLegacyIe = this.__environmentGet("engine.name") === "mshtml" && this.__environmentGet("browser.documentmode") < 9;
      var isOpera = this.__environmentGet("engine.name") === "opera";
      return !(isLegacyIe || isOpera);
    },
    __createScriptElement : function(){

      var script = this.__scriptElement = document.createElement("script");
      script.src = this.__url;
      script.onerror = this.__onNativeErrorBound;
      script.onload = this.__onNativeLoadBound;
      if(this.__environmentGet("engine.name") === "mshtml" && this.__environmentGet("browser.documentmode") < 9){

        script.onreadystatechange = this.__onNativeLoadBound;
      };
      return script;
    },
    __disposeScriptElement : function(){

      var script = this.__scriptElement;
      if(script && script.parentNode){

        this.__headElement.removeChild(script);
      };
    },
    __environmentGet : function(key){

      if(qx && qx.core && qx.core.Environment){

        return qx.core.Environment.get(key);
      } else {

        if(key === "engine.name"){

          return qx.bom.client.Engine.getName();
        };
        if(key === "browser.documentmode"){

          return qx.bom.client.Browser.getDocumentMode();
        };
        if(key == "qx.debug.io"){

          return false;
        };
        throw new Error("Unknown environment key at this phase");
      };
    }
  },
  defer : function(){

    if(qx && qx.core && qx.core.Environment){

      qx.core.Environment.add("qx.debug.io", false);
    };
  }
});

qx.Class.define("qx.event.message.Message", {
  extend : qx.core.Object,
  construct : function(name, data){

    this.base(arguments);
    if(name != null){

      this.setName(name);
    };
    if(data != null){

      this.setData(data);
    };
  },
  properties : {
    name : {
      check : "String"
    },
    data : {
      init : null,
      nullable : true
    },
    sender : {
      check : "Object"
    }
  }
});

qx.Class.define("qx.event.message.Bus", {
  type : "singleton",
  extend : qx.core.Object,
  statics : {
    getSubscriptions : function(){

      return this.getInstance().getSubscriptions();
    },
    subscribe : function(message, subscriber, context){

      return this.getInstance().subscribe(message, subscriber, context);
    },
    checkSubscription : function(message, subscriber, context){

      return this.getInstance().checkSubscription(message, subscriber, context);
    },
    unsubscribe : function(message, subscriber, context){

      return this.getInstance().unsubscribe(message, subscriber, context);
    },
    dispatch : function(msg){

      return this.getInstance().dispatch.apply(this.getInstance(), arguments);
    },
    dispatchByName : function(name, data){

      return this.getInstance().dispatchByName.apply(this.getInstance(), arguments);
    }
  },
  construct : function(){

    this.__subscriptions = {
    };
  },
  members : {
    __subscriptions : null,
    getSubscriptions : function(){

      return this.__subscriptions;
    },
    subscribe : function(message, subscriber, context){

      if(!message || typeof subscriber != "function"){

        this.error("Invalid parameters! " + [message, subscriber, context]);
        return false;
      };
      var sub = this.getSubscriptions();
      if(this.checkSubscription(message)){

        if(this.checkSubscription(message, subscriber, context)){

          this.warn("Object method already subscribed to " + message);
          return false;
        };
        sub[message].push({
          subscriber : subscriber,
          context : context || null
        });
        return true;
      } else {

        sub[message] = [{
          subscriber : subscriber,
          context : context || null
        }];
        return true;
      };
    },
    checkSubscription : function(message, subscriber, context){

      var sub = this.getSubscriptions();
      if(!sub[message] || sub[message].length === 0){

        return false;
      };
      if(subscriber){

        for(var i = 0;i < sub[message].length;i++){

          if(sub[message][i].subscriber === subscriber && sub[message][i].context === (context || null)){

            return true;
          };
        };
        return false;
      };
      return true;
    },
    unsubscribe : function(message, subscriber, context){

      var sub = this.getSubscriptions();
      var subscrList = sub[message];
      if(subscrList){

        if(!subscriber){

          sub[message] = null;
          delete sub[message];
          return true;
        } else {

          if(!context){

            context = null;
          };
          var i = subscrList.length;
          var subscription;
          do {

            subscription = subscrList[--i];
            if(subscription.subscriber === subscriber && subscription.context === context){

              subscrList.splice(i, 1);
              if(subscrList.length === 0){

                sub[message] = null;
                delete sub[message];
              };
              return true;
            };
          }while((i));
        };
      };
      return false;
    },
    dispatch : function(msg){

      var sub = this.getSubscriptions();
      var msgName = msg.getName();
      var dispatched = false;
      for(var key in sub){

        var pos = key.indexOf("*");
        if(pos > -1){

          if(pos === 0 || key.substr(0, pos) === msgName.substr(0, pos)){

            this.__callSubscribers(sub[key], msg);
            dispatched = true;
          };
        } else {

          if(key === msgName){

            this.__callSubscribers(sub[msgName], msg);
            dispatched = true;
          };
        };
      };
      return dispatched;
    },
    dispatchByName : function(name, data){

      var message = new qx.event.message.Message(name, data);
      return this.dispatch(message);
    },
    __callSubscribers : function(subscribers, msg){

      for(var i = 0;i < subscribers.length;i++){

        var subscriber = subscribers[i].subscriber;
        var context = subscribers[i].context;
        if(context && context.isDisposed){

          if(context.isDisposed()){

            subscribers.splice(i, 1);
            i--;
          } else {

            subscriber.call(context, msg);
          };
        } else {

          subscriber.call(context, msg);
        };
      };
    }
  }
});

qx.Bootstrap.define("qx.module.Manipulating", {
  statics : {
    create : function(html, context){

      return qxWeb.$init(qx.bom.Html.clean([html], context), qxWeb);
    },
    clone : function(events){

      var clones = [];
      for(var i = 0;i < this.length;i++){

        if(this[i] && this[i].nodeType === 1){

          clones[i] = this[i].cloneNode(true);
        };
      };
      if(events === true && this.copyEventsTo){

        this.copyEventsTo(clones);
      };
      return qxWeb(clones);
    },
    append : function(html){

      var arr = qx.bom.Html.clean([html]);
      var children = qxWeb.$init(arr, qxWeb);
      this._forEachElement(function(item, index){

        for(var j = 0,m = children.length;j < m;j++){

          if(index == 0){

            qx.dom.Element.insertEnd(children[j], item);
          } else {

            qx.dom.Element.insertEnd(children.eq(j).clone(true)[0], item);
          };
        };
      });
      return this;
    },
    appendTo : function(parent){

      parent = qx.module.Manipulating.__getElementArray(parent);
      for(var i = 0,l = parent.length;i < l;i++){

        this._forEachElement(function(item, j){

          if(i == 0){

            qx.dom.Element.insertEnd(this[j], parent[i]);
          } else {

            qx.dom.Element.insertEnd(this.eq(j).clone(true)[0], parent[i]);
          };
        });
      };
      return this;
    },
    insertBefore : function(target){

      target = qx.module.Manipulating.__getElementArray(target);
      for(var i = 0,l = target.length;i < l;i++){

        this._forEachElement(function(item, index){

          if(i == 0){

            qx.dom.Element.insertBefore(item, target[i]);
          } else {

            qx.dom.Element.insertBefore(this.eq(index).clone(true)[0], target[i]);
          };
        });
      };
      return this;
    },
    insertAfter : function(target){

      target = qx.module.Manipulating.__getElementArray(target);
      for(var i = 0,l = target.length;i < l;i++){

        for(var j = this.length - 1;j >= 0;j--){

          if(!this[j] || this[j].nodeType !== 1){

            continue;
          };
          if(i == 0){

            qx.dom.Element.insertAfter(this[j], target[i]);
          } else {

            qx.dom.Element.insertAfter(this.eq(j).clone(true)[0], target[i]);
          };
        };
      };
      return this;
    },
    __getElementArray : function(arg){

      if(!qx.lang.Type.isArray(arg)){

        var fromSelector = qxWeb(arg);
        arg = fromSelector.length > 0 ? fromSelector : [arg];
      };
      return arg.filter(function(item){

        return (item && (item.nodeType === 1 || item.nodeType === 11));
      });
    },
    wrap : function(wrapper){

      wrapper = qx.module.Manipulating.__getCollectionFromArgument(wrapper);
      if(wrapper.length == 0){

        return this;
      };
      this._forEachElement(function(item){

        var clonedwrapper = wrapper.eq(0).clone(true);
        qx.dom.Element.insertAfter(clonedwrapper[0], item);
        var innermost = qx.module.Manipulating.__getInnermostElement(clonedwrapper[0]);
        qx.dom.Element.insertEnd(item, innermost);
      });
      return this;
    },
    __getCollectionFromArgument : function(arg){

      var coll;
      if(qx.lang.Type.isArray(arg)){

        coll = qxWeb(arg);
      } else {

        var arr = qx.bom.Html.clean([arg]);
        if(arr.length > 0 && qx.dom.Node.isElement(arr[0])){

          coll = qxWeb(arr);
        } else {

          coll = qxWeb(arg);
        };
      };
      return coll;
    },
    __getInnermostElement : function(element){

      if(element.childNodes.length == 0){

        return element;
      };
      for(var i = 0,l = element.childNodes.length;i < l;i++){

        if(element.childNodes[i].nodeType === 1){

          return this.__getInnermostElement(element.childNodes[i]);
        };
      };
      return element;
    },
    remove : function(){

      this._forEachElement(function(item){

        qx.dom.Element.remove(item);
      });
      return this;
    },
    empty : function(){

      this._forEachElement(function(item){

        while(item.firstChild){

          item.removeChild(item.firstChild);
        };
      });
      return this;
    },
    before : function(content){

      if(!qx.lang.Type.isArray(content)){

        content = [content];
      };
      var fragment = document.createDocumentFragment();
      qx.bom.Html.clean(content, document, fragment);
      this._forEachElement(function(item, index){

        var kids = qx.lang.Array.cast(fragment.childNodes, Array);
        for(var i = 0,l = kids.length;i < l;i++){

          var child;
          if(index < this.length - 1){

            child = kids[i].cloneNode(true);
          } else {

            child = kids[i];
          };
          item.parentNode.insertBefore(child, item);
        };
      }, this);
      return this;
    },
    after : function(content){

      if(!qx.lang.Type.isArray(content)){

        content = [content];
      };
      var fragment = document.createDocumentFragment();
      qx.bom.Html.clean(content, document, fragment);
      this._forEachElement(function(item, index){

        var kids = qx.lang.Array.cast(fragment.childNodes, Array);
        for(var i = kids.length - 1;i >= 0;i--){

          var child;
          if(index < this.length - 1){

            child = kids[i].cloneNode(true);
          } else {

            child = kids[i];
          };
          item.parentNode.insertBefore(child, item.nextSibling);
        };
      }, this);
      return this;
    },
    getScrollLeft : function(){

      var obj = this[0];
      if(!obj){

        return null;
      };
      var Node = qx.dom.Node;
      if(Node.isWindow(obj) || Node.isDocument(obj)){

        return qx.bom.Viewport.getScrollLeft();
      };
      return obj.scrollLeft;
    },
    getScrollTop : function(){

      var obj = this[0];
      if(!obj){

        return null;
      };
      var Node = qx.dom.Node;
      if(Node.isWindow(obj) || Node.isDocument(obj)){

        return qx.bom.Viewport.getScrollTop();
      };
      return obj.scrollTop;
    },
    _animationDescription : {
      scrollLeft : {
        duration : 700,
        timing : "ease-in",
        keep : 100,
        keyFrames : {
          '0' : {
          },
          '100' : {
            scrollLeft : 1
          }
        }
      },
      scrollTop : {
        duration : 700,
        timing : "ease-in",
        keep : 100,
        keyFrames : {
          '0' : {
          },
          '100' : {
            scrollTop : 1
          }
        }
      }
    },
    __animateScroll : function(property, value, duration){

      var desc = qx.lang.Object.clone(qx.module.Manipulating._animationDescription[property], true);
      desc.keyFrames[100][property] = value;
      return this.animate(desc, duration);
    },
    setScrollLeft : function(value, duration){

      var Node = qx.dom.Node;
      if(duration && qx.bom.element && qx.bom.element.AnimationJs){

        qx.module.Manipulating.__animateScroll.bind(this, "scrollLeft", value, duration)();
      };
      for(var i = 0,l = this.length,obj;i < l;i++){

        obj = this[i];
        if(Node.isElement(obj)){

          if(!(duration && qx.bom.element && qx.bom.element.AnimationJs)){

            obj.scrollLeft = value;
          };
        } else if(Node.isWindow(obj)){

          obj.scrollTo(value, this.getScrollTop(obj));
        } else if(Node.isDocument(obj)){

          Node.getWindow(obj).scrollTo(value, this.getScrollTop(obj));
        };;
      };
      return this;
    },
    setScrollTop : function(value, duration){

      var Node = qx.dom.Node;
      if(duration && qx.bom.element && qx.bom.element.AnimationJs){

        qx.module.Manipulating.__animateScroll.bind(this, "scrollTop", value, duration)();
      };
      for(var i = 0,l = this.length,obj;i < l;i++){

        obj = this[i];
        if(Node.isElement(obj)){

          if(!(duration && qx.bom.element && qx.bom.element.AnimationJs)){

            obj.scrollTop = value;
          };
        } else if(Node.isWindow(obj)){

          obj.scrollTo(this.getScrollLeft(obj), value);
        } else if(Node.isDocument(obj)){

          Node.getWindow(obj).scrollTo(this.getScrollLeft(obj), value);
        };;
      };
      return this;
    },
    focus : function(){

      try{

        this[0].focus();
      } catch(ex) {
      };
      return this;
    },
    blur : function(){

      this.forEach(function(item, index){

        try{

          item.blur();
        } catch(ex) {
        };
      });
      return this;
    }
  },
  defer : function(statics){

    qxWeb.$attachStatic({
      "create" : statics.create
    });
    qxWeb.$attach({
      "append" : statics.append,
      "appendTo" : statics.appendTo,
      "remove" : statics.remove,
      "empty" : statics.empty,
      "before" : statics.before,
      "insertBefore" : statics.insertBefore,
      "after" : statics.after,
      "insertAfter" : statics.insertAfter,
      "wrap" : statics.wrap,
      "clone" : statics.clone,
      "getScrollLeft" : statics.getScrollLeft,
      "setScrollLeft" : statics.setScrollLeft,
      "getScrollTop" : statics.getScrollTop,
      "setScrollTop" : statics.setScrollTop,
      "focus" : statics.focus,
      "blur" : statics.blur
    });
  }
});

qx.Bootstrap.define("qx.bom.Html", {
  statics : {
    __fixNonDirectlyClosableHelper : function(all, front, tag){

      return tag.match(/^(abbr|br|col|img|input|link|meta|param|hr|area|embed)$/i) ? all : front + "></" + tag + ">";
    },
    __convertMap : {
      opt : [1, "<select multiple='multiple'>", "</select>"],
      leg : [1, "<fieldset>", "</fieldset>"],
      table : [1, "<table>", "</table>"],
      tr : [2, "<table><tbody>", "</tbody></table>"],
      td : [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      col : [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
      def : qx.core.Environment.select("engine.name", {
        "mshtml" : [1, "div<div>", "</div>"],
        "default" : null
      })
    },
    fixEmptyTags : function(html){

      return html.replace(/(<(\w+)[^>]*?)\/>/g, this.__fixNonDirectlyClosableHelper);
    },
    __convertHtmlString : function(html, context){

      var div = context.createElement("div");
      html = qx.bom.Html.fixEmptyTags(html);
      var tags = html.replace(/^\s+/, "").substring(0, 5).toLowerCase();
      var wrap,map = this.__convertMap;
      if(!tags.indexOf("<opt")){

        wrap = map.opt;
      } else if(!tags.indexOf("<leg")){

        wrap = map.leg;
      } else if(tags.match(/^<(thead|tbody|tfoot|colg|cap)/)){

        wrap = map.table;
      } else if(!tags.indexOf("<tr")){

        wrap = map.tr;
      } else if(!tags.indexOf("<td") || !tags.indexOf("<th")){

        wrap = map.td;
      } else if(!tags.indexOf("<col")){

        wrap = map.col;
      } else {

        wrap = map.def;
      };;;;;
      if(wrap){

        div.innerHTML = wrap[1] + html + wrap[2];
        var depth = wrap[0];
        while(depth--){

          div = div.lastChild;
        };
      } else {

        div.innerHTML = html;
      };
      if((qx.core.Environment.get("engine.name") == "mshtml")){

        var hasBody = /<tbody/i.test(html);
        var tbody = !tags.indexOf("<table") && !hasBody ? div.firstChild && div.firstChild.childNodes : wrap[1] == "<table>" && !hasBody ? div.childNodes : [];
        for(var j = tbody.length - 1;j >= 0;--j){

          if(tbody[j].tagName.toLowerCase() === "tbody" && !tbody[j].childNodes.length){

            tbody[j].parentNode.removeChild(tbody[j]);
          };
        };
        if(/^\s/.test(html)){

          div.insertBefore(context.createTextNode(html.match(/^\s*/)[0]), div.firstChild);
        };
      };
      return qx.lang.Array.fromCollection(div.childNodes);
    },
    clean : function(objs, context, fragment){

      context = context || document;
      if(typeof context.createElement === "undefined"){

        context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
      };
      if(!fragment && objs.length === 1 && typeof objs[0] === "string"){

        var match = /^<(\w+)\s*\/?>$/.exec(objs[0]);
        if(match){

          return [context.createElement(match[1])];
        };
      };
      var obj,ret = [];
      for(var i = 0,l = objs.length;i < l;i++){

        obj = objs[i];
        if(typeof obj === "string"){

          obj = this.__convertHtmlString(obj, context);
        };
        if(obj.nodeType){

          ret.push(obj);
        } else if(obj instanceof qx.type.BaseArray || (typeof qxWeb !== "undefined" && obj instanceof qxWeb)){

          ret.push.apply(ret, Array.prototype.slice.call(obj, 0));
        } else if(obj.toElement){

          ret.push(obj.toElement());
        } else {

          ret.push.apply(ret, obj);
        };;
      };
      if(fragment){

        return qx.bom.Html.extractScripts(ret, fragment);
      };
      return ret;
    },
    extractScripts : function(elements, fragment){

      var scripts = [],elem;
      for(var i = 0;elements[i];i++){

        elem = elements[i];
        if(elem.nodeType == 1 && elem.tagName.toLowerCase() === "script" && (!elem.type || elem.type.toLowerCase() === "text/javascript")){

          if(elem.parentNode){

            elem.parentNode.removeChild(elements[i]);
          };
          scripts.push(elem);
        } else {

          if(elem.nodeType === 1){

            var scriptList = qx.lang.Array.fromCollection(elem.getElementsByTagName("script"));
            elements.splice.apply(elements, [i + 1, 0].concat(scriptList));
          };
          if(fragment){

            fragment.appendChild(elem);
          };
        };
      };
      return scripts;
    }
  }
});

qx.Mixin.define("qx.ui.mobile.container.MNativeScroll", {
  construct : function(){

    this.addCssClass("native");
    this._snapPoints = [];
    this.addListenerOnce("appear", this._onAppear, this);
    this.addListener("trackstart", this._onTrackStart, this);
    this.addListener("trackend", this._onTrackEnd, this);
    if(qx.core.Environment.get("os.name") == "ios"){

      this.addListener("touchmove", this._onTouchMove, this);
    };
  },
  members : {
    _snapPoints : null,
    _lastScrollTime : null,
    _snapAfterMomentum : null,
    _onAppear : function(){

      this._calcSnapPoints();
    },
    _onTouchMove : function(evt){

      if(this._isScrollableY()){

        evt.stopPropagation();
      } else {

        evt.preventDefault();
      };
    },
    _onTrackStart : function(){

      this._lastScrollTime = Date.now();
      this._snapAfterMomentum = false;
      if(qx.core.Environment.get("os.name") == "ios"){

        if(this._isScrollableY()){

          var scrollTop = this.getContentElement().scrollTop;
          var maxScrollTop = this.getContentElement().scrollHeight - this.getLayoutParent().getContentElement().offsetHeight;
          if(scrollTop === 0){

            this.getContentElement().scrollTop = 1;
          } else if(scrollTop == maxScrollTop){

            this.getContentElement().scrollTop = maxScrollTop - 1;
          };
        };
      };
    },
    _onTrackEnd : function(evt){

      var swipeDuration = Date.now() - this._lastScrollTime;
      if(swipeDuration < 250 && (Math.abs(evt.getDelta().y) > 10 || Math.abs(evt.getDelta().x) > 10)){

        setTimeout(function(){

          this._snapAfterMomentum = true;
        }.bind(this), 500);
      } else {

        this._snap();
      };
    },
    _onScroll : function(){

      if(this._snapTimerId){

        clearTimeout(this._snapTimerId);
      };
      if(this._snapAfterMomentum || qx.core.Environment.get("browser.name") == "iemobile"){

        this._snapTimerId = setTimeout(function(){

          this._snap();
          this._snapAfterMomentum = false;
        }.bind(this), 100);
      };
    },
    _calcSnapPoints : function(){

      if(this._scrollProperties){

        var snap = this._scrollProperties.snap;
        if(snap){

          qx.bom.Event.removeNativeListener(this._getContentElement(), "scroll", this._onScroll.bind(this));
          qx.bom.Event.addNativeListener(this._getContentElement(), "scroll", this._onScroll.bind(this));
          this._snapPoints = [];
          var snapTargets = this.getContentElement().querySelectorAll(snap);
          for(var i = 0;i < snapTargets.length;i++){

            var snapPoint = qx.bom.element.Location.getRelative(this._getContentElement(), snapTargets[i], "scroll", "scroll");
            this._snapPoints.push(snapPoint);
          };
        };
      };
    },
    _determineSnapPoint : function(current, snapProperty){

      for(var i = 0;i < this._snapPoints.length;i++){

        var snapPoint = this._snapPoints[i];
        if(current <= -snapPoint[snapProperty]){

          if(i > 0){

            var previousSnapPoint = this._snapPoints[i - 1];
            var previousSnapDiff = Math.abs(current + previousSnapPoint[snapProperty]);
            var nextSnapDiff = Math.abs(current + snapPoint[snapProperty]);
            if(previousSnapDiff < nextSnapDiff){

              return -previousSnapPoint[snapProperty];
            } else {

              return -snapPoint[snapProperty];
            };
          } else {

            return -snapPoint[snapProperty];
          };
        };
      };
      return current;
    },
    _snap : function(){

      var current = this._getPosition();
      var nextX = this._determineSnapPoint(current[0], "left");
      var nextY = this._determineSnapPoint(current[1], "top");
      if(nextX != current[0] || nextY != current[1]){

        this._scrollTo(nextX, nextY, 100);
      };
    },
    _refresh : function(){

      this._calcSnapPoints();
    },
    _createScrollElement : function(){

      return null;
    },
    _getPosition : function(){

      return [this.getContentElement().scrollLeft, this.getContentElement().scrollTop];
    },
    _getScrollContentElement : function(){

      return null;
    },
    _scrollTo : function(x, y, time){

      var position = this._getPosition();
      var element = this.getContentElement();
      var startX = -position[0] + element.scrollLeft;
      var startY = -position[1] + element.scrollTop;
      var endX = -x + element.scrollLeft;
      var endY = -y + element.scrollTop;
      if(!this._isScrollableY()){

        endY = 0;
      };
      if(!this._isScrollableX()){

        endX = 0;
      };
      var animationMap = {
        "duration" : time,
        "keyFrames" : {
          '0' : {
            "transform" : "translate3d(" + startX + "px," + startY + "px,0)"
          },
          '100' : {
            "transform" : "translate3d(" + endX + "px," + endY + "px,0)"
          }
        },
        "timing" : "ease-out"
      };
      if(element && element.children.length > 0){

        var animationHandle = qx.bom.element.Animation.animate(element.children[0], animationMap);
        animationHandle.addListener("end", function(){

          element.scrollLeft = x;
          element.scrollTop = y;
        }, this);
      };
    }
  },
  destruct : function(){

    qx.bom.Event.removeNativeListener(this._getContentElement(), "scroll", this._onScroll.bind(this));
    this.removeListener("touchmove", this._onTouchMove, this);
    this.removeListener("appear", this._onAppear, this);
    this.removeListener("trackstart", this._onTrackStart, this);
    this.removeListener("trackend", this._onTrackEnd, this);
  }
});

qx.Class.define("qx.ui.mobile.container.Scroll", {
  extend : qx.ui.mobile.container.Composite,
  construct : function(scrollProperties){

    this.base(arguments);
    if(scrollProperties){

      this._scrollProperties = scrollProperties;
    };
  },
  events : {
    pageEnd : "qx.event.type.Event"
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "scroll"
    },
    delegate : {
      init : null,
      nullable : true
    }
  },
  members : {
    _scrollProperties : null,
    _createContainerElement : function(){

      var element = this.base(arguments);
      var scrollElement = this._createScrollElement();
      if(scrollElement){

        return scrollElement;
      };
      return element;
    },
    _getContentElement : function(){

      var contentElement = this.base(arguments);
      var scrollContentElement = this._getScrollContentElement();
      return scrollContentElement || contentElement;
    },
    refresh : function(){

      this._refresh();
    },
    scrollTo : function(x, y, time){

      this._scrollTo(x, y, time);
    },
    getPosition : function(){

      return this._getPosition();
    },
    isScrollable : function(){

      return this._isScrollable();
    },
    _isScrollable : function(){

      return this._isScrollableX() || this._isScrollableY();
    },
    _isScrollableX : function(){

      if(this.getLayoutParent() === null){

        return false;
      };
      var parentWidth = this.getContainerElement().clientWidth;
      var contentWidth = this.getContentElement().scrollWidth;
      var scrollContentElement = this._getScrollContentElement();
      if(scrollContentElement){

        contentWidth = qx.bom.element.Dimension.getWidth(scrollContentElement);
      };
      return parentWidth < contentWidth;
    },
    _isScrollableY : function(){

      if(this.getLayoutParent() === null){

        return false;
      };
      var parentHeight = this.getContainerElement().clientHeight;
      var contentHeight = this.getContentElement().scrollHeight;
      var scrollContentElement = this._getScrollContentElement();
      if(scrollContentElement){

        contentHeight = qx.bom.element.Dimension.getHeight(scrollContentElement);
      };
      return parentHeight < contentHeight;
    },
    scrollToElement : function(target, time){

      this._scrollToElement(target, time);
    },
    _scrollToElement : function(element, time){

      if(this._getContentElement() && this._isScrollable()){

        if(typeof time === "undefined"){

          time = 0;
        };
        var location = qx.bom.element.Location.getRelative(this._getContentElement(), element, "scroll", "scroll");
        var offset = this._getScrollOffset();
        this._scrollTo(-location.left - offset[0], -location.top - offset[1], time);
      };
    },
    _getScrollOffset : function(){

      var delegate = this.getDelegate();
      if(delegate != null && delegate.getScrollOffset){

        return delegate.getScrollOffset.bind(this)();
      } else {

        return [0, 0];
      };
    },
    scrollToWidget : function(widget, time){

      if(widget){

        this._scrollToElement(widget.getContentElement(), time);
      };
    }
  },
  defer : function(statics){

    if(qx.core.Environment.get("qx.mobile.nativescroll") == false){

      qx.Class.include(statics, qx.ui.mobile.container.MIScroll);
    } else {

      qx.Class.include(statics, qx.ui.mobile.container.MNativeScroll);
    };
  }
});

qx.Class.define("mobile.page.Abstract", {
  extend : qx.ui.mobile.page.NavigationPage,
  construct : function(wrapContentByGroup){

    this.base(arguments, wrapContentByGroup);
    this.setShowBackButton(true);
    this.setBackButtonText("Back");
  },
  members : {
    _back : function(){

      qx.core.Init.getApplication().getRouting().back();
    }
  }
});

qx.Class.define("mobile.page.Login", {
  extend : mobile.page.Abstract,
  construct : function(){

    this.base(arguments);
    this.setTitle("Login");
  },
  members : {
    __form : null,
    _initialize : function(){

      this.base(arguments);
      var user = new qx.ui.mobile.form.TextField();
      user.setRequired(true);
      var pwd = new qx.ui.mobile.form.PasswordField();
      pwd.setRequired(true);
      var loginButton = new qx.ui.mobile.form.Button("Login");
      loginButton.addListener("tap", this._onButtonTap, this);
      var loginForm = this.__form = new qx.ui.mobile.form.Form();
      loginForm.add(user, "Username");
      loginForm.add(pwd, "Password");
      this.getContent().add(new qx.ui.mobile.form.renderer.Single(loginForm));
      this.getContent().add(loginButton);
    },
    _onButtonTap : function(){

      qx.core.Init.getApplication().getRouting().executeGet("/overview");
    }
  }
});

qx.Interface.define("qx.ui.form.IStringForm", {
  events : {
    "changeValue" : "qx.event.type.Data"
  },
  members : {
    setValue : function(value){

      return arguments.length == 1;
    },
    resetValue : function(){
    },
    getValue : function(){
    }
  }
});

qx.Mixin.define("qx.ui.mobile.form.MText", {
  construct : function(value){

    this.initMaxLength();
    this.initPlaceholder();
    this.initReadOnly();
  },
  properties : {
    maxLength : {
      check : "PositiveInteger",
      nullable : true,
      init : null,
      apply : "_applyMaxLength"
    },
    placeholder : {
      check : "String",
      nullable : true,
      init : null,
      apply : "_applyPlaceholder"
    },
    readOnly : {
      check : "Boolean",
      nullable : true,
      init : null,
      apply : "_applyAttribute"
    }
  },
  members : {
    _applyMaxLength : function(value, old){

      this._setAttribute("maxlength", value);
    },
    _applyPlaceholder : function(value, old){

      if(qx.core.Environment.get("os.name") == "android" && value !== null){

        value = " " + value;
      };
      this._setAttribute("placeholder", value);
    },
    focus : function(){

      if(this.isReadOnly() || this.getEnabled() == false){

        return;
      };
      var targetElement = this.getContainerElement();
      if(targetElement){

        qx.bom.Element.focus(targetElement);
      };
    },
    blur : function(){

      var targetElement = this.getContainerElement();
      if(targetElement){

        qx.bom.Element.blur(targetElement);
      };
    }
  }
});

qx.Mixin.define("qx.ui.mobile.form.MValue", {
  construct : function(value){

    if(value){

      this.setValue(value);
    };
    if(this._getTagName() == "input" || this._getTagName() == "textarea"){

      qx.event.Registration.addListener(this.getContentElement(), "change", this._onChangeContent, this);
      qx.event.Registration.addListener(this.getContentElement(), "input", this._onInput, this);
    };
    this.addListener("focus", this._onFocus, this);
    this.addListener("blur", this._onBlur, this);
  },
  events : {
    "input" : "qx.event.type.Data",
    "changeValue" : "qx.event.type.Data"
  },
  properties : {
    liveUpdate : {
      check : "Boolean",
      init : false
    }
  },
  members : {
    __oldValue : null,
    __inputTimeoutHandle : null,
    __hasFocus : null,
    _convertValue : function(value){

      if(typeof value === 'boolean'){

        return value;
      } else if(typeof value === 'number'){

        return value;
      } else {

        return value || "";
      };
    },
    _onFocus : function(){

      this.__hasFocus = true;
    },
    _onBlur : function(){

      this.__hasFocus = false;
    },
    hasFocus : function(){

      return this.__hasFocus;
    },
    setValue : function(value){

      value = this._convertValue(value);
      if(this.__oldValue != value){

        if(this._setValue){

          this._setValue(value);
        } else {

          this._setAttribute("value", value);
        };
        this.__fireChangeValue(value);
      };
    },
    getValue : function(){

      return this._convertValue(this._getValue ? this._getValue() : this._getAttribute("value"));
    },
    resetValue : function(){

      this.setValue(null);
    },
    _onChangeContent : function(evt){

      this.__fireChangeValue(this._convertValue(evt.getData()));
    },
    _onInput : function(evt){

      var data = evt.getData();
      this.fireDataEvent("input", data, true);
      if(this.getLiveUpdate()){

        if(this._setValue){

          this._setValue(data);
        } else {

          this.__fireChangeValue(this._convertValue(data));
        };
      };
    },
    _getCaretPosition : function(){

      var val = this.getContentElement().value;
      if(val && this._getAttribute("type") !== "number"){

        return val.slice(0, this.getContentElement().selectionStart).length;
      } else {

        return val.length;
      };
    },
    _setCaretPosition : function(position){

      if(position != null && this.hasFocus()){

        if(this._getAttribute("type") !== "number" && this.getContentElement().setSelectionRange){

          this.getContentElement().setSelectionRange(position, position);
        };
      };
    },
    __fireChangeValue : function(value){

      if(this.__oldValue != value){

        this.__oldValue = value;
        this.fireDataEvent("changeValue", value);
      };
    }
  },
  destruct : function(){

    this.removeListener("focus", this._onFocus, this);
    this.removeListener("blur", this._onBlur, this);
  }
});

qx.Mixin.define("qx.ui.mobile.form.MState", {
  members : {
    __states : null,
    addState : function(state){

      if(this.__states === null){

        this.__states = {
        };
      };
      this.__states[state] = true;
      this.addCssClass(state);
    },
    hasState : function(state){

      return this.__states !== null && this.__states[state];
    },
    removeState : function(state){

      if(this.hasState(state)){

        delete this.__states[state];
        this.removeCssClass(state);
      };
    },
    replaceState : function(oldState, newState){

      if(this.hasState(oldState)){

        delete this.__states[oldState];
        this.__states[newState] = true;
        this.removeCssClass(oldState);
        this.addCssClass(newState);
      } else {

        this.addState(newState);
      };
    }
  }
});

qx.Mixin.define("qx.ui.form.MForm", {
  construct : function(){

    if(qx.core.Environment.get("qx.dynlocale")){

      qx.locale.Manager.getInstance().addListener("changeLocale", this.__onChangeLocale, this);
    };
  },
  properties : {
    valid : {
      check : "Boolean",
      init : true,
      apply : "_applyValid",
      event : "changeValid"
    },
    required : {
      check : "Boolean",
      init : false,
      event : "changeRequired"
    },
    invalidMessage : {
      check : "String",
      init : "",
      event : "changeInvalidMessage"
    },
    requiredInvalidMessage : {
      check : "String",
      nullable : true,
      event : "changeInvalidMessage"
    }
  },
  members : {
    _applyValid : function(value, old){

      value ? this.removeState("invalid") : this.addState("invalid");
    },
    __onChangeLocale : qx.core.Environment.select("qx.dynlocale", {
      "true" : function(e){

        var invalidMessage = this.getInvalidMessage();
        if(invalidMessage && invalidMessage.translate){

          this.setInvalidMessage(invalidMessage.translate());
        };
        var requiredInvalidMessage = this.getRequiredInvalidMessage();
        if(requiredInvalidMessage && requiredInvalidMessage.translate){

          this.setRequiredInvalidMessage(requiredInvalidMessage.translate());
        };
      },
      "false" : null
    })
  },
  destruct : function(){

    if(qx.core.Environment.get("qx.dynlocale")){

      qx.locale.Manager.getInstance().removeListener("changeLocale", this.__onChangeLocale, this);
    };
  }
});

qx.Mixin.define("qx.ui.form.MModelProperty", {
  properties : {
    model : {
      nullable : true,
      event : "changeModel",
      apply : "_applyModel",
      dereference : true
    }
  },
  members : {
    _applyModel : function(value, old){
    }
  }
});

qx.Interface.define("qx.ui.form.IForm", {
  events : {
    "changeEnabled" : "qx.event.type.Data",
    "changeValid" : "qx.event.type.Data",
    "changeInvalidMessage" : "qx.event.type.Data",
    "changeRequired" : "qx.event.type.Data"
  },
  members : {
    setEnabled : function(enabled){

      return arguments.length == 1;
    },
    getEnabled : function(){
    },
    setRequired : function(required){

      return arguments.length == 1;
    },
    getRequired : function(){
    },
    setValid : function(valid){

      return arguments.length == 1;
    },
    getValid : function(){
    },
    setInvalidMessage : function(message){

      return arguments.length == 1;
    },
    getInvalidMessage : function(){
    },
    setRequiredInvalidMessage : function(message){

      return arguments.length == 1;
    },
    getRequiredInvalidMessage : function(){
    }
  }
});

qx.Interface.define("qx.ui.form.IModel", {
  events : {
    "changeModel" : "qx.event.type.Data"
  },
  members : {
    setModel : function(value){
    },
    getModel : function(){
    },
    resetModel : function(){
    }
  }
});

qx.Class.define("qx.ui.mobile.form.Input", {
  extend : qx.ui.mobile.core.Widget,
  include : [qx.ui.form.MForm, qx.ui.form.MModelProperty, qx.ui.mobile.form.MState],
  implement : [qx.ui.form.IForm, qx.ui.form.IModel],
  type : "abstract",
  construct : function(){

    this.base(arguments);
    this._setAttribute("type", this._getType());
    this.addCssClass("gap");
    this.addListener("focus", this._onSelected, this);
  },
  members : {
    _getTagName : function(){

      return "input";
    },
    _getType : function(){

      if(qx.core.Environment.get("qx.debug")){

        throw new Error("Abstract method call");
      };
    },
    __getScrollContainer : function(){

      var scroll = this;
      while(!(scroll instanceof qx.ui.mobile.container.Scroll)){

        if(scroll.getLayoutParent){

          var layoutParent = scroll.getLayoutParent();
          if(layoutParent == null || layoutParent instanceof qx.ui.mobile.core.Root){

            return null;
          };
          scroll = layoutParent;
        } else {

          return null;
        };
      };
      return scroll;
    },
    _onSelected : function(evt){

      if(!(evt.getTarget() instanceof qx.ui.mobile.form.TextField) && !(evt.getTarget() instanceof qx.ui.mobile.form.NumberField)){

        return;
      };
      var scrollContainer = this.__getScrollContainer();
      if(scrollContainer === null){

        return;
      };
      setTimeout(function(){

        scrollContainer.scrollToWidget(this.getLayoutParent(), 0);
        this._setStyle("position", "relative");
        qx.bom.AnimationFrame.request(function(){

          this._setStyle("position", null);
        }, this);
      }.bind(this), 300);
    }
  },
  destruct : function(){

    this.removeListener("focus", this._onSelected, this);
  }
});

qx.Class.define("qx.ui.mobile.form.TextField", {
  extend : qx.ui.mobile.form.Input,
  include : [qx.ui.mobile.form.MValue, qx.ui.mobile.form.MText],
  implement : [qx.ui.form.IStringForm],
  construct : function(value){

    this.base(arguments);
    this.addListener("keypress", this._onKeyPress, this);
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "text-field"
    }
  },
  members : {
    _getType : function(){

      return "text";
    },
    _onKeyPress : function(evt){

      if(evt.getKeyCode() == 13){

        this.blur();
      };
    }
  },
  destruct : function(){

    this.removeListener("keypress", this._onKeyPress, this);
  }
});

qx.Class.define("qx.ui.mobile.form.NumberField", {
  extend : qx.ui.mobile.form.Input,
  include : [qx.ui.mobile.form.MValue, qx.ui.mobile.form.MText],
  implement : [qx.ui.form.IStringForm],
  construct : function(value){

    this.base(arguments);
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "number-field"
    },
    minimum : {
      check : "Integer",
      init : '',
      apply : "_onChangeMinimum"
    },
    maximum : {
      check : "Integer",
      init : '',
      apply : "_onChangeMaximum"
    },
    step : {
      check : "Integer",
      init : '',
      apply : "_onChangeStep"
    }
  },
  members : {
    _getType : function(){

      return "number";
    },
    _onChangeStep : function(value, old){

      this._setAttribute("step", value);
    },
    _onChangeMaximum : function(value, old){

      this._setAttribute("max", value);
    },
    _onChangeMinimum : function(value, old){

      this._setAttribute("min", value);
    }
  }
});

qx.Class.define("qx.ui.mobile.form.PasswordField", {
  extend : qx.ui.mobile.form.TextField,
  properties : {
    defaultCssClass : {
      refine : true,
      init : "password-field"
    }
  },
  members : {
    _getType : function(){

      return "password";
    }
  }
});

qx.Class.define("qx.ui.form.Form", {
  extend : qx.core.Object,
  construct : function(){

    this.base(arguments);
    this.__groups = [];
    this._buttons = [];
    this._buttonOptions = [];
    this._validationManager = this._createValidationManager();
    this._resetter = this._createResetter();
  },
  events : {
    "change" : "qx.event.type.Event"
  },
  members : {
    __groups : null,
    _validationManager : null,
    _groupCounter : 0,
    _buttons : null,
    _buttonOptions : null,
    _resetter : null,
    add : function(item, label, validator, name, validatorContext, options){

      if(this.__isFirstAdd()){

        this.__groups.push({
          title : null,
          items : [],
          labels : [],
          names : [],
          options : [],
          headerOptions : {
          }
        });
      };
      this.__groups[this._groupCounter].items.push(item);
      this.__groups[this._groupCounter].labels.push(label);
      this.__groups[this._groupCounter].options.push(options);
      if(name == null){

        name = label.replace(/\s+|&|-|\+|\*|\/|\||!|\.|,|:|\?|;|~|%|\{|\}|\(|\)|\[|\]|<|>|=|\^|@|\\/g, "");
      };
      this.__groups[this._groupCounter].names.push(name);
      this._validationManager.add(item, validator, validatorContext);
      this._resetter.add(item);
      this.fireEvent("change");
    },
    addGroupHeader : function(title, options){

      if(!this.__isFirstAdd()){

        this._groupCounter++;
      };
      this.__groups.push({
        title : title,
        items : [],
        labels : [],
        names : [],
        options : [],
        headerOptions : options
      });
      this.fireEvent("change");
    },
    addButton : function(button, options){

      this._buttons.push(button);
      this._buttonOptions.push(options || null);
      this.fireEvent("change");
    },
    __isFirstAdd : function(){

      return this.__groups.length === 0;
    },
    remove : function(item){

      for(var i = 0;i < this.__groups.length;i++){

        var group = this.__groups[i];
        for(var j = 0;j < group.items.length;j++){

          var storedItem = group.items[j];
          if(storedItem === item){

            group.items.splice(j, 1);
            group.labels.splice(j, 1);
            group.names.splice(j, 1);
            group.options.splice(j, 1);
            this._validationManager.remove(item);
            this._resetter.remove(item);
            this.fireEvent("change");
            return true;
          };
        };
      };
      return false;
    },
    removeGroupHeader : function(title){

      for(var i = 0;i < this.__groups.length;i++){

        var group = this.__groups[i];
        if(group.title === title){

          var targetGroup;
          if(i == 0){

            if(this.__groups.length == 1){

              group.title = null;
              group.headerOptions = {
              };
              this.fireEvent("change");
              return true;
            } else {

              targetGroup = this.__groups[i + 1];
            };
          } else {

            targetGroup = this.__groups[i - 1];
          };
          targetGroup.items = targetGroup.items.concat(group.items);
          targetGroup.labels = targetGroup.labels.concat(group.labels);
          targetGroup.names = targetGroup.names.concat(group.names);
          targetGroup.options = targetGroup.options.concat(group.options);
          this.__groups.splice(i, 1);
          this._groupCounter--;
          this.fireEvent("change");
          return true;
        };
      };
      return false;
    },
    removeButton : function(button){

      for(var i = 0;i < this._buttons.length;i++){

        var storedButton = this._buttons[i];
        if(storedButton === button){

          this._buttons.splice(i, 1);
          this._buttonOptions.splice(i, 1);
          this.fireEvent("change");
          return true;
        };
      };
      return false;
    },
    reset : function(){

      this._resetter.reset();
      this._validationManager.reset();
    },
    redefineResetter : function(){

      this._resetter.redefine();
    },
    redefineResetterItem : function(item){

      this._resetter.redefineItem(item);
    },
    validate : function(){

      return this._validationManager.validate();
    },
    getValidationManager : function(){

      return this._validationManager;
    },
    getGroups : function(){

      return this.__groups;
    },
    getButtons : function(){

      return this._buttons;
    },
    getButtonOptions : function(){

      return this._buttonOptions;
    },
    getItems : function(){

      var items = {
      };
      for(var i = 0;i < this.__groups.length;i++){

        var group = this.__groups[i];
        for(var j = 0;j < group.names.length;j++){

          var name = group.names[j];
          items[name] = group.items[j];
        };
      };
      return items;
    },
    _createValidationManager : function(){

      return new qx.ui.form.validation.Manager();
    },
    _createResetter : function(){

      return new qx.ui.form.Resetter();
    }
  },
  destruct : function(){

    this.__groups = this._buttons = this._buttonOptions = null;
    this._validationManager.dispose();
    this._resetter.dispose();
  }
});

qx.Class.define("qx.ui.form.validation.Manager", {
  extend : qx.core.Object,
  construct : function(){

    this.base(arguments);
    this.__formItems = [];
    this.__asyncResults = {
    };
    this.setRequiredFieldMessage(qx.locale.Manager.tr("This field is required"));
  },
  events : {
    "changeValid" : "qx.event.type.Data",
    "complete" : "qx.event.type.Event"
  },
  properties : {
    validator : {
      check : "value instanceof Function || qx.Class.isSubClassOf(value.constructor, qx.ui.form.validation.AsyncValidator)",
      init : null,
      nullable : true
    },
    invalidMessage : {
      check : "String",
      init : ""
    },
    requiredFieldMessage : {
      check : "String",
      init : ""
    },
    context : {
      nullable : true
    }
  },
  members : {
    __formItems : null,
    __valid : null,
    __asyncResults : null,
    __syncValid : null,
    add : function(formItem, validator, context){

      if(!this.__supportsInvalid(formItem)){

        throw new Error("Added widget not supported.");
      };
      if(this.__supportsSingleSelection(formItem) && !formItem.getValue){

        if(validator != null){

          throw new Error("Widgets supporting selection can only be validated " + "in the form validator");
        };
      };
      var dataEntry = {
        item : formItem,
        validator : validator,
        valid : null,
        context : context
      };
      this.__formItems.push(dataEntry);
    },
    remove : function(formItem){

      var items = this.__formItems;
      for(var i = 0,len = items.length;i < len;i++){

        if(formItem === items[i].item){

          items.splice(i, 1);
          return formItem;
        };
      };
      return null;
    },
    getItems : function(){

      var items = [];
      for(var i = 0;i < this.__formItems.length;i++){

        items.push(this.__formItems[i].item);
      };
      return items;
    },
    validate : function(){

      var valid = true;
      this.__syncValid = true;
      var items = [];
      for(var i = 0;i < this.__formItems.length;i++){

        var formItem = this.__formItems[i].item;
        var validator = this.__formItems[i].validator;
        items.push(formItem);
        if(validator == null){

          var validatorResult = this.__validateRequired(formItem);
          valid = valid && validatorResult;
          this.__syncValid = validatorResult && this.__syncValid;
          continue;
        };
        var validatorResult = this.__validateItem(this.__formItems[i], formItem.getValue());
        valid = validatorResult && valid;
        if(validatorResult != null){

          this.__syncValid = validatorResult && this.__syncValid;
        };
      };
      var formValid = this.__validateForm(items);
      if(qx.lang.Type.isBoolean(formValid)){

        this.__syncValid = formValid && this.__syncValid;
      };
      valid = formValid && valid;
      this.__setValid(valid);
      if(qx.lang.Object.isEmpty(this.__asyncResults)){

        this.fireEvent("complete");
      };
      return valid;
    },
    __validateRequired : function(formItem){

      if(formItem.getRequired()){

        if(this.__supportsSingleSelection(formItem)){

          var validatorResult = !!formItem.getSelection()[0];
        } else {

          var value = formItem.getValue();
          var validatorResult = !!value || value === 0;
        };
        formItem.setValid(validatorResult);
        var individualMessage = formItem.getRequiredInvalidMessage();
        var message = individualMessage ? individualMessage : this.getRequiredFieldMessage();
        formItem.setInvalidMessage(message);
        return validatorResult;
      };
      return true;
    },
    __validateItem : function(dataEntry, value){

      var formItem = dataEntry.item;
      var context = dataEntry.context;
      var validator = dataEntry.validator;
      if(this.__isAsyncValidator(validator)){

        this.__asyncResults[formItem.toHashCode()] = null;
        validator.validate(formItem, formItem.getValue(), this, context);
        return null;
      };
      var validatorResult = null;
      try{

        var validatorResult = validator.call(context || this, value, formItem);
        if(validatorResult === undefined){

          validatorResult = true;
        };
      } catch(e) {

        if(e instanceof qx.core.ValidationError){

          validatorResult = false;
          if(e.message && e.message != qx.type.BaseError.DEFAULTMESSAGE){

            var invalidMessage = e.message;
          } else {

            var invalidMessage = e.getComment();
          };
          formItem.setInvalidMessage(invalidMessage);
        } else {

          throw e;
        };
      };
      formItem.setValid(validatorResult);
      dataEntry.valid = validatorResult;
      return validatorResult;
    },
    __validateForm : function(items){

      var formValidator = this.getValidator();
      var context = this.getContext() || this;
      if(formValidator == null){

        return true;
      };
      this.setInvalidMessage("");
      if(this.__isAsyncValidator(formValidator)){

        this.__asyncResults[this.toHashCode()] = null;
        formValidator.validateForm(items, this, context);
        return null;
      };
      try{

        var formValid = formValidator.call(context, items, this);
        if(formValid === undefined){

          formValid = true;
        };
      } catch(e) {

        if(e instanceof qx.core.ValidationError){

          formValid = false;
          if(e.message && e.message != qx.type.BaseError.DEFAULTMESSAGE){

            var invalidMessage = e.message;
          } else {

            var invalidMessage = e.getComment();
          };
          this.setInvalidMessage(invalidMessage);
        } else {

          throw e;
        };
      };
      return formValid;
    },
    __isAsyncValidator : function(validator){

      var async = false;
      if(!qx.lang.Type.isFunction(validator)){

        async = qx.Class.isSubClassOf(validator.constructor, qx.ui.form.validation.AsyncValidator);
      };
      return async;
    },
    __supportsInvalid : function(formItem){

      var clazz = formItem.constructor;
      return qx.Class.hasInterface(clazz, qx.ui.form.IForm);
    },
    __supportsSingleSelection : function(formItem){

      var clazz = formItem.constructor;
      return qx.Class.hasInterface(clazz, qx.ui.core.ISingleSelection);
    },
    __setValid : function(value){

      this._showToolTip(value);
      var oldValue = this.__valid;
      this.__valid = value;
      if(oldValue != value){

        this.fireDataEvent("changeValid", value, oldValue);
      };
    },
    _showToolTip : function(valid){

      if(!qx.ui.tooltip || !qx.ui.tooltip.Manager){

        return;
      };
      var tooltip = qx.ui.tooltip.Manager.getInstance().getSharedErrorTooltip();
      if(!valid){

        var firstInvalid;
        for(var i = 0;i < this.__formItems.length;i++){

          var item = this.__formItems[i].item;
          if(!item.isValid()){

            firstInvalid = item;
            if(!(item.getContentLocation)){

              return;
            };
            if(item.isSeeable() === false){

              continue;
            };
            tooltip.setLabel(item.getInvalidMessage());
            if(tooltip.getPlaceMethod() == "mouse"){

              var location = item.getContentLocation();
              var top = location.top - tooltip.getOffsetTop();
              tooltip.placeToPoint({
                left : location.right,
                top : top
              });
            } else {

              tooltip.placeToWidget(item);
            };
            tooltip.show();
            return;
          };
        };
      } else {

        tooltip.exclude();
      };
    },
    getValid : function(){

      return this.__valid;
    },
    isValid : function(){

      return this.getValid();
    },
    getInvalidMessages : function(){

      var messages = [];
      for(var i = 0;i < this.__formItems.length;i++){

        var formItem = this.__formItems[i].item;
        if(!formItem.getValid()){

          messages.push(formItem.getInvalidMessage());
        };
      };
      if(this.getInvalidMessage() != ""){

        messages.push(this.getInvalidMessage());
      };
      return messages;
    },
    getInvalidFormItems : function(){

      var res = [];
      for(var i = 0;i < this.__formItems.length;i++){

        var formItem = this.__formItems[i].item;
        if(!formItem.getValid()){

          res.push(formItem);
        };
      };
      return res;
    },
    reset : function(){

      for(var i = 0;i < this.__formItems.length;i++){

        var dataEntry = this.__formItems[i];
        dataEntry.item.setValid(true);
      };
      this.__valid = null;
    },
    setItemValid : function(formItem, valid){

      this.__asyncResults[formItem.toHashCode()] = valid;
      formItem.setValid(valid);
      this.__checkValidationComplete();
    },
    setFormValid : function(valid){

      this.__asyncResults[this.toHashCode()] = valid;
      this.__checkValidationComplete();
    },
    __checkValidationComplete : function(){

      var valid = this.__syncValid;
      for(var hash in this.__asyncResults){

        var currentResult = this.__asyncResults[hash];
        valid = currentResult && valid;
        if(currentResult == null){

          return;
        };
      };
      this.__setValid(valid);
      this.__asyncResults = {
      };
      this.fireEvent("complete");
    }
  },
  destruct : function(){

    this.__formItems = null;
  }
});

qx.Class.define("qx.ui.form.validation.AsyncValidator", {
  extend : qx.core.Object,
  construct : function(validator){

    this.base(arguments);
    this.__validatorFunction = validator;
  },
  members : {
    __validatorFunction : null,
    __item : null,
    __manager : null,
    __usedForForm : null,
    validate : function(item, value, manager, context){

      this.__usedForForm = false;
      this.__item = item;
      this.__manager = manager;
      this.__validatorFunction.call(context || this, this, value);
    },
    validateForm : function(items, manager, context){

      this.__usedForForm = true;
      this.__manager = manager;
      this.__validatorFunction.call(context, items, this);
    },
    setValid : function(valid, message){

      if(this.__usedForForm){

        if(message !== undefined){

          this.__manager.setInvalidMessage(message);
        };
        this.__manager.setFormValid(valid);
      } else {

        if(message !== undefined){

          this.__item.setInvalidMessage(message);
        };
        this.__manager.setItemValid(this.__item, valid);
      };
    }
  },
  destruct : function(){

    this.__manager = this.__item = null;
  }
});

qx.Interface.define("qx.ui.core.ISingleSelection", {
  events : {
    "changeSelection" : "qx.event.type.Data"
  },
  members : {
    getSelection : function(){

      return true;
    },
    setSelection : function(items){

      return arguments.length == 1;
    },
    resetSelection : function(){

      return true;
    },
    isSelected : function(item){

      return arguments.length == 1;
    },
    isSelectionEmpty : function(){

      return true;
    },
    getSelectables : function(all){

      return arguments.length == 1;
    }
  }
});

qx.Class.define("qx.ui.form.Resetter", {
  extend : qx.core.Object,
  construct : function(){

    this.base(arguments);
    this.__items = [];
  },
  members : {
    __items : null,
    add : function(item){

      if(this._supportsValue(item)){

        var init = item.getValue();
      } else if(this.__supportsSingleSelection(item)){

        var init = item.getSelection();
      } else if(this.__supportsDataBindingSelection(item)){

        var init = item.getSelection().concat();
      } else {

        throw new Error("Item " + item + " not supported for reseting.");
      };;
      this.__items.push({
        item : item,
        init : init
      });
    },
    remove : function(item){

      for(var i = 0;i < this.__items.length;i++){

        var storedItem = this.__items[i];
        if(storedItem.item === item){

          this.__items.splice(i, 1);
          return true;
        };
      };
      return false;
    },
    reset : function(){

      for(var i = 0;i < this.__items.length;i++){

        var dataEntry = this.__items[i];
        this.__setItem(dataEntry.item, dataEntry.init);
      };
    },
    resetItem : function(item){

      var init;
      for(var i = 0;i < this.__items.length;i++){

        var dataEntry = this.__items[i];
        if(dataEntry.item === item){

          init = dataEntry.init;
          break;
        };
      };
      if(init === undefined){

        throw new Error("The given item has not been added.");
      };
      this.__setItem(item, init);
    },
    __setItem : function(item, init){

      if(this._supportsValue(item)){

        item.setValue(init);
      } else if(this.__supportsSingleSelection(item) || this.__supportsDataBindingSelection(item)){

        item.setSelection(init);
      };
    },
    redefine : function(){

      for(var i = 0;i < this.__items.length;i++){

        var item = this.__items[i].item;
        this.__items[i].init = this.__getCurrentValue(item);
      };
    },
    redefineItem : function(item){

      var dataEntry;
      for(var i = 0;i < this.__items.length;i++){

        if(this.__items[i].item === item){

          dataEntry = this.__items[i];
          break;
        };
      };
      if(dataEntry === undefined){

        throw new Error("The given item has not been added.");
      };
      dataEntry.init = this.__getCurrentValue(dataEntry.item);
    },
    __getCurrentValue : function(item){

      if(this._supportsValue(item)){

        return item.getValue();
      } else if(this.__supportsSingleSelection(item) || this.__supportsDataBindingSelection(item)){

        return item.getSelection();
      };
    },
    __supportsSingleSelection : function(formItem){

      var clazz = formItem.constructor;
      return qx.Class.hasInterface(clazz, qx.ui.core.ISingleSelection);
    },
    __supportsDataBindingSelection : function(formItem){

      var clazz = formItem.constructor;
      return qx.Class.hasInterface(clazz, qx.data.controller.ISelection);
    },
    _supportsValue : function(formItem){

      var clazz = formItem.constructor;
      return (qx.Class.hasInterface(clazz, qx.ui.form.IBooleanForm) || qx.Class.hasInterface(clazz, qx.ui.form.IColorForm) || qx.Class.hasInterface(clazz, qx.ui.form.IDateForm) || qx.Class.hasInterface(clazz, qx.ui.form.INumberForm) || qx.Class.hasInterface(clazz, qx.ui.form.IStringForm));
    }
  },
  destruct : function(){

    this.__items = null;
  }
});

qx.Interface.define("qx.data.controller.ISelection", {
  members : {
    setSelection : function(value){
    },
    getSelection : function(){
    },
    resetSelection : function(){
    }
  }
});

qx.Interface.define("qx.ui.form.IBooleanForm", {
  events : {
    "changeValue" : "qx.event.type.Data"
  },
  members : {
    setValue : function(value){

      return arguments.length == 1;
    },
    resetValue : function(){
    },
    getValue : function(){
    }
  }
});

qx.Interface.define("qx.ui.form.IColorForm", {
  events : {
    "changeValue" : "qx.event.type.Data"
  },
  members : {
    setValue : function(value){

      return arguments.length == 1;
    },
    resetValue : function(){
    },
    getValue : function(){
    }
  }
});

qx.Interface.define("qx.ui.form.IDateForm", {
  events : {
    "changeValue" : "qx.event.type.Data"
  },
  members : {
    setValue : function(value){

      return arguments.length == 1;
    },
    resetValue : function(){
    },
    getValue : function(){
    }
  }
});

qx.Interface.define("qx.ui.form.INumberForm", {
  events : {
    "changeValue" : "qx.event.type.Data"
  },
  members : {
    setValue : function(value){

      return arguments.length == 1;
    },
    resetValue : function(){
    },
    getValue : function(){
    }
  }
});

qx.Class.define("qx.ui.mobile.form.Form", {
  extend : qx.ui.form.Form,
  construct : function(){

    this.base(arguments);
    this.__invalidItems = [];
  },
  members : {
    __renderer : null,
    __invalidItems : null,
    _createResetter : function(){

      return new qx.ui.mobile.form.Resetter();
    },
    setRenderer : function(renderer){

      this.__renderer = renderer;
    },
    validate : function(){

      var validateResult = this.base(arguments);
      this.__invalidItems = [];
      if(this.__renderer != null){

        this.__renderer.resetForm();
      };
      var groups = this.getGroups();
      for(var i = 0;i < groups.length;i++){

        var group = groups[i];
        for(var j = 0;j < group.items.length;j++){

          var item = group.items[j];
          if(!item.isValid()){

            this.__invalidItems.push(item);
            if(this.__renderer != null){

              this.__renderer.showErrorForItem(item);
            } else {

              alert('error ' + item.getInvalidMessage());
            };
          };
        };
      };
      if(this.__renderer != null){

        this.__renderer._domUpdated();
      };
      return validateResult;
    },
    showRow : function(groupIndex, rowIndex){

      var item = this._getItemByIndex(groupIndex, rowIndex);
      if(item){

        this.__renderer.showItem(item);
      };
    },
    hideRow : function(groupIndex, rowIndex){

      var item = this._getItemByIndex(groupIndex, rowIndex);
      if(item){

        this.__renderer.hideItem(item);
      };
    },
    _getItemByIndex : function(groupIndex, rowIndex){

      var groups = this.getGroups();
      var group = groups[groupIndex];
      if(group){

        var item = group.items[rowIndex];
        return item;
      };
      return null;
    },
    reset : function(){

      this.base(arguments);
      this.__renderer.resetForm();
    },
    getInvalidItems : function(){

      return this.__invalidItems;
    }
  }
});

qx.Class.define("qx.ui.mobile.form.Resetter", {
  extend : qx.ui.form.Resetter,
  members : {
    _supportsValue : function(formItem){

      var clazz = formItem.constructor;
      return (this.base(arguments, formItem) || qx.Class.hasMixin(clazz, qx.ui.mobile.form.MValue));
    }
  }
});

qx.Interface.define("qx.ui.form.renderer.IFormRenderer", {
  members : {
    addItems : function(items, names, title, itemsOptions, headerOptions){
    },
    addButton : function(button, options){
    }
  }
});

qx.Class.define("qx.ui.mobile.form.renderer.AbstractRenderer", {
  type : "abstract",
  extend : qx.ui.mobile.core.Widget,
  implement : qx.ui.form.renderer.IFormRenderer,
  construct : function(form){

    this.base(arguments);
    this._form = form;
    this._render();
    form.addListener("change", this._onFormChange, this);
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "form"
    }
  },
  members : {
    _form : null,
    _onFormChange : function(){

      this._removeAll();
      this.resetForm();
      this._render();
    },
    _render : function(){

      var groups = this._form.getGroups();
      for(var i = 0;i < groups.length;i++){

        var group = groups[i];
        this.addItems(group.items, group.labels, group.title, group.options, group.headerOptions);
      };
      var buttons = this._form.getButtons();
      var buttonOptions = this._form.getButtonOptions();
      for(var i = 0;i < buttons.length;i++){

        this.addButton(buttons[i], buttonOptions[i]);
      };
      this._form.setRenderer(this);
    },
    addItems : function(items, names, title){

      throw new Error("Abstract method call");
    },
    addButton : function(button){

      throw new Error("Abstract method call");
    },
    showErrorForItem : function(item){

      throw new Error("Abstract method call");
    },
    resetForm : function(){

      throw new Error("Abstract method call");
    }
  }
});

qx.Class.define("qx.ui.mobile.form.ToggleButton", {
  extend : qx.ui.mobile.core.Widget,
  include : [qx.ui.mobile.form.MValue, qx.ui.form.MForm, qx.ui.form.MModelProperty, qx.ui.mobile.form.MState],
  implement : [qx.ui.form.IForm, qx.ui.form.IModel],
  construct : function(value, labelChecked, labelUnchecked){

    this.base(arguments);
    if(labelChecked && labelUnchecked){

      this.__labelUnchecked = labelUnchecked;
      this.__labelChecked = labelChecked;
    };
    this._setAttribute("data-label-checked", this.__labelChecked);
    this._setAttribute("data-label-unchecked", this.__labelUnchecked);
    this.__switch = this._createSwitch();
    this._add(this.__switch);
    if(value){

      this.setValue(value);
    };
    this.addListener("tap", this._onTap, this);
    this.addListener("swipe", this._onSwipe, this);
    this.addCssClass("gap");
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "togglebutton"
    }
  },
  members : {
    __switch : null,
    __value : false,
    __labelUnchecked : "OFF",
    __labelChecked : "ON",
    __lastToggleTimestamp : 0,
    _getChild : function(){

      return this.__switch;
    },
    _createSwitch : function(){

      var toggleButtonSwitch = new qx.ui.mobile.container.Composite();
      toggleButtonSwitch.addCssClass("togglebutton-switch");
      return toggleButtonSwitch;
    },
    _setValue : function(value){

      if(typeof value !== 'boolean'){

        throw new Error("value for " + this + " should be boolean");
      };
      if(value){

        this.addCssClass("checked");
      } else {

        this.removeCssClass("checked");
      };
      this.__value = value;
    },
    _getValue : function(){

      return this.__value;
    },
    toggle : function(){

      this.setValue(!this.getValue());
    },
    _onTap : function(evt){

      if(this._checkLastPointerTime()){

        this.toggle();
      };
    },
    _onSwipe : function(evt){

      if(this._checkLastPointerTime()){

        var direction = evt.getDirection();
        if(direction == "left"){

          if(this.__value == true){

            this.toggle();
          };
        } else {

          if(this.__value == false){

            this.toggle();
          };
        };
      };
    },
    _checkLastPointerTime : function(){

      var elapsedTime = new Date().getTime() - this.__lastToggleTimestamp;
      this.__lastToggleTimestamp = new Date().getTime();
      return elapsedTime > 500;
    }
  },
  destruct : function(){

    this.removeListener("tap", this._onTap, this);
    this.removeListener("swipe", this._onSwipe, this);
    this._disposeObjects("__switch", "__labelUnchecked", "__labelChecked");
  }
});

qx.Class.define("qx.ui.mobile.form.CheckBox", {
  extend : qx.ui.mobile.form.Input,
  include : [qx.ui.mobile.form.MValue],
  construct : function(value){

    this.base(arguments);
    if(typeof value != undefined){

      this._state = value;
    };
    this.addListener("tap", this._onTap, this);
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "checkbox"
    }
  },
  members : {
    _state : null,
    _getTagName : function(){

      return "span";
    },
    _getType : function(){

      return null;
    },
    _onTap : function(){

      this.setValue(!this.getValue());
    },
    _setValue : function(value){

      if(value == true){

        this.addCssClass("checked");
      } else {

        this.removeCssClass("checked");
      };
      this._setAttribute("checked", value);
      this._state = value;
    },
    _getValue : function(){

      return this._state;
    }
  },
  destruct : function(){

    this.removeListener("tap", this._onTap, this);
  }
});

qx.Class.define("qx.ui.mobile.form.RadioButton", {
  extend : qx.ui.mobile.form.Input,
  include : [qx.ui.mobile.form.MValue],
  construct : function(value){

    this.base(arguments);
    this.addListener("tap", this._onTap, this);
  },
  events : {
    changeValue : "qx.event.type.Data"
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "radio"
    },
    group : {
      check : "qx.ui.mobile.form.RadioGroup",
      nullable : true,
      apply : "_applyGroup"
    }
  },
  members : {
    _state : null,
    _getTagName : function(){

      return "span";
    },
    _getType : function(){

      return null;
    },
    _onTap : function(){

      this.fireDataEvent("changeValue", {
      });
      this.setValue(true);
    },
    _applyGroup : function(value, old){

      if(old){

        old.remove(this);
      };
      if(value){

        value.add(this);
      };
    },
    _setValue : function(value){

      if(value == true){

        this.addCssClass("checked");
      } else {

        this.removeCssClass("checked");
      };
      this._state = value;
    },
    _getValue : function(){

      return this._state;
    }
  },
  destruct : function(){

    qx.event.Registration.removeListener(this, "tap", this._onTap, this);
  }
});

qx.Class.define("qx.ui.mobile.form.SelectBox", {
  extend : qx.ui.mobile.core.Widget,
  include : [qx.ui.mobile.form.MValue, qx.ui.form.MForm, qx.ui.mobile.form.MText, qx.ui.mobile.form.MState],
  implement : [qx.ui.form.IForm, qx.ui.form.IModel],
  construct : function(){

    this.base(arguments);
    this._setAttribute("type", "text");
    this.setReadOnly(true);
    this.addListener("focus", this.blur);
    this.addListener("tap", this._onTap, this);
    this.__selectionDialog = this._createSelectionDialog();
    this.addCssClass("gap");
    this.__selectionDialog.addListener("changeSelection", this._onChangeSelection, this);
  },
  events : {
    changeSelection : "qx.event.type.Data"
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "selectbox"
    },
    activatable : {
      refine : true,
      init : true
    },
    nullable : {
      init : true,
      check : "Boolean",
      apply : "_applyNullable"
    },
    model : {
      check : "qx.data.Array",
      apply : "_applyModel",
      event : "changeModel",
      nullable : true,
      init : null
    },
    selection : {
      init : null,
      validate : "_validateSelection",
      apply : "_applySelection",
      nullable : true
    }
  },
  members : {
    __selectionDialog : null,
    _getTagName : function(){

      return "input";
    },
    _createSelectionDialog : function(){

      var menu = new qx.ui.mobile.dialog.Menu();
      menu.setSelectedItemClass("selectbox-selected");
      menu.setUnselectedItemClass("selectbox-unselected");
      menu.setHideOnBlockerTap(true);
      return menu;
    },
    getSelectionDialog : function(){

      return this.__selectionDialog;
    },
    setDialogTitle : function(title){

      this.__selectionDialog.setTitle(title);
    },
    setClearButtonLabel : function(value){

      this.__selectionDialog.setClearButtonLabel(value);
    },
    _setValue : function(value){

      if(this.getModel() == null){

        return;
      };
      if(value == ""){

        if(this.isNullable()){

          this.setSelection(null);
        } else {

          this.setSelection(0);
        };
      } else if(value != null){

        this.setSelection(this.getModel().indexOf(value));
      } else {

        this.setSelection(null);
      };
    },
    _getValue : function(){

      return this._getAttribute("value");
    },
    _render : function(){

      if(this.getModel() != null && this.getModel().length > 0){

        var selectedItem = this.getModel().getItem(this.getSelection());
        this._setAttribute("value", selectedItem);
      };
      this._domUpdated();
    },
    _applyModel : function(value, old){

      value.addListener("change", this._render, this);
      if(old != null){

        old.removeListener("change", this._render, this);
      };
      this._render();
    },
    __showSelectionDialog : function(){

      if(this.isEnabled() == true){

        this.__selectionDialog.setSelectedIndex(this.getSelection());
        this.__selectionDialog.setItems(this.getModel());
        this.__selectionDialog.show();
      };
    },
    _onChangeSelection : function(evt){

      this.setSelection(evt.getData().index);
      this._render();
    },
    _onTap : function(evt){

      this.__showSelectionDialog();
      evt.getOriginalTarget().focus();
    },
    _validateSelection : function(value){

      if(value != null && qx.lang.Type.isNumber(value) == false){

        throw new qx.core.ValidationError("Validation Error: Input value is not a number");
      };
      if(this.getModel() === null){

        throw new qx.core.ValidationError("Validation Error: Please apply model before selection");
      };
      if(!this.isNullable() && value === null){

        throw new qx.core.ValidationError("Validation Error: SelectBox is not nullable");
      };
      if(value != null && (value < 0 || value >= this.getModel().getLength())){

        throw new qx.core.ValidationError("Validation Error: Input value is out of model range");
      };
    },
    _applySelection : function(value, old){

      var selectedItem = this.getModel().getItem(value);
      this.fireDataEvent("changeSelection", {
        index : value,
        item : selectedItem
      });
      this._render();
    },
    _applyNullable : function(value, old){

      this.__selectionDialog.setNullable(value);
    }
  },
  destruct : function(){

    this.__selectionDialog.removeListener("changeSelection", this._onChangeSelection, this);
    this._disposeObjects("__selectionDialog", "__selectionDialogTitle");
    this.removeListener("focus", this.blur);
    this.removeListener("tap", this._onTap, this);
  }
});

qx.Class.define("qx.ui.mobile.dialog.Popup", {
  extend : qx.ui.mobile.core.Widget,
  statics : {
    ROOT : null
  },
  construct : function(widget, anchor){

    this.base(arguments);
    this.exclude();
    if(qx.ui.mobile.dialog.Popup.ROOT == null){

      qx.ui.mobile.dialog.Popup.ROOT = qx.core.Init.getApplication().getRoot();
    };
    qx.ui.mobile.dialog.Popup.ROOT.add(this);
    this.__anchor = anchor;
    if(widget){

      this._initializeChild(widget);
    };
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "popup"
    },
    title : {
      apply : "_applyTitle",
      nullable : true,
      check : "String",
      event : "changeTitle"
    },
    icon : {
      check : "String",
      apply : "_applyIcon",
      nullable : true,
      event : "changeIcon"
    },
    modal : {
      init : false,
      check : "Boolean",
      nullable : false
    },
    hideOnBlockerTap : {
      check : "Boolean",
      init : false
    }
  },
  members : {
    __isShown : false,
    __childrenContainer : null,
    __percentageTop : null,
    __anchor : null,
    __widget : null,
    __titleWidget : null,
    __lastPopupDimension : null,
    _updatePosition : function(){

      this.removeCssClasses(['top', 'bottom', 'left', 'right', 'anchor']);
      if(this.__anchor){

        this.addCssClass('anchor');
        var rootHeight = qx.ui.mobile.dialog.Popup.ROOT.getHeight();
        var rootWidth = qx.ui.mobile.dialog.Popup.ROOT.getWidth();
        var rootPosition = qx.bom.element.Location.get(qx.ui.mobile.dialog.Popup.ROOT.getContainerElement());
        var anchorPosition = qx.bom.element.Location.get(this.__anchor.getContainerElement());
        var popupDimension = qx.bom.element.Dimension.getSize(this.getContainerElement());
        this.__lastPopupDimension = popupDimension;
        var computedPopupPosition = qx.util.placement.Placement.compute(popupDimension, {
          width : rootPosition.left + rootWidth,
          height : rootPosition.top + rootHeight
        }, anchorPosition, {
          left : 0,
          right : 0,
          top : 0,
          bottom : 0
        }, "bottom-left", "keep-align", "keep-align");
        this._resetPosition();
        var isTop = anchorPosition.top > computedPopupPosition.top;
        var isLeft = anchorPosition.left > computedPopupPosition.left;
        computedPopupPosition.top = computedPopupPosition.top - rootPosition.top;
        computedPopupPosition.left = computedPopupPosition.left - rootPosition.left;
        var isOutsideViewPort = computedPopupPosition.top < 0 || computedPopupPosition.left < 0 || computedPopupPosition.left + popupDimension.width > rootWidth || computedPopupPosition.top + popupDimension.height > rootHeight;
        if(isOutsideViewPort){

          this._positionToCenter();
        } else {

          if(isTop){

            this.addCssClass('bottom');
          } else {

            this.addCssClass('top');
          };
          if(isLeft){

            this.addCssClass('right');
          } else {

            this.addCssClass('left');
          };
          this.placeTo(computedPopupPosition.left, computedPopupPosition.top);
        };
      } else if(this.__childrenContainer){

        this._positionToCenter();
      };
    },
    show : function(){

      if(!this.__isShown){

        qx.core.Init.getApplication().fireEvent("popup");
        this.__registerEventListener();
        this.placeTo(-1000, -1000);
        this.base(arguments);
        this._updatePosition();
      };
      this.__isShown = true;
      if(this.getModal() === true){

        qx.ui.mobile.core.Blocker.getInstance().show();
        if(this.getHideOnBlockerTap()){

          qx.ui.mobile.core.Blocker.getInstance().addListener("tap", this.hide, this);
        };
      };
    },
    hide : function(){

      if(this.__isShown){

        this.__unregisterEventListener();
        this.exclude();
      };
      this.__isShown = false;
      if(this.getModal()){

        qx.ui.mobile.core.Blocker.getInstance().hide();
      };
      qx.ui.mobile.core.Blocker.getInstance().removeListener("tap", this.hide, this);
    },
    hideWithDelay : function(delay){

      if(delay){

        qx.lang.Function.delay(this.hide, delay, this);
      } else {

        this.hide();
      };
    },
    isShown : function(){

      return this.__isShown;
    },
    toggleVisibility : function(){

      if(this.__isShown == true){

        this.hide();
      } else {

        this.show();
      };
    },
    placeTo : function(left, top){

      this._setStyle("left", left + "px");
      this._setStyle("top", top + "px");
    },
    _trackUserTap : function(evt){

      var clientX = evt.getViewportLeft();
      var clientY = evt.getViewportTop();
      var popupLocation = qx.bom.element.Location.get(this.getContainerElement());
      var isOutsideWidget = clientX < popupLocation.left || clientX > popupLocation.left + this.__lastPopupDimension.width || clientY > popupLocation.top + this.__lastPopupDimension.height || clientY < popupLocation.top;
      if(isOutsideWidget){

        this.hide();
      };
    },
    _positionToCenter : function(){

      var container = this.getContainerElement();
      container.style.position = "absolute";
      container.style.marginLeft = -(container.offsetWidth / 2) + "px";
      container.style.marginTop = -(container.offsetHeight / 2) + "px";
      container.style.left = "50%";
      container.style.top = "50%";
    },
    _resetPosition : function(){

      var container = this.getContainerElement();
      container.style.left = "0px";
      container.style.top = "0px";
      container.style.marginLeft = null;
      container.style.marginTop = null;
    },
    __registerEventListener : function(){

      qx.core.Init.getApplication().addListener("stop", this.hide, this);
      qx.core.Init.getApplication().addListener("popup", this.hide, this);
      qx.event.Registration.addListener(window, "resize", this._updatePosition, this);
      if(this.__anchor){

        this.__anchor.addCssClass("anchor-target");
        qx.ui.mobile.dialog.Popup.ROOT.addListener("pointerdown", this._trackUserTap, this);
      };
    },
    __unregisterEventListener : function(){

      qx.core.Init.getApplication().removeListener("stop", this.hide, this);
      qx.core.Init.getApplication().removeListener("popup", this.hide, this);
      qx.event.Registration.removeListener(window, "resize", this._updatePosition, this);
      if(this.__anchor){

        this.__anchor.removeCssClass("anchor-target");
        qx.ui.mobile.dialog.Popup.ROOT.removeListener("pointerdown", this._trackUserTap, this);
      };
    },
    _initializeChild : function(widget){

      if(this.__childrenContainer == null){

        this.__childrenContainer = new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox());
        this.__childrenContainer.setDefaultCssClass("popup-content");
        this._add(this.__childrenContainer);
      };
      if(this._createTitleWidget()){

        this.__childrenContainer.remove(this._createTitleWidget());
        this.__childrenContainer.add(this._createTitleWidget());
      };
      this.__childrenContainer.add(widget, {
        flex : 1
      });
      this.__widget = widget;
    },
    _createTitleWidget : function(){

      if(this.__titleWidget){

        return this.__titleWidget;
      };
      if(this.getTitle() || this.getIcon()){

        this.__titleWidget = new qx.ui.mobile.basic.Atom(this.getTitle(), this.getIcon());
        this.__titleWidget.addCssClass('popup-title');
        return this.__titleWidget;
      } else {

        return null;
      };
    },
    _applyTitle : function(value, old){

      if(value){

        if(this.__titleWidget){

          this.__titleWidget.setLabel(value);
        } else {

          this.__titleWidget = new qx.ui.mobile.basic.Atom(value, this.getIcon());
          this.__titleWidget.addCssClass('popup-title');
          if(this.__widget){

            this.__childrenContainer.addBefore(this._createTitleWidget(), this.__widget);
          } else {

            if(this.__childrenContainer){

              this.__childrenContainer.add(this._createTitleWidget());
            };
          };
        };
      };
    },
    _applyIcon : function(value, old){

      if(value){

        if(this.__titleWidget){

          this.__titleWidget.setIcon(value);
        } else {

          this.__titleWidget = new qx.ui.mobile.basic.Atom(this.getTitle(), value);
          this.__titleWidget.addCssClass('popup-title');
          if(this.__widget){

            this.__childrenContainer.addBefore(this._createTitleWidget(), this.__widget);
          } else {

            if(this.__childrenContainer){

              this.__childrenContainer.add(this._createTitleWidget());
            };
          };
        };
      };
    },
    add : function(widget){

      this.removeWidget();
      this._initializeChild(widget);
    },
    setAnchor : function(widget){

      this.__anchor = widget;
      this._updatePosition();
    },
    getTitleWidget : function(){

      return this.__titleWidget;
    },
    removeWidget : function(){

      if(this.__widget){

        this.__childrenContainer.remove(this.__widget);
        return this.__widget;
      } else {

        if(qx.core.Environment.get("qx.debug")){

          qx.log.Logger.debug(this, "this popup has no widget attached yet");
        };
        return null;
      };
    },
    _getBlocker : function(){

      return qx.ui.mobile.core.Blocker.getInstance();
    }
  },
  destruct : function(){

    this.__unregisterEventListener();
    this._disposeObjects("__childrenContainer");
    this.__isShown = this.__percentageTop = this._anchor = this.__widget = this.__lastPopupDimension = null;
  }
});

qx.Class.define("qx.ui.mobile.core.Blocker", {
  extend : qx.ui.mobile.core.Widget,
  type : "singleton",
  statics : {
    ROOT : null
  },
  construct : function(){

    this.base(arguments);
    if(qx.ui.mobile.core.Blocker.ROOT == null){

      qx.ui.mobile.core.Blocker.ROOT = qx.core.Init.getApplication().getRoot();
    };
    this.forceHide();
    qx.ui.mobile.core.Blocker.ROOT.add(this);
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "blocker"
    }
  },
  members : {
    __count : 0,
    show : function(){

      if(this.__count == 0){

        this._updateSize();
        this.__registerEventListener();
        this.base(arguments);
      };
      this.__count++;
    },
    hide : function(){

      this.__count--;
      if(this.__count <= 0){

        this.__count = 0;
        this.__unregisterEventListener();
        this.exclude();
      };
    },
    forceHide : function(){

      this.__count = 0;
      this.hide();
    },
    isShown : function(){

      return this.__count > 0;
    },
    _updateSize : function(){

      if(qx.ui.mobile.core.Blocker.ROOT == this.getLayoutParent()){

        this.getContainerElement().style.top = qx.bom.Viewport.getScrollTop() + "px";
        this.getContainerElement().style.left = qx.bom.Viewport.getScrollLeft() + "px";
        this.getContainerElement().style.width = qx.bom.Viewport.getWidth() + "px";
        this.getContainerElement().style.height = qx.bom.Viewport.getHeight() + "px";
      } else if(this.getLayoutParent() != null){

        var dimension = qx.bom.element.Dimension.getSize(this.getLayoutParent().getContainerElement());
        this.getContainerElement().style.width = dimension.width + "px";
        this.getContainerElement().style.height = dimension.height + "px";
      };
    },
    _onScroll : function(evt){

      this._updateSize();
    },
    __registerEventListener : function(){

      qx.event.Registration.addListener(window, "resize", this._updateSize, this);
      qx.event.Registration.addListener(window, "scroll", this._onScroll, this);
      this.addListener("pointerdown", qx.bom.Event.preventDefault, this);
      this.addListener("pointerup", qx.bom.Event.preventDefault, this);
    },
    __unregisterEventListener : function(){

      qx.event.Registration.removeListener(window, "resize", this._updateSize, this);
      qx.event.Registration.removeListener(window, "scroll", this._onScroll, this);
      this.removeListener("pointerdown", qx.bom.Event.preventDefault, this);
      this.removeListener("pointerup", qx.bom.Event.preventDefault, this);
    }
  },
  destruct : function(){

    qx.ui.mobile.core.Blocker.ROOT.remove(this);
    this.__unregisterEventListener();
  }
});

qx.Class.define("qx.ui.mobile.dialog.Menu", {
  extend : qx.ui.mobile.dialog.Popup,
  construct : function(itemsModel, anchor){

    this.__selectionList = this._createSelectionList();
    if(itemsModel){

      this.__selectionList.setModel(itemsModel);
    };
    this.__menuContainer = new qx.ui.mobile.container.Composite();
    this.__clearButton = this._createClearButton();
    this.__listScroller = this._createListScroller(this.__selectionList);
    this.__menuContainer.add(this.__listScroller);
    this.__menuContainer.add(this.__clearButton);
    this.base(arguments, this.__menuContainer, anchor);
    if(anchor){

      this.setModal(false);
    } else {

      this.setModal(true);
    };
  },
  events : {
    changeSelection : "qx.event.type.Data"
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "menu"
    },
    selectedItemClass : {
      init : "item-selected"
    },
    unselectedItemClass : {
      init : "item-unselected"
    },
    nullable : {
      init : false,
      check : "Boolean",
      apply : "_applyNullable"
    },
    clearButtonLabel : {
      init : "None",
      check : "String",
      apply : "_applyClearButtonLabel"
    },
    selectedIndex : {
      check : "Integer",
      apply : "_applySelectedIndex",
      nullable : true
    },
    visibleListItems : {
      check : "Integer",
      apply : "_updatePosition",
      nullable : true
    }
  },
  members : {
    __selectionList : null,
    __clearButton : null,
    __listScroller : null,
    __menuContainer : null,
    show : function(){

      this.base(arguments);
      this.scrollToItem(this.getSelectedIndex());
    },
    _createClearButton : function(){

      var clearButton = new qx.ui.mobile.form.Button(this.getClearButtonLabel());
      clearButton.addListener("tap", this.__onClearButtonTap, this);
      clearButton.exclude();
      return clearButton;
    },
    _createListScroller : function(selectionList){

      var listScroller = new qx.ui.mobile.container.Scroll({
        "snap" : ".list-item"
      });
      listScroller.add(selectionList, {
        flex : 1
      });
      listScroller.addCssClass("menu-scroller");
      return listScroller;
    },
    _getListScroller : function(){

      return this.__listScroller;
    },
    _updatePosition : function(){

      var parentHeight = qx.ui.mobile.dialog.Popup.ROOT.getHeight();
      var listScrollerHeight = parseInt(parentHeight, 10) * 0.75;
      listScrollerHeight = parseInt(listScrollerHeight, 10);
      if(this.getVisibleListItems() !== null){

        var newListScrollerHeight = this.__selectionList.getListItemHeight() * this.getVisibleListItems();
        listScrollerHeight = Math.min(newListScrollerHeight, listScrollerHeight);
      };
      qx.bom.element.Style.set(this.__listScroller.getContainerElement(), "maxHeight", listScrollerHeight + "px");
      this.base(arguments);
    },
    _createSelectionList : function(){

      var self = this;
      var selectionList = new qx.ui.mobile.list.List({
        configureItem : function(item, data, row){

          item.setTitle(data);
          item.setShowArrow(false);
          var isItemSelected = (self.getSelectedIndex() == row);
          if(isItemSelected){

            item.removeCssClass(self.getUnselectedItemClass());
            item.addCssClass(self.getSelectedItemClass());
          } else {

            item.removeCssClass(self.getSelectedItemClass());
            item.addCssClass(self.getUnselectedItemClass());
          };
        }
      });
      selectionList.addListener("changeSelection", this.__onListChangeSelection, this);
      selectionList.addListener("tap", this._onSelectionListTap, this);
      return selectionList;
    },
    getSelectionList : function(){

      return this.__selectionList;
    },
    _onSelectionListTap : function(){

      this.hideWithDelay(500);
    },
    setItems : function(itemsModel){

      if(this.__selectionList){

        this.__selectionList.setModel(null);
        this.__selectionList.setModel(itemsModel);
      };
    },
    __onListChangeSelection : function(evt){

      this.setSelectedIndex(evt.getData());
    },
    __onClearButtonTap : function(){

      this.fireDataEvent("changeSelection", {
        index : null,
        item : null
      });
      this.hide();
    },
    _applySelectedIndex : function(value, old){

      var listModel = this.__selectionList.getModel();
      if(listModel !== null){

        var selectedItem = listModel.getItem(value);
        this.fireDataEvent("changeSelection", {
          index : value,
          item : selectedItem
        });
      };
      this._render();
    },
    _applyNullable : function(value, old){

      if(value){

        this.__clearButton.setVisibility("visible");
      } else {

        this.__clearButton.setVisibility("excluded");
      };
    },
    _applyClearButtonLabel : function(value, old){

      this.__clearButton.setValue(value);
    },
    _render : function(){

      var tmpModel = this.__selectionList.getModel();
      this.__selectionList.setModel(null);
      this.__selectionList.setModel(tmpModel);
    },
    scrollToItem : function(index){

      if(index !== null && this.__selectionList.getModel() != null){

        var listItems = qxWeb("#" + this.__listScroller.getId() + " .list-item");
        var targetListItemElement = listItems[index];
        this.__listScroller.scrollToElement(targetListItemElement);
      };
    }
  },
  destruct : function(){

    this.__selectionList.removeListener("tap", this._onSelectionListTap, this);
    this._disposeObjects("__selectionList", "__clearButton", "__listScroller", "__menuContainer");
  }
});

qx.Class.define("qx.ui.mobile.list.List", {
  extend : qx.ui.mobile.core.Widget,
  construct : function(delegate){

    this.base(arguments);
    this.__provider = new qx.ui.mobile.list.provider.Provider(this);
    this.addListener("tap", this._onTap, this);
    this.addListener("trackstart", this._onTrackStart, this);
    this.addListener("track", this._onTrack, this);
    this.addListener("trackend", this._onTrackEnd, this);
    if(delegate){

      this.setDelegate(delegate);
    };
    if(qx.core.Environment.get("qx.dynlocale")){

      qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
    };
  },
  events : {
    changeSelection : "qx.event.type.Data",
    changeGroupSelection : "qx.event.type.Data",
    removeItem : "qx.event.type.Data"
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "list"
    },
    delegate : {
      apply : "_applyDelegate",
      event : "changeDelegate",
      init : null,
      nullable : true
    },
    model : {
      check : "qx.data.Array",
      apply : "_applyModel",
      event : "changeModel",
      nullable : true,
      init : null
    },
    itemCount : {
      check : "Integer",
      init : 0
    }
  },
  members : {
    __provider : null,
    __minDeleteDistance : null,
    __isScrollingBlocked : null,
    __trackElement : null,
    _getTagName : function(){

      return "ul";
    },
    _onTap : function(evt){

      var element = this._getElement(evt);
      if(!element){

        return;
      };
      var row = -1;
      if(qx.bom.element.Class.has(element, "list-item")){

        if(qx.bom.element.Attribute.get(element, "data-selectable") != "false" && qx.dom.Element.hasChild(this.getContainerElement(), element)){

          row = parseInt(element.getAttribute("data-row"), 10);
        };
        if(row != -1){

          this.fireDataEvent("changeSelection", row);
        };
      } else {

        var group = parseInt(element.getAttribute("data-group"), 10);
        if(qx.bom.element.Attribute.get(element, "data-selectable") != "false"){

          this.fireDataEvent("changeGroupSelection", group);
        };
      };
    },
    _onTrackStart : function(evt){

      this.__isScrollingBlocked = null;
      this.__trackElement = null;
      var element = this._getElement(evt);
      if(element && qx.bom.element.Class.has(element, "list-item") && qx.bom.element.Class.has(element, "removable")){

        this.__trackElement = element;
        this.__minDeleteDistance = qx.bom.element.Dimension.getWidth(element) / 2;
        qx.bom.element.Class.add(element, "track");
      };
    },
    _onTrack : function(evt){

      if(!this.__trackElement){

        return;
      };
      var element = this.__trackElement;
      var delta = evt.getDelta();
      var deltaX = Math.round(delta.x * 0.1) / 0.1;
      if(this.__isScrollingBlocked === null){

        this.__isScrollingBlocked = (delta.axis == "x");
      };
      if(!this.__isScrollingBlocked){

        return;
      };
      var opacity = 1 - (Math.abs(deltaX) / this.__minDeleteDistance);
      opacity = Math.round(opacity * 100) / 100;
      qx.bom.element.Style.set(element, "transform", "translate3d(" + deltaX + "px,0,0)");
      qx.bom.element.Style.set(element, "opacity", opacity);
      evt.preventDefault();
    },
    _onTrackEnd : function(evt){

      if(!this.__trackElement){

        return;
      };
      var element = this.__trackElement;
      if(Math.abs(evt.getDelta().x) > this.__minDeleteDistance){

        var row = parseInt(element.getAttribute("data-row"), 10);
        this.fireDataEvent("removeItem", row);
      } else {

        qx.bom.AnimationFrame.request(function(){

          qx.bom.element.Style.set(element, "transform", "translate3d(0,0,0)");
          qx.bom.element.Style.set(element, "opacity", "1");
          qx.bom.element.Class.remove(element, "track");
        }.bind(this));
      };
    },
    _getElement : function(evt){

      var element = evt.getOriginalTarget();
      if(element.tagName == "UL"){

        return null;
      };
      while(element.tagName != "LI"){

        element = element.parentNode;
      };
      return element;
    },
    _applyModel : function(value, old){

      if(old != null){

        old.removeListener("changeBubble", this.__onModelChangeBubble, this);
      };
      if(value != null){

        value.addListener("changeBubble", this.__onModelChangeBubble, this);
      };
      if(old != null){

        old.removeListener("change", this.__onModelChange, this);
      };
      if(value != null){

        value.addListener("change", this.__onModelChange, this);
      };
      if(old != null){

        old.removeListener("changeLength", this.__onModelChangeLength, this);
      };
      if(value != null){

        value.addListener("changeLength", this.__onModelChangeLength, this);
      };
      this.__render();
    },
    _applyDelegate : function(value, old){

      this.__provider.setDelegate(value);
    },
    __onModelChangeLength : function(evt){

      this.__render();
    },
    _onChangeLocale : qx.core.Environment.select("qx.dynlocale", {
      "true" : function(e){

        this.__render();
      },
      "false" : null
    }),
    __onModelChange : function(evt){

      if(evt && evt.getData() && evt.getData().type == "order"){

        this.__render();
      };
    },
    __onModelChangeBubble : function(evt){

      if(evt){

        var data = evt.getData();
        var isArray = (qx.lang.Type.isArray(data.old) && qx.lang.Type.isArray(data.value));
        if(!isArray || (isArray && data.old.length == data.value.length)){

          var rows = this._extractRowsToRender(data.name);
          for(var i = 0;i < rows.length;i++){

            this.__renderRow(rows[i]);
          };
        };
      };
    },
    _extractRowsToRender : function(name){

      var rows = [];
      if(!name){

        return rows;
      };
      var containsPoint = (name.indexOf(".") != -1);
      if(containsPoint){

        var candidate = name.split(".")[0];
        candidate = candidate.replace("[", "");
        candidate = candidate.replace("]", "");
        var isRange = (candidate.indexOf("-") != -1);
        if(isRange){

          var rangeMembers = candidate.split("-");
          var startRange = parseInt(rangeMembers[0], 10);
          var endRange = parseInt(rangeMembers[1], 10);
          for(var i = startRange;i <= endRange;i++){

            rows.push(i);
          };
        } else {

          rows.push(parseInt(candidate.match(/\d+/)[0], 10));
        };
      } else {

        var match = name.match(/\d+/);
        if(match.length == 1){

          rows.push(parseInt(match[0], 10));
        };
      };
      return rows;
    },
    __renderRow : function(index){

      var renderedItems = qx.bom.Selector.query(".list-item", this.getContentElement());
      var oldNode = renderedItems[index];
      var newNode = this.__provider.getItemElement(this.getModel().getItem(index), index);
      this.getContentElement().replaceChild(newNode, oldNode);
      this._domUpdated();
    },
    getListItemHeight : function(){

      var listItemHeight = 0;
      if(this.getModel() != null && this.getModel().length > 0){

        var listHeight = qx.bom.element.Style.get(this.getContentElement(), "height");
        listItemHeight = parseInt(listHeight) / this.getModel().length;
      };
      return listItemHeight;
    },
    __render : function(){

      this._setHtml("");
      var model = this.getModel();
      this.setItemCount(model ? model.getLength() : 0);
      var groupIndex = 0;
      for(var index = 0;index < this.getItemCount();index++){

        if(this.__hasGroup()){

          var groupElement = this._renderGroup(index, groupIndex);
          if(groupElement){

            groupIndex++;
            this.getContentElement().appendChild(groupElement);
          };
        };
        var item = model.getItem(index);
        this.getContentElement().appendChild(this.__provider.getItemElement(item, index));
      };
      this._domUpdated();
    },
    _renderGroup : function(itemIndex, groupIndex){

      var group = this.__getGroup(itemIndex);
      if(itemIndex === 0){

        return this.__provider.getGroupElement(group, groupIndex);
      } else {

        var previousGroup = this.__getGroup(itemIndex - 1);
        if(!qx.lang.Object.equals(group, previousGroup)){

          return this.__provider.getGroupElement(group, groupIndex);
        };
      };
    },
    __hasGroup : function(){

      return qx.util.Delegate.getMethod(this.getDelegate(), "group") !== null;
    },
    __getGroup : function(index){

      var item = this.getModel().getItem(index);
      var group = qx.util.Delegate.getMethod(this.getDelegate(), "group");
      return group(item, index);
    }
  },
  destruct : function(){

    this.__trackElement = null;
    this._disposeObjects("__provider");
    if(qx.core.Environment.get("qx.dynlocale")){

      qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
    };
  }
});

qx.Class.define("qx.ui.mobile.list.provider.Provider", {
  extend : qx.core.Object,
  properties : {
    delegate : {
      event : "changeDelegate",
      init : null,
      nullable : true,
      apply : "_applyDelegate"
    }
  },
  members : {
    __itemRenderer : null,
    __groupRenderer : null,
    _setItemRenderer : function(renderer){

      this.__itemRenderer = renderer;
    },
    _getItemRenderer : function(){

      return this.__itemRenderer;
    },
    _setGroupRenderer : function(renderer){

      this.__groupRenderer = renderer;
    },
    _getGroupRenderer : function(){

      return this.__groupRenderer;
    },
    getItemElement : function(data, row){

      this.__itemRenderer.reset();
      this._configureItem(data, row);
      var clone = qx.bom.Element.clone(this.__itemRenderer.getContainerElement(), true);
      clone.setAttribute("data-row", row);
      return clone;
    },
    getGroupElement : function(data, group){

      this.__groupRenderer.reset();
      this._configureGroupItem(data, group);
      var clone = qx.bom.Element.clone(this.__groupRenderer.getContainerElement(), true);
      clone.removeAttribute("id");
      clone.setAttribute("data-group", group);
      return clone;
    },
    _configureItem : function(data, row){

      var delegate = this.getDelegate();
      if(delegate != null && delegate.configureItem != null){

        delegate.configureItem(this.__itemRenderer, data, row);
      };
    },
    _configureGroupItem : function(data, group){

      var configureGroupItem = qx.util.Delegate.getMethod(this.getDelegate(), "configureGroupItem");
      if(configureGroupItem){

        configureGroupItem(this.__groupRenderer, data, group);
      };
    },
    _createGroupRenderer : function(){

      var createGroupRenderer = qx.util.Delegate.getMethod(this.getDelegate(), "createGroupRenderer");
      var groupRenderer = null;
      if(createGroupRenderer == null){

        groupRenderer = new qx.ui.mobile.list.renderer.group.Default();
      } else {

        groupRenderer = createGroupRenderer();
      };
      return groupRenderer;
    },
    _createItemRenderer : function(){

      var createItemRenderer = qx.util.Delegate.getMethod(this.getDelegate(), "createItemRenderer");
      var itemRenderer = null;
      if(createItemRenderer == null){

        itemRenderer = new qx.ui.mobile.list.renderer.Default();
      } else {

        itemRenderer = createItemRenderer();
      };
      return itemRenderer;
    },
    _applyDelegate : function(value, old){

      this._setItemRenderer(this._createItemRenderer());
      this._setGroupRenderer(this._createGroupRenderer());
    }
  },
  destruct : function(){

    this._disposeObjects("__itemRenderer", "__groupRenderer");
  }
});

qx.Class.define("qx.util.Delegate", {
  statics : {
    getMethod : function(delegate, specificMethod){

      if(qx.util.Delegate.containsMethod(delegate, specificMethod)){

        return qx.lang.Function.bind(delegate[specificMethod], delegate);
      };
      return null;
    },
    containsMethod : function(delegate, specificMethod){

      var Type = qx.lang.Type;
      if(Type.isObject(delegate)){

        return Type.isFunction(delegate[specificMethod]);
      };
      return false;
    }
  }
});

qx.Class.define("qx.ui.mobile.list.renderer.group.Abstract", {
  extend : qx.ui.mobile.container.Composite,
  type : "abstract",
  construct : function(layout){

    this.base(arguments, layout);
    this.initSelectable();
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "group-item"
    },
    selectable : {
      check : "Boolean",
      init : false,
      apply : "_applyAttribute"
    },
    activatable : {
      refine : true,
      init : true
    }
  },
  members : {
    reset : function(){

      if(qx.core.Environment.get("qx.debug")){

        throw new Error("Abstract method call");
      };
    },
    _getTagName : function(){

      return "li";
    }
  }
});

qx.Class.define("qx.ui.mobile.list.renderer.group.Default", {
  extend : qx.ui.mobile.list.renderer.group.Abstract,
  construct : function(layout){

    this.base(arguments, layout || new qx.ui.mobile.layout.HBox().set({
      alignY : "middle"
    }));
    this._init();
  },
  members : {
    __image : null,
    __title : null,
    __rightContainer : null,
    getImageWidget : function(){

      return this.__image;
    },
    getTitleWidget : function(){

      return this.__title;
    },
    setImage : function(source){

      this.__image.setSource(source);
    },
    setTitle : function(title){

      if(title && title.translate){

        this.__title.setValue(title.translate());
      } else {

        this.__title.setValue(title);
      };
    },
    setGroup : function(groupTitle){

      this._setAttribute("data-group", groupTitle);
    },
    _init : function(){

      this.__image = this._createImage();
      this.add(this.__image);
      this.__rightContainer = this._createRightContainer();
      this.add(this.__rightContainer, {
        flex : 1
      });
      this.__title = this._createTitle();
      this.__rightContainer.add(this.__title);
    },
    _createRightContainer : function(){

      return new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox());
    },
    _createImage : function(){

      var image = new qx.ui.mobile.basic.Image();
      image.setAnonymous(true);
      image.addCssClass("group-item-image");
      return image;
    },
    _createTitle : function(){

      var title = new qx.ui.mobile.basic.Label();
      title.setWrap(false);
      title.addCssClass("group-item-title");
      return title;
    },
    reset : function(){

      this.__image.setSource(null);
      this.__title.setValue("");
    }
  },
  destruct : function(){

    this._disposeObjects("__image", "__title", "__rightContainer");
  }
});

qx.Class.define("qx.ui.mobile.list.renderer.Abstract", {
  extend : qx.ui.mobile.container.Composite,
  type : "abstract",
  construct : function(layout){

    this.base(arguments, layout);
    this.initSelectable();
    this.initRemovable();
    this.initShowArrow();
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "list-item"
    },
    selected : {
      check : "Boolean",
      init : false,
      apply : "_applySelected"
    },
    selectable : {
      check : "Boolean",
      init : true,
      apply : "_applyAttribute"
    },
    removable : {
      check : "Boolean",
      init : false,
      apply : "_applyRemovable"
    },
    showArrow : {
      check : "Boolean",
      init : false,
      apply : "_applyShowArrow"
    },
    activatable : {
      refine : true,
      init : true
    }
  },
  members : {
    reset : function(){

      if(qx.core.Environment.get("qx.debug")){

        throw new Error("Abstract method call");
      };
    },
    _getTagName : function(){

      return "li";
    },
    getRowIndexFromEvent : function(evt){

      return this.getRowIndex(evt.getOriginalTarget());
    },
    getRowIndex : function(element){

      while(element.tagName != "LI"){

        element = element.parentNode;
      };
      return element.getAttribute("data-row");
    },
    _applyShowArrow : function(value, old){

      if(value){

        this.addCssClass("arrow");
      } else {

        this.removeCssClass("arrow");
      };
    },
    _applyRemovable : function(value, old){

      if(value){

        this.addCssClass("removable");
      } else {

        this.removeCssClass("removable");
      };
    },
    _applySelected : function(value, old){

      if(value){

        this.addCssClass("selected");
      } else {

        this.removeCssClass("selected");
      };
    }
  }
});

qx.Class.define("qx.ui.mobile.list.renderer.Default", {
  extend : qx.ui.mobile.list.renderer.Abstract,
  construct : function(layout){

    this.base(arguments, layout || new qx.ui.mobile.layout.HBox().set({
      alignY : "middle"
    }));
    this._init();
  },
  members : {
    __image : null,
    __title : null,
    __subtitle : null,
    __rightContainer : null,
    getImageWidget : function(){

      return this.__image;
    },
    getTitleWidget : function(){

      return this.__title;
    },
    getSubtitleWidget : function(){

      return this.__subtitle;
    },
    setImage : function(source){

      this.__image.setSource(source);
    },
    setTitle : function(title){

      if(title && title.translate){

        this.__title.setValue(title.translate());
      } else {

        this.__title.setValue(title);
      };
    },
    setSubtitle : function(subtitle){

      if(subtitle && subtitle.translate){

        this.__subtitle.setValue(subtitle.translate());
      } else {

        this.__subtitle.setValue(subtitle);
      };
    },
    _init : function(){

      this.__image = this._createImage();
      this.add(this.__image);
      this.__rightContainer = this._createRightContainer();
      this.add(this.__rightContainer, {
        flex : 1
      });
      this.__title = this._createTitle();
      this.__rightContainer.add(this.__title);
      this.__subtitle = this._createSubtitle();
      this.__rightContainer.add(this.__subtitle);
    },
    _createRightContainer : function(){

      return new qx.ui.mobile.container.Composite(new qx.ui.mobile.layout.VBox());
    },
    _createImage : function(){

      var image = new qx.ui.mobile.basic.Image();
      image.setAnonymous(true);
      image.addCssClass("list-item-image");
      return image;
    },
    _createTitle : function(){

      var title = new qx.ui.mobile.basic.Label();
      title.setWrap(false);
      title.addCssClass("list-item-title");
      return title;
    },
    _createSubtitle : function(){

      var subtitle = new qx.ui.mobile.basic.Label();
      subtitle.setWrap(false);
      subtitle.addCssClass("list-item-subtitle");
      return subtitle;
    },
    reset : function(){

      this.__image.setSource(null);
      this.__title.setValue("");
      this.__subtitle.setValue("");
    }
  },
  destruct : function(){

    this._disposeObjects("__image", "__title", "__subtitle", "__rightContainer");
  }
});

qx.Class.define("qx.ui.mobile.form.renderer.Single", {
  extend : qx.ui.mobile.form.renderer.AbstractRenderer,
  construct : function(form){

    this.__errorMessageContainers = [];
    this._rows = [];
    this._labels = [];
    this.base(arguments, form);
    this.addCssClass("single");
  },
  statics : {
    ONE_LINE_WIDGETS : [qx.ui.mobile.form.ToggleButton, qx.ui.mobile.form.RadioButton, qx.ui.mobile.form.TextField, qx.ui.mobile.form.PasswordField, qx.ui.mobile.form.NumberField, qx.ui.mobile.form.CheckBox, qx.ui.mobile.form.SelectBox]
  },
  members : {
    _rows : null,
    _labels : null,
    _onFormChange : function(){

      this._disposeArray("_labels");
      this._disposeArray("_rows");
      this._rows = [];
      this._labels = [];
      this.base(arguments);
    },
    __errorMessageContainers : null,
    _getTagName : function(){

      return "ul";
    },
    _isOneLineWidget : function(item){

      var widgets = qx.ui.mobile.form.renderer.Single.ONE_LINE_WIDGETS;
      for(var i = 0;i < widgets.length;i++){

        var widget = widgets[i];
        if(item instanceof widget){

          return true;
        };
      };
      return false;
    },
    addItems : function(items, names, title){

      if(title !== null){

        this._addGroupHeader(title);
      };
      this._addGroupHeaderRow();
      for(var i = 0,l = items.length;i < l;i++){

        var item = items[i];
        var name = names[i];
        var isLastItem = (i == items.length - 1);
        if(item instanceof qx.ui.mobile.form.TextArea){

          if(qx.core.Environment.get("qx.mobile.nativescroll") == false){

            this._addToScrollContainer(item, name);
          } else {

            this._addRow(item, name, new qx.ui.mobile.layout.VBox());
          };
        } else {

          if(this._isOneLineWidget(item)){

            this._addRow(item, name, new qx.ui.mobile.layout.HBox());
          } else {

            this._addRow(item, name, new qx.ui.mobile.layout.VBox());
          };
        };
        if(!item.isValid()){

          this.showErrorForItem(item);
        };
        if(!isLastItem){

          this._addSeparationRow();
        };
      };
      this._addGroupFooterRow();
    },
    _addInScrollComposite : function(item, name){

      this._addToScrollContainer(item, name);
    },
    _addToScrollContainer : function(item, name){

      var scrollContainer = new qx.ui.mobile.container.Scroll();
      scrollContainer.addCssClass("form-row-scroll");
      scrollContainer.add(item, {
        flex : 1
      });
      this._addRow(scrollContainer, name, new qx.ui.mobile.layout.VBox());
    },
    _addInSeparateLines : function(item, name){

      this._addRow(item, name, new qx.ui.mobile.layout.VBox());
    },
    _addInOneLine : function(item, name){

      this._addRow(item, name, new qx.ui.mobile.layout.HBox());
    },
    _addRow : function(item, name, layout){

      var row = new qx.ui.mobile.form.Row(layout);
      row.addCssClass("form-row-content");
      if(name !== null){

        var label = new qx.ui.mobile.form.Label(name);
        label.setLabelFor(item.getId());
        row.add(label, {
          flex : 1
        });
        this._labels.push(label);
      };
      row.add(item);
      this._add(row);
      this._rows.push(row);
    },
    _addSeparationRow : function(){

      var row = new qx.ui.mobile.form.Row();
      row.addCssClass("form-separation-row");
      this._add(row);
      this._rows.push(row);
    },
    _addGroupHeaderRow : function(){

      var row = new qx.ui.mobile.form.Row();
      row.addCssClass("form-row-group-first");
      this._add(row);
      this._rows.push(row);
    },
    _addGroupFooterRow : function(){

      var row = new qx.ui.mobile.form.Row();
      row.addCssClass("form-row-group-last");
      this._add(row);
      this._rows.push(row);
    },
    _addGroupHeader : function(title){

      var row = new qx.ui.mobile.form.Row();
      row.addCssClass("form-row-group-title");
      var titleLabel = new qx.ui.mobile.basic.Label(title);
      row.add(titleLabel);
      this._add(row);
      this._labels.push(titleLabel);
      this._rows.push(row);
    },
    addButton : function(button){

      var row = new qx.ui.mobile.form.Row(new qx.ui.mobile.layout.HBox());
      row.add(button, {
        flex : 1
      });
      this._add(row);
      this._rows.push(row);
    },
    showErrorForItem : function(item){

      var errorNode = qx.dom.Element.create('div');
      errorNode.innerHTML = item.getInvalidMessage();
      qx.bom.element.Class.add(errorNode, 'form-element-error');
      qx.dom.Element.insertAfter(errorNode, this._getParentRow(item).getContainerElement());
      this.__errorMessageContainers.push(errorNode);
    },
    showItem : function(item){

      this._getParentRow(item).removeCssClass("exclude");
    },
    hideItem : function(item){

      this._getParentRow(item).addCssClass("exclude");
    },
    _getParentRow : function(item){

      var parent = item.getLayoutParent();
      while(!parent.hasCssClass("form-row")){

        parent = parent.getLayoutParent();
      };
      return parent;
    },
    resetForm : function(){

      for(var i = 0;i < this.__errorMessageContainers.length;i++){

        qx.dom.Element.remove(this.__errorMessageContainers[i]);
      };
    }
  },
  destruct : function(){

    this.resetForm();
    this._disposeArray("_labels");
    this._disposeArray("_rows");
  }
});

qx.Class.define("qx.ui.mobile.form.TextArea", {
  extend : qx.ui.mobile.core.Widget,
  include : [qx.ui.mobile.form.MValue, qx.ui.mobile.form.MText, qx.ui.form.MForm, qx.ui.form.MModelProperty, qx.ui.mobile.form.MState],
  implement : [qx.ui.form.IForm, qx.ui.form.IModel],
  construct : function(value){

    this.base(arguments);
    if(qx.core.Environment.get("qx.mobile.nativescroll") == false){

      this.addListener("appear", this._fixChildElementsHeight, this);
      this.addListener("input", this._fixChildElementsHeight, this);
      this.addListener("changeValue", this._fixChildElementsHeight, this);
    };
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "text-area"
    }
  },
  members : {
    _getTagName : function(){

      return "textarea";
    },
    _fixChildElementsHeight : function(evt){

      this.getContentElement().style.height = 'auto';
      this.getContentElement().style.height = this.getContentElement().scrollHeight + 'px';
      var scroll = this.__getScrollContainer();
      if(scroll){

        scroll.refresh();
      };
    },
    __getScrollContainer : function(){

      var scroll = this;
      while(!(scroll instanceof qx.ui.mobile.container.Scroll)){

        if(scroll.getLayoutParent){

          var layoutParent = scroll.getLayoutParent();
          if(layoutParent == null || layoutParent instanceof qx.ui.mobile.core.Root){

            return null;
          };
          scroll = layoutParent;
        } else {

          return null;
        };
      };
      return scroll;
    }
  },
  destruct : function(){

    if(qx.core.Environment.get("qx.mobile.nativescroll") == false){

      this.removeListener("appear", this._fixChildElementsHeight, this);
      this.removeListener("input", this._fixChildElementsHeight, this);
      this.removeListener("changeValue", this._fixChildElementsHeight, this);
    };
  }
});

qx.Class.define("qx.ui.mobile.form.Row", {
  extend : qx.ui.mobile.container.Composite,
  construct : function(layout){

    this.base(arguments, layout);
    this.initSelectable();
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "form-row"
    },
    selectable : {
      check : "Boolean",
      init : false,
      apply : "_applyAttribute"
    }
  },
  members : {
    _getTagName : function(){

      return "li";
    }
  }
});

qx.Class.define("qx.ui.mobile.form.Label", {
  extend : qx.ui.mobile.core.Widget,
  construct : function(value){

    this.base(arguments);
    if(value){

      this.setValue(value);
    };
    this.addCssClass("gap");
    this._setLayout(new qx.ui.mobile.layout.HBox().set({
      "alignY" : "middle",
      "alignX" : "left"
    }));
    this.initWrap();
    if(qx.core.Environment.get("qx.dynlocale")){

      qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
    };
    this.addListener("tap", this._onTap, this);
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "label"
    },
    value : {
      nullable : true,
      init : null,
      apply : "_applyValue",
      event : "changeValue"
    },
    anonymous : {
      refine : true,
      init : false
    },
    wrap : {
      check : "Boolean",
      init : true,
      apply : "_applyWrap"
    }
  },
  members : {
    __forWidget : null,
    _getTagName : function(){

      return "label";
    },
    _applyValue : function(value, old){

      var html = value;
      if(qx.core.Environment.get("css.flexboxSyntax") === "flexbox"){

        html = "<p>" + value + "</p>";
      };
      this._setHtml(html);
    },
    _applyWrap : function(value, old){

      if(value){

        this.removeCssClass("no-wrap");
      } else {

        this.addCssClass("no-wrap");
      };
    },
    _changeEnabled : function(evt){

      if(evt){

        this.setEnabled(evt.getData());
      };
    },
    setLabelFor : function(elementId){

      if(this.__forWidget){

        this.__forWidget.removeListener("changeEnabled", this._changeEnabled, this);
      };
      this.__forWidget = qx.ui.mobile.core.Widget.getWidgetById(elementId);
      if(this.__forWidget){

        this.__forWidget.addListener("changeEnabled", this._changeEnabled, this);
        this.setEnabled(this.__forWidget.getEnabled());
      };
      this._setAttribute("for", elementId);
    },
    _onTap : function(evt){

      if(this.__forWidget && qx.core.Environment.get("event.dispatchevent")){

        var target = this.__forWidget.getContentElement();
        qx.event.Registration.fireEvent(target, "tap", qx.event.type.Tap, [evt.getNativeEvent(), target, null, true, true]);
      };
    },
    _onChangeLocale : qx.core.Environment.select("qx.dynlocale", {
      "true" : function(e){

        var content = this.getValue();
        if(content && content.translate){

          this.setValue(content.translate());
        };
      },
      "false" : null
    })
  },
  destruct : function(){

    this.removeListener("tap", this._onTap, this);
    if(this.__forWidget){

      this.__forWidget.removeListener("changeEnabled", this._changeEnabled, this);
      this.__forWidget = null;
    };
  }
});

qx.Class.define("mobile.page.Overview", {
  extend : qx.ui.mobile.page.NavigationPage,
  construct : function(){

    this.base(arguments);
    this.setTitle("Overview");
  },
  events : {
    "show" : "qx.event.type.Data"
  },
  members : {
    _initialize : function(){

      this.base(arguments);
      var list = new qx.ui.mobile.list.List({
        configureItem : function(item, data, row){

          item.setTitle(data.title);
          item.setSubtitle(data.subtitle);
          item.setShowArrow(true);
        }
      });
      var data = [{
        title : "Basic Widgets",
        subtitle : "Buttons, Labels, Images, Atoms...",
        path : "testhtml"
      }, {
        title : "Dialog Widgets",
        subtitle : "Popups, Confirm Dialogs...",
        path : "dialog"
      }, {
        title : "Form Elements",
        subtitle : "TextField, TextArea, Checkboxes...",
        path : "form"
      }, {
        title : "List",
        subtitle : "A large list",
        path : "list"
      }, {
        title : "Carousel",
        subtitle : "A carousel container",
        path : "carousel"
      }, {
        title : "Drawer",
        subtitle : "Create a drawer container",
        path : "drawer"
      }, {
        title : "Tab Bar",
        subtitle : "Using tabs to switch views",
        path : "tab"
      }, {
        title : "Toolbar",
        subtitle : "Toolbar buttons and separators",
        path : "toolbar"
      }, {
        title : "Maps",
        subtitle : "Geolocation on a fullscreen map",
        path : "maps"
      }, {
        title : "Canvas",
        subtitle : "Draw onto a HTML5 canvas",
        path : "canvas"
      }, {
        title : "Events",
        subtitle : "Touch, Tap, Swipe...",
        path : "event"
      }, {
        title : "Data Binding",
        subtitle : "See how data binding works",
        path : "databinding"
      }, {
        title : "Page Transitions",
        subtitle : "Slide, Fade, Cube...",
        path : "animation"
      }, {
        title : "Theming",
        subtitle : "Modify the look of an app...",
        path : "theming"
      }];
      list.setModel(new qx.data.Array(data));
      list.addListener("changeSelection", function(evt){

        var path = data[evt.getData()].path;
        qx.core.Init.getApplication().getRouting().executeGet("/" + path);
      }, this);
      this.getContent().add(list);
    }
  }
});

qx.Mixin.define("qx.data.marshal.MEventBubbling", {
  events : {
    "changeBubble" : "qx.event.type.Data"
  },
  members : {
    _applyEventPropagation : function(value, old, name){

      this.fireDataEvent("changeBubble", {
        value : value,
        name : name,
        old : old,
        item : this
      });
      this._registerEventChaining(value, old, name);
    },
    _registerEventChaining : function(value, old, name){

      if(old != null && old.getUserData && old.getUserData("idBubble-" + this.$$hash) != null){

        var listeners = old.getUserData("idBubble-" + this.$$hash);
        for(var i = 0;i < listeners.length;i++){

          old.removeListenerById(listeners[i]);
        };
        old.setUserData("idBubble-" + this.$$hash, null);
      };
      if((value instanceof qx.core.Object) && qx.Class.hasMixin(value.constructor, qx.data.marshal.MEventBubbling)){

        var listener = qx.lang.Function.bind(this.__changePropertyListener, this, name);
        var id = value.addListener("changeBubble", listener, this);
        var listeners = value.getUserData("idBubble-" + this.$$hash);
        if(listeners == null){

          listeners = [];
          value.setUserData("idBubble-" + this.$$hash, listeners);
        };
        listeners.push(id);
      };
    },
    __changePropertyListener : function(name, e){

      var data = e.getData();
      var value = data.value;
      var old = data.old;
      if(qx.Class.hasInterface(e.getTarget().constructor, qx.data.IListData)){

        if(data.name.indexOf){

          var dotIndex = data.name.indexOf(".") != -1 ? data.name.indexOf(".") : data.name.length;
          var bracketIndex = data.name.indexOf("[") != -1 ? data.name.indexOf("[") : data.name.length;
          if(bracketIndex == 0){

            var newName = name + data.name;
          } else if(dotIndex < bracketIndex){

            var index = data.name.substring(0, dotIndex);
            var rest = data.name.substring(dotIndex + 1, data.name.length);
            if(rest[0] != "["){

              rest = "." + rest;
            };
            var newName = name + "[" + index + "]" + rest;
          } else if(bracketIndex < dotIndex){

            var index = data.name.substring(0, bracketIndex);
            var rest = data.name.substring(bracketIndex, data.name.length);
            var newName = name + "[" + index + "]" + rest;
          } else {

            var newName = name + "[" + data.name + "]";
          };;
        } else {

          var newName = name + "[" + data.name + "]";
        };
      } else {

        if(parseInt(name) == name && name !== ""){

          name = "[" + name + "]";
        };
        var newName = name + "." + data.name;
      };
      this.fireDataEvent("changeBubble", {
        value : value,
        name : newName,
        old : old,
        item : data.item || e.getTarget()
      });
    }
  }
});

qx.Class.define("qx.data.Array", {
  extend : qx.core.Object,
  include : qx.data.marshal.MEventBubbling,
  implement : [qx.data.IListData],
  construct : function(param){

    this.base(arguments);
    if(param == undefined){

      this.__array = [];
    } else if(arguments.length > 1){

      this.__array = [];
      for(var i = 0;i < arguments.length;i++){

        this.__array.push(arguments[i]);
      };
    } else if(typeof param == "number"){

      this.__array = new Array(param);
    } else if(param instanceof Array){

      this.__array = qx.lang.Array.clone(param);
    } else {

      this.__array = [];
      this.dispose();
      throw new Error("Type of the parameter not supported!");
    };;;
    for(var i = 0;i < this.__array.length;i++){

      this._applyEventPropagation(this.__array[i], null, i);
    };
    this.__updateLength();
    if(qx.core.Environment.get("qx.debug")){

      this[0] = "Please use 'toArray()' to see the content.";
    };
  },
  properties : {
    autoDisposeItems : {
      check : "Boolean",
      init : false
    }
  },
  events : {
    "change" : "qx.event.type.Data",
    "changeLength" : "qx.event.type.Data"
  },
  members : {
    __array : null,
    concat : function(array){

      if(array){

        var newArray = this.__array.concat(array);
      } else {

        var newArray = this.__array.concat();
      };
      return new qx.data.Array(newArray);
    },
    join : function(connector){

      return this.__array.join(connector);
    },
    pop : function(){

      var item = this.__array.pop();
      this.__updateLength();
      this._registerEventChaining(null, item, this.length - 1);
      this.fireDataEvent("changeBubble", {
        value : [],
        name : this.length + "",
        old : [item],
        item : this
      });
      this.fireDataEvent("change", {
        start : this.length - 1,
        end : this.length - 1,
        type : "remove",
        removed : [item],
        added : []
      }, null);
      return item;
    },
    push : function(varargs){

      for(var i = 0;i < arguments.length;i++){

        this.__array.push(arguments[i]);
        this.__updateLength();
        this._registerEventChaining(arguments[i], null, this.length - 1);
        this.fireDataEvent("changeBubble", {
          value : [arguments[i]],
          name : (this.length - 1) + "",
          old : [],
          item : this
        });
        this.fireDataEvent("change", {
          start : this.length - 1,
          end : this.length - 1,
          type : "add",
          added : [arguments[i]],
          removed : []
        }, null);
      };
      return this.length;
    },
    reverse : function(){

      if(this.length == 0){

        return;
      };
      var oldArray = this.__array.concat();
      this.__array.reverse();
      this.__updateEventPropagation(0, this.length);
      this.fireDataEvent("change", {
        start : 0,
        end : this.length - 1,
        type : "order",
        added : [],
        removed : []
      }, null);
      this.fireDataEvent("changeBubble", {
        value : this.__array,
        name : "0-" + (this.__array.length - 1),
        old : oldArray,
        item : this
      });
    },
    shift : function(){

      if(this.length == 0){

        return;
      };
      var item = this.__array.shift();
      this.__updateLength();
      this._registerEventChaining(null, item, this.length - 1);
      this.__updateEventPropagation(0, this.length);
      this.fireDataEvent("changeBubble", {
        value : [],
        name : "0",
        old : [item],
        item : this
      });
      this.fireDataEvent("change", {
        start : 0,
        end : this.length - 1,
        type : "remove",
        removed : [item],
        added : []
      }, null);
      return item;
    },
    slice : function(from, to){

      return new qx.data.Array(this.__array.slice(from, to));
    },
    splice : function(startIndex, amount, varargs){

      var oldLength = this.__array.length;
      var returnArray = this.__array.splice.apply(this.__array, arguments);
      if(this.__array.length != oldLength){

        this.__updateLength();
      } else if(amount == arguments.length - 2){

        var addedItems = qx.lang.Array.fromArguments(arguments, 2);
        for(var i = 0;i < addedItems.length;i++){

          if(addedItems[i] !== returnArray[i]){

            break;
          };
          if(i == addedItems.length - 1){

            return new qx.data.Array();
          };
        };
      };
      var removed = amount > 0;
      var added = arguments.length > 2;
      if(removed || added){

        var addedItems = qx.lang.Array.fromArguments(arguments, 2);
        if(returnArray.length == 0){

          var type = "add";
          var end = startIndex + addedItems.length;
        } else if(addedItems.length == 0){

          var type = "remove";
          var end = this.length - 1;
        } else {

          var type = "add/remove";
          var end = startIndex + Math.abs(addedItems.length - returnArray.length);
        };
        this.fireDataEvent("change", {
          start : startIndex,
          end : end,
          type : type,
          added : addedItems,
          removed : returnArray
        }, null);
      };
      for(var i = 0;i < returnArray.length;i++){

        this._registerEventChaining(null, returnArray[i], i);
      };
      for(var i = 2;i < arguments.length;i++){

        this._registerEventChaining(arguments[i], null, startIndex + (i - 2));
      };
      this.__updateEventPropagation(startIndex + (arguments.length - 2) - amount, this.length);
      var value = [];
      for(var i = 2;i < arguments.length;i++){

        value[i - 2] = arguments[i];
      };
      var endIndex = (startIndex + Math.max(arguments.length - 3, amount - 1));
      var name = startIndex == endIndex ? endIndex : startIndex + "-" + endIndex;
      this.fireDataEvent("changeBubble", {
        value : value,
        name : name + "",
        old : returnArray,
        item : this
      });
      return (new qx.data.Array(returnArray));
    },
    sort : function(func){

      if(this.length == 0){

        return;
      };
      var oldArray = this.__array.concat();
      this.__array.sort.apply(this.__array, arguments);
      if(qx.lang.Array.equals(this.__array, oldArray) === true){

        return;
      };
      this.__updateEventPropagation(0, this.length);
      this.fireDataEvent("change", {
        start : 0,
        end : this.length - 1,
        type : "order",
        added : [],
        removed : []
      }, null);
      this.fireDataEvent("changeBubble", {
        value : this.__array,
        name : "0-" + (this.length - 1),
        old : oldArray,
        item : this
      });
    },
    unshift : function(varargs){

      for(var i = arguments.length - 1;i >= 0;i--){

        this.__array.unshift(arguments[i]);
        this.__updateLength();
        this.__updateEventPropagation(0, this.length);
        this.fireDataEvent("changeBubble", {
          value : [this.__array[0]],
          name : "0",
          old : [this.__array[1]],
          item : this
        });
        this.fireDataEvent("change", {
          start : 0,
          end : this.length - 1,
          type : "add",
          added : [arguments[i]],
          removed : []
        }, null);
      };
      return this.length;
    },
    toArray : function(){

      return this.__array;
    },
    getItem : function(index){

      return this.__array[index];
    },
    setItem : function(index, item){

      var oldItem = this.__array[index];
      if(oldItem === item){

        return;
      };
      this.__array[index] = item;
      this._registerEventChaining(item, oldItem, index);
      if(this.length != this.__array.length){

        this.__updateLength();
      };
      this.fireDataEvent("changeBubble", {
        value : [item],
        name : index + "",
        old : [oldItem],
        item : this
      });
      this.fireDataEvent("change", {
        start : index,
        end : index,
        type : "add/remove",
        added : [item],
        removed : [oldItem]
      }, null);
    },
    getLength : function(){

      return this.length;
    },
    indexOf : function(item){

      return this.__array.indexOf(item);
    },
    lastIndexOf : function(item){

      return this.__array.lastIndexOf(item);
    },
    toString : function(){

      if(this.__array != null){

        return this.__array.toString();
      };
      return "";
    },
    contains : function(item){

      return this.__array.indexOf(item) !== -1;
    },
    copy : function(){

      return this.concat();
    },
    insertAt : function(index, item){

      this.splice(index, 0, item).dispose();
    },
    insertBefore : function(before, item){

      var index = this.indexOf(before);
      if(index == -1){

        this.push(item);
      } else {

        this.splice(index, 0, item).dispose();
      };
    },
    insertAfter : function(after, item){

      var index = this.indexOf(after);
      if(index == -1 || index == (this.length - 1)){

        this.push(item);
      } else {

        this.splice(index + 1, 0, item).dispose();
      };
    },
    removeAt : function(index){

      var returnArray = this.splice(index, 1);
      var item = returnArray.getItem(0);
      returnArray.dispose();
      return item;
    },
    removeAll : function(){

      for(var i = 0;i < this.__array.length;i++){

        this._registerEventChaining(null, this.__array[i], i);
      };
      if(this.getLength() == 0){

        return [];
      };
      var oldLength = this.getLength();
      var items = this.__array.concat();
      this.__array.length = 0;
      this.__updateLength();
      this.fireDataEvent("changeBubble", {
        value : [],
        name : "0-" + (oldLength - 1),
        old : items,
        item : this
      });
      this.fireDataEvent("change", {
        start : 0,
        end : oldLength - 1,
        type : "remove",
        removed : items,
        added : []
      }, null);
      return items;
    },
    append : function(array){

      if(array instanceof qx.data.Array){

        array = array.toArray();
      };
      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert.assertArray(array, "The parameter must be an array.");
      };
      Array.prototype.push.apply(this.__array, array);
      for(var i = 0;i < array.length;i++){

        this._registerEventChaining(array[i], null, this.__array.length + i);
      };
      var oldLength = this.length;
      this.__updateLength();
      var name = oldLength == (this.length - 1) ? oldLength : oldLength + "-" + (this.length - 1);
      this.fireDataEvent("changeBubble", {
        value : array,
        name : name + "",
        old : [],
        item : this
      });
      this.fireDataEvent("change", {
        start : oldLength,
        end : this.length - 1,
        type : "add",
        added : array,
        removed : []
      }, null);
    },
    remove : function(item){

      var index = this.indexOf(item);
      if(index != -1){

        this.splice(index, 1).dispose();
        return item;
      };
    },
    equals : function(array){

      if(this.length !== array.length){

        return false;
      };
      for(var i = 0;i < this.length;i++){

        if(this.getItem(i) !== array.getItem(i)){

          return false;
        };
      };
      return true;
    },
    sum : function(){

      var result = 0;
      for(var i = 0;i < this.length;i++){

        result += this.getItem(i);
      };
      return result;
    },
    max : function(){

      var result = this.getItem(0);
      for(var i = 1;i < this.length;i++){

        if(this.getItem(i) > result){

          result = this.getItem(i);
        };
      };
      return result === undefined ? null : result;
    },
    min : function(){

      var result = this.getItem(0);
      for(var i = 1;i < this.length;i++){

        if(this.getItem(i) < result){

          result = this.getItem(i);
        };
      };
      return result === undefined ? null : result;
    },
    forEach : function(callback, context){

      for(var i = 0;i < this.__array.length;i++){

        callback.call(context, this.__array[i], i, this);
      };
    },
    filter : function(callback, self){

      return new qx.data.Array(this.__array.filter(callback, self));
    },
    map : function(callback, self){

      return new qx.data.Array(this.__array.map(callback, self));
    },
    some : function(callback, self){

      return this.__array.some(callback, self);
    },
    every : function(callback, self){

      return this.__array.every(callback, self);
    },
    reduce : function(callback, initValue){

      return this.__array.reduce(callback, initValue);
    },
    reduceRight : function(callback, initValue){

      return this.__array.reduceRight(callback, initValue);
    },
    __updateLength : function(){

      var oldLength = this.length;
      this.length = this.__array.length;
      this.fireDataEvent("changeLength", this.length, oldLength);
    },
    __updateEventPropagation : function(from, to){

      for(var i = from;i < to;i++){

        this._registerEventChaining(this.__array[i], this.__array[i], i);
      };
    }
  },
  destruct : function(){

    for(var i = 0;i < this.__array.length;i++){

      var item = this.__array[i];
      this._applyEventPropagation(null, item, i);
      if(this.isAutoDisposeItems() && item && item instanceof qx.core.Object){

        item.dispose();
      };
    };
    this.__array = null;
  }
});

qx.Class.define("mobile.page.Basic", {
  extend : mobile.page.Abstract,
  construct : function(){

    this.base(arguments, false);
    this.setTitle("Basic Widgets");
    this._widgets = [];
  },
  members : {
    _widgets : null,
    _initialize : function(){

      this.base(arguments);
      this.getContent().add(new qx.ui.mobile.form.Title("Widget Modes"));
      var toggleEnableButton = new qx.ui.mobile.form.ToggleButton(true, "Enable", "Disable");
      toggleEnableButton.addListener("changeValue", function(e){

        for(var i = 0;i < this._widgets.length;i++){

          this._widgets[i].toggleEnabled();
        };
      }, this);
      var toggleLabelWrapButton = new qx.ui.mobile.form.ToggleButton(true, "Wrap", "Ellipsis");
      toggleLabelWrapButton.addListener("changeValue", function(e){

        exLabel.toggleWrap();
      }, this);
      var exButton = new qx.ui.mobile.form.Button("Button");
      var exToggleButton = new qx.ui.mobile.form.ToggleButton(false);
      var labelText = "qx.Mobile is a sophisticated HTML5 framework. It provides specific UI widgets for touch devices, handling of mobile events like swiping, custom theming and much more. It is suitable for mobile web browsers on platforms such as Android, iOS, WP8 or BlackBerry 10.";
      var exLabel = new qx.ui.mobile.basic.Label(labelText);
      exLabel.addCssClass("space-top");
      var exImage = new qx.ui.mobile.basic.Image("mobile/icon/mobile.png");
      var positions = ["top", "left", "right", "bottom"];
      var iconSrc = "mobile/icon/mobile.png";
      var atomGroup = new qx.ui.mobile.form.Group();
      for(var i = 0;i < positions.length;i++){

        var atomExample = new qx.ui.mobile.basic.Atom("Icon Position: " + positions[i], iconSrc);
        atomExample.setIconPosition(positions[i]);
        atomGroup.add(atomExample);
        this._widgets.push(atomExample);
      };
      var exCollapsible = this._createCollapsible();
      this._widgets.push(exButton);
      this._widgets.push(exToggleButton);
      this._widgets.push(exLabel);
      this._widgets.push(exImage);
      this._widgets.push(exCollapsible);
      var menuGroup = new qx.ui.mobile.form.Group([toggleEnableButton, toggleLabelWrapButton]);
      this.getContent().add(menuGroup);
      this.getContent().add(new qx.ui.mobile.form.Title("Button"));
      var buttonGroup = new qx.ui.mobile.form.Group([exButton], false);
      this.getContent().add(buttonGroup);
      this.getContent().add(new qx.ui.mobile.form.Title("ToggleButton"));
      var toggleButtonGroup = new qx.ui.mobile.form.Group;
      toggleButtonGroup.add(exToggleButton);
      this.getContent().add(toggleButtonGroup);
      this.getContent().add(new qx.ui.mobile.form.Title("Label"));
      this.getContent().add(new qx.ui.mobile.form.Group([exLabel]));
      this.getContent().add(new qx.ui.mobile.form.Title("Image"));
      this.getContent().add(new qx.ui.mobile.form.Group([exImage], false));
      this.getContent().add(new qx.ui.mobile.form.Title("Collapsible"));
      this.getContent().add(new qx.ui.mobile.form.Group([exCollapsible], false));
      this.getContent().add(new qx.ui.mobile.form.Title("Atoms"));
      this.getContent().add(atomGroup);
    },
    _createCollapsible : function(){

      var collapsible = new qx.ui.mobile.container.Collapsible("Collapsible Header");
      var label = new qx.ui.mobile.basic.Label("This is the content of the Collapsible.");
      collapsible.add(label);
      return collapsible;
    }
  }
});

qx.Class.define("qx.ui.mobile.form.Title", {
  extend : qx.ui.mobile.basic.Label,
  properties : {
    wrap : {
      refine : true,
      init : false
    },
    defaultCssClass : {
      refine : true,
      init : "form-title"
    }
  },
  members : {
    _getTagName : function(){

      return "h2";
    }
  }
});

qx.Class.define("qx.ui.mobile.form.Group", {
  extend : qx.ui.mobile.container.Composite,
  construct : function(widgets, showBorder){

    this.base(arguments);
    this.addCssClass("bordered");
    if(showBorder != null){

      this.setShowBorder(showBorder);
    };
    if(widgets){

      for(var i = 0;i < widgets.length;i++){

        this.add(widgets[i]);
      };
    };
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "group"
    },
    showBorder : {
      check : "Boolean",
      init : true,
      apply : "_onChangeShowBorder"
    }
  },
  members : {
    _onChangeShowBorder : function(){

      if(this.isShowBorder() == true){

        this.addCssClass("bordered");
      } else {

        this.removeCssClass("bordered");
      };
    }
  }
});

qx.Class.define("qx.ui.mobile.container.Collapsible", {
  extend : qx.ui.mobile.core.Widget,
  construct : function(title){

    this.base(arguments);
    this._header = this._createHeader();
    this._header.addCssClass("collapsible-header");
    this._header.addListener("tap", this.toggleCollapsed, this);
    this.setTitle(title);
    this._content = this._createContent();
    this._content.addCssClass("collapsible-content");
    this._add(this._header);
    this._add(this._content);
    this.initCollapsed();
    this.initCombined();
    this.addCssClass("gap");
  },
  properties : {
    defaultCssClass : {
      refine : true,
      init : "collapsible"
    },
    collapsed : {
      check : "Boolean",
      init : true,
      nullable : false,
      apply : "_applyCollapsed",
      event : "changeCollapsed"
    },
    combined : {
      check : "Boolean",
      init : true,
      apply : "_applyCombined"
    }
  },
  members : {
    _header : null,
    _content : null,
    add : function(child, layoutProperties){

      if(child && this._content instanceof qx.ui.mobile.container.Composite){

        this._content.add(child, layoutProperties);
      };
    },
    setTitle : function(title){

      if(title && this._header instanceof qx.ui.mobile.basic.Label){

        this._header.setValue(title);
      };
    },
    getHeader : function(){

      return this._header;
    },
    getContent : function(){

      return this._content;
    },
    _createHeader : function(){

      var header = new qx.ui.mobile.basic.Label();
      header.setAnonymous(false);
      header.setActivatable(true);
      return header;
    },
    _createContent : function(){

      return new qx.ui.mobile.container.Composite();
    },
    _applyCollapsed : function(value, old){

      if(value === true){

        this._content.exclude();
        this.addCssClass("collapsed");
      } else {

        this._content.show();
        this.removeCssClass("collapsed");
      };
    },
    _applyCombined : function(value, old){

      if(value === true){

        this.addCssClass("combined");
      } else {

        this.removeCssClass("combined");
      };
    }
  },
  destruct : function(){

    this._header.removeListener("tap", this.toggleCollapsed, this);
    this._disposeObjects("_header", "_content");
  }
});

qx.Class.define("mobile.page.Testhtml", {
  extend : qx.ui.mobile.page.NavigationPage,
  construct : function(){

    this.base(arguments);
    this.setTitle("Overview");
    this.setShowBackButton(true);
    this.setBackButtonText("Back");
  },
  members : {
    _initialize : function(){

      this.base(arguments);
      this.getContent().add(new qx.ui.mobile.basic.Label("Your first app."));
      var e = new qx.ui.mobile.embed.Html(this._getHtml("s4", "index.html"));
      this.getContent().add(e);
    },
    _getHtml : function(namespace, name){

      ms123.util.Remote._username = "admin";
      ms123.util.Remote._password = "admin";
      return ms123.util.Remote.rpcSync("docbook:getHtml", {
        namespace : namespace,
        name : name
      });
    },
    _back : function(){

      qx.core.Init.getApplication().getRouting().back();
    }
  }
});

qx.Class.define("qx.ui.mobile.embed.Html", {
  extend : qx.ui.mobile.core.Widget,
  construct : function(html){

    this.base(arguments);
    if(html){

      this.setHtml(html);
    };
  },
  properties : {
    html : {
      check : "String",
      init : null,
      nullable : true,
      event : "changeHtml",
      apply : "_applyHtml"
    }
  },
  members : {
    _applyHtml : function(value, old){

      this._setHtml(value);
    }
  }
});

qx.Class.define("ms123.util.Remote", {
  statics : {
    _username : "",
    _password : "",
    _lastuse : 0,
    _sessionTimeout : 60 * 1000 * 30,
    _getPassword : function(){

      var now = new Date().getTime();
      var time = now - ms123.util.Remote._lastuse;
      if(ms123.util.Remote._lastuse != 0 && time > ms123.util.Remote._sessionTimeout){

        ms123.form.Dialog.alert(qx.locale.Manager.tr('util.remote.session-timeout'), function(e){

          window.location.reload();
        });
      } else {

        ms123.util.Remote._lastuse = new Date().getTime();
      };
      return ms123.util.Remote._password;
    },
    _getUserName : function(){

      return ms123.util.Remote._username;
    },
    sendSync : function(url, method, type, data, msg){

      var params = {
        url : url,
        method : method,
        type : type,
        data : data,
        async : false,
        msg : msg
      };
      return ms123.util.Remote.send(params);
    },
    rpcSync : function(dummy, parameter){

      if(arguments.length < 1){

        throw "RpcSync not enough args";
      };
      var s = arguments[0].split(":");
      if(s.length != 2){

        throw "RpcSync wrong arg(service:method)";
      };
      var service = s[0];
      var method = s[1];
      var newArgs = [];
      newArgs.push(method);
      for(var i = 1;i < arguments.length;i++){

        newArgs.push(arguments[i]);
      };
      var namespace = "xyz";
      if(parameter && parameter.namespace){

        namespace = parameter.namespace;
      };
      var rpc = new ms123.util.Rpc("/rpc/" + namespace, service);
      rpc.setUsername(ms123.util.Remote._getUserName());
      rpc.setPassword(ms123.util.Remote._getPassword());
      rpc.setUseBasicHttpAuth(true);
      rpc.setTimeout(5000000);
      if(newArgs.length == 0)newArgs.push({
      });
      var result = rpc.callSync.apply(rpc, newArgs);
      return result;
    },
    rpcAsync : function(params){

      if(params.async != null && params.async == false){

        try{

          var result = ms123.util.Remote.rpcSync(params.service + ":" + params.method, params.parameter);
          if(params.completed)params.completed.call(params.context, result);
          return result;
        } catch(ex) {

          if(params.failed)params.failed.call(params.context, ex); else throw ex;
        };
      } else {

        var namespace = "xyz";
        if(params.parameter && params.parameter.namespace){

          namespace = params.parameter.namespace;
        };
        var rpc = new ms123.util.Rpc("/rpc/" + namespace, params.service);
        rpc.setUsername(ms123.util.Remote._getUserName());
        rpc.setPassword(ms123.util.Remote._getPassword());
        rpc.setUseBasicHttpAuth(true);
        rpc.setTimeout(5000000);
        var handler = function(result, ex){

          if(ex == null){

            params.completed.call(params.context, result);
          } else {

            params.failed.call(params.context, ex);
          };
        };
        rpc.callAsync(handler, params.method, params.parameter);
      };
    },
    send : function(params){

      var ret = null;
      var url = params.url;
      var method = (params.method != null) ? params.method : "GET";
      var type = (params.type != null) ? params.type : "application/json";
      var async = (params.async != null) ? params.async : false;
      var req = new qx.io.remote.Request(url, method, type);
      if(params.data != null){

        req.setData(params.data);
      };
      if(params.timeoutvalue != null){

        req.setTimeout(params.timeoutvalue);
      };
      if(params.contenttype != null){

        req.setRequestHeader("Content-Type", params.contenttype);
      };
      req.setAsynchronous(async);
      if(params.completed == null){

        req.addListener("completed", function(e){

          ret = e.getContent();
          if(params.msg != null){

            ms123.form.Dialog.alert(params.msg);
          };
        }, this);
      } else {

        req.addListener("completed", params.completed, params.context);
      };
      if(params.failed != null){

        req.addListener("failed", params.failed, params.context);
      };
      if(params.timeout != null){

        req.addListener("timeout", params.timeout, params.context);
      };
      req.setUsername(ms123.util.Remote._getUserName());
      req.setPassword(ms123.util.Remote._getPassword());
      req.setUseBasicHttpAuth(true);
      req.send();
      return ret;
    },
    setSessionTimeout : function(timeout){

      if(timeout == undefined)timeout = 60 * 1000 * 30;
      if(timeout == -1)timeout = 60 * 1000 * 30000;
      ms123.util.Remote._sessionTimeout = timeout;
    },
    setCredentials : function(username, password){

      ms123.util.Remote._username = username;
      ms123.util.Remote._password = password;
      ms123.util.Remote._lastuse = new Date().getTime();
    }
  }
});

qx.Mixin.define("qx.ui.core.MLayoutHandling", {
  members : {
    setLayout : function(layout){

      this._setLayout(layout);
    },
    getLayout : function(){

      return this._getLayout();
    }
  },
  statics : {
    remap : function(members){

      members.getLayout = members._getLayout;
      members.setLayout = members._setLayout;
    }
  }
});

qx.Mixin.define("qx.ui.core.MChildrenHandling", {
  members : {
    getChildren : function(){

      return this._getChildren();
    },
    hasChildren : function(){

      return this._hasChildren();
    },
    indexOf : function(child){

      return this._indexOf(child);
    },
    add : function(child, options){

      this._add(child, options);
    },
    addAt : function(child, index, options){

      this._addAt(child, index, options);
    },
    addBefore : function(child, before, options){

      this._addBefore(child, before, options);
    },
    addAfter : function(child, after, options){

      this._addAfter(child, after, options);
    },
    remove : function(child){

      this._remove(child);
    },
    removeAt : function(index){

      return this._removeAt(index);
    },
    removeAll : function(){

      return this._removeAll();
    }
  },
  statics : {
    remap : function(members){

      members.getChildren = members._getChildren;
      members.hasChildren = members._hasChildren;
      members.indexOf = members._indexOf;
      members.add = members._add;
      members.addAt = members._addAt;
      members.addBefore = members._addBefore;
      members.addAfter = members._addAfter;
      members.remove = members._remove;
      members.removeAt = members._removeAt;
      members.removeAll = members._removeAll;
    }
  }
});

qx.Class.define("qx.ui.container.Composite", {
  extend : qx.ui.core.Widget,
  include : [qx.ui.core.MChildrenHandling, qx.ui.core.MLayoutHandling],
  construct : function(layout){

    this.base(arguments);
    if(layout != null){

      this._setLayout(layout);
    };
  },
  events : {
    addChildWidget : "qx.event.type.Data",
    removeChildWidget : "qx.event.type.Data"
  },
  members : {
    _afterAddChild : function(child){

      this.fireNonBubblingEvent("addChildWidget", qx.event.type.Data, [child]);
    },
    _afterRemoveChild : function(child){

      this.fireNonBubblingEvent("removeChildWidget", qx.event.type.Data, [child]);
    }
  },
  defer : function(statics, members){

    qx.ui.core.MChildrenHandling.remap(members);
    qx.ui.core.MLayoutHandling.remap(members);
  }
});

qx.Class.define("ms123.form.Dialog", {
  extend : qx.ui.container.Composite,
  statics : {
    getInstanceByType : function(type){

      try{

        if(type == null)return "";
        return new ms123.form[qx.lang.String.firstUp(type)];
      } catch(e) {

        this.error(type + " is not a valid ms123.form type");
      };
    },
    alert : function(message, callback, context, inWindow){

      (new ms123.form.Alert({
        "message" : message,
        "callback" : callback || null,
        "context" : context || null,
        "inWindow" : inWindow !== undefined ? inWindow : true
      })).show();
    },
    confirm : function(message, callback, context, inWindow){

      (new ms123.form.Confirm({
        "message" : message,
        "callback" : callback || null,
        "context" : context || null,
        "inWindow" : inWindow !== undefined ? inWindow : true
      })).show();
    },
    prompt : function(message, callback, context, inWindow){

      (new ms123.form.Prompt({
        "message" : message,
        "callback" : callback || null,
        "context" : context || null,
        "inWindow" : inWindow !== undefined ? inWindow : true
      })).show();
    },
    select : function(message, options, callback, context, inWindow){

      (new ms123.form.Select({
        "message" : message,
        "allowCancel" : true,
        "options" : options,
        "callback" : callback || null,
        "context" : context || null,
        "inWindow" : inWindow !== undefined ? inWindow : true
      })).show();
    }
  },
  properties : {
    callback : {
      check : "Function",
      nullable : true
    },
    actionCallback : {
      check : "Function",
      nullable : true
    },
    context : {
      check : "Object",
      nullable : true
    },
    image : {
      check : "String",
      nullable : true,
      apply : "_applyImage"
    },
    message : {
      check : "String",
      nullable : true,
      apply : "_applyMessage"
    },
    useBlocker : {
      check : "Boolean",
      init : true
    },
    blockerColor : {
      check : "String",
      init : "black"
    },
    blockerOpacity : {
      check : "Number",
      init : 0.5
    },
    windowWidth : {
      check : "Number",
      init : 400
    },
    windowHeight : {
      check : "Number",
      init : 500
    },
    allowCancel : {
      check : "Boolean",
      init : true,
      event : "changeAllowCancel"
    },
    inWindow : {
      check : "Boolean",
      init : true
    },
    render : {
      check : "Boolean",
      init : true
    },
    useHtml : {
      check : "Boolean",
      init : false
    },
    noOkButton : {
      check : "Boolean",
      init : false
    },
    hide : {
      check : "Boolean",
      init : true
    },
    focusable : {
      refine : true,
      init : true
    }
  },
  events : {
    "show" : "qx.event.type.Event",
    "hide" : "qx.event.type.Event"
  },
  construct : function(properties){

    this.base(arguments);
    this.setLayout(new qx.ui.layout.Grow());
    var inWindow = true;
    var render = true;
    this._hasMessage = false;
    if(typeof properties == "object"){

      inWindow = (properties.inWindow !== undefined) ? properties.inWindow : true;
      render = (properties.render !== undefined) ? properties.render : true;
      this._hasMessage = (properties.message !== undefined) ? true : false;
      this._noOkButton = (properties.noOkButton !== undefined) ? properties.noOkButton : false;
      if(properties.actionCallback){

        this.setActionCallback(properties.actionCallback);
      };
      if(properties.useHtml){

        this.setUseHtml(properties.useHtml);
      };
      if(properties.windowWidth){

        this.setWindowWidth(properties.windowWidth);
      };
      if(properties.windowHeight){

        this.setWindowHeight(properties.windowHeight);
      };
    };
    if(inWindow && render){

      this._addToRoot(properties);
    };
    this._render = render;
    this._warn = false;
    if(properties.warn !== undefined){

      this._warn = properties.warn;
      delete properties.warn;
    };
    this._createWidgetContent();
    if(typeof properties == "object"){

      this.set(properties);
    } else if(typeof properties == "string"){

      this._hasMessage = true;
      this.setMessage(properties);
    };
  },
  members : {
    _image : null,
    _message : null,
    _okButton : null,
    _cancelButton : null,
    _inWindow : false,
    _render : true,
    _hide : true,
    _hasMessage : false,
    _createWidgetContent : function(){

      this.error("_createWidgetContent not implemented!");
    },
    _addToRoot : function(properties){

      this._inWindow = true;
      this.set({
        'visibility' : "hidden"
      });
      this.setLayout(new qx.ui.layout.Grow());
      var root = qx.core.Init.getApplication().getRoot();
      root.add(this);
      var maxWindowZIndex = 1E5;
      var windows = root.getWindows();
      for(var i = 0;i < windows.length;i++){

        var zIndex = windows[i].getZIndex();
        maxWindowZIndex = Math.max(maxWindowZIndex, zIndex);
      };
      this.setZIndex(maxWindowZIndex + 1);
      qx.ui.core.FocusHandler.getInstance().addRoot(this);
      this.getApplicationRoot().addListener("resize", function(e){

        var bounds = this.getBounds();
        this.set({
          marginTop : Math.round((qx.bom.Document.getHeight() - bounds.height) / 2),
          marginLeft : Math.round((qx.bom.Document.getWidth() - bounds.width) / 2)
        });
      }, this);
      this.addListener("appear", function(e){

        var bounds = this.getBounds();
        this.set({
          marginTop : Math.round((qx.bom.Document.getHeight() - bounds.height) / 2),
          marginLeft : Math.round((qx.bom.Document.getWidth() - bounds.width) / 2)
        });
      }, this);
    },
    _createButton : function(b){

      var button = new qx.ui.form.Button(b.label);
      button.setIcon(b.icon);
      button.setAllowStretchX(false);
      button.addListener("execute", function(){

        if(this.getCallback()){

          this.getCallback().call(this.getContext(), b.value);
        };
      }, this);
      b.button = button;
      return button;
    },
    _createOkButton : function(){

      var okButton = this._okButton = new qx.ui.form.Button(this.tr("OK"));
      okButton.setIcon("icon/22/actions/dialog-ok.png");
      okButton.setAllowStretchX(false);
      okButton.addListener("execute", this._handleOk, this);
      return okButton;
    },
    _createCancelButton : function(){

      var cancelButton = this._cancelButton = new qx.ui.form.Button(this.tr("Cancel"));
      cancelButton.setAllowStretchX(false);
      cancelButton.setIcon("icon/22/actions/dialog-cancel.png");
      cancelButton.addListener("execute", this._handleCancel, this);
      this.bind("allowCancel", cancelButton, "visibility", {
        converter : function(value){

          return value ? "visible" : "excluded";
        }
      });
      return cancelButton;
    },
    _applyImage : function(value, old){

      this._image.setSource(value);
      this._image.setVisibility(value ? "visible" : "excluded");
    },
    _applyMessage : function(value, old){

      this._message.setValue(value);
      this._message.setVisibility(value ? "visible" : "excluded");
    },
    show : function(){

      if(this.isUseBlocker()){

        this.__blocker = new qx.ui.core.Blocker(this.getApplicationRoot());
        this.__blocker.setColor(this.getBlockerColor());
        this.__blocker.setOpacity(this.getBlockerOpacity());
        this.__blocker.blockContent(this.getZIndex() - 1);
      };
      this.setVisibility("visible");
      this.__previousFocus = qx.ui.core.FocusHandler.getInstance().getActiveWidget();
      this.focus();
      this.fireEvent("show");
    },
    hide : function(){

      if(this._inWindow == false)return;
      this.setVisibility("hidden");
      if(this.isUseBlocker()){

        this.__blocker.forceUnblock();
      };
      if(this.__previousFocus){

        try{

          this.__previousFocus.focus();
        } catch(e) {
        };
      };
      this.fireEvent("hide");
    },
    _handleOk : function(){

      if(this._hide)this.hide();
      if(this.getCallback()){

        this.getCallback().call(this.getContext(), true);
      };
      this.resetCallback();
    },
    _handleCancel : function(){

      if(this._hide)this.hide();
      if(this.getCallback()){

        this.getCallback().call(this.getContext());
      };
      this.resetCallback();
    }
  },
  defer : function(){

    ms123.form["alert"] = ms123.form.Dialog.alert;
    ms123.form["confirm"] = ms123.form.Dialog.confirm;
    ms123.form["prompt"] = ms123.form.Dialog.prompt;
    ms123.form["select"] = ms123.form.Dialog.select;
    ms123.form["form"] = ms123.form.Dialog.form;
  }
});

qx.Class.define("ms123.form.Alert", {
  extend : ms123.form.Dialog,
  members : {
    _applyMessage : function(value, old){

      if(this.getUseHtml()){

        this._message.setHtml(value);
      } else {

        this._message.setValue(value);
        this._message.setVisibility(value ? "visible" : "excluded");
      };
    },
    _createWidgetContent : function(){

      var groupboxContainer = new qx.ui.groupbox.GroupBox().set({
        contentPadding : [16, 16, 16, 16]
      });
      groupboxContainer.setLayout(new qx.ui.layout.VBox(10));
      this.add(groupboxContainer);
      var hbox = new qx.ui.container.Composite;
      hbox.setLayout(new qx.ui.layout.HBox(10));
      groupboxContainer.add(hbox);
      this._image = new qx.ui.basic.Image("icon/48/status/dialog-information.png");
      hbox.add(this._image);
      if(this.getUseHtml()){

        this._message = new qx.ui.embed.Html();
        hbox.setWidth(this.getWindowWidth());
        hbox.setHeight(this.getWindowHeight());
        this._message.setOverflowY("auto");
        this._message.setOverflowX("auto");
        this._message.setAllowStretchY(true);
      } else {

        this._message = new qx.ui.basic.Label();
        this._message.setRich(true);
        this._message.setWidth(this.getWindowWidth());
      };
      this._message.setAllowStretchX(true);
      this._message.setSelectable(true);
      hbox.add(this._message, {
        flex : 1
      });
      var okButton = this._createOkButton();
      var buttonPane = new qx.ui.container.Composite;
      var bpLayout = new qx.ui.layout.HBox();
      bpLayout.setAlignX("center");
      buttonPane.setLayout(bpLayout);
      if(this._noOkButton == false){

        buttonPane.add(okButton);
      };
      groupboxContainer.add(buttonPane);
    }
  }
});

qx.Mixin.define("qx.ui.core.MRemoteChildrenHandling", {
  members : {
    __forward : function(functionName, a1, a2, a3){

      var container = this.getChildrenContainer();
      if(container === this){

        functionName = "_" + functionName;
      };
      return (container[functionName])(a1, a2, a3);
    },
    getChildren : function(){

      return this.__forward("getChildren");
    },
    hasChildren : function(){

      return this.__forward("hasChildren");
    },
    add : function(child, options){

      return this.__forward("add", child, options);
    },
    remove : function(child){

      return this.__forward("remove", child);
    },
    removeAll : function(){

      return this.__forward("removeAll");
    },
    indexOf : function(child){

      return this.__forward("indexOf", child);
    },
    addAt : function(child, index, options){

      this.__forward("addAt", child, index, options);
    },
    addBefore : function(child, before, options){

      this.__forward("addBefore", child, before, options);
    },
    addAfter : function(child, after, options){

      this.__forward("addAfter", child, after, options);
    },
    removeAt : function(index){

      return this.__forward("removeAt", index);
    }
  }
});

qx.Mixin.define("qx.ui.core.MRemoteLayoutHandling", {
  members : {
    setLayout : function(layout){

      this.getChildrenContainer().setLayout(layout);
    },
    getLayout : function(){

      return this.getChildrenContainer().getLayout();
    }
  }
});

qx.Mixin.define("qx.ui.core.MContentPadding", {
  properties : {
    contentPaddingTop : {
      check : "Integer",
      init : 0,
      apply : "_applyContentPadding",
      themeable : true
    },
    contentPaddingRight : {
      check : "Integer",
      init : 0,
      apply : "_applyContentPadding",
      themeable : true
    },
    contentPaddingBottom : {
      check : "Integer",
      init : 0,
      apply : "_applyContentPadding",
      themeable : true
    },
    contentPaddingLeft : {
      check : "Integer",
      init : 0,
      apply : "_applyContentPadding",
      themeable : true
    },
    contentPadding : {
      group : ["contentPaddingTop", "contentPaddingRight", "contentPaddingBottom", "contentPaddingLeft"],
      mode : "shorthand",
      themeable : true
    }
  },
  members : {
    __contentPaddingSetter : {
      contentPaddingTop : "setPaddingTop",
      contentPaddingRight : "setPaddingRight",
      contentPaddingBottom : "setPaddingBottom",
      contentPaddingLeft : "setPaddingLeft"
    },
    __contentPaddingThemedSetter : {
      contentPaddingTop : "setThemedPaddingTop",
      contentPaddingRight : "setThemedPaddingRight",
      contentPaddingBottom : "setThemedPaddingBottom",
      contentPaddingLeft : "setThemedPaddingLeft"
    },
    __contentPaddingResetter : {
      contentPaddingTop : "resetPaddingTop",
      contentPaddingRight : "resetPaddingRight",
      contentPaddingBottom : "resetPaddingBottom",
      contentPaddingLeft : "resetPaddingLeft"
    },
    _applyContentPadding : function(value, old, name, variant){

      var target = this._getContentPaddingTarget();
      if(value == null){

        var resetter = this.__contentPaddingResetter[name];
        target[resetter]();
      } else {

        if(variant == "setThemed" || variant == "resetThemed"){

          var setter = this.__contentPaddingThemedSetter[name];
          target[setter](value);
        } else {

          var setter = this.__contentPaddingSetter[name];
          target[setter](value);
        };
      };
    }
  }
});

qx.Class.define("qx.ui.groupbox.GroupBox", {
  extend : qx.ui.core.Widget,
  include : [qx.ui.core.MRemoteChildrenHandling, qx.ui.core.MRemoteLayoutHandling, qx.ui.core.MContentPadding, qx.ui.form.MForm],
  implement : [qx.ui.form.IForm],
  construct : function(legend, icon){

    this.base(arguments);
    this._setLayout(new qx.ui.layout.Canvas);
    this._createChildControl("frame");
    this._createChildControl("legend");
    if(legend != null){

      this.setLegend(legend);
    };
    if(icon != null){

      this.setIcon(icon);
    };
  },
  properties : {
    appearance : {
      refine : true,
      init : "groupbox"
    },
    legendPosition : {
      check : ["top", "middle"],
      init : "middle",
      apply : "_applyLegendPosition",
      themeable : true
    }
  },
  members : {
    _forwardStates : {
      invalid : true
    },
    _createChildControlImpl : function(id, hash){

      var control;
      switch(id){case "frame":
      control = new qx.ui.container.Composite();
      this._add(control, {
        left : 0,
        top : 6,
        right : 0,
        bottom : 0
      });
      break;case "legend":
      control = new qx.ui.basic.Atom();
      control.addListener("resize", this._repositionFrame, this);
      this._add(control, {
        left : 0,
        right : 0
      });
      break;};
      return control || this.base(arguments, id);
    },
    _getContentPaddingTarget : function(){

      return this.getChildControl("frame");
    },
    _applyLegendPosition : function(e){

      if(this.getChildControl("legend").getBounds()){

        this._repositionFrame();
      };
    },
    _repositionFrame : function(){

      var legend = this.getChildControl("legend");
      var frame = this.getChildControl("frame");
      var height = legend.getBounds().height;
      if(this.getLegendPosition() == "middle"){

        frame.setLayoutProperties({
          "top" : Math.round(height / 2)
        });
      } else if(this.getLegendPosition() == "top"){

        frame.setLayoutProperties({
          "top" : height
        });
      };
    },
    getChildrenContainer : function(){

      return this.getChildControl("frame");
    },
    setLegend : function(legend){

      var control = this.getChildControl("legend");
      if(legend !== null){

        control.setLabel(legend);
        control.show();
      } else {

        control.exclude();
      };
    },
    getLegend : function(){

      return this.getChildControl("legend").getLabel();
    },
    setIcon : function(icon){

      this.getChildControl("legend").setIcon(icon);
    },
    getIcon : function(){

      return this.getChildControl("legend").getIcon();
    }
  }
});

qx.Class.define("qx.ui.layout.Canvas", {
  extend : qx.ui.layout.Abstract,
  properties : {
    desktop : {
      check : "Boolean",
      init : false
    }
  },
  members : {
    verifyLayoutProperty : qx.core.Environment.select("qx.debug", {
      "true" : function(item, name, value){

        var layoutProperties = {
          top : 1,
          left : 1,
          bottom : 1,
          right : 1,
          width : 1,
          height : 1,
          edge : 1
        };
        this.assert(layoutProperties[name] == 1, "The property '" + name + "' is not supported by the Canvas layout!");
        if(name == "width" || name == "height"){

          this.assertMatch(value, qx.ui.layout.Util.PERCENT_VALUE);
        } else {

          if(typeof value === "number"){

            this.assertInteger(value);
          } else if(qx.lang.Type.isString(value)){

            this.assertMatch(value, qx.ui.layout.Util.PERCENT_VALUE);
          } else {

            this.fail("Bad format of layout property '" + name + "': " + value + ". The value must be either an integer or an percent string.");
          };
        };
      },
      "false" : null
    }),
    renderLayout : function(availWidth, availHeight, padding){

      var children = this._getLayoutChildren();
      var child,size,props;
      var left,top,right,bottom,width,height;
      var marginTop,marginRight,marginBottom,marginLeft;
      for(var i = 0,l = children.length;i < l;i++){

        child = children[i];
        size = child.getSizeHint();
        props = child.getLayoutProperties();
        marginTop = child.getMarginTop();
        marginRight = child.getMarginRight();
        marginBottom = child.getMarginBottom();
        marginLeft = child.getMarginLeft();
        left = props.left != null ? props.left : props.edge;
        if(qx.lang.Type.isString(left)){

          left = Math.round(parseFloat(left) * availWidth / 100);
        };
        right = props.right != null ? props.right : props.edge;
        if(qx.lang.Type.isString(right)){

          right = Math.round(parseFloat(right) * availWidth / 100);
        };
        top = props.top != null ? props.top : props.edge;
        if(qx.lang.Type.isString(top)){

          top = Math.round(parseFloat(top) * availHeight / 100);
        };
        bottom = props.bottom != null ? props.bottom : props.edge;
        if(qx.lang.Type.isString(bottom)){

          bottom = Math.round(parseFloat(bottom) * availHeight / 100);
        };
        if(left != null && right != null){

          width = availWidth - left - right - marginLeft - marginRight;
          if(width < size.minWidth){

            width = size.minWidth;
          } else if(width > size.maxWidth){

            width = size.maxWidth;
          };
          left += marginLeft;
        } else {

          width = props.width;
          if(width == null){

            width = size.width;
          } else {

            width = Math.round(parseFloat(width) * availWidth / 100);
            if(width < size.minWidth){

              width = size.minWidth;
            } else if(width > size.maxWidth){

              width = size.maxWidth;
            };
          };
          if(right != null){

            left = availWidth - width - right - marginRight - marginLeft;
          } else if(left == null){

            left = marginLeft;
          } else {

            left += marginLeft;
          };
        };
        if(top != null && bottom != null){

          height = availHeight - top - bottom - marginTop - marginBottom;
          if(height < size.minHeight){

            height = size.minHeight;
          } else if(height > size.maxHeight){

            height = size.maxHeight;
          };
          top += marginTop;
        } else {

          height = props.height;
          if(height == null){

            height = size.height;
          } else {

            height = Math.round(parseFloat(height) * availHeight / 100);
            if(height < size.minHeight){

              height = size.minHeight;
            } else if(height > size.maxHeight){

              height = size.maxHeight;
            };
          };
          if(bottom != null){

            top = availHeight - height - bottom - marginBottom - marginTop;
          } else if(top == null){

            top = marginTop;
          } else {

            top += marginTop;
          };
        };
        left += padding.left;
        top += padding.top;
        child.renderLayout(left, top, width, height);
      };
    },
    _computeSizeHint : function(){

      var neededWidth = 0,neededMinWidth = 0;
      var neededHeight = 0,neededMinHeight = 0;
      var width,minWidth;
      var height,minHeight;
      var children = this._getLayoutChildren();
      var child,props,hint;
      var desktop = this.isDesktop();
      var left,top,right,bottom;
      for(var i = 0,l = children.length;i < l;i++){

        child = children[i];
        props = child.getLayoutProperties();
        hint = child.getSizeHint();
        var marginX = child.getMarginLeft() + child.getMarginRight();
        var marginY = child.getMarginTop() + child.getMarginBottom();
        width = hint.width + marginX;
        minWidth = hint.minWidth + marginX;
        left = props.left != null ? props.left : props.edge;
        if(left && typeof left === "number"){

          width += left;
          minWidth += left;
        };
        right = props.right != null ? props.right : props.edge;
        if(right && typeof right === "number"){

          width += right;
          minWidth += right;
        };
        neededWidth = Math.max(neededWidth, width);
        neededMinWidth = desktop ? 0 : Math.max(neededMinWidth, minWidth);
        height = hint.height + marginY;
        minHeight = hint.minHeight + marginY;
        top = props.top != null ? props.top : props.edge;
        if(top && typeof top === "number"){

          height += top;
          minHeight += top;
        };
        bottom = props.bottom != null ? props.bottom : props.edge;
        if(bottom && typeof bottom === "number"){

          height += bottom;
          minHeight += bottom;
        };
        neededHeight = Math.max(neededHeight, height);
        neededMinHeight = desktop ? 0 : Math.max(neededMinHeight, minHeight);
      };
      return {
        width : neededWidth,
        minWidth : neededMinWidth,
        height : neededHeight,
        minHeight : neededMinHeight
      };
    }
  }
});

qx.Class.define("qx.ui.layout.Util", {
  statics : {
    PERCENT_VALUE : /[0-9]+(?:\.[0-9]+)?%/,
    computeFlexOffsets : function(flexibles, avail, used){

      var child,key,flexSum,flexStep;
      var grow = avail > used;
      var remaining = Math.abs(avail - used);
      var roundingOffset,currentOffset;
      var result = {
      };
      for(key in flexibles){

        child = flexibles[key];
        result[key] = {
          potential : grow ? child.max - child.value : child.value - child.min,
          flex : grow ? child.flex : 1 / child.flex,
          offset : 0
        };
      };
      while(remaining != 0){

        flexStep = Infinity;
        flexSum = 0;
        for(key in result){

          child = result[key];
          if(child.potential > 0){

            flexSum += child.flex;
            flexStep = Math.min(flexStep, child.potential / child.flex);
          };
        };
        if(flexSum == 0){

          break;
        };
        flexStep = Math.min(remaining, flexStep * flexSum) / flexSum;
        roundingOffset = 0;
        for(key in result){

          child = result[key];
          if(child.potential > 0){

            currentOffset = Math.min(remaining, child.potential, Math.ceil(flexStep * child.flex));
            roundingOffset += currentOffset - flexStep * child.flex;
            if(roundingOffset >= 1){

              roundingOffset -= 1;
              currentOffset -= 1;
            };
            child.potential -= currentOffset;
            if(grow){

              child.offset += currentOffset;
            } else {

              child.offset -= currentOffset;
            };
            remaining -= currentOffset;
          };
        };
      };
      return result;
    },
    computeHorizontalAlignOffset : function(align, width, availWidth, marginLeft, marginRight){

      if(marginLeft == null){

        marginLeft = 0;
      };
      if(marginRight == null){

        marginRight = 0;
      };
      var value = 0;
      switch(align){case "left":
      value = marginLeft;
      break;case "right":
      value = availWidth - width - marginRight;
      break;case "center":
      value = Math.round((availWidth - width) / 2);
      if(value < marginLeft){

        value = marginLeft;
      } else if(value < marginRight){

        value = Math.max(marginLeft, availWidth - width - marginRight);
      };
      break;};
      return value;
    },
    computeVerticalAlignOffset : function(align, height, availHeight, marginTop, marginBottom){

      if(marginTop == null){

        marginTop = 0;
      };
      if(marginBottom == null){

        marginBottom = 0;
      };
      var value = 0;
      switch(align){case "top":
      value = marginTop;
      break;case "bottom":
      value = availHeight - height - marginBottom;
      break;case "middle":
      value = Math.round((availHeight - height) / 2);
      if(value < marginTop){

        value = marginTop;
      } else if(value < marginBottom){

        value = Math.max(marginTop, availHeight - height - marginBottom);
      };
      break;};
      return value;
    },
    collapseMargins : function(varargs){

      var max = 0,min = 0;
      for(var i = 0,l = arguments.length;i < l;i++){

        var value = arguments[i];
        if(value < 0){

          min = Math.min(min, value);
        } else if(value > 0){

          max = Math.max(max, value);
        };
      };
      return max + min;
    },
    computeHorizontalGaps : function(children, spacing, collapse){

      if(spacing == null){

        spacing = 0;
      };
      var gaps = 0;
      if(collapse){

        gaps += children[0].getMarginLeft();
        for(var i = 1,l = children.length;i < l;i += 1){

          gaps += this.collapseMargins(spacing, children[i - 1].getMarginRight(), children[i].getMarginLeft());
        };
        gaps += children[l - 1].getMarginRight();
      } else {

        for(var i = 1,l = children.length;i < l;i += 1){

          gaps += children[i].getMarginLeft() + children[i].getMarginRight();
        };
        gaps += (spacing * (l - 1));
      };
      return gaps;
    },
    computeVerticalGaps : function(children, spacing, collapse){

      if(spacing == null){

        spacing = 0;
      };
      var gaps = 0;
      if(collapse){

        gaps += children[0].getMarginTop();
        for(var i = 1,l = children.length;i < l;i += 1){

          gaps += this.collapseMargins(spacing, children[i - 1].getMarginBottom(), children[i].getMarginTop());
        };
        gaps += children[l - 1].getMarginBottom();
      } else {

        for(var i = 1,l = children.length;i < l;i += 1){

          gaps += children[i].getMarginTop() + children[i].getMarginBottom();
        };
        gaps += (spacing * (l - 1));
      };
      return gaps;
    },
    computeHorizontalSeparatorGaps : function(children, spacing, separator){

      var instance = qx.theme.manager.Decoration.getInstance().resolve(separator);
      var insets = instance.getInsets();
      var width = insets.left + insets.right;
      var gaps = 0;
      for(var i = 0,l = children.length;i < l;i++){

        var child = children[i];
        gaps += child.getMarginLeft() + child.getMarginRight();
      };
      gaps += (spacing + width + spacing) * (l - 1);
      return gaps;
    },
    computeVerticalSeparatorGaps : function(children, spacing, separator){

      var instance = qx.theme.manager.Decoration.getInstance().resolve(separator);
      var insets = instance.getInsets();
      var height = insets.top + insets.bottom;
      var gaps = 0;
      for(var i = 0,l = children.length;i < l;i++){

        var child = children[i];
        gaps += child.getMarginTop() + child.getMarginBottom();
      };
      gaps += (spacing + height + spacing) * (l - 1);
      return gaps;
    },
    arrangeIdeals : function(beginMin, beginIdeal, beginMax, endMin, endIdeal, endMax){

      if(beginIdeal < beginMin || endIdeal < endMin){

        if(beginIdeal < beginMin && endIdeal < endMin){

          beginIdeal = beginMin;
          endIdeal = endMin;
        } else if(beginIdeal < beginMin){

          endIdeal -= (beginMin - beginIdeal);
          beginIdeal = beginMin;
          if(endIdeal < endMin){

            endIdeal = endMin;
          };
        } else if(endIdeal < endMin){

          beginIdeal -= (endMin - endIdeal);
          endIdeal = endMin;
          if(beginIdeal < beginMin){

            beginIdeal = beginMin;
          };
        };;
      };
      if(beginIdeal > beginMax || endIdeal > endMax){

        if(beginIdeal > beginMax && endIdeal > endMax){

          beginIdeal = beginMax;
          endIdeal = endMax;
        } else if(beginIdeal > beginMax){

          endIdeal += (beginIdeal - beginMax);
          beginIdeal = beginMax;
          if(endIdeal > endMax){

            endIdeal = endMax;
          };
        } else if(endIdeal > endMax){

          beginIdeal += (endIdeal - endMax);
          endIdeal = endMax;
          if(beginIdeal > beginMax){

            beginIdeal = beginMax;
          };
        };;
      };
      return {
        begin : beginIdeal,
        end : endIdeal
      };
    }
  }
});

qx.Class.define("qx.ui.basic.Atom", {
  extend : qx.ui.core.Widget,
  construct : function(label, icon){

    if(qx.core.Environment.get("qx.debug")){

      this.assertArgumentsCount(arguments, 0, 2);
    };
    this.base(arguments);
    this._setLayout(new qx.ui.layout.Atom());
    if(label != null){

      this.setLabel(label);
    };
    if(icon !== undefined){

      this.setIcon(icon);
    };
  },
  properties : {
    appearance : {
      refine : true,
      init : "atom"
    },
    label : {
      apply : "_applyLabel",
      nullable : true,
      check : "String",
      event : "changeLabel"
    },
    rich : {
      check : "Boolean",
      init : false,
      apply : "_applyRich"
    },
    icon : {
      check : "String",
      apply : "_applyIcon",
      nullable : true,
      themeable : true,
      event : "changeIcon"
    },
    gap : {
      check : "Integer",
      nullable : false,
      event : "changeGap",
      apply : "_applyGap",
      themeable : true,
      init : 4
    },
    show : {
      init : "both",
      check : ["both", "label", "icon"],
      themeable : true,
      inheritable : true,
      apply : "_applyShow",
      event : "changeShow"
    },
    iconPosition : {
      init : "left",
      check : ["top", "right", "bottom", "left", "top-left", "bottom-left", "top-right", "bottom-right"],
      themeable : true,
      apply : "_applyIconPosition"
    },
    center : {
      init : false,
      check : "Boolean",
      themeable : true,
      apply : "_applyCenter"
    }
  },
  members : {
    _createChildControlImpl : function(id, hash){

      var control;
      switch(id){case "label":
      control = new qx.ui.basic.Label(this.getLabel());
      control.setAnonymous(true);
      control.setRich(this.getRich());
      this._add(control);
      if(this.getLabel() == null || this.getShow() === "icon"){

        control.exclude();
      };
      break;case "icon":
      control = new qx.ui.basic.Image(this.getIcon());
      control.setAnonymous(true);
      this._addAt(control, 0);
      if(this.getIcon() == null || this.getShow() === "label"){

        control.exclude();
      };
      break;};
      return control || this.base(arguments, id);
    },
    _forwardStates : {
      focused : true,
      hovered : true
    },
    _handleLabel : function(){

      if(this.getLabel() == null || this.getShow() === "icon"){

        this._excludeChildControl("label");
      } else {

        this._showChildControl("label");
      };
    },
    _handleIcon : function(){

      if(this.getIcon() == null || this.getShow() === "label"){

        this._excludeChildControl("icon");
      } else {

        this._showChildControl("icon");
      };
    },
    _applyLabel : function(value, old){

      var label = this.getChildControl("label", true);
      if(label){

        label.setValue(value);
      };
      this._handleLabel();
    },
    _applyRich : function(value, old){

      var label = this.getChildControl("label", true);
      if(label){

        label.setRich(value);
      };
    },
    _applyIcon : function(value, old){

      var icon = this.getChildControl("icon", true);
      if(icon){

        icon.setSource(value);
      };
      this._handleIcon();
    },
    _applyGap : function(value, old){

      try{

        this._getLayout().setGap(value);
      } catch(e) {

        console.debug("setGap:" + e.stack);
      };
    },
    _applyShow : function(value, old){

      this._handleLabel();
      this._handleIcon();
    },
    _applyIconPosition : function(value, old){

      this._getLayout().setIconPosition(value);
    },
    _applyCenter : function(value, old){

      this._getLayout().setCenter(value);
    },
    _applySelectable : function(value, old){

      this.base(arguments, value, old);
      var label = this.getChildControl("label", true);
      if(label){

        this.getChildControl("label").setSelectable(value);
      };
    }
  }
});

qx.Class.define("qx.ui.layout.Atom", {
  extend : qx.ui.layout.Abstract,
  properties : {
    gap : {
      check : "Integer",
      init : 4,
      apply : "_applyLayoutChange"
    },
    iconPosition : {
      check : ["left", "top", "right", "bottom", "top-left", "bottom-left", "top-right", "bottom-right"],
      init : "left",
      apply : "_applyLayoutChange"
    },
    center : {
      check : "Boolean",
      init : false,
      apply : "_applyLayoutChange"
    }
  },
  members : {
    verifyLayoutProperty : qx.core.Environment.select("qx.debug", {
      "true" : function(item, name, value){

        this.assert(false, "The property '" + name + "' is not supported by the Atom layout!");
      },
      "false" : null
    }),
    renderLayout : function(availWidth, availHeight, padding){

      var left = padding.left;
      var top = padding.top;
      var Util = qx.ui.layout.Util;
      var iconPosition = this.getIconPosition();
      var children = this._getLayoutChildren();
      var length = children.length;
      var width,height;
      var child,hint;
      var gap = this.getGap();
      var center = this.getCenter();
      var allowedPositions = ["bottom", "right", "top-right", "bottom-right"];
      if(allowedPositions.indexOf(iconPosition) != -1){

        var start = length - 1;
        var end = -1;
        var increment = -1;
      } else {

        var start = 0;
        var end = length;
        var increment = 1;
      };
      if(iconPosition == "top" || iconPosition == "bottom"){

        if(center){

          var allocatedHeight = 0;
          for(var i = start;i != end;i += increment){

            height = children[i].getSizeHint().height;
            if(height > 0){

              allocatedHeight += height;
              if(i != start){

                allocatedHeight += gap;
              };
            };
          };
          top += Math.round((availHeight - allocatedHeight) / 2);
        };
        var childTop = top;
        for(var i = start;i != end;i += increment){

          child = children[i];
          hint = child.getSizeHint();
          width = Math.min(hint.maxWidth, Math.max(availWidth, hint.minWidth));
          height = hint.height;
          left = Util.computeHorizontalAlignOffset("center", width, availWidth) + padding.left;
          child.renderLayout(left, childTop, width, height);
          if(height > 0){

            childTop = top + height + gap;
          };
        };
      } else {

        var remainingWidth = availWidth;
        var shrinkTarget = null;
        var count = 0;
        for(var i = start;i != end;i += increment){

          child = children[i];
          width = child.getSizeHint().width;
          if(width > 0){

            if(!shrinkTarget && child instanceof qx.ui.basic.Label){

              shrinkTarget = child;
            } else {

              remainingWidth -= width;
            };
            count++;
          };
        };
        if(count > 1){

          var gapSum = (count - 1) * gap;
          remainingWidth -= gapSum;
        };
        if(shrinkTarget){

          var hint = shrinkTarget.getSizeHint();
          var shrinkTargetWidth = Math.max(hint.minWidth, Math.min(remainingWidth, hint.maxWidth));
          remainingWidth -= shrinkTargetWidth;
        };
        if(center && remainingWidth > 0){

          left += Math.round(remainingWidth / 2);
        };
        for(var i = start;i != end;i += increment){

          child = children[i];
          hint = child.getSizeHint();
          height = Math.min(hint.maxHeight, Math.max(availHeight, hint.minHeight));
          if(child === shrinkTarget){

            width = shrinkTargetWidth;
          } else {

            width = hint.width;
          };
          var align = "middle";
          if(iconPosition == "top-left" || iconPosition == "top-right"){

            align = "top";
          } else if(iconPosition == "bottom-left" || iconPosition == "bottom-right"){

            align = "bottom";
          };
          var childTop = top + Util.computeVerticalAlignOffset(align, hint.height, availHeight);
          child.renderLayout(left, childTop, width, height);
          if(width > 0){

            left += width + gap;
          };
        };
      };
    },
    _computeSizeHint : function(){

      var children = this._getLayoutChildren();
      var length = children.length;
      var hint,result;
      if(length === 1){

        var hint = children[0].getSizeHint();
        result = {
          width : hint.width,
          height : hint.height,
          minWidth : hint.minWidth,
          minHeight : hint.minHeight
        };
      } else {

        var minWidth = 0,width = 0;
        var minHeight = 0,height = 0;
        var iconPosition = this.getIconPosition();
        var gap = this.getGap();
        if(iconPosition === "top" || iconPosition === "bottom"){

          var count = 0;
          for(var i = 0;i < length;i++){

            hint = children[i].getSizeHint();
            width = Math.max(width, hint.width);
            minWidth = Math.max(minWidth, hint.minWidth);
            if(hint.height > 0){

              height += hint.height;
              minHeight += hint.minHeight;
              count++;
            };
          };
          if(count > 1){

            var gapSum = (count - 1) * gap;
            height += gapSum;
            minHeight += gapSum;
          };
        } else {

          var count = 0;
          for(var i = 0;i < length;i++){

            hint = children[i].getSizeHint();
            height = Math.max(height, hint.height);
            minHeight = Math.max(minHeight, hint.minHeight);
            if(hint.width > 0){

              width += hint.width;
              minWidth += hint.minWidth;
              count++;
            };
          };
          if(count > 1){

            var gapSum = (count - 1) * gap;
            width += gapSum;
            minWidth += gapSum;
          };
        };
        result = {
          minWidth : minWidth,
          width : width,
          minHeight : minHeight,
          height : height
        };
      };
      return result;
    }
  }
});

qx.Class.define("qx.ui.basic.Label", {
  extend : qx.ui.core.Widget,
  implement : [qx.ui.form.IStringForm],
  construct : function(value){

    this.base(arguments);
    if(value != null){

      this.setValue(value);
    };
    if(qx.core.Environment.get("qx.dynlocale")){

      qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
    };
  },
  properties : {
    rich : {
      check : "Boolean",
      init : false,
      event : "changeRich",
      apply : "_applyRich"
    },
    wrap : {
      check : "Boolean",
      init : true,
      apply : "_applyWrap"
    },
    value : {
      check : "String",
      apply : "_applyValue",
      event : "changeValue",
      nullable : true
    },
    buddy : {
      check : "qx.ui.core.Widget",
      apply : "_applyBuddy",
      nullable : true,
      init : null,
      dereference : true
    },
    textAlign : {
      check : ["left", "center", "right", "justify"],
      nullable : true,
      themeable : true,
      apply : "_applyTextAlign",
      event : "changeTextAlign"
    },
    appearance : {
      refine : true,
      init : "label"
    },
    selectable : {
      refine : true,
      init : false
    },
    allowGrowX : {
      refine : true,
      init : false
    },
    allowGrowY : {
      refine : true,
      init : false
    },
    allowShrinkY : {
      refine : true,
      init : false
    }
  },
  members : {
    __font : null,
    __invalidContentSize : null,
    __buddyEnabledBinding : null,
    __tapListenerId : null,
    __webfontListenerId : null,
    _getContentHint : function(){

      if(this.__invalidContentSize){

        this.__contentSize = this.__computeContentSize();
        delete this.__invalidContentSize;
      };
      return {
        width : this.__contentSize.width,
        height : this.__contentSize.height
      };
    },
    _hasHeightForWidth : function(){

      return this.getRich() && this.getWrap();
    },
    _applySelectable : function(value){

      if(!qx.core.Environment.get("css.textoverflow") && qx.core.Environment.get("html.xul")){

        if(value && !this.isRich()){

          if(qx.core.Environment.get("qx.debug")){

            this.warn("Only rich labels are selectable in browsers with Gecko engine!");
          };
          return;
        };
      };
      this.base(arguments, value);
    },
    _getContentHeightForWidth : function(width){

      if(!this.getRich() && !this.getWrap()){

        return null;
      };
      return this.__computeContentSize(width).height;
    },
    _createContentElement : function(){

      return new qx.html.Label;
    },
    _applyTextAlign : function(value, old){

      this.getContentElement().setStyle("textAlign", value);
    },
    _applyTextColor : function(value, old){

      if(value){

        this.getContentElement().setStyle("color", qx.theme.manager.Color.getInstance().resolve(value));
      } else {

        this.getContentElement().removeStyle("color");
      };
    },
    __contentSize : {
      width : 0,
      height : 0
    },
    _applyFont : function(value, old){

      if(old && this.__font && this.__webfontListenerId){

        this.__font.removeListenerById(this.__webfontListenerId);
        this.__webfontListenerId = null;
      };
      var styles;
      if(value){

        this.__font = qx.theme.manager.Font.getInstance().resolve(value);
        if(this.__font instanceof qx.bom.webfonts.WebFont){

          this.__webfontListenerId = this.__font.addListener("changeStatus", this._onWebFontStatusChange, this);
        };
        styles = this.__font.getStyles();
      } else {

        this.__font = null;
        styles = qx.bom.Font.getDefaultStyles();
      };
      if(this.getTextColor() != null){

        delete styles["color"];
      };
      this.getContentElement().setStyles(styles);
      this.__invalidContentSize = true;
      qx.ui.core.queue.Layout.add(this);
    },
    __computeContentSize : function(width){

      var Label = qx.bom.Label;
      var font = this.getFont();
      var styles = font ? this.__font.getStyles() : qx.bom.Font.getDefaultStyles();
      var content = this.getValue() || "A";
      var rich = this.getRich();
      if(this.__webfontListenerId){

        this.__fixEllipsis();
      };
      return rich ? Label.getHtmlSize(content, styles, width) : Label.getTextSize(content, styles);
    },
    __fixEllipsis : function(){

      if(!this.getContentElement()){

        return;
      };
      if(qx.core.Environment.get("os.name") == "osx" && qx.core.Environment.get("engine.name") == "gecko" && parseInt(qx.core.Environment.get("engine.version"), 10) < 16 && parseInt(qx.core.Environment.get("engine.version"), 10) > 9){

        var domEl = this.getContentElement().getDomElement();
        if(domEl){

          domEl.innerHTML = domEl.innerHTML;
        };
      };
    },
    _applyBuddy : function(value, old){

      if(old != null){

        old.removeBinding(this.__buddyEnabledBinding);
        this.__buddyEnabledBinding = null;
        this.removeListenerById(this.__tapListenerId);
        this.__tapListenerId = null;
      };
      if(value != null){

        this.__buddyEnabledBinding = value.bind("enabled", this, "enabled");
        this.__tapListenerId = this.addListener("tap", function(){

          if(value.isFocusable()){

            value.focus.apply(value);
          };
          if("toggleValue" in value && typeof value.toggleValue === "function"){

            value.toggleValue();
          };
        }, this);
      };
    },
    _applyRich : function(value){

      this.getContentElement().setRich(value);
      this.__invalidContentSize = true;
      qx.ui.core.queue.Layout.add(this);
    },
    _applyWrap : function(value, old){

      if(value && !this.isRich()){

        if(qx.core.Environment.get("qx.debug")){

          this.warn("Only rich labels support wrap.");
        };
      };
      if(this.isRich()){

        var whiteSpace = value ? "normal" : "nowrap";
        this.getContentElement().setStyle("whiteSpace", whiteSpace);
      };
    },
    _onChangeLocale : qx.core.Environment.select("qx.dynlocale", {
      "true" : function(e){

        var content = this.getValue();
        if(content && content.translate){

          this.setValue(content.translate());
        };
      },
      "false" : null
    }),
    _onWebFontStatusChange : function(ev){

      if(ev.getData().valid === true){

        this.__invalidContentSize = true;
        qx.ui.core.queue.Layout.add(this);
      };
    },
    _applyValue : function(value, old){

      this.getContentElement().setValue(value);
      this.__invalidContentSize = true;
      qx.ui.core.queue.Layout.add(this);
    }
  },
  destruct : function(){

    if(qx.core.Environment.get("qx.dynlocale")){

      qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
    };
    if(this.__buddyEnabledBinding != null){

      var buddy = this.getBuddy();
      if(buddy != null && !buddy.isDisposed()){

        buddy.removeBinding(this.__buddyEnabledBinding);
      };
    };
    if(this.__font && this.__webfontListenerId){

      this.__font.removeListenerById(this.__webfontListenerId);
    };
    this.__font = this.__buddyEnabledBinding = null;
  }
});

qx.Class.define("qx.html.Label", {
  extend : qx.html.Element,
  members : {
    __rich : null,
    _applyProperty : function(name, value){

      this.base(arguments, name, value);
      if(name == "value"){

        var element = this.getDomElement();
        qx.bom.Label.setValue(element, value);
      };
    },
    _createDomElement : function(){

      var rich = this.__rich;
      var el = qx.bom.Label.create(this._content, rich);
      return el;
    },
    _copyData : function(fromMarkup){

      return this.base(arguments, true);
    },
    setRich : function(value){

      var element = this.getDomElement();
      if(element){

        throw new Error("The label mode cannot be modified after initial creation");
      };
      value = !!value;
      if(this.__rich == value){

        return this;
      };
      this.__rich = value;
      return this;
    },
    setValue : function(value){

      this._setProperty("value", value);
      return this;
    },
    getValue : function(){

      return this._getProperty("value");
    }
  }
});

qx.Bootstrap.define("qx.bom.Label", {
  statics : {
    __styles : {
      fontFamily : 1,
      fontSize : 1,
      fontWeight : 1,
      fontStyle : 1,
      lineHeight : 1
    },
    __prepareText : function(){

      var el = this.__createMeasureElement(false);
      document.body.insertBefore(el, document.body.firstChild);
      return this._textElement = el;
    },
    __prepareHtml : function(){

      var el = this.__createMeasureElement(true);
      document.body.insertBefore(el, document.body.firstChild);
      return this._htmlElement = el;
    },
    __createMeasureElement : function(html){

      var el = qx.dom.Element.create("div");
      var style = el.style;
      style.width = style.height = "auto";
      style.left = style.top = "-1000px";
      style.visibility = "hidden";
      style.position = "absolute";
      style.overflow = "visible";
      style.display = "block";
      if(html){

        style.whiteSpace = "normal";
      } else {

        style.whiteSpace = "nowrap";
        if(!qx.core.Environment.get("css.textoverflow") && qx.core.Environment.get("html.xul")){

          var inner = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "label");
          var style = inner.style;
          style.padding = "0";
          style.margin = "0";
          style.width = "auto";
          for(var key in this.__styles){

            style[key] = "inherit";
          };
          el.appendChild(inner);
        };
      };
      return el;
    },
    __getStyles : function(html){

      var styles = {
      };
      if(html){

        styles.whiteSpace = "normal";
      } else if(!qx.core.Environment.get("css.textoverflow") && qx.core.Environment.get("html.xul")){

        styles.display = "block";
      } else {

        styles.overflow = "hidden";
        styles.whiteSpace = "nowrap";
        styles[qx.core.Environment.get("css.textoverflow")] = "ellipsis";
      };
      return styles;
    },
    create : function(content, html, win){

      if(!win){

        win = window;
      };
      var el = win.document.createElement("div");
      if(html){

        el.useHtml = true;
      } else if(!qx.core.Environment.get("css.textoverflow") && qx.core.Environment.get("html.xul")){

        var xulel = win.document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "label");
        var style = xulel.style;
        style.cursor = "inherit";
        style.color = "inherit";
        style.overflow = "hidden";
        style.maxWidth = "100%";
        style.padding = "0";
        style.margin = "0";
        style.width = "auto";
        for(var key in this.__styles){

          xulel.style[key] = "inherit";
        };
        xulel.setAttribute("crop", "end");
        el.appendChild(xulel);
      } else {

        qx.bom.element.Style.setStyles(el, this.__getStyles(html));
      };
      if(content){

        this.setValue(el, content);
      };
      return el;
    },
    setValue : function(element, value){

      value = value || "";
      if(element.useHtml){

        element.innerHTML = value;
      } else if(!qx.core.Environment.get("css.textoverflow") && qx.core.Environment.get("html.xul")){

        element.firstChild.setAttribute("value", value);
      } else {

        qx.bom.element.Attribute.set(element, "text", value);
      };
    },
    getValue : function(element){

      if(element.useHtml){

        return element.innerHTML;
      } else if(!qx.core.Environment.get("css.textoverflow") && qx.core.Environment.get("html.xul")){

        return element.firstChild.getAttribute("value") || "";
      } else {

        return qx.bom.element.Attribute.get(element, "text");
      };
    },
    getHtmlSize : function(content, styles, width){

      var element = this._htmlElement || this.__prepareHtml();
      element.style.width = width != undefined ? width + "px" : "auto";
      element.innerHTML = content;
      return this.__measureSize(element, styles);
    },
    getTextSize : function(text, styles){

      var element = this._textElement || this.__prepareText();
      if(!qx.core.Environment.get("css.textoverflow") && qx.core.Environment.get("html.xul")){

        element.firstChild.setAttribute("value", text);
      } else {

        qx.bom.element.Attribute.set(element, "text", text);
      };
      return this.__measureSize(element, styles);
    },
    __measureSize : function(element, styles){

      var keys = this.__styles;
      if(!styles){

        styles = {
        };
      };
      for(var key in keys){

        element.style[key] = styles[key] || "";
      };
      var size = qx.bom.element.Dimension.getSize(element);
      if((qx.core.Environment.get("engine.name") == "gecko")){

        size.width++;
      };
      if((qx.core.Environment.get("engine.name") == "mshtml") && parseFloat(qx.core.Environment.get("engine.version")) >= 9){

        size.width++;
      };
      if(qx.core.Environment.get("browser.name") == "chrome" && parseFloat(qx.core.Environment.get("browser.version")) >= 22){

        size.width++;
      };
      if(qx.core.Environment.get("browser.name") == "safari" && parseFloat(qx.core.Environment.get("browser.version")) >= 6){

        size.width++;
      };
      return size;
    }
  }
});

qx.Class.define("qx.theme.manager.Font", {
  type : "singleton",
  extend : qx.util.ValueManager,
  properties : {
    theme : {
      check : "Theme",
      nullable : true,
      apply : "_applyTheme",
      event : "changeTheme"
    }
  },
  members : {
    resolveDynamic : function(value){

      var dynamic = this._dynamic;
      return value instanceof qx.bom.Font ? value : dynamic[value];
    },
    resolve : function(value){

      var cache = this._dynamic;
      var resolved = cache[value];
      if(resolved){

        return resolved;
      };
      var theme = this.getTheme();
      if(theme !== null && theme.fonts[value]){

        var font = this.__getFontClass(theme.fonts[value]);
        return cache[value] = (new font).set(theme.fonts[value]);
      };
      return value;
    },
    isDynamic : function(value){

      var cache = this._dynamic;
      if(value && (value instanceof qx.bom.Font || cache[value] !== undefined)){

        return true;
      };
      var theme = this.getTheme();
      if(theme !== null && value && theme.fonts[value]){

        var font = this.__getFontClass(theme.fonts[value]);
        cache[value] = (new font).set(theme.fonts[value]);
        return true;
      };
      return false;
    },
    __resolveInclude : function(fonts, fontName){

      if(fonts[fontName].include){

        var fontToInclude = fonts[fonts[fontName].include];
        fonts[fontName].include = null;
        delete fonts[fontName].include;
        fonts[fontName] = qx.lang.Object.mergeWith(fonts[fontName], fontToInclude, false);
        this.__resolveInclude(fonts, fontName);
      };
    },
    _applyTheme : function(value){

      var dest = this._dynamic;
      for(var key in dest){

        if(dest[key].themed){

          dest[key].dispose();
          delete dest[key];
        };
      };
      if(value){

        var source = value.fonts;
        for(var key in source){

          if(source[key].include && source[source[key].include]){

            this.__resolveInclude(source, key);
          };
          var font = this.__getFontClass(source[key]);
          dest[key] = (new font).set(source[key]);
          dest[key].themed = true;
        };
      };
      this._setDynamic(dest);
    },
    __getFontClass : function(config){

      if(config.sources){

        return qx.bom.webfonts.WebFont;
      };
      return qx.bom.Font;
    }
  },
  destruct : function(){

    this._disposeMap("_dynamic");
  }
});

qx.Class.define("qx.bom.Font", {
  extend : qx.core.Object,
  construct : function(size, family){

    this.base(arguments);
    this.__lookupMap = {
      fontFamily : "",
      fontSize : null,
      fontWeight : null,
      fontStyle : null,
      textDecoration : null,
      lineHeight : null,
      color : null,
      textShadow : null
    };
    if(size !== undefined){

      this.setSize(size);
    };
    if(family !== undefined){

      this.setFamily(family);
    };
  },
  statics : {
    fromString : function(str){

      var font = new qx.bom.Font();
      var parts = str.split(/\s+/);
      var name = [];
      var part;
      for(var i = 0;i < parts.length;i++){

        switch(part = parts[i]){case "bold":
        font.setBold(true);
        break;case "italic":
        font.setItalic(true);
        break;case "underline":
        font.setDecoration("underline");
        break;default:
        var temp = parseInt(part, 10);
        if(temp == part || qx.lang.String.contains(part, "px")){

          font.setSize(temp);
        } else {

          name.push(part);
        };
        break;};
      };
      if(name.length > 0){

        font.setFamily(name);
      };
      return font;
    },
    fromConfig : function(config){

      var font = new qx.bom.Font;
      font.set(config);
      return font;
    },
    __defaultStyles : {
      fontFamily : "",
      fontSize : "",
      fontWeight : "",
      fontStyle : "",
      textDecoration : "",
      lineHeight : 1.2,
      color : "",
      textShadow : ""
    },
    getDefaultStyles : function(){

      return this.__defaultStyles;
    }
  },
  properties : {
    size : {
      check : "Integer",
      nullable : true,
      apply : "_applySize"
    },
    lineHeight : {
      check : "Number",
      nullable : true,
      apply : "_applyLineHeight"
    },
    family : {
      check : "Array",
      nullable : true,
      apply : "_applyFamily"
    },
    bold : {
      check : "Boolean",
      nullable : true,
      apply : "_applyBold"
    },
    italic : {
      check : "Boolean",
      nullable : true,
      apply : "_applyItalic"
    },
    decoration : {
      check : ["underline", "line-through", "overline"],
      nullable : true,
      apply : "_applyDecoration"
    },
    color : {
      check : "Color",
      nullable : true,
      apply : "_applyColor"
    },
    textShadow : {
      nullable : true,
      check : "String",
      apply : "_applyTextShadow"
    }
  },
  members : {
    __lookupMap : null,
    _applySize : function(value, old){

      this.__lookupMap.fontSize = value === null ? null : value + "px";
    },
    _applyLineHeight : function(value, old){

      this.__lookupMap.lineHeight = value === null ? null : value;
    },
    _applyFamily : function(value, old){

      var family = "";
      for(var i = 0,l = value.length;i < l;i++){

        if(value[i].indexOf(" ") > 0){

          family += '"' + value[i] + '"';
        } else {

          family += value[i];
        };
        if(i !== l - 1){

          family += ",";
        };
      };
      this.__lookupMap.fontFamily = family;
    },
    _applyBold : function(value, old){

      this.__lookupMap.fontWeight = value == null ? null : value ? "bold" : "normal";
    },
    _applyItalic : function(value, old){

      this.__lookupMap.fontStyle = value == null ? null : value ? "italic" : "normal";
    },
    _applyDecoration : function(value, old){

      this.__lookupMap.textDecoration = value == null ? null : value;
    },
    _applyColor : function(value, old){

      this.__lookupMap.color = null;
      if(value){

        this.__lookupMap.color = qx.theme.manager.Color.getInstance().resolve(value);
      };
    },
    _applyTextShadow : function(value, old){

      this.__lookupMap.textShadow = value == null ? null : value;
    },
    getStyles : function(){

      return this.__lookupMap;
    }
  }
});

qx.Class.define("qx.bom.webfonts.WebFont", {
  extend : qx.bom.Font,
  events : {
    "changeStatus" : "qx.event.type.Data"
  },
  properties : {
    sources : {
      nullable : true,
      apply : "_applySources"
    }
  },
  members : {
    __families : null,
    _applySources : function(value, old){

      var families = [];
      for(var i = 0,l = value.length;i < l;i++){

        var familyName = this._quoteFontFamily(value[i].family);
        families.push(familyName);
        var sourcesList = value[i].source;
        qx.bom.webfonts.Manager.getInstance().require(familyName, sourcesList, this._onWebFontChangeStatus, this);
      };
      this.setFamily(families.concat(this.getFamily()));
    },
    _onWebFontChangeStatus : function(ev){

      var result = ev.getData();
      this.fireDataEvent("changeStatus", result);
      if(qx.core.Environment.get("qx.debug")){

        if(result.valid === false){

          this.warn("WebFont " + result.family + " was not applied, perhaps the source file could not be loaded.");
        };
      };
    },
    _quoteFontFamily : function(familyName){

      return familyName.replace(/["']/g, "");
    }
  }
});

qx.Class.define("qx.bom.webfonts.Manager", {
  extend : qx.core.Object,
  type : "singleton",
  construct : function(){

    this.base(arguments);
    this.__createdStyles = [];
    this.__validators = {
    };
    this.__queue = [];
    this.__preferredFormats = this.getPreferredFormats();
    var browser = qx.core.Environment.get("browser.name");
    var version = parseInt(qx.core.Environment.get("browser.version"), 10);
    if((browser == "chrome" && version < 35) || (browser == "opera") && version < 22){

      this.__needsAbsoluteUri = true;
    };
  },
  statics : {
    FONT_FORMATS : ["eot", "woff", "ttf", "svg"],
    VALIDATION_TIMEOUT : 5000
  },
  members : {
    __createdStyles : null,
    __styleSheet : null,
    __validators : null,
    __preferredFormats : null,
    __queue : null,
    __queueInterval : null,
    __needsAbsoluteUri : false,
    require : function(familyName, sourcesList, callback, context){

      var sources = [];
      for(var i = 0,l = sourcesList.length;i < l;i++){

        var split = sourcesList[i].split("#");
        var src = qx.util.ResourceManager.getInstance().toUri(split[0]);
        if(split.length > 1){

          src = src + "#" + split[1];
        };
        if(this.__needsAbsoluteUri){

          src = qx.util.Uri.getAbsolute(src);
        };
        sources.push(src);
      };
      if(qx.core.Environment.get("engine.name") == "mshtml" && (parseInt(qx.core.Environment.get("engine.version")) < 9 || qx.core.Environment.get("browser.documentmode") < 9)){

        if(!this.__queueInterval){

          this.__queueInterval = new qx.event.Timer(100);
          this.__queueInterval.addListener("interval", this.__flushQueue, this);
        };
        if(!this.__queueInterval.isEnabled()){

          this.__queueInterval.start();
        };
        this.__queue.push([familyName, sources, callback, context]);
      } else {

        this.__require(familyName, sources, callback, context);
      };
    },
    remove : function(familyName){

      var index = null;
      for(var i = 0,l = this.__createdStyles.length;i < l;i++){

        if(this.__createdStyles[i] == familyName){

          index = i;
          this.__removeRule(familyName);
          break;
        };
      };
      if(index){

        qx.lang.Array.removeAt(this.__createdStyles, index);
      };
      if(familyName in this.__validators){

        this.__validators[familyName].dispose();
        delete this.__validators[familyName];
      };
    },
    getPreferredFormats : function(){

      var preferredFormats = [];
      var browser = qx.core.Environment.get("browser.name");
      var browserVersion = qx.core.Environment.get("browser.version");
      var os = qx.core.Environment.get("os.name");
      var osVersion = qx.core.Environment.get("os.version");
      if((browser == "ie" && qx.core.Environment.get("browser.documentmode") >= 9) || (browser == "firefox" && browserVersion >= 3.6) || (browser == "chrome" && browserVersion >= 6)){

        preferredFormats.push("woff");
      };
      if((browser == "opera" && browserVersion >= 10) || (browser == "safari" && browserVersion >= 3.1) || (browser == "firefox" && browserVersion >= 3.5) || (browser == "chrome" && browserVersion >= 4) || (browser == "mobile safari" && os == "ios" && osVersion >= 4.2)){

        preferredFormats.push("ttf");
      };
      if(browser == "ie" && browserVersion >= 4){

        preferredFormats.push("eot");
      };
      if(browser == "mobileSafari" && os == "ios" && osVersion >= 4.1){

        preferredFormats.push("svg");
      };
      return preferredFormats;
    },
    removeStyleSheet : function(){

      this.__createdStyles = [];
      if(this.__styleSheet){

        qx.bom.Stylesheet.removeSheet(this.__styleSheet);
      };
      this.__styleSheet = null;
    },
    __require : function(familyName, sources, callback, context){

      if(!qx.lang.Array.contains(this.__createdStyles, familyName)){

        var sourcesMap = this.__getSourcesMap(sources);
        var rule = this.__getRule(familyName, sourcesMap);
        if(!rule){

          throw new Error("Couldn't create @font-face rule for WebFont " + familyName + "!");
        };
        if(!this.__styleSheet){

          this.__styleSheet = qx.bom.Stylesheet.createElement();
        };
        try{

          this.__addRule(rule);
        } catch(ex) {

          if(qx.core.Environment.get("qx.debug")){

            this.warn("Error while adding @font-face rule:", ex.message);
            return;
          };
        };
        this.__createdStyles.push(familyName);
      };
      if(!this.__validators[familyName]){

        this.__validators[familyName] = new qx.bom.webfonts.Validator(familyName);
        this.__validators[familyName].setTimeout(qx.bom.webfonts.Manager.VALIDATION_TIMEOUT);
        this.__validators[familyName].addListenerOnce("changeStatus", this.__onFontChangeStatus, this);
      };
      if(callback){

        var cbContext = context || window;
        this.__validators[familyName].addListenerOnce("changeStatus", callback, cbContext);
      };
      this.__validators[familyName].validate();
    },
    __flushQueue : function(){

      if(this.__queue.length == 0){

        this.__queueInterval.stop();
        return;
      };
      var next = this.__queue.shift();
      this.__require.apply(this, next);
    },
    __onFontChangeStatus : function(ev){

      var result = ev.getData();
      if(result.valid === false){

        qx.event.Timer.once(function(){

          this.remove(result.family);
        }, this, 250);
      };
    },
    __getSourcesMap : function(sources){

      var formats = qx.bom.webfonts.Manager.FONT_FORMATS;
      var sourcesMap = {
      };
      for(var i = 0,l = sources.length;i < l;i++){

        var type = null;
        for(var x = 0;x < formats.length;x++){

          var reg = new RegExp("\.(" + formats[x] + ")");
          var match = reg.exec(sources[i]);
          if(match){

            type = match[1];
          };
        };
        if(type){

          sourcesMap[type] = sources[i];
        };
      };
      return sourcesMap;
    },
    __getRule : function(familyName, sourcesMap){

      var rules = [];
      var formatList = this.__preferredFormats.length > 0 ? this.__preferredFormats : qx.bom.webfonts.Manager.FONT_FORMATS;
      for(var i = 0,l = formatList.length;i < l;i++){

        var format = formatList[i];
        if(sourcesMap[format]){

          rules.push(this.__getSourceForFormat(format, sourcesMap[format]));
        };
      };
      var rule = "src: " + rules.join(",\n") + ";";
      rule = "font-family: " + familyName + ";\n" + rule;
      rule = rule + "\nfont-style: normal;\nfont-weight: normal;";
      return rule;
    },
    __getSourceForFormat : function(format, url){

      switch(format){case "eot":
      return "url('" + url + "');" + "src: url('" + url + "?#iefix') format('embedded-opentype')";case "woff":
      return "url('" + url + "') format('woff')";case "ttf":
      return "url('" + url + "') format('truetype')";case "svg":
      return "url('" + url + "') format('svg')";default:
      return null;};
    },
    __addRule : function(rule){

      var completeRule = "@font-face {" + rule + "}\n";
      if(qx.core.Environment.get("browser.name") == "ie" && qx.core.Environment.get("browser.documentmode") < 9){

        var cssText = this.__fixCssText(this.__styleSheet.cssText);
        cssText += completeRule;
        this.__styleSheet.cssText = cssText;
      } else {

        this.__styleSheet.insertRule(completeRule, this.__styleSheet.cssRules.length);
      };
    },
    __removeRule : function(familyName){

      var reg = new RegExp("@font-face.*?" + familyName, "m");
      for(var i = 0,l = document.styleSheets.length;i < l;i++){

        var sheet = document.styleSheets[i];
        if(sheet.cssText){

          var cssText = sheet.cssText.replace(/\n/g, "").replace(/\r/g, "");
          cssText = this.__fixCssText(cssText);
          if(reg.exec(cssText)){

            cssText = cssText.replace(reg, "");
          };
          sheet.cssText = cssText;
        } else if(sheet.cssRules){

          for(var j = 0,m = sheet.cssRules.length;j < m;j++){

            var cssText = sheet.cssRules[j].cssText.replace(/\n/g, "").replace(/\r/g, "");
            if(reg.exec(cssText)){

              this.__styleSheet.deleteRule(j);
              return;
            };
          };
        };
      };
    },
    __fixCssText : function(cssText){

      return cssText.replace("'eot)", "'eot')").replace("('embedded-opentype)", "('embedded-opentype')");
    }
  },
  destruct : function(){

    if(this.__queueInterval){

      this.__queueInterval.stop();
      this.__queueInterval.dispose();
    };
    delete this.__createdStyles;
    this.removeStyleSheet();
    for(var prop in this.__validators){

      this.__validators[prop].dispose();
    };
    qx.bom.webfonts.Validator.removeDefaultHelperElements();
  }
});

qx.Class.define("qx.bom.webfonts.Validator", {
  extend : qx.core.Object,
  construct : function(fontFamily){

    this.base(arguments);
    if(fontFamily){

      this.setFontFamily(fontFamily);
    };
    this.__requestedHelpers = this._getRequestedHelpers();
  },
  statics : {
    COMPARISON_FONTS : {
      sans : ["Arial", "Helvetica", "sans-serif"],
      serif : ["Times New Roman", "Georgia", "serif"]
    },
    HELPER_CSS : {
      position : "absolute",
      margin : "0",
      padding : "0",
      top : "-1000px",
      left : "-1000px",
      fontSize : "350px",
      width : "auto",
      height : "auto",
      lineHeight : "normal",
      fontVariant : "normal",
      visibility : "hidden"
    },
    COMPARISON_STRING : "WEei",
    __defaultSizes : null,
    __defaultHelpers : null,
    removeDefaultHelperElements : function(){

      var defaultHelpers = qx.bom.webfonts.Validator.__defaultHelpers;
      if(defaultHelpers){

        for(var prop in defaultHelpers){

          document.body.removeChild(defaultHelpers[prop]);
        };
      };
      delete qx.bom.webfonts.Validator.__defaultHelpers;
    }
  },
  properties : {
    fontFamily : {
      nullable : true,
      init : null,
      apply : "_applyFontFamily"
    },
    timeout : {
      check : "Integer",
      init : 5000
    }
  },
  events : {
    "changeStatus" : "qx.event.type.Data"
  },
  members : {
    __requestedHelpers : null,
    __checkTimer : null,
    __checkStarted : null,
    validate : function(){

      this.__checkStarted = new Date().getTime();
      if(this.__checkTimer){

        this.__checkTimer.restart();
      } else {

        this.__checkTimer = new qx.event.Timer(100);
        this.__checkTimer.addListener("interval", this.__onTimerInterval, this);
        qx.event.Timer.once(function(){

          this.__checkTimer.start();
        }, this, 0);
      };
    },
    _reset : function(){

      if(this.__requestedHelpers){

        for(var prop in this.__requestedHelpers){

          var elem = this.__requestedHelpers[prop];
          document.body.removeChild(elem);
        };
        this.__requestedHelpers = null;
      };
    },
    _isFontValid : function(){

      if(!qx.bom.webfonts.Validator.__defaultSizes){

        this.__init();
      };
      if(!this.__requestedHelpers){

        this.__requestedHelpers = this._getRequestedHelpers();
      };
      this.__requestedHelpers.sans.style.visibility = "visible";
      this.__requestedHelpers.sans.style.visibility = "hidden";
      this.__requestedHelpers.serif.style.visibility = "visible";
      this.__requestedHelpers.serif.style.visibility = "hidden";
      var requestedSans = qx.bom.element.Dimension.getWidth(this.__requestedHelpers.sans);
      var requestedSerif = qx.bom.element.Dimension.getWidth(this.__requestedHelpers.serif);
      var cls = qx.bom.webfonts.Validator;
      if(requestedSans !== cls.__defaultSizes.sans && requestedSerif !== cls.__defaultSizes.serif){

        return true;
      };
      return false;
    },
    _getRequestedHelpers : function(){

      var fontsSans = [this.getFontFamily()].concat(qx.bom.webfonts.Validator.COMPARISON_FONTS.sans);
      var fontsSerif = [this.getFontFamily()].concat(qx.bom.webfonts.Validator.COMPARISON_FONTS.serif);
      return {
        sans : this._getHelperElement(fontsSans),
        serif : this._getHelperElement(fontsSerif)
      };
    },
    _getHelperElement : function(fontFamily){

      var styleMap = qx.lang.Object.clone(qx.bom.webfonts.Validator.HELPER_CSS);
      if(fontFamily){

        if(styleMap.fontFamily){

          styleMap.fontFamily += "," + fontFamily.join(",");
        } else {

          styleMap.fontFamily = fontFamily.join(",");
        };
      };
      var elem = document.createElement("span");
      elem.innerHTML = qx.bom.webfonts.Validator.COMPARISON_STRING;
      qx.bom.element.Style.setStyles(elem, styleMap);
      document.body.appendChild(elem);
      return elem;
    },
    _applyFontFamily : function(value, old){

      if(value !== old){

        this._reset();
      };
    },
    __init : function(){

      var cls = qx.bom.webfonts.Validator;
      if(!cls.__defaultHelpers){

        cls.__defaultHelpers = {
          sans : this._getHelperElement(cls.COMPARISON_FONTS.sans),
          serif : this._getHelperElement(cls.COMPARISON_FONTS.serif)
        };
      };
      cls.__defaultSizes = {
        sans : qx.bom.element.Dimension.getWidth(cls.__defaultHelpers.sans),
        serif : qx.bom.element.Dimension.getWidth(cls.__defaultHelpers.serif)
      };
    },
    __onTimerInterval : function(){

      if(this._isFontValid()){

        this.__checkTimer.stop();
        this._reset();
        this.fireDataEvent("changeStatus", {
          family : this.getFontFamily(),
          valid : true
        });
      } else {

        var now = new Date().getTime();
        if(now - this.__checkStarted >= this.getTimeout()){

          this.__checkTimer.stop();
          this._reset();
          this.fireDataEvent("changeStatus", {
            family : this.getFontFamily(),
            valid : false
          });
        };
      };
    }
  },
  destruct : function(){

    this._reset();
    this.__checkTimer.stop();
    this.__checkTimer.removeListener("interval", this.__onTimerInterval, this);
    this._disposeObjects("__checkTimer");
  }
});

qx.Class.define("qx.ui.layout.VBox", {
  extend : qx.ui.layout.Abstract,
  construct : function(spacing, alignY, separator){

    this.base(arguments);
    if(spacing){

      this.setSpacing(spacing);
    };
    if(alignY){

      this.setAlignY(alignY);
    };
    if(separator){

      this.setSeparator(separator);
    };
  },
  properties : {
    alignY : {
      check : ["top", "middle", "bottom"],
      init : "top",
      apply : "_applyLayoutChange"
    },
    alignX : {
      check : ["left", "center", "right"],
      init : "left",
      apply : "_applyLayoutChange"
    },
    spacing : {
      check : "Integer",
      init : 0,
      apply : "_applyLayoutChange"
    },
    separator : {
      check : "Decorator",
      nullable : true,
      apply : "_applyLayoutChange"
    },
    reversed : {
      check : "Boolean",
      init : false,
      apply : "_applyReversed"
    }
  },
  members : {
    __heights : null,
    __flexs : null,
    __enableFlex : null,
    __children : null,
    _applyReversed : function(){

      this._invalidChildrenCache = true;
      this._applyLayoutChange();
    },
    __rebuildCache : function(){

      var children = this._getLayoutChildren();
      var length = children.length;
      var enableFlex = false;
      var reuse = this.__heights && this.__heights.length != length && this.__flexs && this.__heights;
      var props;
      var heights = reuse ? this.__heights : new Array(length);
      var flexs = reuse ? this.__flexs : new Array(length);
      if(this.getReversed()){

        children = children.concat().reverse();
      };
      for(var i = 0;i < length;i++){

        props = children[i].getLayoutProperties();
        if(props.height != null){

          heights[i] = parseFloat(props.height) / 100;
        };
        if(props.flex != null){

          flexs[i] = props.flex;
          enableFlex = true;
        } else {

          flexs[i] = 0;
        };
      };
      if(!reuse){

        this.__heights = heights;
        this.__flexs = flexs;
      };
      this.__enableFlex = enableFlex;
      this.__children = children;
      delete this._invalidChildrenCache;
    },
    verifyLayoutProperty : qx.core.Environment.select("qx.debug", {
      "true" : function(item, name, value){

        this.assert(name === "flex" || name === "height", "The property '" + name + "' is not supported by the VBox layout!");
        if(name == "height"){

          this.assertMatch(value, qx.ui.layout.Util.PERCENT_VALUE);
        } else {

          this.assertNumber(value);
          this.assert(value >= 0);
        };
      },
      "false" : null
    }),
    renderLayout : function(availWidth, availHeight, padding){

      if(this._invalidChildrenCache){

        this.__rebuildCache();
      };
      var children = this.__children;
      var length = children.length;
      var util = qx.ui.layout.Util;
      var spacing = this.getSpacing();
      var separator = this.getSeparator();
      if(separator){

        var gaps = util.computeVerticalSeparatorGaps(children, spacing, separator);
      } else {

        var gaps = util.computeVerticalGaps(children, spacing, true);
      };
      var i,child,height,percent;
      var heights = [];
      var allocatedHeight = gaps;
      for(i = 0;i < length;i += 1){

        percent = this.__heights[i];
        height = percent != null ? Math.floor((availHeight - gaps) * percent) : children[i].getSizeHint().height;
        heights.push(height);
        allocatedHeight += height;
      };
      if(this.__enableFlex && allocatedHeight != availHeight){

        var flexibles = {
        };
        var flex,offset;
        for(i = 0;i < length;i += 1){

          flex = this.__flexs[i];
          if(flex > 0){

            hint = children[i].getSizeHint();
            flexibles[i] = {
              min : hint.minHeight,
              value : heights[i],
              max : hint.maxHeight,
              flex : flex
            };
          };
        };
        var result = util.computeFlexOffsets(flexibles, availHeight, allocatedHeight);
        for(i in result){

          offset = result[i].offset;
          heights[i] += offset;
          allocatedHeight += offset;
        };
      };
      var top = children[0].getMarginTop();
      if(allocatedHeight < availHeight && this.getAlignY() != "top"){

        top = availHeight - allocatedHeight;
        if(this.getAlignY() === "middle"){

          top = Math.round(top / 2);
        };
      };
      var hint,left,width,height,marginBottom,marginLeft,marginRight;
      this._clearSeparators();
      if(separator){

        var separatorInsets = qx.theme.manager.Decoration.getInstance().resolve(separator).getInsets();
        var separatorHeight = separatorInsets.top + separatorInsets.bottom;
      };
      for(i = 0;i < length;i += 1){

        child = children[i];
        height = heights[i];
        hint = child.getSizeHint();
        marginLeft = child.getMarginLeft();
        marginRight = child.getMarginRight();
        width = Math.max(hint.minWidth, Math.min(availWidth - marginLeft - marginRight, hint.maxWidth));
        left = util.computeHorizontalAlignOffset(child.getAlignX() || this.getAlignX(), width, availWidth, marginLeft, marginRight);
        if(i > 0){

          if(separator){

            top += marginBottom + spacing;
            this._renderSeparator(separator, {
              top : top + padding.top,
              left : padding.left,
              height : separatorHeight,
              width : availWidth
            });
            top += separatorHeight + spacing + child.getMarginTop();
          } else {

            top += util.collapseMargins(spacing, marginBottom, child.getMarginTop());
          };
        };
        child.renderLayout(left + padding.left, top + padding.top, width, height);
        top += height;
        marginBottom = child.getMarginBottom();
      };
    },
    _computeSizeHint : function(){

      if(this._invalidChildrenCache){

        this.__rebuildCache();
      };
      var util = qx.ui.layout.Util;
      var children = this.__children;
      var minHeight = 0,height = 0,percentMinHeight = 0;
      var minWidth = 0,width = 0;
      var child,hint,margin;
      for(var i = 0,l = children.length;i < l;i += 1){

        child = children[i];
        hint = child.getSizeHint();
        height += hint.height;
        var flex = this.__flexs[i];
        var percent = this.__heights[i];
        if(flex){

          minHeight += hint.minHeight;
        } else if(percent){

          percentMinHeight = Math.max(percentMinHeight, Math.round(hint.minHeight / percent));
        } else {

          minHeight += hint.height;
        };
        margin = child.getMarginLeft() + child.getMarginRight();
        if((hint.width + margin) > width){

          width = hint.width + margin;
        };
        if((hint.minWidth + margin) > minWidth){

          minWidth = hint.minWidth + margin;
        };
      };
      minHeight += percentMinHeight;
      var spacing = this.getSpacing();
      var separator = this.getSeparator();
      if(separator){

        var gaps = util.computeVerticalSeparatorGaps(children, spacing, separator);
      } else {

        var gaps = util.computeVerticalGaps(children, spacing, true);
      };
      return {
        minHeight : minHeight + gaps,
        height : height + gaps,
        minWidth : minWidth,
        width : width
      };
    }
  },
  destruct : function(){

    this.__heights = this.__flexs = this.__children = null;
  }
});

qx.Class.define("qx.ui.layout.HBox", {
  extend : qx.ui.layout.Abstract,
  construct : function(spacing, alignX, separator){

    this.base(arguments);
    if(spacing){

      this.setSpacing(spacing);
    };
    if(alignX){

      this.setAlignX(alignX);
    };
    if(separator){

      this.setSeparator(separator);
    };
  },
  properties : {
    alignX : {
      check : ["left", "center", "right"],
      init : "left",
      apply : "_applyLayoutChange"
    },
    alignY : {
      check : ["top", "middle", "bottom"],
      init : "top",
      apply : "_applyLayoutChange"
    },
    spacing : {
      check : "Integer",
      init : 0,
      apply : "_applyLayoutChange"
    },
    separator : {
      check : "Decorator",
      nullable : true,
      apply : "_applyLayoutChange"
    },
    reversed : {
      check : "Boolean",
      init : false,
      apply : "_applyReversed"
    }
  },
  members : {
    __widths : null,
    __flexs : null,
    __enableFlex : null,
    __children : null,
    _applyReversed : function(){

      this._invalidChildrenCache = true;
      this._applyLayoutChange();
    },
    __rebuildCache : function(){

      var children = this._getLayoutChildren();
      var length = children.length;
      var enableFlex = false;
      var reuse = this.__widths && this.__widths.length != length && this.__flexs && this.__widths;
      var props;
      var widths = reuse ? this.__widths : new Array(length);
      var flexs = reuse ? this.__flexs : new Array(length);
      if(this.getReversed()){

        children = children.concat().reverse();
      };
      for(var i = 0;i < length;i++){

        props = children[i].getLayoutProperties();
        if(props.width != null){

          widths[i] = parseFloat(props.width) / 100;
        };
        if(props.flex != null){

          flexs[i] = props.flex;
          enableFlex = true;
        } else {

          flexs[i] = 0;
        };
      };
      if(!reuse){

        this.__widths = widths;
        this.__flexs = flexs;
      };
      this.__enableFlex = enableFlex;
      this.__children = children;
      delete this._invalidChildrenCache;
    },
    verifyLayoutProperty : qx.core.Environment.select("qx.debug", {
      "true" : function(item, name, value){

        this.assert(name === "flex" || name === "width", "The property '" + name + "' is not supported by the HBox layout!");
        if(name == "width"){

          this.assertMatch(value, qx.ui.layout.Util.PERCENT_VALUE);
        } else {

          this.assertNumber(value);
          this.assert(value >= 0);
        };
      },
      "false" : null
    }),
    renderLayout : function(availWidth, availHeight, padding){

      if(this._invalidChildrenCache){

        this.__rebuildCache();
      };
      var children = this.__children;
      var length = children.length;
      var util = qx.ui.layout.Util;
      var spacing = this.getSpacing();
      var separator = this.getSeparator();
      if(separator){

        var gaps = util.computeHorizontalSeparatorGaps(children, spacing, separator);
      } else {

        var gaps = util.computeHorizontalGaps(children, spacing, true);
      };
      var i,child,width,percent;
      var widths = [];
      var allocatedWidth = gaps;
      for(i = 0;i < length;i += 1){

        percent = this.__widths[i];
        width = percent != null ? Math.floor((availWidth - gaps) * percent) : children[i].getSizeHint().width;
        widths.push(width);
        allocatedWidth += width;
      };
      if(this.__enableFlex && allocatedWidth != availWidth){

        var flexibles = {
        };
        var flex,offset;
        for(i = 0;i < length;i += 1){

          flex = this.__flexs[i];
          if(flex > 0){

            hint = children[i].getSizeHint();
            flexibles[i] = {
              min : hint.minWidth,
              value : widths[i],
              max : hint.maxWidth,
              flex : flex
            };
          };
        };
        var result = util.computeFlexOffsets(flexibles, availWidth, allocatedWidth);
        for(i in result){

          offset = result[i].offset;
          widths[i] += offset;
          allocatedWidth += offset;
        };
      };
      var left = children[0].getMarginLeft();
      if(allocatedWidth < availWidth && this.getAlignX() != "left"){

        left = availWidth - allocatedWidth;
        if(this.getAlignX() === "center"){

          left = Math.round(left / 2);
        };
      };
      var hint,top,height,width,marginRight,marginTop,marginBottom;
      var spacing = this.getSpacing();
      this._clearSeparators();
      if(separator){

        var separatorInsets = qx.theme.manager.Decoration.getInstance().resolve(separator).getInsets();
        var separatorWidth = separatorInsets.left + separatorInsets.right;
      };
      for(i = 0;i < length;i += 1){

        child = children[i];
        width = widths[i];
        hint = child.getSizeHint();
        marginTop = child.getMarginTop();
        marginBottom = child.getMarginBottom();
        height = Math.max(hint.minHeight, Math.min(availHeight - marginTop - marginBottom, hint.maxHeight));
        top = util.computeVerticalAlignOffset(child.getAlignY() || this.getAlignY(), height, availHeight, marginTop, marginBottom);
        if(i > 0){

          if(separator){

            left += marginRight + spacing;
            this._renderSeparator(separator, {
              left : left + padding.left,
              top : padding.top,
              width : separatorWidth,
              height : availHeight
            });
            left += separatorWidth + spacing + child.getMarginLeft();
          } else {

            left += util.collapseMargins(spacing, marginRight, child.getMarginLeft());
          };
        };
        child.renderLayout(left + padding.left, top + padding.top, width, height);
        left += width;
        marginRight = child.getMarginRight();
      };
    },
    _computeSizeHint : function(){

      if(this._invalidChildrenCache){

        this.__rebuildCache();
      };
      var util = qx.ui.layout.Util;
      var children = this.__children;
      var minWidth = 0,width = 0,percentMinWidth = 0;
      var minHeight = 0,height = 0;
      var child,hint,margin;
      for(var i = 0,l = children.length;i < l;i += 1){

        child = children[i];
        hint = child.getSizeHint();
        width += hint.width;
        var flex = this.__flexs[i];
        var percent = this.__widths[i];
        if(flex){

          minWidth += hint.minWidth;
        } else if(percent){

          percentMinWidth = Math.max(percentMinWidth, Math.round(hint.minWidth / percent));
        } else {

          minWidth += hint.width;
        };
        margin = child.getMarginTop() + child.getMarginBottom();
        if((hint.height + margin) > height){

          height = hint.height + margin;
        };
        if((hint.minHeight + margin) > minHeight){

          minHeight = hint.minHeight + margin;
        };
      };
      minWidth += percentMinWidth;
      var spacing = this.getSpacing();
      var separator = this.getSeparator();
      if(separator){

        var gaps = util.computeHorizontalSeparatorGaps(children, spacing, separator);
      } else {

        var gaps = util.computeHorizontalGaps(children, spacing, true);
      };
      return {
        minWidth : minWidth + gaps,
        width : width + gaps,
        minHeight : minHeight,
        height : height
      };
    }
  },
  destruct : function(){

    this.__widths = this.__flexs = this.__children = null;
  }
});

qx.Mixin.define("qx.ui.core.MNativeOverflow", {
  properties : {
    overflowX : {
      check : ["hidden", "visible", "scroll", "auto"],
      nullable : true,
      apply : "_applyOverflowX"
    },
    overflowY : {
      check : ["hidden", "visible", "scroll", "auto"],
      nullable : true,
      apply : "_applyOverflowY"
    },
    overflow : {
      group : ["overflowX", "overflowY"]
    }
  },
  members : {
    _applyOverflowX : function(value){

      this.getContentElement().setStyle("overflowX", value);
    },
    _applyOverflowY : function(value){

      this.getContentElement().setStyle("overflowY", value);
    }
  }
});

qx.Class.define("qx.ui.embed.Html", {
  extend : qx.ui.core.Widget,
  include : [qx.ui.core.MNativeOverflow],
  construct : function(html){

    this.base(arguments);
    if(html != null){

      this.setHtml(html);
    };
  },
  properties : {
    html : {
      check : "String",
      apply : "_applyHtml",
      event : "changeHtml",
      nullable : true
    },
    cssClass : {
      check : "String",
      init : "",
      apply : "_applyCssClass"
    },
    selectable : {
      refine : true,
      init : true
    },
    focusable : {
      refine : true,
      init : true
    }
  },
  members : {
    getFocusElement : function(){

      return this.getContentElement();
    },
    _applyHtml : function(value, old){

      var elem = this.getContentElement();
      if(qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") == 9){

        elem.setStyle("position", "relative");
      };
      elem.setAttribute("html", value || "");
    },
    _applyCssClass : function(value, old){

      this.getContentElement().removeClass(old);
      this.getContentElement().addClass(value);
    },
    _applySelectable : function(value){

      this.base(arguments, value);
      if((qx.core.Environment.get("engine.name") == "webkit")){

        this.getContentElement().setStyle("userSelect", value ? "text" : "none");
      };
    },
    _applyFont : function(value, old){

      var styles = value ? qx.theme.manager.Font.getInstance().resolve(value).getStyles() : qx.bom.Font.getDefaultStyles();
      if(this.getTextColor() != null){

        delete styles["color"];
      };
      this.getContentElement().setStyles(styles);
    },
    _applyTextColor : function(value, old){

      if(value){

        this.getContentElement().setStyle("color", qx.theme.manager.Color.getInstance().resolve(value));
      } else {

        this.getContentElement().removeStyle("color");
      };
    }
  }
});

qx.Class.define("ms123.form.Confirm", {
  extend : ms123.form.Dialog,
  statics : {
    getInstance : function(){

      return this.superclass.getInstance(this.classname);
    }
  },
  properties : {
    yesButtonLabel : {
      check : "String",
      nullable : false,
      init : "Yes",
      event : "changeYesButtonLabel"
    },
    yesButtonIcon : {
      check : "String",
      nullable : true,
      init : "icon/22/actions/dialog-ok.png",
      event : "changeYesButtonIcon"
    },
    noButtonLabel : {
      check : "String",
      nullable : false,
      init : "No",
      event : "changeNoButtonLabel"
    },
    noButtonIcon : {
      check : "String",
      nullable : true,
      init : "icon/22/actions/dialog-cancel.png",
      event : "changeNoButtonIcon"
    },
    allowCancel : {
      refine : true,
      init : false
    }
  },
  members : {
    _yesButton : null,
    _noButton : null,
    _createWidgetContent : function(){

      var groupboxContainer = new qx.ui.groupbox.GroupBox().set({
        contentPadding : [16, 16, 16, 16]
      });
      groupboxContainer.setLayout(new qx.ui.layout.VBox(10));
      this.add(groupboxContainer);
      var hbox = new qx.ui.container.Composite;
      hbox.setLayout(new qx.ui.layout.HBox(10));
      groupboxContainer.add(hbox);
      console.log("warning:" + this._warn);
      if(this._warn){

        this._image = new qx.ui.basic.Image("icon/48/status/dialog-warning.png");
      } else {

        this._image = new qx.ui.basic.Image();
        this._image.setVisibility("excluded");
      };
      hbox.add(this._image);
      this._message = new qx.ui.basic.Label();
      this._message.setRich(true);
      this._message.setWidth(200);
      this._message.setAllowStretchX(true);
      hbox.add(this._message, {
        flex : 1
      });
      var _this = this;
      var yesButton = this._yesButton = new qx.ui.form.Button;
      yesButton.setAllowStretchX(true);
      yesButton.addListener("execute", this._handleYes, this);
      yesButton.setLabel(this.tr("yes"));
      this.bind("yesButtonIcon", yesButton, "icon");
      var noButton = this._noButton = new qx.ui.form.Button;
      noButton.setAllowStretchX(true);
      noButton.addListener("execute", this._handleNo, this);
      noButton.setLabel(this.tr("no"));
      this.bind("noButtonIcon", noButton, "icon");
      var cancelButton = this._createCancelButton();
      var buttonPane = new qx.ui.container.Composite;
      var bpLayout = new qx.ui.layout.HBox(5);
      bpLayout.setAlignX("center");
      buttonPane.setLayout(bpLayout);
      buttonPane.add(yesButton);
      buttonPane.add(noButton);
      buttonPane.add(cancelButton);
      groupboxContainer.add(buttonPane);
    },
    _handleYes : function(){

      this.hide();
      if(this.getCallback()){

        this.getCallback().call(this.getContext(), true);
      };
      this.resetCallback();
    },
    _handleNo : function(){

      this.hide();
      if(this.getCallback()){

        this.getCallback().call(this.getContext(), false);
      };
    }
  }
});

qx.Mixin.define("qx.ui.core.MExecutable", {
  events : {
    "execute" : "qx.event.type.Event"
  },
  properties : {
    command : {
      check : "qx.ui.core.Command",
      apply : "_applyCommand",
      event : "changeCommand",
      nullable : true
    }
  },
  members : {
    __executableBindingIds : null,
    __semaphore : false,
    __executeListenerId : null,
    _bindableProperties : ["enabled", "label", "icon", "toolTipText", "value", "menu"],
    execute : function(){

      var cmd = this.getCommand();
      if(cmd){

        if(this.__semaphore){

          this.__semaphore = false;
        } else {

          this.__semaphore = true;
          cmd.execute(this);
        };
      };
      this.fireEvent("execute");
    },
    __onCommandExecute : function(e){

      if(this.__semaphore){

        this.__semaphore = false;
        return;
      };
      this.__semaphore = true;
      this.execute();
    },
    _applyCommand : function(value, old){

      if(old != null){

        old.removeListenerById(this.__executeListenerId);
      };
      if(value != null){

        this.__executeListenerId = value.addListener("execute", this.__onCommandExecute, this);
      };
      var ids = this.__executableBindingIds;
      if(ids == null){

        this.__executableBindingIds = ids = {
        };
      };
      var selfPropertyValue;
      for(var i = 0;i < this._bindableProperties.length;i++){

        var property = this._bindableProperties[i];
        if(old != null && !old.isDisposed() && ids[property] != null){

          old.removeBinding(ids[property]);
          ids[property] = null;
        };
        if(value != null && qx.Class.hasProperty(this.constructor, property)){

          var cmdPropertyValue = value.get(property);
          if(cmdPropertyValue == null){

            selfPropertyValue = this.get(property);
            if(selfPropertyValue == null){

              this.syncAppearance();
              selfPropertyValue = qx.util.PropertyUtil.getThemeValue(this, property);
            };
          } else {

            selfPropertyValue = null;
          };
          ids[property] = value.bind(property, this, property);
          if(selfPropertyValue){

            this.set(property, selfPropertyValue);
          };
        };
      };
    }
  },
  destruct : function(){

    this._applyCommand(null, this.getCommand());
    this.__executableBindingIds = null;
  }
});

qx.Interface.define("qx.ui.form.IExecutable", {
  events : {
    "execute" : "qx.event.type.Data"
  },
  members : {
    setCommand : function(command){

      return arguments.length == 1;
    },
    getCommand : function(){
    },
    execute : function(){
    }
  }
});

qx.Class.define("qx.ui.form.Button", {
  extend : qx.ui.basic.Atom,
  include : [qx.ui.core.MExecutable],
  implement : [qx.ui.form.IExecutable],
  construct : function(label, icon, command){

    this.base(arguments, label, icon);
    if(command != null){

      this.setCommand(command);
    };
    this.addListener("pointerover", this._onPointerOver);
    this.addListener("pointerout", this._onPointerOut);
    this.addListener("pointerdown", this._onPointerDown);
    this.addListener("pointerup", this._onPointerUp);
    this.addListener("tap", this._onTap);
    this.addListener("keydown", this._onKeyDown);
    this.addListener("keyup", this._onKeyUp);
    this.addListener("dbltap", this._onStopEvent);
  },
  properties : {
    appearance : {
      refine : true,
      init : "button"
    },
    focusable : {
      refine : true,
      init : true
    }
  },
  members : {
    _forwardStates : {
      focused : true,
      hovered : true,
      pressed : true,
      disabled : true
    },
    press : function(){

      if(this.hasState("abandoned")){

        return;
      };
      this.addState("pressed");
    },
    release : function(){

      if(this.hasState("pressed")){

        this.removeState("pressed");
      };
    },
    reset : function(){

      this.removeState("pressed");
      this.removeState("abandoned");
      this.removeState("hovered");
    },
    _onPointerOver : function(e){

      if(!this.isEnabled() || e.getTarget() !== this){

        return;
      };
      if(this.hasState("abandoned")){

        this.removeState("abandoned");
        this.addState("pressed");
      };
      this.addState("hovered");
    },
    _onPointerOut : function(e){

      if(!this.isEnabled() || e.getTarget() !== this){

        return;
      };
      this.removeState("hovered");
      if(this.hasState("pressed")){

        this.removeState("pressed");
        this.addState("abandoned");
      };
    },
    _onPointerDown : function(e){

      if(!e.isLeftPressed()){

        return;
      };
      e.stopPropagation();
      this.capture();
      this.removeState("abandoned");
      this.addState("pressed");
    },
    _onPointerUp : function(e){

      this.releaseCapture();
      var hasPressed = this.hasState("pressed");
      var hasAbandoned = this.hasState("abandoned");
      if(hasPressed){

        this.removeState("pressed");
      };
      if(hasAbandoned){

        this.removeState("abandoned");
      };
      e.stopPropagation();
    },
    _onTap : function(e){

      this.execute();
      e.stopPropagation();
    },
    _onKeyDown : function(e){

      switch(e.getKeyIdentifier()){case "Enter":case "Space":
      this.removeState("abandoned");
      this.addState("pressed");
      e.stopPropagation();};
    },
    _onKeyUp : function(e){

      switch(e.getKeyIdentifier()){case "Enter":case "Space":
      if(this.hasState("pressed")){

        this.removeState("abandoned");
        this.removeState("pressed");
        this.execute();
        e.stopPropagation();
      };};
    }
  }
});

qx.Class.define("ms123.form.Prompt", {
  extend : ms123.form.Dialog,
  properties : {
    value : {
      check : "String",
      nullable : true,
      apply : "_applyValue",
      event : "changeValue"
    }
  },
  members : {
    _textField : null,
    _createWidgetContent : function(){

      var groupboxContainer = new qx.ui.groupbox.GroupBox().set({
        contentPadding : [16, 16, 16, 16]
      });
      groupboxContainer.setLayout(new qx.ui.layout.VBox(10));
      this.add(groupboxContainer);
      var hbox = new qx.ui.container.Composite;
      hbox.setLayout(new qx.ui.layout.HBox(10));
      groupboxContainer.add(hbox);
      this._message = new qx.ui.basic.Label();
      this._message.setRich(true);
      this._message.setWidth(200);
      this._message.setAllowStretchX(true);
      hbox.add(this._message, {
        flex : 1
      });
      this._textField = new qx.ui.form.TextField();
      this._textField.addListener("changeValue", function(e){

        this.setValue(e.getData());
      }, this);
      this.addListener("show", function(){

        this.setValue("");
      }, this);
      groupboxContainer.add(this._textField);
      var buttonPane = new qx.ui.container.Composite;
      var bpLayout = new qx.ui.layout.HBox(5);
      bpLayout.setAlignX("center");
      buttonPane.setLayout(bpLayout);
      buttonPane.add(this._createOkButton());
      buttonPane.add(this._createCancelButton());
      groupboxContainer.add(buttonPane);
    },
    _applyValue : function(value, old){

      this._textField.setValue(value);
    },
    _handleOk : function(){

      this.hide();
      if(this.getCallback()){

        this.getCallback().call(this.getContext(), this.getValue());
      };
    }
  }
});

qx.Class.define("qx.ui.form.AbstractField", {
  extend : qx.ui.core.Widget,
  implement : [qx.ui.form.IStringForm, qx.ui.form.IForm],
  include : [qx.ui.form.MForm],
  type : "abstract",
  statics : {
    __stylesheet : null,
    __addPlaceholderRules : function(){

      var colorManager = qx.theme.manager.Color.getInstance();
      var color = colorManager.resolve("text-placeholder");
      var selector;
      if(qx.core.Environment.get("engine.name") == "gecko"){

        if(parseFloat(qx.core.Environment.get("engine.version")) >= 19){

          selector = "input::-moz-placeholder, textarea::-moz-placeholder";
        } else {

          selector = "input:-moz-placeholder, textarea:-moz-placeholder";
        };
        qx.ui.style.Stylesheet.getInstance().addRule(selector, "color: " + color + " !important");
      } else if(qx.core.Environment.get("engine.name") == "webkit"){

        selector = "input.qx-placeholder-color::-webkit-input-placeholder, textarea.qx-placeholder-color::-webkit-input-placeholder";
        qx.ui.style.Stylesheet.getInstance().addRule(selector, "color: " + color);
      } else if(qx.core.Environment.get("engine.name") == "mshtml"){

        selector = "input.qx-placeholder-color:-ms-input-placeholder, textarea.qx-placeholder-color:-ms-input-placeholder";
        qx.ui.style.Stylesheet.getInstance().addRule(selector, "color: " + color + " !important");
      };;
    }
  },
  construct : function(value){

    this.base(arguments);
    this.__useQxPlaceholder = !qx.core.Environment.get("css.placeholder");
    if(value != null){

      this.setValue(value);
    };
    this.getContentElement().addListener("change", this._onChangeContent, this);
    if(this.__useQxPlaceholder){

      this.addListener("syncAppearance", this._syncPlaceholder, this);
    } else {

      qx.ui.form.AbstractField.__addPlaceholderRules();
      this.getContentElement().addClass("qx-placeholder-color");
    };
    if(qx.core.Environment.get("qx.dynlocale")){

      qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
    };
  },
  events : {
    "input" : "qx.event.type.Data",
    "changeValue" : "qx.event.type.Data"
  },
  properties : {
    textAlign : {
      check : ["left", "center", "right"],
      nullable : true,
      themeable : true,
      apply : "_applyTextAlign"
    },
    readOnly : {
      check : "Boolean",
      apply : "_applyReadOnly",
      event : "changeReadOnly",
      init : false
    },
    selectable : {
      refine : true,
      init : true
    },
    focusable : {
      refine : true,
      init : true
    },
    maxLength : {
      apply : "_applyMaxLength",
      check : "PositiveInteger",
      init : Infinity
    },
    liveUpdate : {
      check : "Boolean",
      init : false
    },
    placeholder : {
      check : "String",
      nullable : true,
      apply : "_applyPlaceholder"
    },
    filter : {
      check : "RegExp",
      nullable : true,
      init : null
    }
  },
  members : {
    __nullValue : true,
    _placeholder : null,
    __oldValue : null,
    __oldInputValue : null,
    __useQxPlaceholder : true,
    __font : null,
    __webfontListenerId : null,
    getFocusElement : function(){

      var el = this.getContentElement();
      if(el){

        return el;
      };
    },
    _createInputElement : function(){

      return new qx.html.Input("text");
    },
    renderLayout : function(left, top, width, height){

      var updateInsets = this._updateInsets;
      var changes = this.base(arguments, left, top, width, height);
      if(!changes){

        return;
      };
      var inner = changes.size || updateInsets;
      var pixel = "px";
      if(inner || changes.local || changes.margin){

        var innerWidth = width;
        var innerHeight = height;
      };
      var input = this.getContentElement();
      if(updateInsets && this.__useQxPlaceholder){

        if(this.__useQxPlaceholder){

          var insets = this.getInsets();
          this._getPlaceholderElement().setStyles({
            paddingTop : insets.top + pixel,
            paddingRight : insets.right + pixel,
            paddingBottom : insets.bottom + pixel,
            paddingLeft : insets.left + pixel
          });
        };
      };
      if(inner || changes.margin){

        if(this.__useQxPlaceholder){

          var insets = this.getInsets();
          this._getPlaceholderElement().setStyles({
            "width" : (innerWidth - insets.left - insets.right) + pixel,
            "height" : (innerHeight - insets.top - insets.bottom) + pixel
          });
        };
        input.setStyles({
          "width" : innerWidth + pixel,
          "height" : innerHeight + pixel
        });
        this._renderContentElement(innerHeight, input);
      };
      if(changes.position){

        if(this.__useQxPlaceholder){

          this._getPlaceholderElement().setStyles({
            "left" : left + pixel,
            "top" : top + pixel
          });
        };
      };
    },
    _renderContentElement : function(innerHeight, element){
    },
    _createContentElement : function(){

      var el = this._createInputElement();
      el.setSelectable(this.getSelectable());
      el.setEnabled(this.getEnabled());
      el.addListener("input", this._onHtmlInput, this);
      el.setAttribute("spellcheck", "false");
      el.addClass("qx-abstract-field");
      if((qx.core.Environment.get("engine.name") == "mshtml") && (qx.core.Environment.get("browser.documentmode") == 8)){

        el.setStyles({
          backgroundImage : "url(" + qx.util.ResourceManager.getInstance().toUri("qx/static/blank.gif") + ")"
        });
      };
      return el;
    },
    _applyEnabled : function(value, old){

      this.base(arguments, value, old);
      this.getContentElement().setEnabled(value);
      if(this.__useQxPlaceholder){

        if(value){

          this._showPlaceholder();
        } else {

          this._removePlaceholder();
        };
      } else {

        var input = this.getContentElement();
        input.setAttribute("placeholder", value ? this.getPlaceholder() : "");
      };
    },
    __textSize : {
      width : 16,
      height : 16
    },
    _getContentHint : function(){

      return {
        width : this.__textSize.width * 10,
        height : this.__textSize.height || 16
      };
    },
    _applyFont : function(value, old){

      if(old && this.__font && this.__webfontListenerId){

        this.__font.removeListenerById(this.__webfontListenerId);
        this.__webfontListenerId = null;
      };
      var styles;
      if(value){

        this.__font = qx.theme.manager.Font.getInstance().resolve(value);
        if(this.__font instanceof qx.bom.webfonts.WebFont){

          this.__webfontListenerId = this.__font.addListener("changeStatus", this._onWebFontStatusChange, this);
        };
        styles = this.__font.getStyles();
      } else {

        styles = qx.bom.Font.getDefaultStyles();
      };
      if(this.getTextColor() != null){

        delete styles["color"];
      };
      if(qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") < 11){

        qx.html.Element.flush();
        this.getContentElement().setStyles(styles, true);
      } else {

        this.getContentElement().setStyles(styles);
      };
      if(this.__useQxPlaceholder){

        delete styles["color"];
        this._getPlaceholderElement().setStyles(styles);
      };
      if(value){

        this.__textSize = qx.bom.Label.getTextSize("A", styles);
      } else {

        delete this.__textSize;
      };
      qx.ui.core.queue.Layout.add(this);
    },
    _applyTextColor : function(value, old){

      if(value){

        this.getContentElement().setStyle("color", qx.theme.manager.Color.getInstance().resolve(value));
      } else {

        this.getContentElement().removeStyle("color");
      };
    },
    _applyMaxLength : function(value, old){

      if(value){

        this.getContentElement().setAttribute("maxLength", value);
      } else {

        this.getContentElement().removeAttribute("maxLength");
      };
    },
    tabFocus : function(){

      this.base(arguments);
      this.selectAllText();
    },
    _getTextSize : function(){

      return this.__textSize;
    },
    _onHtmlInput : function(e){

      var value = e.getData();
      var fireEvents = true;
      this.__nullValue = false;
      if(this.__oldInputValue && this.__oldInputValue === value){

        fireEvents = false;
      };
      if(this.getFilter() != null){

        var filteredValue = "";
        var index = value.search(this.getFilter());
        var processedValue = value;
        while(index >= 0){

          filteredValue = filteredValue + (processedValue.charAt(index));
          processedValue = processedValue.substring(index + 1, processedValue.length);
          index = processedValue.search(this.getFilter());
        };
        if(filteredValue != value){

          fireEvents = false;
          value = filteredValue;
          this.getContentElement().setValue(value);
        };
      };
      if(fireEvents){

        this.fireDataEvent("input", value, this.__oldInputValue);
        this.__oldInputValue = value;
        if(this.getLiveUpdate()){

          this.__fireChangeValueEvent(value);
        };
      };
    },
    _onWebFontStatusChange : function(ev){

      if(ev.getData().valid === true){

        var styles = this.__font.getStyles();
        this.__textSize = qx.bom.Label.getTextSize("A", styles);
        qx.ui.core.queue.Layout.add(this);
      };
    },
    __fireChangeValueEvent : function(value){

      var old = this.__oldValue;
      this.__oldValue = value;
      if(old != value){

        this.fireNonBubblingEvent("changeValue", qx.event.type.Data, [value, old]);
      };
    },
    setValue : function(value){

      if(value === null){

        if(this.__nullValue){

          return value;
        };
        value = "";
        this.__nullValue = true;
      } else {

        this.__nullValue = false;
        if(this.__useQxPlaceholder){

          this._removePlaceholder();
        };
      };
      if(qx.lang.Type.isString(value)){

        var elem = this.getContentElement();
        if(elem.getValue() != value){

          var oldValue = elem.getValue();
          elem.setValue(value);
          var data = this.__nullValue ? null : value;
          this.__oldValue = oldValue;
          this.__fireChangeValueEvent(data);
          this.__oldInputValue = this.__oldValue;
        };
        if(this.__useQxPlaceholder){

          this._showPlaceholder();
        };
        return value;
      };
      throw new Error("Invalid value type: " + value);
    },
    getValue : function(){

      var value = this.getContentElement().getValue();
      return this.__nullValue ? null : value;
    },
    resetValue : function(){

      this.setValue(null);
    },
    _onChangeContent : function(e){

      this.__nullValue = e.getData() === null;
      this.__fireChangeValueEvent(e.getData());
    },
    getTextSelection : function(){

      return this.getContentElement().getTextSelection();
    },
    getTextSelectionLength : function(){

      return this.getContentElement().getTextSelectionLength();
    },
    getTextSelectionStart : function(){

      return this.getContentElement().getTextSelectionStart();
    },
    getTextSelectionEnd : function(){

      return this.getContentElement().getTextSelectionEnd();
    },
    setTextSelection : function(start, end){

      this.getContentElement().setTextSelection(start, end);
    },
    clearTextSelection : function(){

      this.getContentElement().clearTextSelection();
    },
    selectAllText : function(){

      this.setTextSelection(0);
    },
    setLayoutParent : function(parent){

      this.base(arguments, parent);
      if(this.__useQxPlaceholder){

        if(parent){

          this.getLayoutParent().getContentElement().add(this._getPlaceholderElement());
        } else {

          var placeholder = this._getPlaceholderElement();
          placeholder.getParent().remove(placeholder);
        };
      };
    },
    _showPlaceholder : function(){

      var fieldValue = this.getValue() || "";
      var placeholder = this.getPlaceholder();
      if(placeholder != null && fieldValue == "" && !this.hasState("focused") && !this.hasState("disabled")){

        if(this.hasState("showingPlaceholder")){

          this._syncPlaceholder();
        } else {

          this.addState("showingPlaceholder");
        };
      };
    },
    _onPointerDownPlaceholder : function(){

      window.setTimeout(function(){

        this.focus();
      }.bind(this), 0);
    },
    _removePlaceholder : function(){

      if(this.hasState("showingPlaceholder")){

        if(this.__useQxPlaceholder){

          this._getPlaceholderElement().setStyle("visibility", "hidden");
        };
        this.removeState("showingPlaceholder");
      };
    },
    _syncPlaceholder : function(){

      if(this.hasState("showingPlaceholder") && this.__useQxPlaceholder){

        this._getPlaceholderElement().setStyle("visibility", "visible");
      };
    },
    _getPlaceholderElement : function(){

      if(this._placeholder == null){

        this._placeholder = new qx.html.Label();
        var colorManager = qx.theme.manager.Color.getInstance();
        this._placeholder.setStyles({
          "zIndex" : 11,
          "position" : "absolute",
          "color" : colorManager.resolve("text-placeholder"),
          "whiteSpace" : "normal",
          "cursor" : "text",
          "visibility" : "hidden"
        });
        this._placeholder.addListener("pointerdown", this._onPointerDownPlaceholder, this);
      };
      return this._placeholder;
    },
    _onChangeLocale : qx.core.Environment.select("qx.dynlocale", {
      "true" : function(e){

        var content = this.getPlaceholder();
        if(content && content.translate){

          this.setPlaceholder(content.translate());
        };
      },
      "false" : null
    }),
    _onChangeTheme : function(){

      this.base(arguments);
      if(this._placeholder){

        this._placeholder.dispose();
        this._placeholder = null;
      };
      if(!this.__useQxPlaceholder && qx.ui.form.AbstractField.__stylesheet){

        qx.bom.Stylesheet.removeSheet(qx.ui.form.AbstractField.__stylesheet);
        qx.ui.form.AbstractField.__stylesheet = null;
        qx.ui.form.AbstractField.__addPlaceholderRules();
      };
    },
    _applyPlaceholder : function(value, old){

      if(this.__useQxPlaceholder){

        this._getPlaceholderElement().setValue(value);
        if(value != null){

          this.addListener("focusin", this._removePlaceholder, this);
          this.addListener("focusout", this._showPlaceholder, this);
          this._showPlaceholder();
        } else {

          this.removeListener("focusin", this._removePlaceholder, this);
          this.removeListener("focusout", this._showPlaceholder, this);
          this._removePlaceholder();
        };
      } else {

        if(this.getEnabled()){

          this.getContentElement().setAttribute("placeholder", value);
        };
      };
    },
    _applyTextAlign : function(value, old){

      this.getContentElement().setStyle("textAlign", value);
    },
    _applyReadOnly : function(value, old){

      var element = this.getContentElement();
      element.setAttribute("readOnly", value);
      if(value){

        this.addState("readonly");
        this.setFocusable(false);
      } else {

        this.removeState("readonly");
        this.setFocusable(true);
      };
    }
  },
  defer : function(statics){

    var css = "border: none;" + "padding: 0;" + "margin: 0;" + "display : block;" + "background : transparent;" + "outline: none;" + "appearance: none;" + "position: absolute;" + "autoComplete: off;" + "resize: none;" + "border-radius: 0;";
    qx.ui.style.Stylesheet.getInstance().addRule(".qx-abstract-field", css);
  },
  destruct : function(){

    if(this._placeholder){

      this._placeholder.removeListener("pointerdown", this._onPointerDownPlaceholder, this);
      var parent = this._placeholder.getParent();
      if(parent){

        parent.remove(this._placeholder);
      };
      this._placeholder.dispose();
    };
    this._placeholder = this.__font = null;
    if(qx.core.Environment.get("qx.dynlocale")){

      qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
    };
    if(this.__font && this.__webfontListenerId){

      this.__font.removeListenerById(this.__webfontListenerId);
    };
    this.getContentElement().removeListener("input", this._onHtmlInput, this);
  }
});

qx.Class.define("qx.html.Input", {
  extend : qx.html.Element,
  construct : function(type, styles, attributes){

    if(type === "select" || type === "textarea"){

      var nodeName = type;
    } else {

      nodeName = "input";
    };
    this.base(arguments, nodeName, styles, attributes);
    this.__type = type;
  },
  members : {
    __type : null,
    __selectable : null,
    __enabled : null,
    _createDomElement : function(){

      return qx.bom.Input.create(this.__type);
    },
    _applyProperty : function(name, value){

      this.base(arguments, name, value);
      var element = this.getDomElement();
      if(name === "value"){

        qx.bom.Input.setValue(element, value);
      } else if(name === "wrap"){

        qx.bom.Input.setWrap(element, value);
        this.setStyle("overflow", element.style.overflow, true);
        this.setStyle("overflowX", element.style.overflowX, true);
        this.setStyle("overflowY", element.style.overflowY, true);
      };
    },
    setEnabled : function(value){

      this.__enabled = value;
      this.setAttribute("disabled", value === false);
      if(qx.core.Environment.get("engine.name") == "webkit"){

        if(!value){

          this.setStyles({
            "userModify" : "read-only",
            "userSelect" : "none"
          });
        } else {

          this.setStyles({
            "userModify" : null,
            "userSelect" : this.__selectable ? null : "none"
          });
        };
      };
    },
    setSelectable : qx.core.Environment.select("engine.name", {
      "webkit" : function(value){

        this.__selectable = value;
        this.base(arguments, this.__enabled && value);
      },
      "default" : function(value){

        this.base(arguments, value);
      }
    }),
    setValue : function(value){

      var element = this.getDomElement();
      if(element){

        if(element.value != value){

          qx.bom.Input.setValue(element, value);
        };
      } else {

        this._setProperty("value", value);
      };
      return this;
    },
    getValue : function(){

      var element = this.getDomElement();
      if(element){

        return qx.bom.Input.getValue(element);
      };
      return this._getProperty("value") || "";
    },
    setWrap : function(wrap, direct){

      if(this.__type === "textarea"){

        this._setProperty("wrap", wrap, direct);
      } else {

        throw new Error("Text wrapping is only support by textareas!");
      };
      return this;
    },
    getWrap : function(){

      if(this.__type === "textarea"){

        return this._getProperty("wrap");
      } else {

        throw new Error("Text wrapping is only support by textareas!");
      };
    }
  }
});

qx.Bootstrap.define("qx.bom.Input", {
  statics : {
    __types : {
      text : 1,
      textarea : 1,
      select : 1,
      checkbox : 1,
      radio : 1,
      password : 1,
      hidden : 1,
      submit : 1,
      image : 1,
      file : 1,
      search : 1,
      reset : 1,
      button : 1
    },
    create : function(type, attributes, win){

      if(qx.core.Environment.get("qx.debug")){

        qx.core.Assert.assertKeyInMap(type, this.__types, "Unsupported input type.");
      };
      var attributes = attributes ? qx.lang.Object.clone(attributes) : {
      };
      var tag;
      if(type === "textarea" || type === "select"){

        tag = type;
      } else {

        tag = "input";
        attributes.type = type;
      };
      return qx.dom.Element.create(tag, attributes, win);
    },
    setValue : function(element, value){

      var tag = element.nodeName.toLowerCase();
      var type = element.type;
      var Array = qx.lang.Array;
      var Type = qx.lang.Type;
      if(typeof value === "number"){

        value += "";
      };
      if((type === "checkbox" || type === "radio")){

        if(Type.isArray(value)){

          element.checked = Array.contains(value, element.value);
        } else {

          element.checked = element.value == value;
        };
      } else if(tag === "select"){

        var isArray = Type.isArray(value);
        var options = element.options;
        var subel,subval;
        for(var i = 0,l = options.length;i < l;i++){

          subel = options[i];
          subval = subel.getAttribute("value");
          if(subval == null){

            subval = subel.text;
          };
          subel.selected = isArray ? Array.contains(value, subval) : value == subval;
        };
        if(isArray && value.length == 0){

          element.selectedIndex = -1;
        };
      } else if((type === "text" || type === "textarea") && (qx.core.Environment.get("engine.name") == "mshtml")){

        element.$$inValueSet = true;
        element.value = value;
        element.$$inValueSet = null;
      } else {

        element.value = value;
      };;
    },
    getValue : function(element){

      var tag = element.nodeName.toLowerCase();
      if(tag === "option"){

        return (element.attributes.value || {
        }).specified ? element.value : element.text;
      };
      if(tag === "select"){

        var index = element.selectedIndex;
        if(index < 0){

          return null;
        };
        var values = [];
        var options = element.options;
        var one = element.type == "select-one";
        var clazz = qx.bom.Input;
        var value;
        for(var i = one ? index : 0,max = one ? index + 1 : options.length;i < max;i++){

          var option = options[i];
          if(option.selected){

            value = clazz.getValue(option);
            if(one){

              return value;
            };
            values.push(value);
          };
        };
        return values;
      } else {

        return (element.value || "").replace(/\r/g, "");
      };
    },
    setWrap : qx.core.Environment.select("engine.name", {
      "mshtml" : function(element, wrap){

        var wrapValue = wrap ? "soft" : "off";
        var styleValue = wrap ? "auto" : "";
        element.wrap = wrapValue;
        element.style.overflowY = styleValue;
      },
      "gecko|webkit" : function(element, wrap){

        var wrapValue = wrap ? "soft" : "off";
        var styleValue = wrap ? "" : "auto";
        element.setAttribute("wrap", wrapValue);
        element.style.overflow = styleValue;
      },
      "default" : function(element, wrap){

        element.style.whiteSpace = wrap ? "normal" : "nowrap";
      }
    })
  }
});

qx.Class.define("qx.ui.form.TextField", {
  extend : qx.ui.form.AbstractField,
  properties : {
    appearance : {
      refine : true,
      init : "textfield"
    },
    allowGrowY : {
      refine : true,
      init : false
    },
    allowShrinkY : {
      refine : true,
      init : false
    }
  },
  members : {
    _renderContentElement : function(innerHeight, element){

      if((qx.core.Environment.get("engine.name") == "mshtml") && (parseInt(qx.core.Environment.get("engine.version"), 10) < 9 || qx.core.Environment.get("browser.documentmode") < 9)){

        element.setStyles({
          "line-height" : innerHeight + 'px'
        });
      };
    }
  }
});

qx.Class.define("ms123.form.Select", {
  extend : ms123.form.Dialog,
  properties : {
    options : {
      check : "Array",
      nullable : false,
      event : "changeOptions"
    }
  },
  members : {
    _createWidgetContent : function(){

      var groupboxContainer = new qx.ui.groupbox.GroupBox().set({
        contentPadding : [16, 16, 16, 16]
      });
      groupboxContainer.setLayout(new qx.ui.layout.VBox(10));
      this.add(groupboxContainer);
      var hbox = new qx.ui.container.Composite;
      hbox.setLayout(new qx.ui.layout.HBox(10));
      groupboxContainer.add(hbox);
      this._message = new qx.ui.basic.Label();
      this._message.setRich(true);
      this._message.setWidth(200);
      this._message.setAllowStretchX(true);
      hbox.add(this._message, {
        flex : 1
      });
      var buttonPane = new qx.ui.container.Composite;
      var bpLayout = new qx.ui.layout.HBox(5);
      bpLayout.setAlignX("center");
      buttonPane.setLayout(bpLayout);
      this.addListener("changeOptions", function(event){

        buttonPane.removeAll();
        var options = event.getData();
        options.forEach(function(option){

          var button = new qx.ui.form.Button(option.label, option.icon);
          button.setAllowStretchX(true);
          var value = "" + option.value;
          button.addListener("execute", function(){

            this._handleSelection(value);
          }, this);
          buttonPane.add(button);
        }, this);
        var cancelButton = this._createCancelButton();
        buttonPane.add(cancelButton);
      }, this);
      groupboxContainer.add(buttonPane);
    },
    _handleSelection : function(value){

      this.hide();
      if(this.getCallback()){

        this.getCallback().call(this.getContext(), value);
      };
    }
  }
});

qx.Class.define("qx.ui.layout.Grow", {
  extend : qx.ui.layout.Abstract,
  members : {
    verifyLayoutProperty : qx.core.Environment.select("qx.debug", {
      "true" : function(item, name, value){

        this.assert(false, "The property '" + name + "' is not supported by the Grow layout!");
      },
      "false" : null
    }),
    renderLayout : function(availWidth, availHeight, padding){

      var children = this._getLayoutChildren();
      var child,size,width,height;
      for(var i = 0,l = children.length;i < l;i++){

        child = children[i];
        size = child.getSizeHint();
        width = availWidth;
        if(width < size.minWidth){

          width = size.minWidth;
        } else if(width > size.maxWidth){

          width = size.maxWidth;
        };
        height = availHeight;
        if(height < size.minHeight){

          height = size.minHeight;
        } else if(height > size.maxHeight){

          height = size.maxHeight;
        };
        child.renderLayout(padding.left, padding.top, width, height);
      };
    },
    _computeSizeHint : function(){

      var children = this._getLayoutChildren();
      var child,size;
      var neededWidth = 0,neededHeight = 0;
      var minWidth = 0,minHeight = 0;
      var maxWidth = Infinity,maxHeight = Infinity;
      for(var i = 0,l = children.length;i < l;i++){

        child = children[i];
        size = child.getSizeHint();
        neededWidth = Math.max(neededWidth, size.width);
        neededHeight = Math.max(neededHeight, size.height);
        minWidth = Math.max(minWidth, size.minWidth);
        minHeight = Math.max(minHeight, size.minHeight);
        maxWidth = Math.min(maxWidth, size.maxWidth);
        maxHeight = Math.min(maxHeight, size.maxHeight);
      };
      return {
        width : neededWidth,
        height : neededHeight,
        minWidth : minWidth,
        minHeight : minHeight,
        maxWidth : maxWidth,
        maxHeight : maxHeight
      };
    }
  }
});

qx.Class.define("qx.ui.core.FocusHandler", {
  extend : qx.core.Object,
  type : "singleton",
  construct : function(){

    this.base(arguments);
    this.__roots = {
    };
  },
  members : {
    __roots : null,
    __activeChild : null,
    __focusedChild : null,
    __currentRoot : null,
    connectTo : function(root){

      root.addListener("keypress", this.__onKeyPress, this);
      root.addListener("focusin", this._onFocusIn, this, true);
      root.addListener("focusout", this._onFocusOut, this, true);
      root.addListener("activate", this._onActivate, this, true);
      root.addListener("deactivate", this._onDeactivate, this, true);
    },
    addRoot : function(widget){

      this.__roots[widget.$$hash] = widget;
    },
    removeRoot : function(widget){

      delete this.__roots[widget.$$hash];
    },
    getActiveWidget : function(){

      return this.__activeChild;
    },
    isActive : function(widget){

      return this.__activeChild == widget;
    },
    getFocusedWidget : function(){

      return this.__focusedChild;
    },
    isFocused : function(widget){

      return this.__focusedChild == widget;
    },
    isFocusRoot : function(widget){

      return !!this.__roots[widget.$$hash];
    },
    _onActivate : function(e){

      var target = e.getTarget();
      this.__activeChild = target;
      var root = this.__findFocusRoot(target);
      if(root != this.__currentRoot){

        this.__currentRoot = root;
      };
    },
    _onDeactivate : function(e){

      var target = e.getTarget();
      if(this.__activeChild == target){

        this.__activeChild = null;
      };
    },
    _onFocusIn : function(e){

      var target = e.getTarget();
      if(target != this.__focusedChild){

        this.__focusedChild = target;
        target.visualizeFocus();
      };
    },
    _onFocusOut : function(e){

      var target = e.getTarget();
      if(target == this.__focusedChild){

        this.__focusedChild = null;
        target.visualizeBlur();
      };
    },
    __onKeyPress : function(e){

      if(e.getKeyIdentifier() != "Tab"){

        return;
      };
      if(!this.__currentRoot){

        return;
      };
      e.stopPropagation();
      e.preventDefault();
      var current = this.__focusedChild;
      if(!e.isShiftPressed()){

        var next = current ? this.__getWidgetAfter(current) : this.__getFirstWidget();
      } else {

        var next = current ? this.__getWidgetBefore(current) : this.__getLastWidget();
      };
      if(next){

        next.tabFocus();
      };
    },
    __findFocusRoot : function(widget){

      var roots = this.__roots;
      while(widget){

        if(roots[widget.$$hash]){

          return widget;
        };
        widget = widget.getLayoutParent();
      };
      return null;
    },
    __compareTabOrder : function(widget1, widget2){

      if(widget1 === widget2){

        return 0;
      };
      var tab1 = widget1.getTabIndex() || 0;
      var tab2 = widget2.getTabIndex() || 0;
      if(tab1 != tab2){

        return tab1 - tab2;
      };
      var el1 = widget1.getContentElement().getDomElement();
      var el2 = widget2.getContentElement().getDomElement();
      var Location = qx.bom.element.Location;
      var loc1 = Location.get(el1);
      var loc2 = Location.get(el2);
      if(loc1.top != loc2.top){

        return loc1.top - loc2.top;
      };
      if(loc1.left != loc2.left){

        return loc1.left - loc2.left;
      };
      var z1 = widget1.getZIndex();
      var z2 = widget2.getZIndex();
      if(z1 != z2){

        return z1 - z2;
      };
      return 0;
    },
    __getFirstWidget : function(){

      return this.__getFirst(this.__currentRoot, null);
    },
    __getLastWidget : function(){

      return this.__getLast(this.__currentRoot, null);
    },
    __getWidgetAfter : function(widget){

      var root = this.__currentRoot;
      if(root == widget){

        return this.__getFirstWidget();
      };
      while(widget && widget.getAnonymous()){

        widget = widget.getLayoutParent();
      };
      if(widget == null){

        return [];
      };
      var result = [];
      this.__collectAllAfter(root, widget, result);
      result.sort(this.__compareTabOrder);
      var len = result.length;
      return len > 0 ? result[0] : this.__getFirstWidget();
    },
    __getWidgetBefore : function(widget){

      var root = this.__currentRoot;
      if(root == widget){

        return this.__getLastWidget();
      };
      while(widget && widget.getAnonymous()){

        widget = widget.getLayoutParent();
      };
      if(widget == null){

        return [];
      };
      var result = [];
      this.__collectAllBefore(root, widget, result);
      result.sort(this.__compareTabOrder);
      var len = result.length;
      return len > 0 ? result[len - 1] : this.__getLastWidget();
    },
    __collectAllAfter : function(parent, widget, result){

      var children = parent.getLayoutChildren();
      var child;
      for(var i = 0,l = children.length;i < l;i++){

        child = children[i];
        if(!(child instanceof qx.ui.core.Widget)){

          continue;
        };
        if(!this.isFocusRoot(child) && child.isEnabled() && child.isVisible()){

          if(child.isTabable() && this.__compareTabOrder(widget, child) < 0){

            result.push(child);
          };
          this.__collectAllAfter(child, widget, result);
        };
      };
    },
    __collectAllBefore : function(parent, widget, result){

      var children = parent.getLayoutChildren();
      var child;
      for(var i = 0,l = children.length;i < l;i++){

        child = children[i];
        if(!(child instanceof qx.ui.core.Widget)){

          continue;
        };
        if(!this.isFocusRoot(child) && child.isEnabled() && child.isVisible()){

          if(child.isTabable() && this.__compareTabOrder(widget, child) > 0){

            result.push(child);
          };
          this.__collectAllBefore(child, widget, result);
        };
      };
    },
    __getFirst : function(parent, firstWidget){

      var children = parent.getLayoutChildren();
      var child;
      for(var i = 0,l = children.length;i < l;i++){

        child = children[i];
        if(!(child instanceof qx.ui.core.Widget)){

          continue;
        };
        if(!this.isFocusRoot(child) && child.isEnabled() && child.isVisible()){

          if(child.isTabable()){

            if(firstWidget == null || this.__compareTabOrder(child, firstWidget) < 0){

              firstWidget = child;
            };
          };
          firstWidget = this.__getFirst(child, firstWidget);
        };
      };
      return firstWidget;
    },
    __getLast : function(parent, lastWidget){

      var children = parent.getLayoutChildren();
      var child;
      for(var i = 0,l = children.length;i < l;i++){

        child = children[i];
        if(!(child instanceof qx.ui.core.Widget)){

          continue;
        };
        if(!this.isFocusRoot(child) && child.isEnabled() && child.isVisible()){

          if(child.isTabable()){

            if(lastWidget == null || this.__compareTabOrder(child, lastWidget) > 0){

              lastWidget = child;
            };
          };
          lastWidget = this.__getLast(child, lastWidget);
        };
      };
      return lastWidget;
    }
  },
  destruct : function(){

    this._disposeMap("__roots");
    this.__focusedChild = this.__activeChild = this.__currentRoot = null;
  }
});

qx.Class.define("qx.ui.core.Blocker", {
  extend : qx.core.Object,
  events : {
    blocked : "qx.event.type.Event",
    unblocked : "qx.event.type.Event"
  },
  construct : function(widget){

    this.base(arguments);
    this._widget = widget;
    widget.addListener("resize", this.__onBoundsChange, this);
    widget.addListener("move", this.__onBoundsChange, this);
    widget.addListener("disappear", this.__onWidgetDisappear, this);
    if(qx.Class.isDefined("qx.ui.root.Abstract") && widget instanceof qx.ui.root.Abstract){

      this._isRoot = true;
      this.setKeepBlockerActive(true);
    };
    if(qx.core.Environment.get("qx.dyntheme")){

      qx.theme.manager.Color.getInstance().addListener("changeTheme", this._onChangeTheme, this);
    };
    this.__activeElements = [];
    this.__focusElements = [];
  },
  properties : {
    color : {
      check : "Color",
      init : null,
      nullable : true,
      apply : "_applyColor",
      themeable : true
    },
    opacity : {
      check : "Number",
      init : 1,
      apply : "_applyOpacity",
      themeable : true
    },
    keepBlockerActive : {
      check : "Boolean",
      init : false
    }
  },
  members : {
    __blocker : null,
    __blockerCount : 0,
    __activeElements : null,
    __focusElements : null,
    __timer : null,
    _widget : null,
    _isRoot : false,
    __appearListener : null,
    __onBoundsChange : function(e){

      var data = e.getData();
      if(this.isBlocked()){

        this._updateBlockerBounds(data);
      };
    },
    __onWidgetAppear : function(){

      this._updateBlockerBounds(this._widget.getBounds());
      if(this._widget.isRootWidget()){

        this._widget.getContentElement().add(this.getBlockerElement());
      } else {

        this._widget.getLayoutParent().getContentElement().add(this.getBlockerElement());
      };
    },
    __onWidgetDisappear : function(){

      if(this.isBlocked()){

        this.getBlockerElement().getParent().remove(this.getBlockerElement());
        this._widget.addListenerOnce("appear", this.__onWidgetAppear, this);
      };
    },
    _updateBlockerBounds : function(bounds){

      this.getBlockerElement().setStyles({
        width : bounds.width + "px",
        height : bounds.height + "px",
        left : bounds.left + "px",
        top : bounds.top + "px"
      });
    },
    _applyColor : function(value, old){

      var color = qx.theme.manager.Color.getInstance().resolve(value);
      this.__setBlockersStyle("backgroundColor", color);
    },
    _applyOpacity : function(value, old){

      this.__setBlockersStyle("opacity", value);
    },
    _onChangeTheme : qx.core.Environment.select("qx.dyntheme", {
      "true" : function(){

        this._applyColor(this.getColor());
      },
      "false" : null
    }),
    __setBlockersStyle : function(key, value){

      var blockers = [];
      this.__blocker && blockers.push(this.__blocker);
      for(var i = 0;i < blockers.length;i++){

        blockers[i].setStyle(key, value);
      };
    },
    _backupActiveWidget : function(){

      var focusHandler = qx.event.Registration.getManager(window).getHandler(qx.event.handler.Focus);
      this.__activeElements.push(focusHandler.getActive());
      this.__focusElements.push(focusHandler.getFocus());
      if(this._widget.isFocusable()){

        this._widget.focus();
      };
    },
    _restoreActiveWidget : function(){

      var activeElementsLength = this.__activeElements.length;
      if(activeElementsLength > 0){

        var widget = this.__activeElements[activeElementsLength - 1];
        if(widget){

          qx.bom.Element.activate(widget);
        };
        this.__activeElements.pop();
      };
      var focusElementsLength = this.__focusElements.length;
      if(focusElementsLength > 0){

        var widget = this.__focusElements[focusElementsLength - 1];
        if(widget){

          qx.bom.Element.focus(this.__focusElements[focusElementsLength - 1]);
        };
        this.__focusElements.pop();
      };
    },
    __createBlockerElement : function(){

      return new qx.html.Blocker(this.getColor(), this.getOpacity());
    },
    getBlockerElement : function(widget){

      if(!this.__blocker){

        this.__blocker = this.__createBlockerElement();
        this.__blocker.setStyle("zIndex", 15);
        if(!widget){

          if(this._isRoot){

            widget = this._widget;
          } else {

            widget = this._widget.getLayoutParent();
          };
        };
        widget.getContentElement().add(this.__blocker);
        this.__blocker.exclude();
      };
      return this.__blocker;
    },
    block : function(){

      this._block();
    },
    _block : function(zIndex, blockContent){

      if(!this._isRoot && !this._widget.getLayoutParent()){

        this.__appearListener = this._widget.addListenerOnce("appear", this._block.bind(this, zIndex));
        return;
      };
      var parent;
      if(this._isRoot || blockContent){

        parent = this._widget;
      } else {

        parent = this._widget.getLayoutParent();
      };
      var blocker = this.getBlockerElement(parent);
      if(zIndex != null){

        blocker.setStyle("zIndex", zIndex);
      };
      this.__blockerCount++;
      if(this.__blockerCount < 2){

        this._backupActiveWidget();
        var bounds = this._widget.getBounds();
        if(bounds){

          this._updateBlockerBounds(bounds);
        };
        blocker.include();
        if(!blockContent){

          blocker.activate();
        };
        blocker.addListener("deactivate", this.__activateBlockerElement, this);
        blocker.addListener("keypress", this.__stopTabEvent, this);
        blocker.addListener("keydown", this.__stopTabEvent, this);
        blocker.addListener("keyup", this.__stopTabEvent, this);
        this.fireEvent("blocked", qx.event.type.Event);
      };
    },
    isBlocked : function(){

      return this.__blockerCount > 0;
    },
    unblock : function(){

      if(this.__appearListener){

        this._widget.removeListenerById(this.__appearListener);
      };
      if(!this.isBlocked()){

        return;
      };
      this.__blockerCount--;
      if(this.__blockerCount < 1){

        this.__unblock();
        this.__blockerCount = 0;
      };
    },
    forceUnblock : function(){

      if(!this.isBlocked()){

        return;
      };
      this.__blockerCount = 0;
      this.__unblock();
    },
    __unblock : function(){

      this._restoreActiveWidget();
      var blocker = this.getBlockerElement();
      blocker.removeListener("deactivate", this.__activateBlockerElement, this);
      blocker.removeListener("keypress", this.__stopTabEvent, this);
      blocker.removeListener("keydown", this.__stopTabEvent, this);
      blocker.removeListener("keyup", this.__stopTabEvent, this);
      blocker.exclude();
      this.fireEvent("unblocked", qx.event.type.Event);
    },
    blockContent : function(zIndex){

      this._block(zIndex, true);
    },
    __stopTabEvent : function(e){

      if(e.getKeyIdentifier() == "Tab"){

        e.stop();
      };
    },
    __activateBlockerElement : function(){

      if(this.getKeepBlockerActive()){

        this.getBlockerElement().activate();
      };
    }
  },
  destruct : function(){

    if(qx.core.Environment.get("qx.dyntheme")){

      qx.theme.manager.Color.getInstance().removeListener("changeTheme", this._onChangeTheme, this);
    };
    this._widget.removeListener("resize", this.__onBoundsChange, this);
    this._widget.removeListener("move", this.__onBoundsChange, this);
    this._widget.removeListener("appear", this.__onWidgetAppear, this);
    this._widget.removeListener("disappear", this.__onWidgetDisappear, this);
    if(this.__appearListener){

      this._widget.removeListenerById(this.__appearListener);
    };
    this._disposeObjects("__blocker", "__timer");
    this.__activeElements = this.__focusElements = this._widget = null;
  }
});

qx.Class.define("qx.html.Blocker", {
  extend : qx.html.Element,
  construct : function(backgroundColor, opacity){

    var backgroundColor = backgroundColor ? qx.theme.manager.Color.getInstance().resolve(backgroundColor) : null;
    var styles = {
      position : "absolute",
      opacity : opacity || 0,
      backgroundColor : backgroundColor
    };
    if((qx.core.Environment.get("engine.name") == "mshtml")){

      styles.backgroundImage = "url(" + qx.util.ResourceManager.getInstance().toUri("qx/static/blank.gif") + ")";
      styles.backgroundRepeat = "repeat";
    };
    this.base(arguments, "div", styles);
    this.addListener("mousedown", this._stopPropagation, this);
    this.addListener("mouseup", this._stopPropagation, this);
    this.addListener("click", this._stopPropagation, this);
    this.addListener("dblclick", this._stopPropagation, this);
    this.addListener("mousemove", this._stopPropagation, this);
    this.addListener("mouseover", this._stopPropagation, this);
    this.addListener("mouseout", this._stopPropagation, this);
    this.addListener("mousewheel", this._stopPropagation, this);
    this.addListener("roll", this._stopPropagation, this);
    this.addListener("contextmenu", this._stopPropagation, this);
    this.addListener("pointerdown", this._stopPropagation, this);
    this.addListener("pointerup", this._stopPropagation, this);
    this.addListener("pointermove", this._stopPropagation, this);
    this.addListener("pointerover", this._stopPropagation, this);
    this.addListener("pointerout", this._stopPropagation, this);
    this.addListener("tap", this._stopPropagation, this);
    this.addListener("dbltap", this._stopPropagation, this);
    this.addListener("swipe", this._stopPropagation, this);
    this.addListener("longtap", this._stopPropagation, this);
    this.addListener("appear", this.__refreshCursor, this);
    this.addListener("disappear", this.__refreshCursor, this);
  },
  members : {
    _stopPropagation : function(e){

      e.stopPropagation();
    },
    __refreshCursor : function(){

      var currentCursor = this.getStyle("cursor");
      this.setStyle("cursor", null, true);
      this.setStyle("cursor", currentCursor, true);
    }
  }
});

qx.Class.define("qx.io.remote.Rpc", {
  extend : qx.core.Object,
  construct : function(url, serviceName){

    this.base(arguments);
    if(url !== undefined){

      this.setUrl(url);
    };
    if(serviceName != null){

      this.setServiceName(serviceName);
    };
    if(qx.core.ServerSettings){

      this.__currentServerSuffix = qx.core.ServerSettings.serverPathSuffix;
    };
  },
  events : {
    "completed" : "qx.event.type.Event",
    "aborted" : "qx.event.type.Event",
    "failed" : "qx.event.type.Event",
    "timeout" : "qx.event.type.Event"
  },
  statics : {
    origin : {
      server : 1,
      application : 2,
      transport : 3,
      local : 4
    },
    localError : {
      timeout : 1,
      abort : 2,
      nodata : 3
    },
    CONVERT_DATES : null,
    RESPONSE_JSON : null,
    makeServerURL : function(instanceId){

      var retVal = null;
      if(qx.core.ServerSettings){

        retVal = qx.core.ServerSettings.serverPathPrefix + "/.qxrpc" + qx.core.ServerSettings.serverPathSuffix;
        if(instanceId != null){

          retVal += "?instanceId=" + instanceId;
        };
      };
      return retVal;
    }
  },
  properties : {
    timeout : {
      check : "Integer",
      nullable : true
    },
    crossDomain : {
      check : "Boolean",
      init : false
    },
    url : {
      check : "String",
      nullable : true
    },
    serviceName : {
      check : "String",
      nullable : true
    },
    serverData : {
      check : "Object",
      nullable : true
    },
    username : {
      check : "String",
      nullable : true
    },
    password : {
      check : "String",
      nullable : true
    },
    useBasicHttpAuth : {
      check : "Boolean",
      nullable : true
    },
    protocol : {
      init : "qx1",
      check : function(val){

        return val == "qx1" || val == "2.0";
      }
    }
  },
  members : {
    __previousServerSuffix : null,
    __currentServerSuffix : null,
    createRequest : function(){

      return new qx.io.remote.Request(this.getUrl(), "POST", "application/json");
    },
    createRpcData : function(id, method, parameters, serverData){

      var requestObject;
      var service;
      if(this.getProtocol() == "qx1"){

        requestObject = {
          "service" : method == "refreshSession" ? null : this.getServiceName(),
          "method" : method,
          "id" : id,
          "params" : parameters
        };
        if(serverData){

          requestObject.server_data = serverData;
        };
      } else {

        service = this.getServiceName();
        if(service && service != ""){

          service += ".";
        } else {

          service = "";
        };
        requestObject = {
          "jsonrpc" : "2.0",
          "method" : service + method,
          "id" : id,
          "params" : parameters
        };
      };
      return requestObject;
    },
    _callInternal : function(args, callType, refreshSession){

      var self = this;
      var offset = (callType == 0 ? 0 : 1);
      var whichMethod = (refreshSession ? "refreshSession" : args[offset]);
      var handler = args[0];
      var argsArray = [];
      var eventTarget = this;
      var protocol = this.getProtocol();
      for(var i = offset + 1;i < args.length;++i){

        argsArray.push(args[i]);
      };
      var req = this.createRequest();
      var serverData = this.getServerData();
      var rpcData = this.createRpcData(req.getSequenceNumber(), whichMethod, argsArray, serverData);
      req.setCrossDomain(this.getCrossDomain());
      if(this.getUsername()){

        req.setUseBasicHttpAuth(this.getUseBasicHttpAuth());
        req.setUsername(this.getUsername());
        req.setPassword(this.getPassword());
      };
      req.setTimeout(this.getTimeout());
      var ex = null;
      var id = null;
      var result = null;
      var response = null;
      var handleRequestFinished = function(eventType, eventTarget){

        switch(callType){case 0:
        break;case 1:
        handler(result, ex, id);
        break;case 2:
        if(!ex){

          eventTarget.fireDataEvent(eventType, response);
        } else {

          ex.id = id;
          if(args[0]){

            eventTarget.fireDataEvent("failed", ex);
          } else {

            eventTarget.fireDataEvent(eventType, ex);
          };
        };};
      };
      var addToStringToObject = function(obj){

        if(protocol == "qx1"){

          obj.toString = function(){

            switch(obj.origin){case qx.io.remote.Rpc.origin.server:
            return "Server error " + obj.code + ": " + obj.message;case qx.io.remote.Rpc.origin.application:
            return "Application error " + obj.code + ": " + obj.message;case qx.io.remote.Rpc.origin.transport:
            return "Transport error " + obj.code + ": " + obj.message;case qx.io.remote.Rpc.origin.local:
            return "Local error " + obj.code + ": " + obj.message;default:
            return ("UNEXPECTED origin " + obj.origin + " error " + obj.code + ": " + obj.message);};
          };
        } else {

          obj.toString = function(){

            var ret;
            ret = "Error " + obj.code + ": " + obj.message;
            if(obj.data){

              ret += " (" + obj.data + ")";
            };
            return ret;
          };
        };
      };
      var makeException = function(origin, code, message){

        var ex = new Object();
        if(protocol == "qx1"){

          ex.origin = origin;
        };
        ex.code = code;
        ex.message = message;
        addToStringToObject(ex);
        return ex;
      };
      req.addListener("failed", function(evt){

        var code = evt.getStatusCode();
        ex = makeException(qx.io.remote.Rpc.origin.transport, code, qx.io.remote.Exchange.statusCodeToString(code));
        id = this.getSequenceNumber();
        handleRequestFinished("failed", eventTarget);
      });
      req.addListener("timeout", function(evt){

        this.debug("TIMEOUT OCCURRED");
        ex = makeException(qx.io.remote.Rpc.origin.local, qx.io.remote.Rpc.localError.timeout, "Local time-out expired for " + whichMethod);
        id = this.getSequenceNumber();
        handleRequestFinished("timeout", eventTarget);
      });
      req.addListener("aborted", function(evt){

        ex = makeException(qx.io.remote.Rpc.origin.local, qx.io.remote.Rpc.localError.abort, "Aborted " + whichMethod);
        id = this.getSequenceNumber();
        handleRequestFinished("aborted", eventTarget);
      });
      req.addListener("completed", function(evt){

        response = evt.getContent();
        if(response === null){

          ex = makeException(qx.io.remote.Rpc.origin.local, qx.io.remote.Rpc.localError.nodata, "No data in response to " + whichMethod);
          id = this.getSequenceNumber();
          handleRequestFinished("failed", eventTarget);
          return;
        };
        if(!qx.lang.Type.isObject(response)){

          if(self._isConvertDates()){

            if(self._isResponseJson()){

              response = qx.lang.Json.parse(response, function(key, value){

                if(value && typeof value === "string"){

                  if(value.indexOf("new Date(Date.UTC(") >= 0){

                    var m = value.match(/new Date\(Date.UTC\((\d+),(\d+),(\d+),(\d+),(\d+),(\d+),(\d+)\)\)/);
                    return new Date(Date.UTC(m[1], m[2], m[3], m[4], m[5], m[6], m[7]));
                  };
                };
                return value;
              });
            } else {

              response = response && response.length > 0 ? eval('(' + response + ')') : null;
            };
          } else {

            response = qx.lang.Json.parse(response);
          };
        };
        id = response["id"];
        if(id != this.getSequenceNumber()){

          this.warn("Received id (" + id + ") does not match requested id " + "(" + this.getSequenceNumber() + ")!");
        };
        var eventType = "completed";
        var exTest = response["error"];
        if(exTest != null){

          result = null;
          addToStringToObject(exTest);
          ex = exTest;
          eventType = "failed";
        } else {

          result = response["result"];
          if(refreshSession){

            result = eval("(" + result + ")");
            var newSuffix = qx.core.ServerSettings.serverPathSuffix;
            if(self.__currentServerSuffix != newSuffix){

              self.__previousServerSuffix = self.__currentServerSuffix;
              self.__currentServerSuffix = newSuffix;
            };
            self.setUrl(self.fixUrl(self.getUrl()));
          };
        };
        handleRequestFinished(eventType, eventTarget);
      });
      var replacer = null;
      if(this._isConvertDates()){

        replacer = function(key, value){

          value = this[key];
          if(qx.lang.Type.isDate(value)){

            var dateParams = value.getUTCFullYear() + "," + value.getUTCMonth() + "," + value.getUTCDate() + "," + value.getUTCHours() + "," + value.getUTCMinutes() + "," + value.getUTCSeconds() + "," + value.getUTCMilliseconds();
            return "new Date(Date.UTC(" + dateParams + "))";
          };
          return value;
        };
      };
      req.setData(qx.lang.Json.stringify(rpcData, replacer));
      req.setAsynchronous(callType > 0);
      if(req.getCrossDomain()){

        req.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      } else {

        req.setRequestHeader("Content-Type", "application/json");
      };
      req.setParseJson(false);
      req.send();
      if(callType == 0){

        if(ex != null){

          var error = new Error(ex.toString());
          error.rpcdetails = ex;
          throw error;
        };
        return result;
      } else {

        return req;
      };
    },
    fixUrl : function(url){

      if(this.__previousServerSuffix == null || this.__currentServerSuffix == null || this.__previousServerSuffix == "" || this.__previousServerSuffix == this.__currentServerSuffix){

        return url;
      };
      var index = url.indexOf(this.__previousServerSuffix);
      if(index == -1){

        return url;
      };
      return (url.substring(0, index) + this.__currentServerSuffix + url.substring(index + this.__previousServerSuffix.length));
    },
    callSync : function(methodName){

      return this._callInternal(arguments, 0);
    },
    callAsync : function(handler, methodName){

      return this._callInternal(arguments, 1);
    },
    callAsyncListeners : function(coalesce, methodName){

      return this._callInternal(arguments, 2);
    },
    refreshSession : function(handler){

      if(qx.core.ServerSettings && qx.core.ServerSettings.serverPathSuffix){

        var timeDiff = (new Date()).getTime() - qx.core.ServerSettings.lastSessionRefresh;
        if(timeDiff / 1000 > (qx.core.ServerSettings.sessionTimeoutInSeconds - 30)){

          this._callInternal([handler], 1, true);
        } else {

          handler(true);
        };
      } else {

        handler(false);
      };
    },
    _isConvertDates : function(){

      return !!(qx.io.remote.Rpc.CONVERT_DATES);
    },
    _isResponseJson : function(){

      return !!(qx.io.remote.Rpc.RESPONSE_JSON);
    },
    abort : function(opaqueCallRef){

      opaqueCallRef.abort();
    }
  }
});

qx.Class.define("qx.io.remote.Request", {
  extend : qx.core.Object,
  construct : function(vUrl, vMethod, vResponseType){

    this.base(arguments);
    this.__requestHeaders = {
    };
    this.__urlParameters = {
    };
    this.__dataParameters = {
    };
    this.__formFields = {
    };
    if(vUrl !== undefined){

      this.setUrl(vUrl);
    };
    if(vMethod !== undefined){

      this.setMethod(vMethod);
    };
    if(vResponseType !== undefined){

      this.setResponseType(vResponseType);
    };
    this.setProhibitCaching(true);
    this.__seqNum = ++qx.io.remote.Request.__seqNum;
  },
  events : {
    "created" : "qx.event.type.Event",
    "configured" : "qx.event.type.Event",
    "sending" : "qx.event.type.Event",
    "receiving" : "qx.event.type.Event",
    "completed" : "qx.io.remote.Response",
    "aborted" : "qx.event.type.Event",
    "failed" : "qx.io.remote.Response",
    "timeout" : "qx.io.remote.Response"
  },
  statics : {
    __seqNum : 0,
    methodAllowsRequestBody : function(httpMethod){

      return (httpMethod == "POST") || (httpMethod == "PUT");
    }
  },
  properties : {
    url : {
      check : "String",
      init : ""
    },
    method : {
      check : ["GET", "POST", "PUT", "HEAD", "DELETE"],
      apply : "_applyMethod",
      init : "GET"
    },
    asynchronous : {
      check : "Boolean",
      init : true
    },
    data : {
      check : "String",
      nullable : true
    },
    username : {
      check : "String",
      nullable : true
    },
    password : {
      check : "String",
      nullable : true
    },
    state : {
      check : ["configured", "queued", "sending", "receiving", "completed", "aborted", "timeout", "failed"],
      init : "configured",
      apply : "_applyState",
      event : "changeState"
    },
    responseType : {
      check : ["text/plain", "text/javascript", "application/json", "application/xml", "text/html"],
      init : "text/plain",
      apply : "_applyResponseType"
    },
    timeout : {
      check : "Integer",
      nullable : true
    },
    prohibitCaching : {
      check : function(v){

        return typeof v == "boolean" || v === "no-url-params-on-post";
      },
      init : true,
      apply : "_applyProhibitCaching"
    },
    crossDomain : {
      check : "Boolean",
      init : false
    },
    fileUpload : {
      check : "Boolean",
      init : false
    },
    transport : {
      check : "qx.io.remote.Exchange",
      nullable : true
    },
    useBasicHttpAuth : {
      check : "Boolean",
      init : false
    },
    parseJson : {
      check : "Boolean",
      init : true
    }
  },
  members : {
    __requestHeaders : null,
    __urlParameters : null,
    __dataParameters : null,
    __formFields : null,
    __seqNum : null,
    send : function(){

      qx.io.remote.RequestQueue.getInstance().add(this);
    },
    abort : function(){

      qx.io.remote.RequestQueue.getInstance().abort(this);
    },
    reset : function(){

      switch(this.getState()){case "sending":case "receiving":
      this.error("Aborting already sent request!");case "queued":
      this.abort();
      break;};
    },
    isConfigured : function(){

      return this.getState() === "configured";
    },
    isQueued : function(){

      return this.getState() === "queued";
    },
    isSending : function(){

      return this.getState() === "sending";
    },
    isReceiving : function(){

      return this.getState() === "receiving";
    },
    isCompleted : function(){

      return this.getState() === "completed";
    },
    isAborted : function(){

      return this.getState() === "aborted";
    },
    isTimeout : function(){

      return this.getState() === "timeout";
    },
    isFailed : function(){

      return this.getState() === "failed";
    },
    __forwardEvent : qx.event.GlobalError.observeMethod(function(e){

      var clonedEvent = e.clone();
      clonedEvent.setTarget(this);
      this.dispatchEvent(clonedEvent);
    }),
    _onqueued : function(e){

      this.setState("queued");
      this.__forwardEvent(e);
    },
    _onsending : function(e){

      this.setState("sending");
      this.__forwardEvent(e);
    },
    _onreceiving : function(e){

      this.setState("receiving");
      this.__forwardEvent(e);
    },
    _oncompleted : function(e){

      this.setState("completed");
      this.__forwardEvent(e);
      this.dispose();
    },
    _onaborted : function(e){

      this.setState("aborted");
      this.__forwardEvent(e);
      this.dispose();
    },
    _ontimeout : function(e){

      this.setState("timeout");
      this.__forwardEvent(e);
      this.dispose();
    },
    _onfailed : function(e){

      this.setState("failed");
      this.__forwardEvent(e);
      this.dispose();
    },
    _applyState : function(value, old){

      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote")){

          this.debug("State: " + value);
        };
      };
    },
    _applyProhibitCaching : function(value, old){

      if(!value){

        this.removeParameter("nocache");
        this.removeRequestHeader("Pragma");
        this.removeRequestHeader("Cache-Control");
        return;
      };
      if(value !== "no-url-params-on-post" || this.getMethod() != "POST"){

        this.setParameter("nocache", new Date().valueOf());
      } else {

        this.removeParameter("nocache");
      };
      this.setRequestHeader("Pragma", "no-cache");
      this.setRequestHeader("Cache-Control", "no-cache");
    },
    _applyMethod : function(value, old){

      if(qx.io.remote.Request.methodAllowsRequestBody(value)){

        this.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      } else {

        this.removeRequestHeader("Content-Type");
      };
      var prohibitCaching = this.getProhibitCaching();
      this._applyProhibitCaching(prohibitCaching, prohibitCaching);
    },
    _applyResponseType : function(value, old){

      this.setRequestHeader("X-Qooxdoo-Response-Type", value);
    },
    setRequestHeader : function(vId, vValue){

      this.__requestHeaders[vId] = vValue;
    },
    removeRequestHeader : function(vId){

      delete this.__requestHeaders[vId];
    },
    getRequestHeader : function(vId){

      return this.__requestHeaders[vId] || null;
    },
    getRequestHeaders : function(){

      return this.__requestHeaders;
    },
    setParameter : function(vId, vValue, bAsData){

      if(bAsData){

        this.__dataParameters[vId] = vValue;
      } else {

        this.__urlParameters[vId] = vValue;
      };
    },
    removeParameter : function(vId, bFromData){

      if(bFromData){

        delete this.__dataParameters[vId];
      } else {

        delete this.__urlParameters[vId];
      };
    },
    getParameter : function(vId, bFromData){

      if(bFromData){

        return this.__dataParameters[vId] || null;
      } else {

        return this.__urlParameters[vId] || null;
      };
    },
    getParameters : function(bFromData){

      return (bFromData ? this.__dataParameters : this.__urlParameters);
    },
    setFormField : function(vId, vValue){

      this.__formFields[vId] = vValue;
    },
    removeFormField : function(vId){

      delete this.__formFields[vId];
    },
    getFormField : function(vId){

      return this.__formFields[vId] || null;
    },
    getFormFields : function(){

      return this.__formFields;
    },
    getSequenceNumber : function(){

      return this.__seqNum;
    }
  },
  destruct : function(){

    this.setTransport(null);
    this.__requestHeaders = this.__urlParameters = this.__dataParameters = this.__formFields = null;
  }
});

qx.Class.define("qx.io.remote.RequestQueue", {
  type : "singleton",
  extend : qx.core.Object,
  construct : function(){

    this.base(arguments);
    this.__queue = [];
    this.__active = [];
    this.__totalRequests = 0;
    this.__timer = new qx.event.Timer(500);
    this.__timer.addListener("interval", this._oninterval, this);
  },
  properties : {
    enabled : {
      init : true,
      check : "Boolean",
      apply : "_applyEnabled"
    },
    maxTotalRequests : {
      check : "Integer",
      nullable : true
    },
    maxConcurrentRequests : {
      check : "Integer",
      init : qx.core.Environment.get("io.maxrequests")
    },
    defaultTimeout : {
      check : "Integer",
      init : 5000
    }
  },
  members : {
    __queue : null,
    __active : null,
    __totalRequests : null,
    __timer : null,
    getRequestQueue : function(){

      return this.__queue;
    },
    getActiveQueue : function(){

      return this.__active;
    },
    _debug : function(){

      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote")){

          var vText = this.__active.length + "/" + (this.__queue.length + this.__active.length);
          this.debug("Progress: " + vText);
          window.status = "Request-Queue Progress: " + vText;
        };
      };
    },
    _check : function(){

      this._debug();
      if(this.__active.length == 0 && this.__queue.length == 0){

        this.__timer.stop();
      };
      if(!this.getEnabled()){

        return;
      };
      if(this.__queue.length == 0 || (this.__queue[0].isAsynchronous() && this.__active.length >= this.getMaxConcurrentRequests())){

        return;
      };
      if(this.getMaxTotalRequests() != null && this.__totalRequests >= this.getMaxTotalRequests()){

        return;
      };
      var vRequest = this.__queue.shift();
      var vTransport = new qx.io.remote.Exchange(vRequest);
      this.__totalRequests++;
      this.__active.push(vTransport);
      this._debug();
      vTransport.addListener("sending", this._onsending, this);
      vTransport.addListener("receiving", this._onreceiving, this);
      vTransport.addListener("completed", this._oncompleted, this);
      vTransport.addListener("aborted", this._oncompleted, this);
      vTransport.addListener("timeout", this._oncompleted, this);
      vTransport.addListener("failed", this._oncompleted, this);
      vTransport._start = (new Date).valueOf();
      vTransport.send();
      if(this.__queue.length > 0){

        this._check();
      };
    },
    _remove : function(vTransport){

      qx.lang.Array.remove(this.__active, vTransport);
      vTransport.dispose();
      this._check();
    },
    __activeCount : 0,
    _onsending : function(e){

      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote")){

          this.__activeCount++;
          e.getTarget()._counted = true;
          this.debug("ActiveCount: " + this.__activeCount);
        };
      };
      e.getTarget().getRequest()._onsending(e);
    },
    _onreceiving : function(e){

      e.getTarget().getRequest()._onreceiving(e);
    },
    _oncompleted : function(e){

      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote")){

          if(e.getTarget()._counted){

            this.__activeCount--;
            this.debug("ActiveCount: " + this.__activeCount);
          };
        };
      };
      var request = e.getTarget().getRequest();
      var requestHandler = "_on" + e.getType();
      this._remove(e.getTarget());
      try{

        if(request[requestHandler]){

          request[requestHandler](e);
        };
      } catch(ex) {

        this.error("Request " + request + " handler " + requestHandler + " threw an error: ", ex);
        try{

          if(request["_onaborted"]){

            var event = qx.event.Registration.createEvent("aborted", qx.event.type.Event);
            request["_onaborted"](event);
          };
        } catch(ex1) {
        };
      };
    },
    _oninterval : function(e){

      var vActive = this.__active;
      if(vActive.length == 0){

        this.__timer.stop();
        return;
      };
      var vCurrent = (new Date).valueOf();
      var vTransport;
      var vRequest;
      var vDefaultTimeout = this.getDefaultTimeout();
      var vTimeout;
      var vTime;
      for(var i = vActive.length - 1;i >= 0;i--){

        vTransport = vActive[i];
        vRequest = vTransport.getRequest();
        if(vRequest.isAsynchronous()){

          vTimeout = vRequest.getTimeout();
          if(vTimeout == 0){

            continue;
          };
          if(vTimeout == null){

            vTimeout = vDefaultTimeout;
          };
          vTime = vCurrent - vTransport._start;
          if(vTime > vTimeout){

            this.warn("Timeout: transport " + vTransport.toHashCode());
            this.warn(vTime + "ms > " + vTimeout + "ms");
            vTransport.timeout();
          };
        };
      };
    },
    _applyEnabled : function(value, old){

      if(value){

        this._check();
      };
      this.__timer.setEnabled(value);
    },
    add : function(vRequest){

      vRequest.setState("queued");
      if(vRequest.isAsynchronous()){

        this.__queue.push(vRequest);
      } else {

        this.__queue.unshift(vRequest);
      };
      this._check();
      if(this.getEnabled()){

        this.__timer.start();
      };
    },
    abort : function(vRequest){

      var vTransport = vRequest.getTransport();
      if(vTransport){

        vTransport.abort();
      } else if(qx.lang.Array.contains(this.__queue, vRequest)){

        qx.lang.Array.remove(this.__queue, vRequest);
      };
    }
  },
  destruct : function(){

    this._disposeArray("__active");
    this._disposeObjects("__timer");
    this.__queue = null;
  }
});

qx.Class.define("qx.io.remote.Exchange", {
  extend : qx.core.Object,
  construct : function(vRequest){

    this.base(arguments);
    this.setRequest(vRequest);
    vRequest.setTransport(this);
  },
  events : {
    "sending" : "qx.event.type.Event",
    "receiving" : "qx.event.type.Event",
    "completed" : "qx.io.remote.Response",
    "aborted" : "qx.event.type.Event",
    "failed" : "qx.io.remote.Response",
    "timeout" : "qx.io.remote.Response"
  },
  statics : {
    typesOrder : ["qx.io.remote.transport.XmlHttp", "qx.io.remote.transport.Iframe", "qx.io.remote.transport.Script"],
    typesReady : false,
    typesAvailable : {
    },
    typesSupported : {
    },
    registerType : function(vClass, vId){

      qx.io.remote.Exchange.typesAvailable[vId] = vClass;
    },
    initTypes : function(){

      if(qx.io.remote.Exchange.typesReady){

        return;
      };
      for(var vId in qx.io.remote.Exchange.typesAvailable){

        var vTransporterImpl = qx.io.remote.Exchange.typesAvailable[vId];
        if(vTransporterImpl.isSupported()){

          qx.io.remote.Exchange.typesSupported[vId] = vTransporterImpl;
        };
      };
      qx.io.remote.Exchange.typesReady = true;
      if(qx.lang.Object.isEmpty(qx.io.remote.Exchange.typesSupported)){

        throw new Error("No supported transport types were found!");
      };
    },
    canHandle : function(vImpl, vNeeds, vResponseType){

      if(!qx.lang.Array.contains(vImpl.handles.responseTypes, vResponseType)){

        return false;
      };
      for(var vKey in vNeeds){

        if(!vImpl.handles[vKey]){

          return false;
        };
      };
      return true;
    },
    _nativeMap : {
      '0' : "created",
      '1' : "configured",
      '2' : "sending",
      '3' : "receiving",
      '4' : "completed"
    },
    wasSuccessful : function(vStatusCode, vReadyState, vIsLocal){

      if(vIsLocal){

        switch(vStatusCode){case null:case 0:
        return true;case -1:
        return vReadyState < 4;default:
        return typeof vStatusCode === "undefined";};
      } else {

        switch(vStatusCode){case -1:
        if(qx.core.Environment.get("qx.debug")){

          if(qx.core.Environment.get("qx.debug.io.remote") && vReadyState > 3){

            qx.log.Logger.debug(this, "Failed with statuscode: -1 at readyState " + vReadyState);
          };
        };
        return vReadyState < 4;case 200:case 304:
        return true;case 201:case 202:case 203:case 204:case 205:
        return true;case 206:
        if(qx.core.Environment.get("qx.debug")){

          if(qx.core.Environment.get("qx.debug.io.remote") && vReadyState === 4){

            qx.log.Logger.debug(this, "Failed with statuscode: 206 (Partial content while being complete!)");
          };
        };
        return vReadyState !== 4;case 300:case 301:case 302:case 303:case 305:case 400:case 401:case 402:case 403:case 404:case 405:case 406:case 407:case 408:case 409:case 410:case 411:case 412:case 413:case 414:case 415:case 500:case 501:case 502:case 503:case 504:case 505:
        if(qx.core.Environment.get("qx.debug")){

          if(qx.core.Environment.get("qx.debug.io.remote")){

            qx.log.Logger.debug(this, "Failed with typical HTTP statuscode: " + vStatusCode);
          };
        };
        return false;case 12002:case 12007:case 12029:case 12030:case 12031:case 12152:case 13030:
        if(qx.core.Environment.get("qx.debug")){

          if(qx.core.Environment.get("qx.debug.io.remote")){

            qx.log.Logger.debug(this, "Failed with MSHTML specific HTTP statuscode: " + vStatusCode);
          };
        };
        return false;default:
        if(vStatusCode > 206 && vStatusCode < 300){

          return true;
        };
        qx.log.Logger.debug(this, "Unknown status code: " + vStatusCode + " (" + vReadyState + ")");
        return false;};
      };
    },
    statusCodeToString : function(vStatusCode){

      switch(vStatusCode){case -1:
      return "Not available";case 0:
      var url = window.location.href;
      if(qx.lang.String.startsWith(url.toLowerCase(), "file:")){

        return ("Unknown status code. " + "Possibly due to application URL using 'file:' protocol?");
      } else {

        return ("Unknown status code. " + "Possibly due to a cross-domain request?");
      };
      break;case 200:
      return "Ok";case 304:
      return "Not modified";case 206:
      return "Partial content";case 204:
      return "No content";case 300:
      return "Multiple choices";case 301:
      return "Moved permanently";case 302:
      return "Moved temporarily";case 303:
      return "See other";case 305:
      return "Use proxy";case 400:
      return "Bad request";case 401:
      return "Unauthorized";case 402:
      return "Payment required";case 403:
      return "Forbidden";case 404:
      return "Not found";case 405:
      return "Method not allowed";case 406:
      return "Not acceptable";case 407:
      return "Proxy authentication required";case 408:
      return "Request time-out";case 409:
      return "Conflict";case 410:
      return "Gone";case 411:
      return "Length required";case 412:
      return "Precondition failed";case 413:
      return "Request entity too large";case 414:
      return "Request-URL too large";case 415:
      return "Unsupported media type";case 500:
      return "Server error";case 501:
      return "Not implemented";case 502:
      return "Bad gateway";case 503:
      return "Out of resources";case 504:
      return "Gateway time-out";case 505:
      return "HTTP version not supported";case 12002:
      return "Server timeout";case 12029:
      return "Connection dropped";case 12030:
      return "Connection dropped";case 12031:
      return "Connection dropped";case 12152:
      return "Connection closed by server";case 13030:
      return "MSHTML-specific HTTP status code";default:
      return "Unknown status code";};
    }
  },
  properties : {
    request : {
      check : "qx.io.remote.Request",
      nullable : true
    },
    implementation : {
      check : "qx.io.remote.transport.Abstract",
      nullable : true,
      apply : "_applyImplementation"
    },
    state : {
      check : ["configured", "sending", "receiving", "completed", "aborted", "timeout", "failed"],
      init : "configured",
      event : "changeState",
      apply : "_applyState"
    }
  },
  members : {
    send : function(){

      var vRequest = this.getRequest();
      if(!vRequest){

        return this.error("Please attach a request object first");
      };
      qx.io.remote.Exchange.initTypes();
      var vUsage = qx.io.remote.Exchange.typesOrder;
      var vSupported = qx.io.remote.Exchange.typesSupported;
      var vResponseType = vRequest.getResponseType();
      var vNeeds = {
      };
      if(vRequest.getAsynchronous()){

        vNeeds.asynchronous = true;
      } else {

        vNeeds.synchronous = true;
      };
      if(vRequest.getCrossDomain()){

        vNeeds.crossDomain = true;
      };
      if(vRequest.getFileUpload()){

        vNeeds.fileUpload = true;
      };
      for(var field in vRequest.getFormFields()){

        vNeeds.programaticFormFields = true;
        break;
      };
      var vTransportImpl,vTransport;
      for(var i = 0,l = vUsage.length;i < l;i++){

        vTransportImpl = vSupported[vUsage[i]];
        if(vTransportImpl){

          if(!qx.io.remote.Exchange.canHandle(vTransportImpl, vNeeds, vResponseType)){

            continue;
          };
          try{

            if(qx.core.Environment.get("qx.debug")){

              if(qx.core.Environment.get("qx.debug.io.remote")){

                this.debug("Using implementation: " + vTransportImpl.classname);
              };
            };
            vTransport = new vTransportImpl;
            this.setImplementation(vTransport);
            vTransport.setUseBasicHttpAuth(vRequest.getUseBasicHttpAuth());
            vTransport.send();
            return true;
          } catch(ex) {

            this.error("Request handler throws error");
            this.error(ex);
            return false;
          };
        };
      };
      this.error("There is no transport implementation available to handle this request: " + vRequest);
    },
    abort : function(){

      var vImplementation = this.getImplementation();
      if(vImplementation){

        if(qx.core.Environment.get("qx.debug")){

          if(qx.core.Environment.get("qx.debug.io.remote")){

            this.debug("Abort: implementation " + vImplementation.toHashCode());
          };
        };
        vImplementation.abort();
      } else {

        if(qx.core.Environment.get("qx.debug")){

          if(qx.core.Environment.get("qx.debug.io.remote")){

            this.debug("Abort: forcing state to be aborted");
          };
        };
        this.setState("aborted");
      };
    },
    timeout : function(){

      var vImplementation = this.getImplementation();
      if(vImplementation){

        var str = "";
        for(var key in vImplementation.getParameters()){

          str += "&" + key + "=" + vImplementation.getParameters()[key];
        };
        this.warn("Timeout: implementation " + vImplementation.toHashCode() + ", " + vImplementation.getUrl() + " [" + vImplementation.getMethod() + "], " + str);
        vImplementation.timeout();
      } else {

        this.warn("Timeout: forcing state to timeout");
        this.setState("timeout");
      };
      this.__disableRequestTimeout();
    },
    __disableRequestTimeout : function(){

      var vRequest = this.getRequest();
      if(vRequest){

        vRequest.setTimeout(0);
      };
    },
    _onsending : function(e){

      this.setState("sending");
    },
    _onreceiving : function(e){

      this.setState("receiving");
    },
    _oncompleted : function(e){

      this.setState("completed");
    },
    _onabort : function(e){

      this.setState("aborted");
    },
    _onfailed : function(e){

      this.setState("failed");
    },
    _ontimeout : function(e){

      this.setState("timeout");
    },
    _applyImplementation : function(value, old){

      if(old){

        old.removeListener("sending", this._onsending, this);
        old.removeListener("receiving", this._onreceiving, this);
        old.removeListener("completed", this._oncompleted, this);
        old.removeListener("aborted", this._onabort, this);
        old.removeListener("timeout", this._ontimeout, this);
        old.removeListener("failed", this._onfailed, this);
      };
      if(value){

        var vRequest = this.getRequest();
        value.setUrl(vRequest.getUrl());
        value.setMethod(vRequest.getMethod());
        value.setAsynchronous(vRequest.getAsynchronous());
        value.setUsername(vRequest.getUsername());
        value.setPassword(vRequest.getPassword());
        value.setParameters(vRequest.getParameters(false));
        value.setFormFields(vRequest.getFormFields());
        value.setRequestHeaders(vRequest.getRequestHeaders());
        if(value instanceof qx.io.remote.transport.XmlHttp){

          value.setParseJson(vRequest.getParseJson());
        };
        var data = vRequest.getData();
        if(data === null){

          var vParameters = vRequest.getParameters(true);
          var vParametersList = [];
          for(var vId in vParameters){

            var paramValue = vParameters[vId];
            if(paramValue instanceof Array){

              for(var i = 0;i < paramValue.length;i++){

                vParametersList.push(encodeURIComponent(vId) + "=" + encodeURIComponent(paramValue[i]));
              };
            } else {

              vParametersList.push(encodeURIComponent(vId) + "=" + encodeURIComponent(paramValue));
            };
          };
          if(vParametersList.length > 0){

            value.setData(vParametersList.join("&"));
          };
        } else {

          value.setData(data);
        };
        value.setResponseType(vRequest.getResponseType());
        value.addListener("sending", this._onsending, this);
        value.addListener("receiving", this._onreceiving, this);
        value.addListener("completed", this._oncompleted, this);
        value.addListener("aborted", this._onabort, this);
        value.addListener("timeout", this._ontimeout, this);
        value.addListener("failed", this._onfailed, this);
      };
    },
    _applyState : function(value, old){

      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote")){

          this.debug("State: " + old + " => " + value);
        };
      };
      switch(value){case "sending":
      this.fireEvent("sending");
      break;case "receiving":
      this.fireEvent("receiving");
      break;case "completed":case "aborted":case "timeout":case "failed":
      var vImpl = this.getImplementation();
      if(!vImpl){

        break;
      };
      this.__disableRequestTimeout();
      if(this.hasListener(value)){

        var vResponse = qx.event.Registration.createEvent(value, qx.io.remote.Response);
        if(value == "completed"){

          var vContent = vImpl.getResponseContent();
          vResponse.setContent(vContent);
          if(vContent === null){

            if(qx.core.Environment.get("qx.debug")){

              if(qx.core.Environment.get("qx.debug.io.remote")){

                this.debug("Altered State: " + value + " => failed");
              };
            };
            value = "failed";
          };
        } else if(value == "failed"){

          vResponse.setContent(vImpl.getResponseContent());
        };
        vResponse.setStatusCode(vImpl.getStatusCode());
        vResponse.setResponseHeaders(vImpl.getResponseHeaders());
        this.dispatchEvent(vResponse);
      };
      this.setImplementation(null);
      vImpl.dispose();
      break;};
    }
  },
  environment : {
    "qx.debug.io.remote" : false,
    "qx.debug.io.remote.data" : false
  },
  destruct : function(){

    var vImpl = this.getImplementation();
    if(vImpl){

      this.setImplementation(null);
      vImpl.dispose();
    };
    this.setRequest(null);
  }
});

qx.Class.define("qx.io.remote.transport.Abstract", {
  type : "abstract",
  extend : qx.core.Object,
  construct : function(){

    this.base(arguments);
    this.setRequestHeaders({
    });
    this.setParameters({
    });
    this.setFormFields({
    });
  },
  events : {
    "created" : "qx.event.type.Event",
    "configured" : "qx.event.type.Event",
    "sending" : "qx.event.type.Event",
    "receiving" : "qx.event.type.Event",
    "completed" : "qx.event.type.Event",
    "aborted" : "qx.event.type.Event",
    "failed" : "qx.event.type.Event",
    "timeout" : "qx.event.type.Event"
  },
  properties : {
    url : {
      check : "String",
      nullable : true
    },
    method : {
      check : "String",
      nullable : true,
      init : "GET"
    },
    asynchronous : {
      check : "Boolean",
      nullable : true,
      init : true
    },
    data : {
      check : "String",
      nullable : true
    },
    username : {
      check : "String",
      nullable : true
    },
    password : {
      check : "String",
      nullable : true
    },
    state : {
      check : ["created", "configured", "sending", "receiving", "completed", "aborted", "timeout", "failed"],
      init : "created",
      event : "changeState",
      apply : "_applyState"
    },
    requestHeaders : {
      check : "Object",
      nullable : true
    },
    parameters : {
      check : "Object",
      nullable : true
    },
    formFields : {
      check : "Object",
      nullable : true
    },
    responseType : {
      check : "String",
      nullable : true
    },
    useBasicHttpAuth : {
      check : "Boolean",
      nullable : true
    }
  },
  members : {
    send : function(){

      throw new Error("send is abstract");
    },
    abort : function(){

      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote")){

          this.warn("Aborting...");
        };
      };
      this.setState("aborted");
    },
    timeout : function(){

      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote")){

          this.warn("Timeout...");
        };
      };
      this.setState("timeout");
    },
    failed : function(){

      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote")){

          this.warn("Failed...");
        };
      };
      this.setState("failed");
    },
    setRequestHeader : function(vLabel, vValue){

      throw new Error("setRequestHeader is abstract");
    },
    getResponseHeader : function(vLabel){

      throw new Error("getResponseHeader is abstract");
    },
    getResponseHeaders : function(){

      throw new Error("getResponseHeaders is abstract");
    },
    getStatusCode : function(){

      throw new Error("getStatusCode is abstract");
    },
    getStatusText : function(){

      throw new Error("getStatusText is abstract");
    },
    getResponseText : function(){

      throw new Error("getResponseText is abstract");
    },
    getResponseXml : function(){

      throw new Error("getResponseXml is abstract");
    },
    getFetchedLength : function(){

      throw new Error("getFetchedLength is abstract");
    },
    _applyState : function(value, old){

      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote")){

          this.debug("State: " + value);
        };
      };
      switch(value){case "created":
      this.fireEvent("created");
      break;case "configured":
      this.fireEvent("configured");
      break;case "sending":
      this.fireEvent("sending");
      break;case "receiving":
      this.fireEvent("receiving");
      break;case "completed":
      this.fireEvent("completed");
      break;case "aborted":
      this.fireEvent("aborted");
      break;case "failed":
      this.fireEvent("failed");
      break;case "timeout":
      this.fireEvent("timeout");
      break;};
      return true;
    }
  },
  destruct : function(){

    this.setRequestHeaders(null);
    this.setParameters(null);
    this.setFormFields(null);
  }
});

qx.Class.define("qx.io.remote.transport.Iframe", {
  extend : qx.io.remote.transport.Abstract,
  construct : function(){

    this.base(arguments);
    var vUniqueId = (new Date).valueOf();
    var vFrameName = "frame_" + vUniqueId;
    var vFormName = "form_" + vUniqueId;
    var vFrameSource;
    if((qx.core.Environment.get("engine.name") == "mshtml")){

      vFrameSource = "javascript:void(0)";
    };
    this.__frame = qx.bom.Iframe.create({
      id : vFrameName,
      name : vFrameName,
      src : vFrameSource
    });
    qx.bom.element.Style.set(this.__frame, "display", "none");
    this.__form = qx.dom.Element.create("form", {
      id : vFormName,
      name : vFormName,
      target : vFrameName
    });
    qx.bom.element.Style.set(this.__form, "display", "none");
    qx.dom.Element.insertEnd(this.__form, qx.dom.Node.getBodyElement(document));
    this.__data = qx.dom.Element.create("textarea", {
      id : "_data_",
      name : "_data_"
    });
    qx.dom.Element.insertEnd(this.__data, this.__form);
    qx.dom.Element.insertEnd(this.__frame, qx.dom.Node.getBodyElement(document));
    qx.event.Registration.addListener(this.__frame, "load", this._onload, this);
    this.__onreadystatechangeWrapper = qx.lang.Function.listener(this._onreadystatechange, this);
    qx.bom.Event.addNativeListener(this.__frame, "readystatechange", this.__onreadystatechangeWrapper);
  },
  statics : {
    handles : {
      synchronous : false,
      asynchronous : true,
      crossDomain : false,
      fileUpload : true,
      programaticFormFields : true,
      responseTypes : ["text/plain", "text/javascript", "application/json", "application/xml", "text/html"]
    },
    isSupported : function(){

      return true;
    },
    _numericMap : {
      "uninitialized" : 1,
      "loading" : 2,
      "loaded" : 2,
      "interactive" : 3,
      "complete" : 4
    }
  },
  members : {
    __data : null,
    __lastReadyState : 0,
    __form : null,
    __frame : null,
    __onreadystatechangeWrapper : null,
    send : function(){

      var vMethod = this.getMethod();
      var vUrl = this.getUrl();
      var vParameters = this.getParameters(false);
      var vParametersList = [];
      for(var vId in vParameters){

        var value = vParameters[vId];
        if(value instanceof Array){

          for(var i = 0;i < value.length;i++){

            vParametersList.push(encodeURIComponent(vId) + "=" + encodeURIComponent(value[i]));
          };
        } else {

          vParametersList.push(encodeURIComponent(vId) + "=" + encodeURIComponent(value));
        };
      };
      if(vParametersList.length > 0){

        vUrl += (vUrl.indexOf("?") >= 0 ? "&" : "?") + vParametersList.join("&");
      };
      if(this.getData() === null){

        var vParameters = this.getParameters(true);
        var vParametersList = [];
        for(var vId in vParameters){

          var value = vParameters[vId];
          if(value instanceof Array){

            for(var i = 0;i < value.length;i++){

              vParametersList.push(encodeURIComponent(vId) + "=" + encodeURIComponent(value[i]));
            };
          } else {

            vParametersList.push(encodeURIComponent(vId) + "=" + encodeURIComponent(value));
          };
        };
        if(vParametersList.length > 0){

          this.setData(vParametersList.join("&"));
        };
      };
      var vFormFields = this.getFormFields();
      for(var vId in vFormFields){

        var vField = document.createElement("textarea");
        vField.name = vId;
        vField.appendChild(document.createTextNode(vFormFields[vId]));
        this.__form.appendChild(vField);
      };
      this.__form.action = vUrl;
      this.__form.method = vMethod;
      this.__data.appendChild(document.createTextNode(this.getData()));
      this.__form.submit();
      this.setState("sending");
    },
    _onload : qx.event.GlobalError.observeMethod(function(e){

      if(qx.core.Environment.get("engine.name") == "opera" && this.getIframeHtmlContent() == ""){

        return;
      };
      if(this.__form.src){

        return;
      };
      this._switchReadyState(qx.io.remote.transport.Iframe._numericMap.complete);
    }),
    _onreadystatechange : qx.event.GlobalError.observeMethod(function(e){

      this._switchReadyState(qx.io.remote.transport.Iframe._numericMap[this.__frame.readyState]);
    }),
    _switchReadyState : function(vReadyState){

      switch(this.getState()){case "completed":case "aborted":case "failed":case "timeout":
      this.warn("Ignore Ready State Change");
      return;};
      while(this.__lastReadyState < vReadyState){

        this.setState(qx.io.remote.Exchange._nativeMap[++this.__lastReadyState]);
      };
    },
    setRequestHeader : function(vLabel, vValue){
    },
    getResponseHeader : function(vLabel){

      return null;
    },
    getResponseHeaders : function(){

      return {
      };
    },
    getStatusCode : function(){

      return 200;
    },
    getStatusText : function(){

      return "";
    },
    getIframeWindow : function(){

      return qx.bom.Iframe.getWindow(this.__frame);
    },
    getIframeDocument : function(){

      return qx.bom.Iframe.getDocument(this.__frame);
    },
    getIframeBody : function(){

      return qx.bom.Iframe.getBody(this.__frame);
    },
    getIframeTextContent : function(){

      var vBody = this.getIframeBody();
      if(!vBody){

        return null;
      };
      if(!vBody.firstChild){

        return "";
      };
      if(vBody.firstChild.tagName && vBody.firstChild.tagName.toLowerCase() == "pre"){

        return vBody.firstChild.innerHTML;
      } else {

        return vBody.innerHTML;
      };
    },
    getIframeHtmlContent : function(){

      var vBody = this.getIframeBody();
      return vBody ? vBody.innerHTML : null;
    },
    getFetchedLength : function(){

      return 0;
    },
    getResponseContent : function(){

      if(this.getState() !== "completed"){

        if(qx.core.Environment.get("qx.debug")){

          if(qx.core.Environment.get("qx.debug.io.remote")){

            this.warn("Transfer not complete, ignoring content!");
          };
        };
        return null;
      };
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote")){

          this.debug("Returning content for responseType: " + this.getResponseType());
        };
      };
      var vText = this.getIframeTextContent();
      switch(this.getResponseType()){case "text/plain":
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote.data")){

          this.debug("Response: " + this._responseContent);
        };
      };
      return vText;case "text/html":
      vText = this.getIframeHtmlContent();
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote.data")){

          this.debug("Response: " + this._responseContent);
        };
      };
      return vText;case "application/json":
      vText = this.getIframeHtmlContent();
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote.data")){

          this.debug("Response: " + this._responseContent);
        };
      };
      try{

        return vText && vText.length > 0 ? qx.lang.Json.parse(vText) : null;
      } catch(ex) {

        return this.error("Could not execute json: (" + vText + ")", ex);
      };case "text/javascript":
      vText = this.getIframeHtmlContent();
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote.data")){

          this.debug("Response: " + this._responseContent);
        };
      };
      try{

        return vText && vText.length > 0 ? window.eval(vText) : null;
      } catch(ex) {

        return this.error("Could not execute javascript: (" + vText + ")", ex);
      };case "application/xml":
      vText = this.getIframeDocument();
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote.data")){

          this.debug("Response: " + this._responseContent);
        };
      };
      return vText;default:
      this.warn("No valid responseType specified (" + this.getResponseType() + ")!");
      return null;};
    }
  },
  defer : function(){

    qx.io.remote.Exchange.registerType(qx.io.remote.transport.Iframe, "qx.io.remote.transport.Iframe");
  },
  destruct : function(){

    if(this.__frame){

      qx.event.Registration.removeListener(this.__frame, "load", this._onload, this);
      qx.bom.Event.removeNativeListener(this.__frame, "readystatechange", this.__onreadystatechangeWrapper);
      if((qx.core.Environment.get("engine.name") == "gecko")){

        this.__frame.src = qx.util.ResourceManager.getInstance().toUri("qx/static/blank.gif");
      };
      qx.dom.Element.remove(this.__frame);
    };
    if(this.__form){

      qx.dom.Element.remove(this.__form);
    };
    this.__frame = this.__form = this.__data = null;
  }
});

qx.Class.define("qx.io.remote.transport.Script", {
  extend : qx.io.remote.transport.Abstract,
  construct : function(){

    this.base(arguments);
    var vUniqueId = ++qx.io.remote.transport.Script.__uniqueId;
    if(vUniqueId >= 2000000000){

      qx.io.remote.transport.Script.__uniqueId = vUniqueId = 1;
    };
    this.__element = null;
    this.__uniqueId = vUniqueId;
  },
  statics : {
    __uniqueId : 0,
    _instanceRegistry : {
    },
    ScriptTransport_PREFIX : "_ScriptTransport_",
    ScriptTransport_ID_PARAM : "_ScriptTransport_id",
    ScriptTransport_DATA_PARAM : "_ScriptTransport_data",
    handles : {
      synchronous : false,
      asynchronous : true,
      crossDomain : true,
      fileUpload : false,
      programaticFormFields : false,
      responseTypes : ["text/plain", "text/javascript", "application/json"]
    },
    isSupported : function(){

      return true;
    },
    _numericMap : {
      "uninitialized" : 1,
      "loading" : 2,
      "loaded" : 2,
      "interactive" : 3,
      "complete" : 4
    },
    _requestFinished : qx.event.GlobalError.observeMethod(function(id, content){

      var vInstance = qx.io.remote.transport.Script._instanceRegistry[id];
      if(vInstance == null){

        if(qx.core.Environment.get("qx.debug")){

          if(qx.core.Environment.get("qx.debug.io.remote")){

            this.warn("Request finished for an unknown instance (probably aborted or timed out before)");
          };
        };
      } else {

        vInstance._responseContent = content;
        vInstance._switchReadyState(qx.io.remote.transport.Script._numericMap.complete);
      };
    })
  },
  members : {
    __lastReadyState : 0,
    __element : null,
    __uniqueId : null,
    send : function(){

      var vUrl = this.getUrl();
      vUrl += (vUrl.indexOf("?") >= 0 ? "&" : "?") + qx.io.remote.transport.Script.ScriptTransport_ID_PARAM + "=" + this.__uniqueId;
      var vParameters = this.getParameters();
      var vParametersList = [];
      for(var vId in vParameters){

        if(vId.indexOf(qx.io.remote.transport.Script.ScriptTransport_PREFIX) == 0){

          this.error("Illegal parameter name. The following prefix is used internally by qooxdoo): " + qx.io.remote.transport.Script.ScriptTransport_PREFIX);
        };
        var value = vParameters[vId];
        if(value instanceof Array){

          for(var i = 0;i < value.length;i++){

            vParametersList.push(encodeURIComponent(vId) + "=" + encodeURIComponent(value[i]));
          };
        } else {

          vParametersList.push(encodeURIComponent(vId) + "=" + encodeURIComponent(value));
        };
      };
      if(vParametersList.length > 0){

        vUrl += "&" + vParametersList.join("&");
      };
      var vData = this.getData();
      if(vData != null){

        vUrl += "&" + qx.io.remote.transport.Script.ScriptTransport_DATA_PARAM + "=" + encodeURIComponent(vData);
      };
      qx.io.remote.transport.Script._instanceRegistry[this.__uniqueId] = this;
      this.__element = document.createElement("script");
      this.__element.charset = "utf-8";
      this.__element.src = vUrl;
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote.data")){

          this.debug("Request: " + vUrl);
        };
      };
      document.body.appendChild(this.__element);
    },
    _switchReadyState : function(vReadyState){

      switch(this.getState()){case "completed":case "aborted":case "failed":case "timeout":
      this.warn("Ignore Ready State Change");
      return;};
      while(this.__lastReadyState < vReadyState){

        this.setState(qx.io.remote.Exchange._nativeMap[++this.__lastReadyState]);
      };
    },
    setRequestHeader : function(vLabel, vValue){
    },
    getResponseHeader : function(vLabel){

      return null;
    },
    getResponseHeaders : function(){

      return {
      };
    },
    getStatusCode : function(){

      return 200;
    },
    getStatusText : function(){

      return "";
    },
    getFetchedLength : function(){

      return 0;
    },
    getResponseContent : function(){

      if(this.getState() !== "completed"){

        if(qx.core.Environment.get("qx.debug")){

          if(qx.core.Environment.get("qx.debug.io.remote")){

            this.warn("Transfer not complete, ignoring content!");
          };
        };
        return null;
      };
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote")){

          this.debug("Returning content for responseType: " + this.getResponseType());
        };
      };
      switch(this.getResponseType()){case "text/plain":case "application/json":case "text/javascript":
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote.data")){

          this.debug("Response: " + this._responseContent);
        };
      };
      var ret = this._responseContent;
      return (ret === 0 ? 0 : (ret || null));default:
      this.warn("No valid responseType specified (" + this.getResponseType() + ")!");
      return null;};
    }
  },
  defer : function(){

    qx.io.remote.Exchange.registerType(qx.io.remote.transport.Script, "qx.io.remote.transport.Script");
  },
  destruct : function(){

    if(this.__element){

      delete qx.io.remote.transport.Script._instanceRegistry[this.__uniqueId];
      document.body.removeChild(this.__element);
    };
    this.__element = this._responseContent = null;
  }
});

qx.Class.define("qx.io.remote.transport.XmlHttp", {
  extend : qx.io.remote.transport.Abstract,
  statics : {
    handles : {
      synchronous : true,
      asynchronous : true,
      crossDomain : false,
      fileUpload : false,
      programaticFormFields : false,
      responseTypes : ["text/plain", "text/javascript", "application/json", "application/xml", "text/html"]
    },
    createRequestObject : qx.core.Environment.select("engine.name", {
      "default" : function(){

        return new XMLHttpRequest;
      },
      "mshtml" : function(){

        if(window.ActiveXObject && qx.xml.Document.XMLHTTP){

          return new ActiveXObject(qx.xml.Document.XMLHTTP);
        };
        if(window.XMLHttpRequest){

          return new XMLHttpRequest;
        };
      }
    }),
    isSupported : function(){

      return !!this.createRequestObject();
    }
  },
  properties : {
    parseJson : {
      check : "Boolean",
      init : true
    }
  },
  members : {
    __localRequest : false,
    __lastReadyState : 0,
    __request : null,
    getRequest : function(){

      if(this.__request === null){

        this.__request = qx.io.remote.transport.XmlHttp.createRequestObject();
        this.__request.onreadystatechange = qx.lang.Function.bind(this._onreadystatechange, this);
      };
      return this.__request;
    },
    send : function(){

      this.__lastReadyState = 0;
      var vRequest = this.getRequest();
      var vMethod = this.getMethod();
      var vAsynchronous = this.getAsynchronous();
      var vUrl = this.getUrl();
      var vLocalRequest = (window.location.protocol === "file:" && !(/^http(s){0,1}\:/.test(vUrl)));
      this.__localRequest = vLocalRequest;
      var vParameters = this.getParameters(false);
      var vParametersList = [];
      for(var vId in vParameters){

        var value = vParameters[vId];
        if(value instanceof Array){

          for(var i = 0;i < value.length;i++){

            vParametersList.push(encodeURIComponent(vId) + "=" + encodeURIComponent(value[i]));
          };
        } else {

          vParametersList.push(encodeURIComponent(vId) + "=" + encodeURIComponent(value));
        };
      };
      if(vParametersList.length > 0){

        vUrl += (vUrl.indexOf("?") >= 0 ? "&" : "?") + vParametersList.join("&");
      };
      if(this.getData() === null){

        var vParameters = this.getParameters(true);
        var vParametersList = [];
        for(var vId in vParameters){

          var value = vParameters[vId];
          if(value instanceof Array){

            for(var i = 0;i < value.length;i++){

              vParametersList.push(encodeURIComponent(vId) + "=" + encodeURIComponent(value[i]));
            };
          } else {

            vParametersList.push(encodeURIComponent(vId) + "=" + encodeURIComponent(value));
          };
        };
        if(vParametersList.length > 0){

          this.setData(vParametersList.join("&"));
        };
      };
      var encode64 = function(input){

        var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var output = "";
        var chr1,chr2,chr3;
        var enc1,enc2,enc3,enc4;
        var i = 0;
        do {

          chr1 = input.charCodeAt(i++);
          chr2 = input.charCodeAt(i++);
          chr3 = input.charCodeAt(i++);
          enc1 = chr1 >> 2;
          enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
          enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
          enc4 = chr3 & 63;
          if(isNaN(chr2)){

            enc3 = enc4 = 64;
          } else if(isNaN(chr3)){

            enc4 = 64;
          };
          output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
        }while((i < input.length));
        return output;
      };
      try{

        if(this.getUsername()){

          if(this.getUseBasicHttpAuth()){

            vRequest.open(vMethod, vUrl, vAsynchronous);
            vRequest.setRequestHeader('Authorization', 'Basic ' + encode64(this.getUsername() + ':' + this.getPassword()));
          } else {

            vRequest.open(vMethod, vUrl, vAsynchronous, this.getUsername(), this.getPassword());
          };
        } else {

          vRequest.open(vMethod, vUrl, vAsynchronous);
        };
      } catch(ex) {

        this.error("Failed with exception: " + ex);
        this.failed();
        return;
      };
      if(!(qx.core.Environment.get("engine.name") == "webkit")){

        vRequest.setRequestHeader('Referer', window.location.href);
      };
      var vRequestHeaders = this.getRequestHeaders();
      for(var vId in vRequestHeaders){

        vRequest.setRequestHeader(vId, vRequestHeaders[vId]);
      };
      try{

        if(qx.core.Environment.get("qx.debug")){

          if(qx.core.Environment.get("qx.debug.io.remote.data")){

            this.debug("Request: " + this.getData());
          };
        };
        if(vLocalRequest && vAsynchronous && qx.core.Environment.get("engine.name") == "mshtml" && (qx.core.Environment.get("engine.version") == 9 && qx.core.Environment.get("browser.documentmode") == 9)){

          qx.event.Timer.once(function(){

            vRequest.send(this.getData());
          }, this, 0);
        } else {

          vRequest.send(this.getData());
        };
      } catch(ex) {

        if(vLocalRequest){

          this.failedLocally();
        } else {

          this.error("Failed to send data to URL '" + vUrl + "': " + ex, "send");
          this.failed();
        };
        return;
      };
      if(!vAsynchronous){

        this._onreadystatechange();
      };
    },
    failedLocally : function(){

      if(this.getState() === "failed"){

        return;
      };
      this.warn("Could not load from file: " + this.getUrl());
      this.failed();
    },
    _onreadystatechange : qx.event.GlobalError.observeMethod(function(e){

      switch(this.getState()){case "completed":case "aborted":case "failed":case "timeout":
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote")){

          this.warn("Ignore Ready State Change");
        };
      };
      return;};
      var vReadyState = this.getReadyState();
      if(vReadyState == 4){

        if(!qx.io.remote.Exchange.wasSuccessful(this.getStatusCode(), vReadyState, this.__localRequest)){

          if(this.getState() === "configured"){

            this.setState("sending");
          };
          this.failed();
          return;
        };
      };
      if(vReadyState == 3 && this.__lastReadyState == 1){

        this.setState(qx.io.remote.Exchange._nativeMap[++this.__lastReadyState]);
      };
      while(this.__lastReadyState < vReadyState){

        this.setState(qx.io.remote.Exchange._nativeMap[++this.__lastReadyState]);
      };
    }),
    getReadyState : function(){

      var vReadyState = null;
      try{

        vReadyState = this.getRequest().readyState;
      } catch(ex) {
      };
      return vReadyState;
    },
    setRequestHeader : function(vLabel, vValue){

      this.getRequestHeaders()[vLabel] = vValue;
    },
    getResponseHeader : function(vLabel){

      var vResponseHeader = null;
      try{

        vResponseHeader = this.getRequest().getResponseHeader(vLabel) || null;
      } catch(ex) {
      };
      return vResponseHeader;
    },
    getStringResponseHeaders : function(){

      var vSourceHeader = null;
      try{

        var vLoadHeader = this.getRequest().getAllResponseHeaders();
        if(vLoadHeader){

          vSourceHeader = vLoadHeader;
        };
      } catch(ex) {
      };
      return vSourceHeader;
    },
    getResponseHeaders : function(){

      var vSourceHeader = this.getStringResponseHeaders();
      var vHeader = {
      };
      if(vSourceHeader){

        var vValues = vSourceHeader.split(/[\r\n]+/g);
        for(var i = 0,l = vValues.length;i < l;i++){

          var vPair = vValues[i].match(/^([^:]+)\s*:\s*(.+)$/i);
          if(vPair){

            vHeader[vPair[1]] = vPair[2];
          };
        };
      };
      return vHeader;
    },
    getStatusCode : function(){

      var vStatusCode = -1;
      try{

        vStatusCode = this.getRequest().status;
        if(vStatusCode === 1223){

          vStatusCode = 204;
        };
      } catch(ex) {
      };
      return vStatusCode;
    },
    getStatusText : function(){

      var vStatusText = "";
      try{

        vStatusText = this.getRequest().statusText;
      } catch(ex) {
      };
      return vStatusText;
    },
    getResponseText : function(){

      var vResponseText = null;
      try{

        vResponseText = this.getRequest().responseText;
      } catch(ex) {

        vResponseText = null;
      };
      return vResponseText;
    },
    getResponseXml : function(){

      var vResponseXML = null;
      var vStatus = this.getStatusCode();
      var vReadyState = this.getReadyState();
      if(qx.io.remote.Exchange.wasSuccessful(vStatus, vReadyState, this.__localRequest)){

        try{

          vResponseXML = this.getRequest().responseXML;
        } catch(ex) {
        };
      };
      if(typeof vResponseXML == "object" && vResponseXML != null){

        if(!vResponseXML.documentElement){

          var s = String(this.getRequest().responseText).replace(/<\?xml[^\?]*\?>/, "");
          vResponseXML.loadXML(s);
        };
        if(!vResponseXML.documentElement){

          throw new Error("Missing Document Element!");
        };
        if(vResponseXML.documentElement.tagName == "parseerror"){

          throw new Error("XML-File is not well-formed!");
        };
      } else {

        throw new Error("Response was not a valid xml document [" + this.getRequest().responseText + "]");
      };
      return vResponseXML;
    },
    getFetchedLength : function(){

      var vText = this.getResponseText();
      return typeof vText == "string" ? vText.length : 0;
    },
    getResponseContent : function(){

      var state = this.getState();
      if(state !== "completed" && state != "failed"){

        if(qx.core.Environment.get("qx.debug")){

          if(qx.core.Environment.get("qx.debug.io.remote")){

            this.warn("Transfer not complete or failed, ignoring content!");
          };
        };
        return null;
      };
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote")){

          this.debug("Returning content for responseType: " + this.getResponseType());
        };
      };
      var vText = this.getResponseText();
      if(state == "failed"){

        if(qx.core.Environment.get("qx.debug")){

          if(qx.core.Environment.get("qx.debug.io.remote.data")){

            this.debug("Failed: " + vText);
          };
        };
        return vText;
      };
      switch(this.getResponseType()){case "text/plain":case "text/html":
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote.data")){

          this.debug("Response: " + vText);
        };
      };
      return vText;case "application/json":
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote.data")){

          this.debug("Response: " + vText);
        };
      };
      try{

        if(vText && vText.length > 0){

          var ret;
          if(this.getParseJson()){

            ret = qx.lang.Json.parse(vText);
            ret = (ret === 0 ? 0 : (ret || null));
          } else {

            ret = vText;
          };
          return ret;
        } else {

          return null;
        };
      } catch(ex) {

        this.error("Could not execute json: [" + vText + "]", ex);
        return "<pre>Could not execute json: \n" + vText + "\n</pre>";
      };case "text/javascript":
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote.data")){

          this.debug("Response: " + vText);
        };
      };
      try{

        if(vText && vText.length > 0){

          var ret = window.eval(vText);
          return (ret === 0 ? 0 : (ret || null));
        } else {

          return null;
        };
      } catch(ex) {

        this.error("Could not execute javascript: [" + vText + "]", ex);
        return null;
      };case "application/xml":
      vText = this.getResponseXml();
      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote.data")){

          this.debug("Response: " + vText);
        };
      };
      return (vText === 0 ? 0 : (vText || null));default:
      this.warn("No valid responseType specified (" + this.getResponseType() + ")!");
      return null;};
    },
    _applyState : function(value, old){

      if(qx.core.Environment.get("qx.debug")){

        if(qx.core.Environment.get("qx.debug.io.remote")){

          this.debug("State: " + value);
        };
      };
      switch(value){case "created":
      this.fireEvent("created");
      break;case "configured":
      this.fireEvent("configured");
      break;case "sending":
      this.fireEvent("sending");
      break;case "receiving":
      this.fireEvent("receiving");
      break;case "completed":
      this.fireEvent("completed");
      break;case "failed":
      this.fireEvent("failed");
      break;case "aborted":
      this.getRequest().abort();
      this.fireEvent("aborted");
      break;case "timeout":
      this.getRequest().abort();
      this.fireEvent("timeout");
      break;};
    }
  },
  defer : function(){

    qx.io.remote.Exchange.registerType(qx.io.remote.transport.XmlHttp, "qx.io.remote.transport.XmlHttp");
  },
  destruct : function(){

    var vRequest = this.getRequest();
    if(vRequest){

      vRequest.onreadystatechange = (function(){
      });
      switch(vRequest.readyState){case 1:case 2:case 3:
      vRequest.abort();};
    };
    this.__request = null;
  }
});

qx.Class.define("qx.io.remote.Response", {
  extend : qx.event.type.Event,
  properties : {
    state : {
      check : "Integer",
      nullable : true
    },
    statusCode : {
      check : "Integer",
      nullable : true
    },
    content : {
      nullable : true
    },
    responseHeaders : {
      check : "Object",
      nullable : true,
      apply : "_applyResponseHeaders"
    }
  },
  members : {
    __lowerHeaders : null,
    clone : function(embryo){

      var clone = this.base(arguments, embryo);
      clone.setType(this.getType());
      clone.setState(this.getState());
      clone.setStatusCode(this.getStatusCode());
      clone.setContent(this.getContent());
      clone.setResponseHeaders(this.getResponseHeaders());
      return clone;
    },
    getResponseHeader : function(vHeader){

      if(this.__lowerHeaders){

        return this.__lowerHeaders[vHeader.toLowerCase()] || null;
      };
      return null;
    },
    _applyResponseHeaders : function(value, old){

      var lowerHeaders = {
      };
      if(value !== null){

        Object.keys(value).forEach(function(key){

          lowerHeaders[key.toLowerCase()] = value[key];
        });
        this.__lowerHeaders = lowerHeaders;
      };
    }
  }
});

qx.Class.define("ms123.util.Rpc", {
  extend : qx.io.remote.Rpc,
  properties : {
  },
  members : {
    createRpcData : function(id, method, parameters, serverData){

      var requestObject;
      var service;
      if(this.getProtocol() == "qx1"){

        console.warn("--> method(" + method + "):" + qx.util.Serializer.toJson(parameters));
        requestObject = {
          "service" : method == "refreshSession" ? null : this.getServiceName(),
          "method" : method,
          "id" : id,
          "params" : parameters.pop()
        };
        if(serverData){

          requestObject.server_data = serverData;
        };
      } else {

        service = this.getServiceName();
        if(service && service != ""){

          service += ".";
        } else {

          service = "";
        };
        requestObject = {
          "jsonrpc" : "2.0",
          "method" : service + method,
          "id" : id,
          "params" : parameters
        };
      };
      return requestObject;
    }
  }
});

qx.Class.define("qx.util.Serializer", {
  statics : {
    toUriParameter : function(object, qxSerializer, dateFormat){

      var result = "";
      var properties = qx.util.PropertyUtil.getAllProperties(object.constructor);
      for(var name in properties){

        if(properties[name].group != undefined){

          continue;
        };
        var value = object["get" + qx.lang.String.firstUp(name)]();
        if(qx.lang.Type.isArray(value)){

          var isdataArray = qx.data && qx.data.IListData && qx.Class.hasInterface(value && value.constructor, qx.data.IListData);
          for(var i = 0;i < value.length;i++){

            var valueAtI = isdataArray ? value.getItem(i) : value[i];
            result += this.__toUriParameter(name, valueAtI, qxSerializer);
          };
        } else if(qx.lang.Type.isDate(value) && dateFormat != null){

          result += this.__toUriParameter(name, dateFormat.format(value), qxSerializer);
        } else {

          result += this.__toUriParameter(name, value, qxSerializer);
        };
      };
      return result.substring(0, result.length - 1);
    },
    __toUriParameter : function(name, value, qxSerializer){

      if(value && value.$$type == "Class"){

        value = value.classname;
      };
      if(value && (value.$$type == "Interface" || value.$$type == "Mixin")){

        value = value.name;
      };
      if(value instanceof qx.core.Object && qxSerializer != null){

        var encValue = encodeURIComponent(qxSerializer(value));
        if(encValue === undefined){

          var encValue = encodeURIComponent(value);
        };
      } else {

        var encValue = encodeURIComponent(value);
      };
      return encodeURIComponent(name) + "=" + encValue + "&";
    },
    toNativeObject : function(object, qxSerializer, dateFormat){

      var result;
      if(object == null){

        return null;
      };
      if(qx.data && qx.data.IListData && qx.Class.hasInterface(object.constructor, qx.data.IListData)){

        result = [];
        for(var i = 0;i < object.getLength();i++){

          result.push(qx.util.Serializer.toNativeObject(object.getItem(i), qxSerializer, dateFormat));
        };
        return result;
      };
      if(qx.lang.Type.isArray(object)){

        result = [];
        for(var i = 0;i < object.length;i++){

          result.push(qx.util.Serializer.toNativeObject(object[i], qxSerializer, dateFormat));
        };
        return result;
      };
      if(object.$$type == "Class"){

        return object.classname;
      };
      if(object.$$type == "Interface" || object.$$type == "Mixin"){

        return object.name;
      };
      if(object instanceof qx.core.Object){

        if(qxSerializer != null){

          var returnValue = qxSerializer(object);
          if(returnValue != undefined){

            return returnValue;
          };
        };
        result = {
        };
        var properties = qx.util.PropertyUtil.getAllProperties(object.constructor);
        for(var name in properties){

          if(properties[name].group != undefined){

            continue;
          };
          var value = object["get" + qx.lang.String.firstUp(name)]();
          result[name] = qx.util.Serializer.toNativeObject(value, qxSerializer, dateFormat);
        };
        return result;
      };
      if(qx.lang.Type.isDate(object) && dateFormat != null){

        return dateFormat.format(object);
      };
      if(qx.locale && qx.locale.LocalizedString && object instanceof qx.locale.LocalizedString){

        return object.toString();
      };
      if(qx.lang.Type.isObject(object)){

        result = {
        };
        for(var key in object){

          result[key] = qx.util.Serializer.toNativeObject(object[key], qxSerializer, dateFormat);
        };
        return result;
      };
      return object;
    },
    toJson : function(object, qxSerializer, dateFormat){

      var result = "";
      if(object == null){

        return "null";
      };
      if(qx.data && qx.data.IListData && qx.Class.hasInterface(object.constructor, qx.data.IListData)){

        result += "[";
        for(var i = 0;i < object.getLength();i++){

          result += qx.util.Serializer.toJson(object.getItem(i), qxSerializer, dateFormat) + ",";
        };
        if(result != "["){

          result = result.substring(0, result.length - 1);
        };
        return result + "]";
      };
      if(qx.lang.Type.isArray(object)){

        result += "[";
        for(var i = 0;i < object.length;i++){

          result += qx.util.Serializer.toJson(object[i], qxSerializer, dateFormat) + ",";
        };
        if(result != "["){

          result = result.substring(0, result.length - 1);
        };
        return result + "]";
      };
      if(object.$$type == "Class"){

        return '"' + object.classname + '"';
      };
      if(object.$$type == "Interface" || object.$$type == "Mixin"){

        return '"' + object.name + '"';
      };
      if(object instanceof qx.core.Object){

        if(qxSerializer != null){

          var returnValue = qxSerializer(object);
          if(returnValue != undefined){

            return '"' + returnValue + '"';
          };
        };
        result += "{";
        var properties = qx.util.PropertyUtil.getAllProperties(object.constructor);
        for(var name in properties){

          if(properties[name].group != undefined){

            continue;
          };
          var value = object["get" + qx.lang.String.firstUp(name)]();
          result += '"' + name + '":' + qx.util.Serializer.toJson(value, qxSerializer, dateFormat) + ",";
        };
        if(result != "{"){

          result = result.substring(0, result.length - 1);
        };
        return result + "}";
      };
      if(qx.locale && qx.locale.LocalizedString && object instanceof qx.locale.LocalizedString){

        object = object.toString();
      };
      if(qx.lang.Type.isDate(object) && dateFormat != null){

        return '"' + dateFormat.format(object) + '"';
      };
      if(qx.lang.Type.isObject(object)){

        result += "{";
        for(var key in object){

          result += '"' + key + '":' + qx.util.Serializer.toJson(object[key], qxSerializer, dateFormat) + ",";
        };
        if(result != "{"){

          result = result.substring(0, result.length - 1);
        };
        return result + "}";
      };
      if(qx.lang.Type.isString(object)){

        object = object.replace(/([\\])/g, '\\\\');
        object = object.replace(/(["])/g, '\\"');
        object = object.replace(/([\r])/g, '\\r');
        object = object.replace(/([\f])/g, '\\f');
        object = object.replace(/([\n])/g, '\\n');
        object = object.replace(/([\t])/g, '\\t');
        object = object.replace(/([\b])/g, '\\b');
        return '"' + object + '"';
      };
      if(qx.lang.Type.isDate(object) || qx.lang.Type.isRegExp(object)){

        return '"' + object + '"';
      };
      return object + "";
    }
  }
});


qx.$$loader.init();

